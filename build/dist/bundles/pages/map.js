module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete installedModules[moduleId];
/******/ 		}
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 98);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _ol_ = {};

/**
 * Constants defined with the define tag cannot be changed in application
 * code, but can be set at compile time.
 * Some reduce the size of the build in advanced compile mode.
 */

/**
 * @define {boolean} Assume touch.  Default is `false`.
 */
_ol_.ASSUME_TOUCH = false;

/**
 * TODO: rename this to something having to do with tile grids
 * see https://github.com/openlayers/openlayers/issues/2076
 * @define {number} Default maximum zoom for default tile grids.
 */
_ol_.DEFAULT_MAX_ZOOM = 42;

/**
 * @define {number} Default min zoom level for the map view.  Default is `0`.
 */
_ol_.DEFAULT_MIN_ZOOM = 0;

/**
 * @define {number} Default maximum allowed threshold  (in pixels) for
 *     reprojection triangulation. Default is `0.5`.
 */
_ol_.DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD = 0.5;

/**
 * @define {number} Default tile size.
 */
_ol_.DEFAULT_TILE_SIZE = 256;

/**
 * @define {string} Default WMS version.
 */
_ol_.DEFAULT_WMS_VERSION = '1.3.0';

/**
 * @define {boolean} Enable the Canvas renderer.  Default is `true`. Setting
 *     this to false at compile time in advanced mode removes all code
 *     supporting the Canvas renderer from the build.
 */
_ol_.ENABLE_CANVAS = true;

/**
 * @define {boolean} Enable integration with the Proj4js library.  Default is
 *     `true`.
 */
_ol_.ENABLE_PROJ4JS = true;

/**
 * @define {boolean} Enable automatic reprojection of raster sources. Default is
 *     `true`.
 */
_ol_.ENABLE_RASTER_REPROJECTION = true;

/**
 * @define {boolean} Enable the WebGL renderer.  Default is `true`. Setting
 *     this to false at compile time in advanced mode removes all code
 *     supporting the WebGL renderer from the build.
 */
_ol_.ENABLE_WEBGL = true;

/**
 * @define {boolean} Include debuggable shader sources.  Default is `true`.
 *     This should be set to `false` for production builds (if `ol.ENABLE_WEBGL`
 *     is `true`).
 */
_ol_.DEBUG_WEBGL = true;

/**
 * @define {number} The size in pixels of the first atlas image. Default is
 * `256`.
 */
_ol_.INITIAL_ATLAS_SIZE = 256;

/**
 * @define {number} The maximum size in pixels of atlas images. Default is
 * `-1`, meaning it is not used (and `ol.WEBGL_MAX_TEXTURE_SIZE` is
 * used instead).
 */
_ol_.MAX_ATLAS_SIZE = -1;

/**
 * @define {number} Maximum mouse wheel delta.
 */
_ol_.MOUSEWHEELZOOM_MAXDELTA = 1;

/**
 * @define {number} Maximum width and/or height extent ratio that determines
 * when the overview map should be zoomed out.
 */
_ol_.OVERVIEWMAP_MAX_RATIO = 0.75;

/**
 * @define {number} Minimum width and/or height extent ratio that determines
 * when the overview map should be zoomed in.
 */
_ol_.OVERVIEWMAP_MIN_RATIO = 0.1;

/**
 * @define {number} Maximum number of source tiles for raster reprojection of
 *     a single tile.
 *     If too many source tiles are determined to be loaded to create a single
 *     reprojected tile the browser can become unresponsive or even crash.
 *     This can happen if the developer defines projections improperly and/or
 *     with unlimited extents.
 *     If too many tiles are required, no tiles are loaded and
 *     `ol.TileState.ERROR` state is set. Default is `100`.
 */
_ol_.RASTER_REPROJECTION_MAX_SOURCE_TILES = 100;

/**
 * @define {number} Maximum number of subdivision steps during raster
 *     reprojection triangulation. Prevents high memory usage and large
 *     number of proj4 calls (for certain transformations and areas).
 *     At most `2*(2^this)` triangles are created for each triangulated
 *     extent (tile/image). Default is `10`.
 */
_ol_.RASTER_REPROJECTION_MAX_SUBDIVISION = 10;

/**
 * @define {number} Maximum allowed size of triangle relative to world width.
 *     When transforming corners of world extent between certain projections,
 *     the resulting triangulation seems to have zero error and no subdivision
 *     is performed.
 *     If the triangle width is more than this (relative to world width; 0-1),
 *     subdivison is forced (up to `ol.RASTER_REPROJECTION_MAX_SUBDIVISION`).
 *     Default is `0.25`.
 */
_ol_.RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH = 0.25;

/**
 * @define {number} Tolerance for geometry simplification in device pixels.
 */
_ol_.SIMPLIFY_TOLERANCE = 0.5;

/**
 * @define {number} Texture cache high water mark.
 */
_ol_.WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK = 1024;

/**
 * @define {string} OpenLayers version.
 */
_ol_.VERSION = 'v4.6.4';

/**
 * The maximum supported WebGL texture size in pixels. If WebGL is not
 * supported, the value is set to `undefined`.
 * @const
 * @type {number|undefined}
 */
_ol_.WEBGL_MAX_TEXTURE_SIZE; // value is set in `ol.has`


/**
 * List of supported WebGL extensions.
 * @const
 * @type {Array.<string>}
 */
_ol_.WEBGL_EXTENSIONS; // value is set in `ol.has`


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 *
 *     function ParentClass(a, b) { }
 *     ParentClass.prototype.foo = function(a) { }
 *
 *     function ChildClass(a, b, c) {
 *       // Call parent constructor
 *       ParentClass.call(this, a, b);
 *     }
 *     ol.inherits(ChildClass, ParentClass);
 *
 *     var child = new ChildClass('a', 'b', 'see');
 *     child.foo(); // This works.
 *
 * @param {!Function} childCtor Child constructor.
 * @param {!Function} parentCtor Parent constructor.
 * @function
 * @api
 */
_ol_.inherits = function (childCtor, parentCtor) {
  childCtor.prototype = Object.create(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
};

/**
 * A reusable function, used e.g. as a default for callbacks.
 *
 * @return {undefined} Nothing.
 */
_ol_.nullFunction = function () {};

/**
 * Gets a unique ID for an object. This mutates the object so that further calls
 * with the same object as a parameter returns the same value. Unique IDs are generated
 * as a strictly increasing sequence. Adapted from goog.getUid.
 *
 * @param {Object} obj The object to get the unique ID for.
 * @return {number} The unique ID for the object.
 */
_ol_.getUid = function (obj) {
  return obj.ol_uid || (obj.ol_uid = ++_ol_.uidCounter_);
};

/**
 * Counter for getUid.
 * @type {number}
 * @private
 */
_ol_.uidCounter_ = 0;
/* harmony default export */ __webpack_exports__["a"] = (_ol_);

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__asserts_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extent_corner_js__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__ = __webpack_require__(75);



var _ol_extent_ = {};

/**
 * Build an extent that includes all given coordinates.
 *
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @return {ol.Extent} Bounding extent.
 * @api
 */
_ol_extent_.boundingExtent = function (coordinates) {
  var extent = _ol_extent_.createEmpty();
  for (var i = 0, ii = coordinates.length; i < ii; ++i) {
    _ol_extent_.extendCoordinate(extent, coordinates[i]);
  }
  return extent;
};

/**
 * @param {Array.<number>} xs Xs.
 * @param {Array.<number>} ys Ys.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @private
 * @return {ol.Extent} Extent.
 */
_ol_extent_.boundingExtentXYs_ = function (xs, ys, opt_extent) {
  var minX = Math.min.apply(null, xs);
  var minY = Math.min.apply(null, ys);
  var maxX = Math.max.apply(null, xs);
  var maxY = Math.max.apply(null, ys);
  return _ol_extent_.createOrUpdate(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Return extent increased by the provided value.
 * @param {ol.Extent} extent Extent.
 * @param {number} value The amount by which the extent should be buffered.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 * @api
 */
_ol_extent_.buffer = function (extent, value, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0] - value;
    opt_extent[1] = extent[1] - value;
    opt_extent[2] = extent[2] + value;
    opt_extent[3] = extent[3] + value;
    return opt_extent;
  } else {
    return [extent[0] - value, extent[1] - value, extent[2] + value, extent[3] + value];
  }
};

/**
 * Creates a clone of an extent.
 *
 * @param {ol.Extent} extent Extent to clone.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} The clone.
 */
_ol_extent_.clone = function (extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent.slice();
  }
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {number} Closest squared distance.
 */
_ol_extent_.closestSquaredDistanceXY = function (extent, x, y) {
  var dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
};

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {ol.Extent} extent Extent.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @return {boolean} The coordinate is contained in the extent.
 * @api
 */
_ol_extent_.containsCoordinate = function (extent, coordinate) {
  return _ol_extent_.containsXY(extent, coordinate[0], coordinate[1]);
};

/**
 * Check if one extent contains another.
 *
 * An extent is deemed contained if it lies completely within the other extent,
 * including if they share one or more edges.
 *
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {boolean} The second extent is contained by or on the edge of the
 *     first.
 * @api
 */
_ol_extent_.containsExtent = function (extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
};

/**
 * Check if the passed coordinate is contained or on the edge of the extent.
 *
 * @param {ol.Extent} extent Extent.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @return {boolean} The x, y values are contained in the extent.
 * @api
 */
_ol_extent_.containsXY = function (extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
};

/**
 * Get the relationship between a coordinate and extent.
 * @param {ol.Extent} extent The extent.
 * @param {ol.Coordinate} coordinate The coordinate.
 * @return {number} The relationship (bitwise compare with
 *     ol.extent.Relationship).
 */
_ol_extent_.coordinateRelationship = function (extent, coordinate) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var x = coordinate[0];
  var y = coordinate[1];
  var relationship = __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].UNKNOWN;
  if (x < minX) {
    relationship = relationship | __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].LEFT;
  } else if (x > maxX) {
    relationship = relationship | __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].RIGHT;
  }
  if (y < minY) {
    relationship = relationship | __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].BELOW;
  } else if (y > maxY) {
    relationship = relationship | __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].ABOVE;
  }
  if (relationship === __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].UNKNOWN) {
    relationship = __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].INTERSECTING;
  }
  return relationship;
};

/**
 * Create an empty extent.
 * @return {ol.Extent} Empty extent.
 * @api
 */
_ol_extent_.createEmpty = function () {
  return [Infinity, Infinity, -Infinity, -Infinity];
};

/**
 * Create a new extent or update the provided extent.
 * @param {number} minX Minimum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxX Maximum X.
 * @param {number} maxY Maximum Y.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.createOrUpdate = function (minX, minY, maxX, maxY, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = minX;
    opt_extent[1] = minY;
    opt_extent[2] = maxX;
    opt_extent[3] = maxY;
    return opt_extent;
  } else {
    return [minX, minY, maxX, maxY];
  }
};

/**
 * Create a new empty extent or make the provided one empty.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.createOrUpdateEmpty = function (opt_extent) {
  return _ol_extent_.createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
};

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.createOrUpdateFromCoordinate = function (coordinate, opt_extent) {
  var x = coordinate[0];
  var y = coordinate[1];
  return _ol_extent_.createOrUpdate(x, y, x, y, opt_extent);
};

/**
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.createOrUpdateFromCoordinates = function (coordinates, opt_extent) {
  var extent = _ol_extent_.createOrUpdateEmpty(opt_extent);
  return _ol_extent_.extendCoordinates(extent, coordinates);
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.createOrUpdateFromFlatCoordinates = function (flatCoordinates, offset, end, stride, opt_extent) {
  var extent = _ol_extent_.createOrUpdateEmpty(opt_extent);
  return _ol_extent_.extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
};

/**
 * @param {Array.<Array.<ol.Coordinate>>} rings Rings.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.createOrUpdateFromRings = function (rings, opt_extent) {
  var extent = _ol_extent_.createOrUpdateEmpty(opt_extent);
  return _ol_extent_.extendRings(extent, rings);
};

/**
 * Determine if two extents are equivalent.
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {boolean} The two extents are equivalent.
 * @api
 */
_ol_extent_.equals = function (extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
};

/**
 * Modify an extent to include another extent.
 * @param {ol.Extent} extent1 The extent to be modified.
 * @param {ol.Extent} extent2 The extent that will be included in the first.
 * @return {ol.Extent} A reference to the first (extended) extent.
 * @api
 */
_ol_extent_.extend = function (extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {ol.Coordinate} coordinate Coordinate.
 */
_ol_extent_.extendCoordinate = function (extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.extendCoordinates = function (extent, coordinates) {
  var i, ii;
  for (i = 0, ii = coordinates.length; i < ii; ++i) {
    _ol_extent_.extendCoordinate(extent, coordinates[i]);
  }
  return extent;
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.extendFlatCoordinates = function (extent, flatCoordinates, offset, end, stride) {
  for (; offset < end; offset += stride) {
    _ol_extent_.extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
  }
  return extent;
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {Array.<Array.<ol.Coordinate>>} rings Rings.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.extendRings = function (extent, rings) {
  var i, ii;
  for (i = 0, ii = rings.length; i < ii; ++i) {
    _ol_extent_.extendCoordinates(extent, rings[i]);
  }
  return extent;
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {number} x X.
 * @param {number} y Y.
 */
_ol_extent_.extendXY = function (extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
};

/**
 * This function calls `callback` for each corner of the extent. If the
 * callback returns a truthy value the function returns that value
 * immediately. Otherwise the function returns `false`.
 * @param {ol.Extent} extent Extent.
 * @param {function(this:T, ol.Coordinate): S} callback Callback.
 * @param {T=} opt_this Value to use as `this` when executing `callback`.
 * @return {S|boolean} Value.
 * @template S, T
 */
_ol_extent_.forEachCorner = function (extent, callback, opt_this) {
  var val;
  val = callback.call(opt_this, _ol_extent_.getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, _ol_extent_.getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, _ol_extent_.getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback.call(opt_this, _ol_extent_.getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
};

/**
 * Get the size of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {number} Area.
 * @api
 */
_ol_extent_.getArea = function (extent) {
  var area = 0;
  if (!_ol_extent_.isEmpty(extent)) {
    area = _ol_extent_.getWidth(extent) * _ol_extent_.getHeight(extent);
  }
  return area;
};

/**
 * Get the bottom left coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Bottom left coordinate.
 * @api
 */
_ol_extent_.getBottomLeft = function (extent) {
  return [extent[0], extent[1]];
};

/**
 * Get the bottom right coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Bottom right coordinate.
 * @api
 */
_ol_extent_.getBottomRight = function (extent) {
  return [extent[2], extent[1]];
};

/**
 * Get the center coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Center.
 * @api
 */
_ol_extent_.getCenter = function (extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
};

/**
 * Get a corner coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @param {ol.extent.Corner} corner Corner.
 * @return {ol.Coordinate} Corner coordinate.
 */
_ol_extent_.getCorner = function (extent, corner) {
  var coordinate;
  if (corner === __WEBPACK_IMPORTED_MODULE_1__extent_corner_js__["a" /* default */].BOTTOM_LEFT) {
    coordinate = _ol_extent_.getBottomLeft(extent);
  } else if (corner === __WEBPACK_IMPORTED_MODULE_1__extent_corner_js__["a" /* default */].BOTTOM_RIGHT) {
    coordinate = _ol_extent_.getBottomRight(extent);
  } else if (corner === __WEBPACK_IMPORTED_MODULE_1__extent_corner_js__["a" /* default */].TOP_LEFT) {
    coordinate = _ol_extent_.getTopLeft(extent);
  } else if (corner === __WEBPACK_IMPORTED_MODULE_1__extent_corner_js__["a" /* default */].TOP_RIGHT) {
    coordinate = _ol_extent_.getTopRight(extent);
  } else {
    __WEBPACK_IMPORTED_MODULE_0__asserts_js__["a" /* default */].assert(false, 13); // Invalid corner
  }
  return (/** @type {!ol.Coordinate} */coordinate
  );
};

/**
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {number} Enlarged area.
 */
_ol_extent_.getEnlargedArea = function (extent1, extent2) {
  var minX = Math.min(extent1[0], extent2[0]);
  var minY = Math.min(extent1[1], extent2[1]);
  var maxX = Math.max(extent1[2], extent2[2]);
  var maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
};

/**
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.getForViewAndSize = function (center, resolution, rotation, size, opt_extent) {
  var dx = resolution * size[0] / 2;
  var dy = resolution * size[1] / 2;
  var cosRotation = Math.cos(rotation);
  var sinRotation = Math.sin(rotation);
  var xCos = dx * cosRotation;
  var xSin = dx * sinRotation;
  var yCos = dy * cosRotation;
  var ySin = dy * sinRotation;
  var x = center[0];
  var y = center[1];
  var x0 = x - xCos + ySin;
  var x1 = x - xCos - ySin;
  var x2 = x + xCos - ySin;
  var x3 = x + xCos + ySin;
  var y0 = y - xSin - yCos;
  var y1 = y - xSin + yCos;
  var y2 = y + xSin + yCos;
  var y3 = y + xSin - yCos;
  return _ol_extent_.createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
};

/**
 * Get the height of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {number} Height.
 * @api
 */
_ol_extent_.getHeight = function (extent) {
  return extent[3] - extent[1];
};

/**
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @return {number} Intersection area.
 */
_ol_extent_.getIntersectionArea = function (extent1, extent2) {
  var intersection = _ol_extent_.getIntersection(extent1, extent2);
  return _ol_extent_.getArea(intersection);
};

/**
 * Get the intersection of two extents.
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent 2.
 * @param {ol.Extent=} opt_extent Optional extent to populate with intersection.
 * @return {ol.Extent} Intersecting extent.
 * @api
 */
_ol_extent_.getIntersection = function (extent1, extent2, opt_extent) {
  var intersection = opt_extent ? opt_extent : _ol_extent_.createEmpty();
  if (_ol_extent_.intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  }
  return intersection;
};

/**
 * @param {ol.Extent} extent Extent.
 * @return {number} Margin.
 */
_ol_extent_.getMargin = function (extent) {
  return _ol_extent_.getWidth(extent) + _ol_extent_.getHeight(extent);
};

/**
 * Get the size (width, height) of an extent.
 * @param {ol.Extent} extent The extent.
 * @return {ol.Size} The extent size.
 * @api
 */
_ol_extent_.getSize = function (extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
};

/**
 * Get the top left coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Top left coordinate.
 * @api
 */
_ol_extent_.getTopLeft = function (extent) {
  return [extent[0], extent[3]];
};

/**
 * Get the top right coordinate of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {ol.Coordinate} Top right coordinate.
 * @api
 */
_ol_extent_.getTopRight = function (extent) {
  return [extent[2], extent[3]];
};

/**
 * Get the width of an extent.
 * @param {ol.Extent} extent Extent.
 * @return {number} Width.
 * @api
 */
_ol_extent_.getWidth = function (extent) {
  return extent[2] - extent[0];
};

/**
 * Determine if one extent intersects another.
 * @param {ol.Extent} extent1 Extent 1.
 * @param {ol.Extent} extent2 Extent.
 * @return {boolean} The two extents intersect.
 * @api
 */
_ol_extent_.intersects = function (extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
};

/**
 * Determine if an extent is empty.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} Is empty.
 * @api
 */
_ol_extent_.isEmpty = function (extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */
_ol_extent_.returnOrUpdate = function (extent, opt_extent) {
  if (opt_extent) {
    opt_extent[0] = extent[0];
    opt_extent[1] = extent[1];
    opt_extent[2] = extent[2];
    opt_extent[3] = extent[3];
    return opt_extent;
  } else {
    return extent;
  }
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {number} value Value.
 */
_ol_extent_.scaleFromCenter = function (extent, value) {
  var deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
  var deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
};

/**
 * Determine if the segment between two coordinates intersects (crosses,
 * touches, or is contained by) the provided extent.
 * @param {ol.Extent} extent The extent.
 * @param {ol.Coordinate} start Segment start coordinate.
 * @param {ol.Coordinate} end Segment end coordinate.
 * @return {boolean} The segment intersects the extent.
 */
_ol_extent_.intersectsSegment = function (extent, start, end) {
  var intersects = false;
  var startRel = _ol_extent_.coordinateRelationship(extent, start);
  var endRel = _ol_extent_.coordinateRelationship(extent, end);
  if (startRel === __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].INTERSECTING || endRel === __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].INTERSECTING) {
    intersects = true;
  } else {
    var minX = extent[0];
    var minY = extent[1];
    var maxX = extent[2];
    var maxY = extent[3];
    var startX = start[0];
    var startY = start[1];
    var endX = end[0];
    var endY = end[1];
    var slope = (endY - startY) / (endX - startX);
    var x, y;
    if (!!(endRel & __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].ABOVE) && !(startRel & __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].ABOVE)) {
      // potentially intersects top
      x = endX - (endY - maxY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].RIGHT) && !(startRel & __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].RIGHT)) {
      // potentially intersects right
      y = endY - (endX - maxX) * slope;
      intersects = y >= minY && y <= maxY;
    }
    if (!intersects && !!(endRel & __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].BELOW) && !(startRel & __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].BELOW)) {
      // potentially intersects bottom
      x = endX - (endY - minY) / slope;
      intersects = x >= minX && x <= maxX;
    }
    if (!intersects && !!(endRel & __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].LEFT) && !(startRel & __WEBPACK_IMPORTED_MODULE_2__extent_relationship_js__["a" /* default */].LEFT)) {
      // potentially intersects left
      y = endY - (endX - minX) * slope;
      intersects = y >= minY && y <= maxY;
    }
  }
  return intersects;
};

/**
 * Apply a transform function to the extent.
 * @param {ol.Extent} extent Extent.
 * @param {ol.TransformFunction} transformFn Transform function.  Called with
 * [minX, minY, maxX, maxY] extent coordinates.
 * @param {ol.Extent=} opt_extent Destination extent.
 * @return {ol.Extent} Extent.
 * @api
 */
_ol_extent_.applyTransform = function (extent, transformFn, opt_extent) {
  var coordinates = [extent[0], extent[1], extent[0], extent[3], extent[2], extent[1], extent[2], extent[3]];
  transformFn(coordinates, coordinates, 2);
  var xs = [coordinates[0], coordinates[2], coordinates[4], coordinates[6]];
  var ys = [coordinates[1], coordinates[3], coordinates[5], coordinates[7]];
  return _ol_extent_.boundingExtentXYs_(xs, ys, opt_extent);
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_extent_);

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _ol_obj_ = {};

/**
 * Polyfill for Object.assign().  Assigns enumerable and own properties from
 * one or more source objects to a target object.
 *
 * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * @param {!Object} target The target object.
 * @param {...Object} var_sources The source object(s).
 * @return {!Object} The modified target object.
 */
_ol_obj_.assign = typeof Object.assign === 'function' ? Object.assign : function (target, var_sources) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert undefined or null to object');
  }

  var output = Object(target);
  for (var i = 1, ii = arguments.length; i < ii; ++i) {
    var source = arguments[i];
    if (source !== undefined && source !== null) {
      for (var key in source) {
        if (source.hasOwnProperty(key)) {
          output[key] = source[key];
        }
      }
    }
  }
  return output;
};

/**
 * Removes all properties from an object.
 * @param {Object} object The object to clear.
 */
_ol_obj_.clear = function (object) {
  for (var property in object) {
    delete object[property];
  }
};

/**
 * Get an array of property values from an object.
 * @param {Object<K,V>} object The object from which to get the values.
 * @return {!Array<V>} The property values.
 * @template K,V
 */
_ol_obj_.getValues = function (object) {
  var values = [];
  for (var property in object) {
    values.push(object[property]);
  }
  return values;
};

/**
 * Determine if an object has any properties.
 * @param {Object} object The object to check.
 * @return {boolean} The object is empty.
 */
_ol_obj_.isEmpty = function (object) {
  var property;
  for (property in object) {
    return false;
  }
  return !property;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_obj_);

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__obj_js__ = __webpack_require__(2);

var _ol_events_ = {};

/**
 * @param {ol.EventsKey} listenerObj Listener object.
 * @return {ol.EventsListenerFunctionType} Bound listener.
 */
_ol_events_.bindListener_ = function (listenerObj) {
  var boundListener = function boundListener(evt) {
    var listener = listenerObj.listener;
    var bindTo = listenerObj.bindTo || listenerObj.target;
    if (listenerObj.callOnce) {
      _ol_events_.unlistenByKey(listenerObj);
    }
    return listener.call(bindTo, evt);
  };
  listenerObj.boundListener = boundListener;
  return boundListener;
};

/**
 * Finds the matching {@link ol.EventsKey} in the given listener
 * array.
 *
 * @param {!Array<!ol.EventsKey>} listeners Array of listeners.
 * @param {!Function} listener The listener function.
 * @param {Object=} opt_this The `this` value inside the listener.
 * @param {boolean=} opt_setDeleteIndex Set the deleteIndex on the matching
 *     listener, for {@link ol.events.unlistenByKey}.
 * @return {ol.EventsKey|undefined} The matching listener object.
 * @private
 */
_ol_events_.findListener_ = function (listeners, listener, opt_this, opt_setDeleteIndex) {
  var listenerObj;
  for (var i = 0, ii = listeners.length; i < ii; ++i) {
    listenerObj = listeners[i];
    if (listenerObj.listener === listener && listenerObj.bindTo === opt_this) {
      if (opt_setDeleteIndex) {
        listenerObj.deleteIndex = i;
      }
      return listenerObj;
    }
  }
  return undefined;
};

/**
 * @param {ol.EventTargetLike} target Target.
 * @param {string} type Type.
 * @return {Array.<ol.EventsKey>|undefined} Listeners.
 */
_ol_events_.getListeners = function (target, type) {
  var listenerMap = target.ol_lm;
  return listenerMap ? listenerMap[type] : undefined;
};

/**
 * Get the lookup of listeners.  If one does not exist on the target, it is
 * created.
 * @param {ol.EventTargetLike} target Target.
 * @return {!Object.<string, Array.<ol.EventsKey>>} Map of
 *     listeners by event type.
 * @private
 */
_ol_events_.getListenerMap_ = function (target) {
  var listenerMap = target.ol_lm;
  if (!listenerMap) {
    listenerMap = target.ol_lm = {};
  }
  return listenerMap;
};

/**
 * Clean up all listener objects of the given type.  All properties on the
 * listener objects will be removed, and if no listeners remain in the listener
 * map, it will be removed from the target.
 * @param {ol.EventTargetLike} target Target.
 * @param {string} type Type.
 * @private
 */
_ol_events_.removeListeners_ = function (target, type) {
  var listeners = _ol_events_.getListeners(target, type);
  if (listeners) {
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      target.removeEventListener(type, listeners[i].boundListener);
      __WEBPACK_IMPORTED_MODULE_0__obj_js__["a" /* default */].clear(listeners[i]);
    }
    listeners.length = 0;
    var listenerMap = target.ol_lm;
    if (listenerMap) {
      delete listenerMap[type];
      if (Object.keys(listenerMap).length === 0) {
        delete target.ol_lm;
      }
    }
  }
};

/**
 * Registers an event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * This function efficiently binds a `listener` to a `this` object, and returns
 * a key for use with {@link ol.events.unlistenByKey}.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @param {boolean=} opt_once If true, add the listener as one-off listener.
 * @return {ol.EventsKey} Unique key for the listener.
 */
_ol_events_.listen = function (target, type, listener, opt_this, opt_once) {
  var listenerMap = _ol_events_.getListenerMap_(target);
  var listeners = listenerMap[type];
  if (!listeners) {
    listeners = listenerMap[type] = [];
  }
  var listenerObj = _ol_events_.findListener_(listeners, listener, opt_this, false);
  if (listenerObj) {
    if (!opt_once) {
      // Turn one-off listener into a permanent one.
      listenerObj.callOnce = false;
    }
  } else {
    listenerObj = /** @type {ol.EventsKey} */{
      bindTo: opt_this,
      callOnce: !!opt_once,
      listener: listener,
      target: target,
      type: type
    };
    target.addEventListener(type, _ol_events_.bindListener_(listenerObj));
    listeners.push(listenerObj);
  }

  return listenerObj;
};

/**
 * Registers a one-off event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * This function efficiently binds a `listener` as self-unregistering listener
 * to a `this` object, and returns a key for use with
 * {@link ol.events.unlistenByKey} in case the listener needs to be unregistered
 * before it is called.
 *
 * When {@link ol.events.listen} is called with the same arguments after this
 * function, the self-unregistering listener will be turned into a permanent
 * listener.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 * @return {ol.EventsKey} Key for unlistenByKey.
 */
_ol_events_.listenOnce = function (target, type, listener, opt_this) {
  return _ol_events_.listen(target, type, listener, opt_this, true);
};

/**
 * Unregisters an event listener on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * To return a listener, this function needs to be called with the exact same
 * arguments that were used for a previous {@link ol.events.listen} call.
 *
 * @param {ol.EventTargetLike} target Event target.
 * @param {string} type Event type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 * @param {Object=} opt_this Object referenced by the `this` keyword in the
 *     listener. Default is the `target`.
 */
_ol_events_.unlisten = function (target, type, listener, opt_this) {
  var listeners = _ol_events_.getListeners(target, type);
  if (listeners) {
    var listenerObj = _ol_events_.findListener_(listeners, listener, opt_this, true);
    if (listenerObj) {
      _ol_events_.unlistenByKey(listenerObj);
    }
  }
};

/**
 * Unregisters event listeners on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * The argument passed to this function is the key returned from
 * {@link ol.events.listen} or {@link ol.events.listenOnce}.
 *
 * @param {ol.EventsKey} key The key.
 */
_ol_events_.unlistenByKey = function (key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.boundListener);
    var listeners = _ol_events_.getListeners(key.target, key.type);
    if (listeners) {
      var i = 'deleteIndex' in key ? key.deleteIndex : listeners.indexOf(key);
      if (i !== -1) {
        listeners.splice(i, 1);
      }
      if (listeners.length === 0) {
        _ol_events_.removeListeners_(key.target, key.type);
      }
    }
    __WEBPACK_IMPORTED_MODULE_0__obj_js__["a" /* default */].clear(key);
  }
};

/**
 * Unregisters all event listeners on an event target. Inspired by
 * {@link https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html}
 *
 * @param {ol.EventTargetLike} target Target.
 */
_ol_events_.unlistenAll = function (target) {
  var listenerMap = _ol_events_.getListenerMap_(target);
  for (var type in listenerMap) {
    _ol_events_.removeListeners_(target, type);
  }
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_events_);

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @enum {string}
 * @const
 */
var _ol_events_EventType_ = {
  /**
   * Generic change event. Triggered when the revision counter is increased.
   * @event ol.events.Event#change
   * @api
   */
  CHANGE: 'change',

  CLEAR: 'clear',
  CLICK: 'click',
  DBLCLICK: 'dblclick',
  DRAGENTER: 'dragenter',
  DRAGOVER: 'dragover',
  DROP: 'drop',
  ERROR: 'error',
  KEYDOWN: 'keydown',
  KEYPRESS: 'keypress',
  LOAD: 'load',
  MOUSEDOWN: 'mousedown',
  MOUSEMOVE: 'mousemove',
  MOUSEOUT: 'mouseout',
  MOUSEUP: 'mouseup',
  MOUSEWHEEL: 'mousewheel',
  MSPOINTERDOWN: 'MSPointerDown',
  RESIZE: 'resize',
  TOUCHSTART: 'touchstart',
  TOUCHMOVE: 'touchmove',
  TOUCHEND: 'touchend',
  WHEEL: 'wheel'
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_events_EventType_);

/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _ol_array_ = {};

/**
 * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
 * https://github.com/darkskyapp/binary-search
 *
 * @param {Array.<*>} haystack Items to search through.
 * @param {*} needle The item to look for.
 * @param {Function=} opt_comparator Comparator function.
 * @return {number} The index of the item if found, -1 if not.
 */
_ol_array_.binarySearch = function (haystack, needle, opt_comparator) {
  var mid, cmp;
  var comparator = opt_comparator || _ol_array_.numberSafeCompareFunction;
  var low = 0;
  var high = haystack.length;
  var found = false;

  while (low < high) {
    /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
     * to double (which gives the wrong results). */
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);

    if (cmp < 0.0) {
      /* Too low. */
      low = mid + 1;
    } else {
      /* Key found or too high */
      high = mid;
      found = !cmp;
    }
  }

  /* Key not found. */
  return found ? low : ~low;
};

/**
 * Compare function for array sort that is safe for numbers.
 * @param {*} a The first object to be compared.
 * @param {*} b The second object to be compared.
 * @return {number} A negative number, zero, or a positive number as the first
 *     argument is less than, equal to, or greater than the second.
 */
_ol_array_.numberSafeCompareFunction = function (a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
};

/**
 * Whether the array contains the given object.
 * @param {Array.<*>} arr The array to test for the presence of the element.
 * @param {*} obj The object for which to test.
 * @return {boolean} The object is in the array.
 */
_ol_array_.includes = function (arr, obj) {
  return arr.indexOf(obj) >= 0;
};

/**
 * @param {Array.<number>} arr Array.
 * @param {number} target Target.
 * @param {number} direction 0 means return the nearest, > 0
 *    means return the largest nearest, < 0 means return the
 *    smallest nearest.
 * @return {number} Index.
 */
_ol_array_.linearFindNearest = function (arr, target, direction) {
  var n = arr.length;
  if (arr[0] <= target) {
    return 0;
  } else if (target <= arr[n - 1]) {
    return n - 1;
  } else {
    var i;
    if (direction > 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] < target) {
          return i - 1;
        }
      }
    } else if (direction < 0) {
      for (i = 1; i < n; ++i) {
        if (arr[i] <= target) {
          return i;
        }
      }
    } else {
      for (i = 1; i < n; ++i) {
        if (arr[i] == target) {
          return i;
        } else if (arr[i] < target) {
          if (arr[i - 1] - target < target - arr[i]) {
            return i - 1;
          } else {
            return i;
          }
        }
      }
    }
    return n - 1;
  }
};

/**
 * @param {Array.<*>} arr Array.
 * @param {number} begin Begin index.
 * @param {number} end End index.
 */
_ol_array_.reverseSubArray = function (arr, begin, end) {
  while (begin < end) {
    var tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
};

/**
 * @param {Array.<VALUE>} arr The array to modify.
 * @param {Array.<VALUE>|VALUE} data The elements or arrays of elements
 *     to add to arr.
 * @template VALUE
 */
_ol_array_.extend = function (arr, data) {
  var i;
  var extension = Array.isArray(data) ? data : [data];
  var length = extension.length;
  for (i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
};

/**
 * @param {Array.<VALUE>} arr The array to modify.
 * @param {VALUE} obj The element to remove.
 * @template VALUE
 * @return {boolean} If the element was removed.
 */
_ol_array_.remove = function (arr, obj) {
  var i = arr.indexOf(obj);
  var found = i > -1;
  if (found) {
    arr.splice(i, 1);
  }
  return found;
};

/**
 * @param {Array.<VALUE>} arr The array to search in.
 * @param {function(VALUE, number, ?) : boolean} func The function to compare.
 * @template VALUE
 * @return {VALUE} The element found.
 */
_ol_array_.find = function (arr, func) {
  var length = arr.length >>> 0;
  var value;

  for (var i = 0; i < length; i++) {
    value = arr[i];
    if (func(value, i, arr)) {
      return value;
    }
  }
  return null;
};

/**
 * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
 * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
 * @return {boolean} Whether the two arrays are equal.
 */
_ol_array_.equals = function (arr1, arr2) {
  var len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (var i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
};

/**
 * @param {Array.<*>} arr The array to sort (modifies original).
 * @param {Function} compareFnc Comparison function.
 */
_ol_array_.stableSort = function (arr, compareFnc) {
  var length = arr.length;
  var tmp = Array(arr.length);
  var i;
  for (i = 0; i < length; i++) {
    tmp[i] = { index: i, value: arr[i] };
  }
  tmp.sort(function (a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });
  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
};

/**
 * @param {Array.<*>} arr The array to search in.
 * @param {Function} func Comparison function.
 * @return {number} Return index.
 */
_ol_array_.findIndex = function (arr, func) {
  var index;
  var found = !arr.every(function (el, idx) {
    index = idx;
    return !func(el, idx, arr);
  });
  return found ? index : -1;
};

/**
 * @param {Array.<*>} arr The array to test.
 * @param {Function=} opt_func Comparison function.
 * @param {boolean=} opt_strict Strictly sorted (default false).
 * @return {boolean} Return index.
 */
_ol_array_.isSorted = function (arr, opt_func, opt_strict) {
  var compare = opt_func || _ol_array_.numberSafeCompareFunction;
  return arr.every(function (currentVal, index) {
    if (index === 0) {
      return true;
    }
    var res = compare(arr[index - 1], currentVal);
    return !(res > 0 || opt_strict && res === 0);
  });
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_array_);

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__asserts_js__ = __webpack_require__(9);

var _ol_math_ = {};

/**
 * Takes a number and clamps it to within the provided bounds.
 * @param {number} value The input number.
 * @param {number} min The minimum value to return.
 * @param {number} max The maximum value to return.
 * @return {number} The input number if it is within bounds, or the nearest
 *     number within the bounds.
 */
_ol_math_.clamp = function (value, min, max) {
  return Math.min(Math.max(value, min), max);
};

/**
 * Return the hyperbolic cosine of a given number. The method will use the
 * native `Math.cosh` function if it is available, otherwise the hyperbolic
 * cosine will be calculated via the reference implementation of the Mozilla
 * developer network.
 *
 * @param {number} x X.
 * @return {number} Hyperbolic cosine of x.
 */
_ol_math_.cosh = function () {
  // Wrapped in a iife, to save the overhead of checking for the native
  // implementation on every invocation.
  var cosh;
  if ('cosh' in Math) {
    // The environment supports the native Math.cosh function, use it…
    cosh = Math.cosh;
  } else {
    // … else, use the reference implementation of MDN:
    cosh = function cosh(x) {
      var y = Math.exp(x);
      return (y + 1 / y) / 2;
    };
  }
  return cosh;
}();

/**
 * @param {number} x X.
 * @return {number} The smallest power of two greater than or equal to x.
 */
_ol_math_.roundUpToPowerOfTwo = function (x) {
  __WEBPACK_IMPORTED_MODULE_0__asserts_js__["a" /* default */].assert(0 < x, 29); // `x` must be greater than `0`
  return Math.pow(2, Math.ceil(Math.log(x) / Math.LN2));
};

/**
 * Returns the square of the closest distance between the point (x, y) and the
 * line segment (x1, y1) to (x2, y2).
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
_ol_math_.squaredSegmentDistance = function (x, y, x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return _ol_math_.squaredDistance(x, y, x1, y1);
};

/**
 * Returns the square of the distance between the points (x1, y1) and (x2, y2).
 * @param {number} x1 X1.
 * @param {number} y1 Y1.
 * @param {number} x2 X2.
 * @param {number} y2 Y2.
 * @return {number} Squared distance.
 */
_ol_math_.squaredDistance = function (x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return dx * dx + dy * dy;
};

/**
 * Solves system of linear equations using Gaussian elimination method.
 *
 * @param {Array.<Array.<number>>} mat Augmented matrix (n x n + 1 column)
 *                                     in row-major order.
 * @return {Array.<number>} The resulting vector.
 */
_ol_math_.solveLinearSystem = function (mat) {
  var n = mat.length;

  for (var i = 0; i < n; i++) {
    // Find max in the i-th column (ignoring i - 1 first rows)
    var maxRow = i;
    var maxEl = Math.abs(mat[i][i]);
    for (var r = i + 1; r < n; r++) {
      var absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }

    if (maxEl === 0) {
      return null; // matrix is singular
    }

    // Swap max row with i-th (current) row
    var tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;

    // Subtract the i-th row to make all the remaining rows 0 in the i-th column
    for (var j = i + 1; j < n; j++) {
      var coef = -mat[j][i] / mat[i][i];
      for (var k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }

  // Solve Ax=b for upper triangular matrix A (mat)
  var x = new Array(n);
  for (var l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (var m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
};

/**
 * Converts radians to to degrees.
 *
 * @param {number} angleInRadians Angle in radians.
 * @return {number} Angle in degrees.
 */
_ol_math_.toDegrees = function (angleInRadians) {
  return angleInRadians * 180 / Math.PI;
};

/**
 * Converts degrees to radians.
 *
 * @param {number} angleInDegrees Angle in degrees.
 * @return {number} Angle in radians.
 */
_ol_math_.toRadians = function (angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
};

/**
 * Returns the modulo of a / b, depending on the sign of b.
 *
 * @param {number} a Dividend.
 * @param {number} b Divisor.
 * @return {number} Modulo.
 */
_ol_math_.modulo = function (a, b) {
  var r = a % b;
  return r * b < 0 ? r + b : r;
};

/**
 * Calculates the linearly interpolated value of x between a and b.
 *
 * @param {number} a Number
 * @param {number} b Number
 * @param {number} x Value to be interpolated.
 * @return {number} Interpolated value.
 */
_ol_math_.lerp = function (a, b, x) {
  return a + x * (b - a);
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_math_);

/***/ }),
/* 7 */
/***/ (function(module, exports) {

module.exports = require("react");

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _ol_dom_ = {};

/**
 * Create an html canvas element and returns its 2d context.
 * @param {number=} opt_width Canvas width.
 * @param {number=} opt_height Canvas height.
 * @return {CanvasRenderingContext2D} The context.
 */
_ol_dom_.createCanvasContext2D = function (opt_width, opt_height) {
  if (typeof document === 'undefined') {
    throw new Error('DOM not supported');
  }
  var canvas = document.createElement('CANVAS');
  if (opt_width) {
    canvas.width = opt_width;
  }
  if (opt_height) {
    canvas.height = opt_height;
  }
  return canvas.getContext('2d');
};

/**
 * Get the current computed width for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerWidth(true)`.
 * @param {!Element} element Element.
 * @return {number} The width.
 */
_ol_dom_.outerWidth = function (element) {
  var width = element.offsetWidth;
  var style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);

  return width;
};

/**
 * Get the current computed height for the given element including margin,
 * padding and border.
 * Equivalent to jQuery's `$(el).outerHeight(true)`.
 * @param {!Element} element Element.
 * @return {number} The height.
 */
_ol_dom_.outerHeight = function (element) {
  var height = element.offsetHeight;
  var style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);

  return height;
};

/**
 * @param {Node} newNode Node to replace old node
 * @param {Node} oldNode The node to be replaced
 */
_ol_dom_.replaceNode = function (newNode, oldNode) {
  var parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
};

/**
 * @param {Node} node The node to remove.
 * @returns {Node} The node that was removed or null.
 */
_ol_dom_.removeNode = function (node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
};

/**
 * @param {Node} node The node to remove the children from.
 */
_ol_dom_.removeChildren = function (node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_dom_);

/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__assertionerror_js__ = __webpack_require__(72);

var _ol_asserts_ = {};

/**
 * @param {*} assertion Assertion we expected to be truthy.
 * @param {number} errorCode Error code.
 */
_ol_asserts_.assert = function (assertion, errorCode) {
  if (!assertion) {
    throw new __WEBPACK_IMPORTED_MODULE_0__assertionerror_js__["a" /* default */](errorCode);
  }
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_asserts_);

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
 * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
 * `'GeometryCollection'`, `'Circle'`.
 * @enum {string}
 */
var _ol_geom_GeometryType_ = {
  POINT: 'Point',
  LINE_STRING: 'LineString',
  LINEAR_RING: 'LinearRing',
  POLYGON: 'Polygon',
  MULTI_POINT: 'MultiPoint',
  MULTI_LINE_STRING: 'MultiLineString',
  MULTI_POLYGON: 'MultiPolygon',
  GEOMETRY_COLLECTION: 'GeometryCollection',
  CIRCLE: 'Circle'
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_geom_GeometryType_);

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__asserts_js__ = __webpack_require__(9);

var _ol_transform_ = {};

/**
 * Collection of affine 2d transformation functions. The functions work on an
 * array of 6 elements. The element order is compatible with the [SVGMatrix
 * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
 * a subset (elements a to f) of a 3x3 martrix:
 * ```
 * [ a c e ]
 * [ b d f ]
 * [ 0 0 1 ]
 * ```
 */

/**
 * @private
 * @type {ol.Transform}
 */
_ol_transform_.tmp_ = new Array(6);

/**
 * Create an identity transform.
 * @return {!ol.Transform} Identity transform.
 */
_ol_transform_.create = function () {
  return [1, 0, 0, 1, 0, 0];
};

/**
 * Resets the given transform to an identity transform.
 * @param {!ol.Transform} transform Transform.
 * @return {!ol.Transform} Transform.
 */
_ol_transform_.reset = function (transform) {
  return _ol_transform_.set(transform, 1, 0, 0, 1, 0, 0);
};

/**
 * Multiply the underlying matrices of two transforms and return the result in
 * the first transform.
 * @param {!ol.Transform} transform1 Transform parameters of matrix 1.
 * @param {!ol.Transform} transform2 Transform parameters of matrix 2.
 * @return {!ol.Transform} transform1 multiplied with transform2.
 */
_ol_transform_.multiply = function (transform1, transform2) {
  var a1 = transform1[0];
  var b1 = transform1[1];
  var c1 = transform1[2];
  var d1 = transform1[3];
  var e1 = transform1[4];
  var f1 = transform1[5];
  var a2 = transform2[0];
  var b2 = transform2[1];
  var c2 = transform2[2];
  var d2 = transform2[3];
  var e2 = transform2[4];
  var f2 = transform2[5];

  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;

  return transform1;
};

/**
 * Set the transform components a-f on a given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} a The a component of the transform.
 * @param {number} b The b component of the transform.
 * @param {number} c The c component of the transform.
 * @param {number} d The d component of the transform.
 * @param {number} e The e component of the transform.
 * @param {number} f The f component of the transform.
 * @return {!ol.Transform} Matrix with transform applied.
 */
_ol_transform_.set = function (transform, a, b, c, d, e, f) {
  transform[0] = a;
  transform[1] = b;
  transform[2] = c;
  transform[3] = d;
  transform[4] = e;
  transform[5] = f;
  return transform;
};

/**
 * Set transform on one matrix from another matrix.
 * @param {!ol.Transform} transform1 Matrix to set transform to.
 * @param {!ol.Transform} transform2 Matrix to set transform from.
 * @return {!ol.Transform} transform1 with transform from transform2 applied.
 */
_ol_transform_.setFromArray = function (transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
};

/**
 * Transforms the given coordinate with the given transform returning the
 * resulting, transformed coordinate. The coordinate will be modified in-place.
 *
 * @param {ol.Transform} transform The transformation.
 * @param {ol.Coordinate|ol.Pixel} coordinate The coordinate to transform.
 * @return {ol.Coordinate|ol.Pixel} return coordinate so that operations can be
 *     chained together.
 */
_ol_transform_.apply = function (transform, coordinate) {
  var x = coordinate[0],
      y = coordinate[1];
  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
  return coordinate;
};

/**
 * Applies rotation to the given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} angle Angle in radians.
 * @return {!ol.Transform} The rotated transform.
 */
_ol_transform_.rotate = function (transform, angle) {
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  return _ol_transform_.multiply(transform, _ol_transform_.set(_ol_transform_.tmp_, cos, sin, -sin, cos, 0, 0));
};

/**
 * Applies scale to a given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} x Scale factor x.
 * @param {number} y Scale factor y.
 * @return {!ol.Transform} The scaled transform.
 */
_ol_transform_.scale = function (transform, x, y) {
  return _ol_transform_.multiply(transform, _ol_transform_.set(_ol_transform_.tmp_, x, 0, 0, y, 0, 0));
};

/**
 * Applies translation to the given transform.
 * @param {!ol.Transform} transform Transform.
 * @param {number} dx Translation x.
 * @param {number} dy Translation y.
 * @return {!ol.Transform} The translated transform.
 */
_ol_transform_.translate = function (transform, dx, dy) {
  return _ol_transform_.multiply(transform, _ol_transform_.set(_ol_transform_.tmp_, 1, 0, 0, 1, dx, dy));
};

/**
 * Creates a composite transform given an initial translation, scale, rotation, and
 * final translation (in that order only, not commutative).
 * @param {!ol.Transform} transform The transform (will be modified in place).
 * @param {number} dx1 Initial translation x.
 * @param {number} dy1 Initial translation y.
 * @param {number} sx Scale factor x.
 * @param {number} sy Scale factor y.
 * @param {number} angle Rotation (in counter-clockwise radians).
 * @param {number} dx2 Final translation x.
 * @param {number} dy2 Final translation y.
 * @return {!ol.Transform} The composite transform.
 */
_ol_transform_.compose = function (transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
  var sin = Math.sin(angle);
  var cos = Math.cos(angle);
  transform[0] = sx * cos;
  transform[1] = sy * sin;
  transform[2] = -sx * sin;
  transform[3] = sy * cos;
  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform;
};

/**
 * Invert the given transform.
 * @param {!ol.Transform} transform Transform.
 * @return {!ol.Transform} Inverse of the transform.
 */
_ol_transform_.invert = function (transform) {
  var det = _ol_transform_.determinant(transform);
  __WEBPACK_IMPORTED_MODULE_0__asserts_js__["a" /* default */].assert(det !== 0, 32); // Transformation matrix cannot be inverted

  var a = transform[0];
  var b = transform[1];
  var c = transform[2];
  var d = transform[3];
  var e = transform[4];
  var f = transform[5];

  transform[0] = d / det;
  transform[1] = -b / det;
  transform[2] = -c / det;
  transform[3] = a / det;
  transform[4] = (c * f - d * e) / det;
  transform[5] = -(a * f - b * e) / det;

  return transform;
};

/**
 * Returns the determinant of the given matrix.
 * @param {!ol.Transform} mat Matrix.
 * @return {number} Determinant.
 */
_ol_transform_.determinant = function (mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_transform_);

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = require("semantic-ui-react");

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _ol_functions_ = {};

/**
 * Always returns true.
 * @returns {boolean} true.
 */
_ol_functions_.TRUE = function () {
  return true;
};

/**
 * Always returns false.
 * @returns {boolean} false.
 */
_ol_functions_.FALSE = function () {
  return false;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_functions_);

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _ol_webgl_ = {};

/**
 * Constants taken from goog.webgl
 */

/**
 * @const
 * @type {number}
 */
_ol_webgl_.ONE = 1;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.SRC_ALPHA = 0x0302;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.COLOR_ATTACHMENT0 = 0x8CE0;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.COLOR_BUFFER_BIT = 0x00004000;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.TRIANGLES = 0x0004;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.TRIANGLE_STRIP = 0x0005;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.ONE_MINUS_SRC_ALPHA = 0x0303;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.ARRAY_BUFFER = 0x8892;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.ELEMENT_ARRAY_BUFFER = 0x8893;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.STREAM_DRAW = 0x88E0;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.STATIC_DRAW = 0x88E4;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.DYNAMIC_DRAW = 0x88E8;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.CULL_FACE = 0x0B44;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.BLEND = 0x0BE2;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.STENCIL_TEST = 0x0B90;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.DEPTH_TEST = 0x0B71;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.SCISSOR_TEST = 0x0C11;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.UNSIGNED_BYTE = 0x1401;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.UNSIGNED_SHORT = 0x1403;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.UNSIGNED_INT = 0x1405;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.FLOAT = 0x1406;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.RGBA = 0x1908;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.FRAGMENT_SHADER = 0x8B30;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.VERTEX_SHADER = 0x8B31;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.LINK_STATUS = 0x8B82;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.LINEAR = 0x2601;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.TEXTURE_MAG_FILTER = 0x2800;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.TEXTURE_MIN_FILTER = 0x2801;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.TEXTURE_WRAP_S = 0x2802;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.TEXTURE_WRAP_T = 0x2803;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.TEXTURE_2D = 0x0DE1;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.TEXTURE0 = 0x84C0;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.CLAMP_TO_EDGE = 0x812F;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.COMPILE_STATUS = 0x8B81;

/**
 * @const
 * @type {number}
 */
_ol_webgl_.FRAMEBUFFER = 0x8D40;

/** end of goog.webgl constants
 */

/**
 * @const
 * @private
 * @type {Array.<string>}
 */
_ol_webgl_.CONTEXT_IDS_ = ['experimental-webgl', 'webgl', 'webkit-3d', 'moz-webgl'];

/**
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {Object=} opt_attributes Attributes.
 * @return {WebGLRenderingContext} WebGL rendering context.
 */
_ol_webgl_.getContext = function (canvas, opt_attributes) {
  var context,
      i,
      ii = _ol_webgl_.CONTEXT_IDS_.length;
  for (i = 0; i < ii; ++i) {
    try {
      context = canvas.getContext(_ol_webgl_.CONTEXT_IDS_[i], opt_attributes);
      if (context) {
        return (/** @type {!WebGLRenderingContext} */context
        );
      }
    } catch (e) {
      // pass
    }
  }
  return null;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_webgl_);

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__objecteventtype_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__observable_js__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__events_event_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__obj_js__ = __webpack_require__(2);






/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Most non-trivial classes inherit from this.
 *
 * This extends {@link ol.Observable} with observable properties, where each
 * property is observable as well as the object as a whole.
 *
 * Classes that inherit from this have pre-defined properties, to which you can
 * add your owns. The pre-defined properties are listed in this documentation as
 * 'Observable Properties', and have their own accessors; for example,
 * {@link ol.Map} has a `target` property, accessed with `getTarget()`  and
 * changed with `setTarget()`. Not all properties are however settable. There
 * are also general-purpose accessors `get()` and `set()`. For example,
 * `get('target')` is equivalent to `getTarget()`.
 *
 * The `set` accessors trigger a change event, and you can monitor this by
 * registering a listener. For example, {@link ol.View} has a `center`
 * property, so `view.on('change:center', function(evt) {...});` would call the
 * function whenever the value of the center property changes. Within the
 * function, `evt.target` would be the view, so `evt.target.getCenter()` would
 * return the new center.
 *
 * You can add your own observable properties with
 * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
 * You can listen for changes on that property value with
 * `object.on('change:prop', listener)`. You can get a list of all
 * properties with {@link ol.Object#getProperties object.getProperties()}.
 *
 * Note that the observable properties are separate from standard JS properties.
 * You can, for example, give your map object a title with
 * `map.title='New title'` and with `map.set('title', 'Another title')`. The
 * first will be a `hasOwnProperty`; the second will appear in
 * `getProperties()`. Only the second is observable.
 *
 * Properties can be deleted by using the unset method. E.g.
 * object.unset('foo').
 *
 * @constructor
 * @extends {ol.Observable}
 * @param {Object.<string, *>=} opt_values An object with key-value pairs.
 * @fires ol.Object.Event
 * @api
 */
var _ol_Object_ = function _ol_Object_(opt_values) {
  __WEBPACK_IMPORTED_MODULE_2__observable_js__["a" /* default */].call(this);

  // Call ol.getUid to ensure that the order of objects' ids is the same as
  // the order in which they were created.  This also helps to ensure that
  // object properties are always added in the same order, which helps many
  // JavaScript engines generate faster code.
  __WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].getUid(this);

  /**
   * @private
   * @type {!Object.<string, *>}
   */
  this.values_ = {};

  if (opt_values !== undefined) {
    this.setProperties(opt_values);
  }
};

__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].inherits(_ol_Object_, __WEBPACK_IMPORTED_MODULE_2__observable_js__["a" /* default */]);

/**
 * @private
 * @type {Object.<string, string>}
 */
_ol_Object_.changeEventTypeCache_ = {};

/**
 * @param {string} key Key name.
 * @return {string} Change name.
 */
_ol_Object_.getChangeEventType = function (key) {
  return _ol_Object_.changeEventTypeCache_.hasOwnProperty(key) ? _ol_Object_.changeEventTypeCache_[key] : _ol_Object_.changeEventTypeCache_[key] = 'change:' + key;
};

/**
 * Gets a value.
 * @param {string} key Key name.
 * @return {*} Value.
 * @api
 */
_ol_Object_.prototype.get = function (key) {
  var value;
  if (this.values_.hasOwnProperty(key)) {
    value = this.values_[key];
  }
  return value;
};

/**
 * Get a list of object property names.
 * @return {Array.<string>} List of property names.
 * @api
 */
_ol_Object_.prototype.getKeys = function () {
  return Object.keys(this.values_);
};

/**
 * Get an object of all property names and values.
 * @return {Object.<string, *>} Object.
 * @api
 */
_ol_Object_.prototype.getProperties = function () {
  return __WEBPACK_IMPORTED_MODULE_4__obj_js__["a" /* default */].assign({}, this.values_);
};

/**
 * @param {string} key Key name.
 * @param {*} oldValue Old value.
 */
_ol_Object_.prototype.notify = function (key, oldValue) {
  var eventType;
  eventType = _ol_Object_.getChangeEventType(key);
  this.dispatchEvent(new _ol_Object_.Event(eventType, key, oldValue));
  eventType = __WEBPACK_IMPORTED_MODULE_1__objecteventtype_js__["a" /* default */].PROPERTYCHANGE;
  this.dispatchEvent(new _ol_Object_.Event(eventType, key, oldValue));
};

/**
 * Sets a value.
 * @param {string} key Key name.
 * @param {*} value Value.
 * @param {boolean=} opt_silent Update without triggering an event.
 * @api
 */
_ol_Object_.prototype.set = function (key, value, opt_silent) {
  if (opt_silent) {
    this.values_[key] = value;
  } else {
    var oldValue = this.values_[key];
    this.values_[key] = value;
    if (oldValue !== value) {
      this.notify(key, oldValue);
    }
  }
};

/**
 * Sets a collection of key-value pairs.  Note that this changes any existing
 * properties and adds new ones (it does not remove any existing properties).
 * @param {Object.<string, *>} values Values.
 * @param {boolean=} opt_silent Update without triggering an event.
 * @api
 */
_ol_Object_.prototype.setProperties = function (values, opt_silent) {
  var key;
  for (key in values) {
    this.set(key, values[key], opt_silent);
  }
};

/**
 * Unsets a property.
 * @param {string} key Key name.
 * @param {boolean=} opt_silent Unset without triggering an event.
 * @api
 */
_ol_Object_.prototype.unset = function (key, opt_silent) {
  if (key in this.values_) {
    var oldValue = this.values_[key];
    delete this.values_[key];
    if (!opt_silent) {
      this.notify(key, oldValue);
    }
  }
};

/**
 * @classdesc
 * Events emitted by {@link ol.Object} instances are instances of this type.
 *
 * @param {string} type The event type.
 * @param {string} key The property name.
 * @param {*} oldValue The old value for `key`.
 * @extends {ol.events.Event}
 * @implements {oli.Object.Event}
 * @constructor
 */
_ol_Object_.Event = function (type, key, oldValue) {
  __WEBPACK_IMPORTED_MODULE_3__events_event_js__["a" /* default */].call(this, type);

  /**
   * The name of the property whose value is changing.
   * @type {string}
   * @api
   */
  this.key = key;

  /**
   * The old value. To get the new value use `e.target.get(e.key)` where
   * `e` is the event object.
   * @type {*}
   * @api
   */
  this.oldValue = oldValue;
};
__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].inherits(_ol_Object_.Event, __WEBPACK_IMPORTED_MODULE_3__events_event_js__["a" /* default */]);
/* harmony default export */ __webpack_exports__["a"] = (_ol_Object_);

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/ol/index.js
var ol = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ol/math.js
var math = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/ol/geom/geometrytype.js
var geometrytype = __webpack_require__(10);

// CONCATENATED MODULE: ./node_modules/ol/sphere.js
/**
 * @license
 * Latitude/longitude spherical geodesy formulae taken from
 * http://www.movable-type.co.uk/scripts/latlong.html
 * Licensed under CC-BY-3.0.
 */




/**
 * @classdesc
 * Class to create objects that can be used with {@link
 * ol.geom.Polygon.circular}.
 *
 * For example to create a sphere whose radius is equal to the semi-major
 * axis of the WGS84 ellipsoid:
 *
 * ```js
 * var wgs84Sphere= new ol.Sphere(6378137);
 * ```
 *
 * @constructor
 * @param {number} radius Radius.
 * @api
 */
var _ol_Sphere_ = function _ol_Sphere_(radius) {

  /**
   * @type {number}
   */
  this.radius = radius;
};

/**
 * Returns the geodesic area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @return {number} Area.
 * @api
 */
_ol_Sphere_.prototype.geodesicArea = function (coordinates) {
  return _ol_Sphere_.getArea_(coordinates, this.radius);
};

/**
 * Returns the distance from c1 to c2 using the haversine formula.
 *
 * @param {ol.Coordinate} c1 Coordinate 1.
 * @param {ol.Coordinate} c2 Coordinate 2.
 * @return {number} Haversine distance.
 * @api
 */
_ol_Sphere_.prototype.haversineDistance = function (c1, c2) {
  return _ol_Sphere_.getDistance_(c1, c2, this.radius);
};

/**
 * Returns the coordinate at the given distance and bearing from `c1`.
 *
 * @param {ol.Coordinate} c1 The origin point (`[lon, lat]` in degrees).
 * @param {number} distance The great-circle distance between the origin
 *     point and the target point.
 * @param {number} bearing The bearing (in radians).
 * @return {ol.Coordinate} The target point.
 */
_ol_Sphere_.prototype.offset = function (c1, distance, bearing) {
  var lat1 = math["a" /* default */].toRadians(c1[1]);
  var lon1 = math["a" /* default */].toRadians(c1[0]);
  var dByR = distance / this.radius;
  var lat = Math.asin(Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing));
  var lon = lon1 + Math.atan2(Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1), Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat));
  return [math["a" /* default */].toDegrees(lon), math["a" /* default */].toDegrees(lat)];
};

/**
 * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
 * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
 * @type {number}
 */
_ol_Sphere_.DEFAULT_RADIUS = 6371008.8;

/**
 * Get the spherical length of a geometry.  This length is the sum of the
 * great circle distances between coordinates.  For polygons, the length is
 * the sum of all rings.  For points, the length is zero.  For multi-part
 * geometries, the length is the sum of the length of each part.
 * @param {ol.geom.Geometry} geometry A geometry.
 * @param {olx.SphereMetricOptions=} opt_options Options for the length
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical length (in meters).
 * @api
 */
_ol_Sphere_.getLength = function (geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || _ol_Sphere_.DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  geometry = geometry.clone().transform(projection, 'EPSG:4326');
  var type = geometry.getType();
  var length = 0;
  var coordinates, coords, i, ii, j, jj;
  switch (type) {
    case geometrytype["a" /* default */].POINT:
    case geometrytype["a" /* default */].MULTI_POINT:
      {
        break;
      }
    case geometrytype["a" /* default */].LINE_STRING:
    case geometrytype["a" /* default */].LINEAR_RING:
      {
        coordinates = /** @type {ol.geom.SimpleGeometry} */geometry.getCoordinates();
        length = _ol_Sphere_.getLength_(coordinates, radius);
        break;
      }
    case geometrytype["a" /* default */].MULTI_LINE_STRING:
    case geometrytype["a" /* default */].POLYGON:
      {
        coordinates = /** @type {ol.geom.SimpleGeometry} */geometry.getCoordinates();
        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          length += _ol_Sphere_.getLength_(coordinates[i], radius);
        }
        break;
      }
    case geometrytype["a" /* default */].MULTI_POLYGON:
      {
        coordinates = /** @type {ol.geom.SimpleGeometry} */geometry.getCoordinates();
        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];
          for (j = 0, jj = coords.length; j < jj; ++j) {
            length += _ol_Sphere_.getLength_(coords[j], radius);
          }
        }
        break;
      }
    case geometrytype["a" /* default */].GEOMETRY_COLLECTION:
      {
        var geometries = /** @type {ol.geom.GeometryCollection} */geometry.getGeometries();
        for (i = 0, ii = geometries.length; i < ii; ++i) {
          length += _ol_Sphere_.getLength(geometries[i], opt_options);
        }
        break;
      }
    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }
  return length;
};

/**
 * Get the cumulative great circle length of linestring coordinates (geographic).
 * @param {Array} coordinates Linestring coordinates.
 * @param {number} radius The sphere radius to use.
 * @return {number} The length (in meters).
 */
_ol_Sphere_.getLength_ = function (coordinates, radius) {
  var length = 0;
  for (var i = 0, ii = coordinates.length; i < ii - 1; ++i) {
    length += _ol_Sphere_.getDistance_(coordinates[i], coordinates[i + 1], radius);
  }
  return length;
};

/**
 * Get the great circle distance between two geographic coordinates.
 * @param {Array} c1 Starting coordinate.
 * @param {Array} c2 Ending coordinate.
 * @param {number} radius The sphere radius to use.
 * @return {number} The great circle distance between the points (in meters).
 */
_ol_Sphere_.getDistance_ = function (c1, c2, radius) {
  var lat1 = math["a" /* default */].toRadians(c1[1]);
  var lat2 = math["a" /* default */].toRadians(c2[1]);
  var deltaLatBy2 = (lat2 - lat1) / 2;
  var deltaLonBy2 = math["a" /* default */].toRadians(c2[0] - c1[0]) / 2;
  var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
};

/**
 * Get the spherical area of a geometry.  This is the area (in meters) assuming
 * that polygon edges are segments of great circles on a sphere.
 * @param {ol.geom.Geometry} geometry A geometry.
 * @param {olx.SphereMetricOptions=} opt_options Options for the area
 *     calculation.  By default, geometries are assumed to be in 'EPSG:3857'.
 *     You can change this by providing a `projection` option.
 * @return {number} The spherical area (in square meters).
 * @api
 */
_ol_Sphere_.getArea = function (geometry, opt_options) {
  var options = opt_options || {};
  var radius = options.radius || _ol_Sphere_.DEFAULT_RADIUS;
  var projection = options.projection || 'EPSG:3857';
  geometry = geometry.clone().transform(projection, 'EPSG:4326');
  var type = geometry.getType();
  var area = 0;
  var coordinates, coords, i, ii, j, jj;
  switch (type) {
    case geometrytype["a" /* default */].POINT:
    case geometrytype["a" /* default */].MULTI_POINT:
    case geometrytype["a" /* default */].LINE_STRING:
    case geometrytype["a" /* default */].MULTI_LINE_STRING:
    case geometrytype["a" /* default */].LINEAR_RING:
      {
        break;
      }
    case geometrytype["a" /* default */].POLYGON:
      {
        coordinates = /** @type {ol.geom.Polygon} */geometry.getCoordinates();
        area = Math.abs(_ol_Sphere_.getArea_(coordinates[0], radius));
        for (i = 1, ii = coordinates.length; i < ii; ++i) {
          area -= Math.abs(_ol_Sphere_.getArea_(coordinates[i], radius));
        }
        break;
      }
    case geometrytype["a" /* default */].MULTI_POLYGON:
      {
        coordinates = /** @type {ol.geom.SimpleGeometry} */geometry.getCoordinates();
        for (i = 0, ii = coordinates.length; i < ii; ++i) {
          coords = coordinates[i];
          area += Math.abs(_ol_Sphere_.getArea_(coords[0], radius));
          for (j = 1, jj = coords.length; j < jj; ++j) {
            area -= Math.abs(_ol_Sphere_.getArea_(coords[j], radius));
          }
        }
        break;
      }
    case geometrytype["a" /* default */].GEOMETRY_COLLECTION:
      {
        var geometries = /** @type {ol.geom.GeometryCollection} */geometry.getGeometries();
        for (i = 0, ii = geometries.length; i < ii; ++i) {
          area += _ol_Sphere_.getArea(geometries[i], opt_options);
        }
        break;
      }
    default:
      {
        throw new Error('Unsupported geometry type: ' + type);
      }
  }
  return area;
};

/**
 * Returns the spherical area for a list of coordinates.
 *
 * [Reference](https://trs-new.jpl.nasa.gov/handle/2014/40409)
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 * Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 * Laboratory, Pasadena, CA, June 2007
 *
 * @param {Array.<ol.Coordinate>} coordinates List of coordinates of a linear
 * ring. If the ring is oriented clockwise, the area will be positive,
 * otherwise it will be negative.
 * @param {number} radius The sphere radius.
 * @return {number} Area (in square meters).
 */
_ol_Sphere_.getArea_ = function (coordinates, radius) {
  var area = 0,
      len = coordinates.length;
  var x1 = coordinates[len - 1][0];
  var y1 = coordinates[len - 1][1];
  for (var i = 0; i < len; i++) {
    var x2 = coordinates[i][0],
        y2 = coordinates[i][1];
    area += math["a" /* default */].toRadians(x2 - x1) * (2 + Math.sin(math["a" /* default */].toRadians(y1)) + Math.sin(math["a" /* default */].toRadians(y2)));
    x1 = x2;
    y1 = y2;
  }
  return area * radius * radius / 2.0;
};
/* harmony default export */ var sphere = (_ol_Sphere_);
// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__(1);

// EXTERNAL MODULE: ./node_modules/ol/proj/units.js
var proj_units = __webpack_require__(26);

// CONCATENATED MODULE: ./node_modules/ol/proj/proj4.js
var _ol_proj_proj4_ = {};

/**
 * @private
 * @type {Proj4}
 */
_ol_proj_proj4_.cache_ = null;

/**
 * Store the proj4 function.
 * @param {Proj4} proj4 The proj4 function.
 */
_ol_proj_proj4_.set = function (proj4) {
  _ol_proj_proj4_.cache_ = proj4;
};

/**
 * Get proj4.
 * @return {Proj4} The proj4 function set above or available globally.
 */
_ol_proj_proj4_.get = function () {
  return _ol_proj_proj4_.cache_ || (typeof window !== 'undefined' ? window['proj4'] : undefined);
};
/* harmony default export */ var proj_proj4 = (_ol_proj_proj4_);
// CONCATENATED MODULE: ./node_modules/ol/proj/projection.js




/**
 * @classdesc
 * Projection definition class. One of these is created for each projection
 * supported in the application and stored in the {@link ol.proj} namespace.
 * You can use these in applications, but this is not required, as API params
 * and options use {@link ol.ProjectionLike} which means the simple string
 * code will suffice.
 *
 * You can use {@link ol.proj.get} to retrieve the object for a particular
 * projection.
 *
 * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
 * with the following aliases:
 * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
 *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
 *     http://www.opengis.net/gml/srs/epsg.xml#4326,
 *     urn:x-ogc:def:crs:EPSG:4326
 * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
 *     urn:ogc:def:crs:EPSG:6.18:3:3857,
 *     http://www.opengis.net/gml/srs/epsg.xml#3857
 *
 * If you use proj4js, aliases can be added using `proj4.defs()`; see
 * [documentation](https://github.com/proj4js/proj4js). To set an alternative
 * namespace for proj4, use {@link ol.proj.setProj4}.
 *
 * @constructor
 * @param {olx.ProjectionOptions} options Projection options.
 * @struct
 * @api
 */
var projection__ol_proj_Projection_ = function _ol_proj_Projection_(options) {
  /**
   * @private
   * @type {string}
   */
  this.code_ = options.code;

  /**
   * Units of projected coordinates. When set to `ol.proj.Units.TILE_PIXELS`, a
   * `this.extent_` and `this.worldExtent_` must be configured properly for each
   * tile.
   * @private
   * @type {ol.proj.Units}
   */
  this.units_ = /** @type {ol.proj.Units} */options.units;

  /**
   * Validity extent of the projection in projected coordinates. For projections
   * with `ol.proj.Units.TILE_PIXELS` units, this is the extent of the tile in
   * tile pixel space.
   * @private
   * @type {ol.Extent}
   */
  this.extent_ = options.extent !== undefined ? options.extent : null;

  /**
   * Extent of the world in EPSG:4326. For projections with
   * `ol.proj.Units.TILE_PIXELS` units, this is the extent of the tile in
   * projected coordinate space.
   * @private
   * @type {ol.Extent}
   */
  this.worldExtent_ = options.worldExtent !== undefined ? options.worldExtent : null;

  /**
   * @private
   * @type {string}
   */
  this.axisOrientation_ = options.axisOrientation !== undefined ? options.axisOrientation : 'enu';

  /**
   * @private
   * @type {boolean}
   */
  this.global_ = options.global !== undefined ? options.global : false;

  /**
   * @private
   * @type {boolean}
   */
  this.canWrapX_ = !!(this.global_ && this.extent_);

  /**
   * @private
   * @type {function(number, ol.Coordinate):number|undefined}
   */
  this.getPointResolutionFunc_ = options.getPointResolution;

  /**
   * @private
   * @type {ol.tilegrid.TileGrid}
   */
  this.defaultTileGrid_ = null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.metersPerUnit_ = options.metersPerUnit;

  var code = options.code;
  if (ol["a" /* default */].ENABLE_PROJ4JS) {
    var proj4js = proj_proj4.get();
    if (typeof proj4js == 'function') {
      var def = proj4js.defs(code);
      if (def !== undefined) {
        if (def.axis !== undefined && options.axisOrientation === undefined) {
          this.axisOrientation_ = def.axis;
        }
        if (options.metersPerUnit === undefined) {
          this.metersPerUnit_ = def.to_meter;
        }
        if (options.units === undefined) {
          this.units_ = def.units;
        }
      }
    }
  }
};

/**
 * @return {boolean} The projection is suitable for wrapping the x-axis
 */
projection__ol_proj_Projection_.prototype.canWrapX = function () {
  return this.canWrapX_;
};

/**
 * Get the code for this projection, e.g. 'EPSG:4326'.
 * @return {string} Code.
 * @api
 */
projection__ol_proj_Projection_.prototype.getCode = function () {
  return this.code_;
};

/**
 * Get the validity extent for this projection.
 * @return {ol.Extent} Extent.
 * @api
 */
projection__ol_proj_Projection_.prototype.getExtent = function () {
  return this.extent_;
};

/**
 * Get the units of this projection.
 * @return {ol.proj.Units} Units.
 * @api
 */
projection__ol_proj_Projection_.prototype.getUnits = function () {
  return this.units_;
};

/**
 * Get the amount of meters per unit of this projection.  If the projection is
 * not configured with `metersPerUnit` or a units identifier, the return is
 * `undefined`.
 * @return {number|undefined} Meters.
 * @api
 */
projection__ol_proj_Projection_.prototype.getMetersPerUnit = function () {
  return this.metersPerUnit_ || proj_units["a" /* default */].METERS_PER_UNIT[this.units_];
};

/**
 * Get the world extent for this projection.
 * @return {ol.Extent} Extent.
 * @api
 */
projection__ol_proj_Projection_.prototype.getWorldExtent = function () {
  return this.worldExtent_;
};

/**
 * Get the axis orientation of this projection.
 * Example values are:
 * enu - the default easting, northing, elevation.
 * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
 *     or south orientated transverse mercator.
 * wnu - westing, northing, up - some planetary coordinate systems have
 *     "west positive" coordinate systems
 * @return {string} Axis orientation.
 * @api
 */
projection__ol_proj_Projection_.prototype.getAxisOrientation = function () {
  return this.axisOrientation_;
};

/**
 * Is this projection a global projection which spans the whole world?
 * @return {boolean} Whether the projection is global.
 * @api
 */
projection__ol_proj_Projection_.prototype.isGlobal = function () {
  return this.global_;
};

/**
* Set if the projection is a global projection which spans the whole world
* @param {boolean} global Whether the projection is global.
* @api
*/
projection__ol_proj_Projection_.prototype.setGlobal = function (global) {
  this.global_ = global;
  this.canWrapX_ = !!(global && this.extent_);
};

/**
 * @return {ol.tilegrid.TileGrid} The default tile grid.
 */
projection__ol_proj_Projection_.prototype.getDefaultTileGrid = function () {
  return this.defaultTileGrid_;
};

/**
 * @param {ol.tilegrid.TileGrid} tileGrid The default tile grid.
 */
projection__ol_proj_Projection_.prototype.setDefaultTileGrid = function (tileGrid) {
  this.defaultTileGrid_ = tileGrid;
};

/**
 * Set the validity extent for this projection.
 * @param {ol.Extent} extent Extent.
 * @api
 */
projection__ol_proj_Projection_.prototype.setExtent = function (extent) {
  this.extent_ = extent;
  this.canWrapX_ = !!(this.global_ && extent);
};

/**
 * Set the world extent for this projection.
 * @param {ol.Extent} worldExtent World extent
 *     [minlon, minlat, maxlon, maxlat].
 * @api
 */
projection__ol_proj_Projection_.prototype.setWorldExtent = function (worldExtent) {
  this.worldExtent_ = worldExtent;
};

/**
 * Set the getPointResolution function (see {@link ol.proj#getPointResolution}
 * for this projection.
 * @param {function(number, ol.Coordinate):number} func Function
 * @api
 */
projection__ol_proj_Projection_.prototype.setGetPointResolution = function (func) {
  this.getPointResolutionFunc_ = func;
};

/**
 * Get the custom point resolution function for this projection (if set).
 * @return {function(number, ol.Coordinate):number|undefined} The custom point
 * resolution function (if set).
 */
projection__ol_proj_Projection_.prototype.getPointResolutionFunc = function () {
  return this.getPointResolutionFunc_;
};
/* harmony default export */ var proj_projection = (projection__ol_proj_Projection_);
// CONCATENATED MODULE: ./node_modules/ol/proj/epsg3857.js




var _ol_proj_EPSG3857_ = {};

/**
 * @classdesc
 * Projection object for web/spherical Mercator (EPSG:3857).
 *
 * @constructor
 * @extends {ol.proj.Projection}
 * @param {string} code Code.
 * @private
 */
_ol_proj_EPSG3857_.Projection_ = function (code) {
  proj_projection.call(this, {
    code: code,
    units: proj_units["a" /* default */].METERS,
    extent: _ol_proj_EPSG3857_.EXTENT,
    global: true,
    worldExtent: _ol_proj_EPSG3857_.WORLD_EXTENT,
    getPointResolution: function getPointResolution(resolution, point) {
      return resolution / math["a" /* default */].cosh(point[1] / _ol_proj_EPSG3857_.RADIUS);
    }
  });
};
ol["a" /* default */].inherits(_ol_proj_EPSG3857_.Projection_, proj_projection);

/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
_ol_proj_EPSG3857_.RADIUS = 6378137;

/**
 * @const
 * @type {number}
 */
_ol_proj_EPSG3857_.HALF_SIZE = Math.PI * _ol_proj_EPSG3857_.RADIUS;

/**
 * @const
 * @type {ol.Extent}
 */
_ol_proj_EPSG3857_.EXTENT = [-_ol_proj_EPSG3857_.HALF_SIZE, -_ol_proj_EPSG3857_.HALF_SIZE, _ol_proj_EPSG3857_.HALF_SIZE, _ol_proj_EPSG3857_.HALF_SIZE];

/**
 * @const
 * @type {ol.Extent}
 */
_ol_proj_EPSG3857_.WORLD_EXTENT = [-180, -85, 180, 85];

/**
 * Projections equal to EPSG:3857.
 *
 * @const
 * @type {Array.<ol.proj.Projection>}
 */
_ol_proj_EPSG3857_.PROJECTIONS = [new _ol_proj_EPSG3857_.Projection_('EPSG:3857'), new _ol_proj_EPSG3857_.Projection_('EPSG:102100'), new _ol_proj_EPSG3857_.Projection_('EPSG:102113'), new _ol_proj_EPSG3857_.Projection_('EPSG:900913'), new _ol_proj_EPSG3857_.Projection_('urn:ogc:def:crs:EPSG:6.18:3:3857'), new _ol_proj_EPSG3857_.Projection_('urn:ogc:def:crs:EPSG::3857'), new _ol_proj_EPSG3857_.Projection_('http://www.opengis.net/gml/srs/epsg.xml#3857')];

/**
 * Transformation from EPSG:4326 to EPSG:3857.
 *
 * @param {Array.<number>} input Input array of coordinate values.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array.<number>} Output array of coordinate values.
 */
_ol_proj_EPSG3857_.fromEPSG4326 = function (input, opt_output, opt_dimension) {
  var length = input.length,
      dimension = opt_dimension > 1 ? opt_dimension : 2,
      output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  var halfSize = _ol_proj_EPSG3857_.HALF_SIZE;
  for (var i = 0; i < length; i += dimension) {
    output[i] = halfSize * input[i] / 180;
    var y = _ol_proj_EPSG3857_.RADIUS * Math.log(Math.tan(Math.PI * (input[i + 1] + 90) / 360));
    if (y > halfSize) {
      y = halfSize;
    } else if (y < -halfSize) {
      y = -halfSize;
    }
    output[i + 1] = y;
  }
  return output;
};

/**
 * Transformation from EPSG:3857 to EPSG:4326.
 *
 * @param {Array.<number>} input Input array of coordinate values.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension (default is `2`).
 * @return {Array.<number>} Output array of coordinate values.
 */
_ol_proj_EPSG3857_.toEPSG4326 = function (input, opt_output, opt_dimension) {
  var length = input.length,
      dimension = opt_dimension > 1 ? opt_dimension : 2,
      output = opt_output;
  if (output === undefined) {
    if (dimension > 2) {
      // preserve values beyond second dimension
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (var i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / _ol_proj_EPSG3857_.HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / _ol_proj_EPSG3857_.RADIUS)) / Math.PI - 90;
  }
  return output;
};
/* harmony default export */ var epsg3857 = (_ol_proj_EPSG3857_);
// CONCATENATED MODULE: ./node_modules/ol/proj/epsg4326.js



var _ol_proj_EPSG4326_ = {};

/**
 * @classdesc
 * Projection object for WGS84 geographic coordinates (EPSG:4326).
 *
 * Note that OpenLayers does not strictly comply with the EPSG definition.
 * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
 * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
 *
 * @constructor
 * @extends {ol.proj.Projection}
 * @param {string} code Code.
 * @param {string=} opt_axisOrientation Axis orientation.
 * @private
 */
_ol_proj_EPSG4326_.Projection_ = function (code, opt_axisOrientation) {
  proj_projection.call(this, {
    code: code,
    units: proj_units["a" /* default */].DEGREES,
    extent: _ol_proj_EPSG4326_.EXTENT,
    axisOrientation: opt_axisOrientation,
    global: true,
    metersPerUnit: _ol_proj_EPSG4326_.METERS_PER_UNIT,
    worldExtent: _ol_proj_EPSG4326_.EXTENT
  });
};
ol["a" /* default */].inherits(_ol_proj_EPSG4326_.Projection_, proj_projection);

/**
 * Radius of WGS84 sphere
 *
 * @const
 * @type {number}
 */
_ol_proj_EPSG4326_.RADIUS = 6378137;

/**
 * Extent of the EPSG:4326 projection which is the whole world.
 *
 * @const
 * @type {ol.Extent}
 */
_ol_proj_EPSG4326_.EXTENT = [-180, -90, 180, 90];

/**
 * @const
 * @type {number}
 */
_ol_proj_EPSG4326_.METERS_PER_UNIT = Math.PI * _ol_proj_EPSG4326_.RADIUS / 180;

/**
 * Projections equal to EPSG:4326.
 *
 * @const
 * @type {Array.<ol.proj.Projection>}
 */
_ol_proj_EPSG4326_.PROJECTIONS = [new _ol_proj_EPSG4326_.Projection_('CRS:84'), new _ol_proj_EPSG4326_.Projection_('EPSG:4326', 'neu'), new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:EPSG::4326', 'neu'), new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'), new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:OGC:1.3:CRS84'), new _ol_proj_EPSG4326_.Projection_('urn:ogc:def:crs:OGC:2:84'), new _ol_proj_EPSG4326_.Projection_('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'), new _ol_proj_EPSG4326_.Projection_('urn:x-ogc:def:crs:EPSG:4326', 'neu')];
/* harmony default export */ var epsg4326 = (_ol_proj_EPSG4326_);
// CONCATENATED MODULE: ./node_modules/ol/proj/projections.js
var _ol_proj_projections_ = {};

/**
 * @private
 * @type {Object.<string, ol.proj.Projection>}
 */
_ol_proj_projections_.cache_ = {};

/**
 * Clear the projections cache.
 */
_ol_proj_projections_.clear = function () {
  _ol_proj_projections_.cache_ = {};
};

/**
 * Get a cached projection by code.
 * @param {string} code The code for the projection.
 * @return {ol.proj.Projection} The projection (if cached).
 */
_ol_proj_projections_.get = function (code) {
  var projections = _ol_proj_projections_.cache_;
  return projections[code] || null;
};

/**
 * Add a projection to the cache.
 * @param {string} code The projection code.
 * @param {ol.proj.Projection} projection The projection to cache.
 */
_ol_proj_projections_.add = function (code, projection) {
  var projections = _ol_proj_projections_.cache_;
  projections[code] = projection;
};
/* harmony default export */ var proj_projections = (_ol_proj_projections_);
// EXTERNAL MODULE: ./node_modules/ol/obj.js
var obj = __webpack_require__(2);

// CONCATENATED MODULE: ./node_modules/ol/proj/transforms.js

var _ol_proj_transforms_ = {};

/**
 * @private
 * @type {Object.<string, Object.<string, ol.TransformFunction>>}
 */
_ol_proj_transforms_.cache_ = {};

/**
 * Clear the transform cache.
 */
_ol_proj_transforms_.clear = function () {
  _ol_proj_transforms_.cache_ = {};
};

/**
 * Registers a conversion function to convert coordinates from the source
 * projection to the destination projection.
 *
 * @param {ol.proj.Projection} source Source.
 * @param {ol.proj.Projection} destination Destination.
 * @param {ol.TransformFunction} transformFn Transform.
 */
_ol_proj_transforms_.add = function (source, destination, transformFn) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transforms = _ol_proj_transforms_.cache_;
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
};

/**
 * Unregisters the conversion function to convert coordinates from the source
 * projection to the destination projection.  This method is used to clean up
 * cached transforms during testing.
 *
 * @param {ol.proj.Projection} source Source projection.
 * @param {ol.proj.Projection} destination Destination projection.
 * @return {ol.TransformFunction} transformFn The unregistered transform.
 */
_ol_proj_transforms_.remove = function (source, destination) {
  var sourceCode = source.getCode();
  var destinationCode = destination.getCode();
  var transforms = _ol_proj_transforms_.cache_;
  var transform = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];
  if (obj["a" /* default */].isEmpty(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }
  return transform;
};

/**
 * Get a transform given a source code and a destination code.
 * @param {string} sourceCode The code for the source projection.
 * @param {string} destinationCode The code for the destination projection.
 * @return {ol.TransformFunction|undefined} The transform function (if found).
 */
_ol_proj_transforms_.get = function (sourceCode, destinationCode) {
  var transform;
  var transforms = _ol_proj_transforms_.cache_;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform = transforms[sourceCode][destinationCode];
  }
  return transform;
};
/* harmony default export */ var proj_transforms = (_ol_proj_transforms_);
// CONCATENATED MODULE: ./node_modules/ol/proj.js











var _ol_proj_ = {};

/**
 * Meters per unit lookup table.
 * @const
 * @type {Object.<ol.proj.Units, number>}
 * @api
 */
_ol_proj_.METERS_PER_UNIT = proj_units["a" /* default */].METERS_PER_UNIT;

/**
 * A place to store the mean radius of the Earth.
 * @private
 * @type {ol.Sphere}
 */
_ol_proj_.SPHERE_ = new sphere(sphere.DEFAULT_RADIUS);

if (ol["a" /* default */].ENABLE_PROJ4JS) {
  /**
   * Register proj4. If not explicitly registered, it will be assumed that
   * proj4js will be loaded in the global namespace. For example in a
   * browserify ES6 environment you could use:
   *
   *     import ol from 'openlayers';
   *     import proj4 from 'proj4';
   *     ol.proj.setProj4(proj4);
   *
   * @param {Proj4} proj4 Proj4.
   * @api
   */
  _ol_proj_.setProj4 = function (proj4) {
    proj_proj4.set(proj4);
  };
}

/**
 * Get the resolution of the point in degrees or distance units.
 * For projections with degrees as the unit this will simply return the
 * provided resolution. For other projections the point resolution is
 * by default estimated by transforming the 'point' pixel to EPSG:4326,
 * measuring its width and height on the normal sphere,
 * and taking the average of the width and height.
 * A custom function can be provided for a specific projection, either
 * by setting the `getPointResolution` option in the
 * {@link ol.proj.Projection} constructor or by using
 * {@link ol.proj.Projection#setGetPointResolution} to change an existing
 * projection object.
 * @param {ol.ProjectionLike} projection The projection.
 * @param {number} resolution Nominal resolution in projection units.
 * @param {ol.Coordinate} point Point to find adjusted resolution at.
 * @param {ol.proj.Units=} opt_units Units to get the point resolution in.
 * Default is the projection's units.
 * @return {number} Point resolution.
 * @api
 */
_ol_proj_.getPointResolution = function (projection, resolution, point, opt_units) {
  projection = _ol_proj_.get(projection);
  var pointResolution;
  var getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
  } else {
    var units = projection.getUnits();
    if (units == proj_units["a" /* default */].DEGREES && !opt_units || opt_units == proj_units["a" /* default */].DEGREES) {
      pointResolution = resolution;
    } else {
      // Estimate point resolution by transforming the center pixel to EPSG:4326,
      // measuring its width and height on the normal sphere, and taking the
      // average of the width and height.
      var toEPSG4326 = _ol_proj_.getTransformFromProjections(projection, _ol_proj_.get('EPSG:4326'));
      var vertices = [point[0] - resolution / 2, point[1], point[0] + resolution / 2, point[1], point[0], point[1] - resolution / 2, point[0], point[1] + resolution / 2];
      vertices = toEPSG4326(vertices, vertices, 2);
      var width = _ol_proj_.SPHERE_.haversineDistance(vertices.slice(0, 2), vertices.slice(2, 4));
      var height = _ol_proj_.SPHERE_.haversineDistance(vertices.slice(4, 6), vertices.slice(6, 8));
      pointResolution = (width + height) / 2;
      var metersPerUnit = opt_units ? proj_units["a" /* default */].METERS_PER_UNIT[opt_units] : projection.getMetersPerUnit();
      if (metersPerUnit !== undefined) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
};

/**
 * Registers transformation functions that don't alter coordinates. Those allow
 * to transform between projections with equal meaning.
 *
 * @param {Array.<ol.proj.Projection>} projections Projections.
 * @api
 */
_ol_proj_.addEquivalentProjections = function (projections) {
  _ol_proj_.addProjections(projections);
  projections.forEach(function (source) {
    projections.forEach(function (destination) {
      if (source !== destination) {
        proj_transforms.add(source, destination, _ol_proj_.cloneTransform);
      }
    });
  });
};

/**
 * Registers transformation functions to convert coordinates in any projection
 * in projection1 to any projection in projection2.
 *
 * @param {Array.<ol.proj.Projection>} projections1 Projections with equal
 *     meaning.
 * @param {Array.<ol.proj.Projection>} projections2 Projections with equal
 *     meaning.
 * @param {ol.TransformFunction} forwardTransform Transformation from any
 *   projection in projection1 to any projection in projection2.
 * @param {ol.TransformFunction} inverseTransform Transform from any projection
 *   in projection2 to any projection in projection1..
 */
_ol_proj_.addEquivalentTransforms = function (projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function (projection1) {
    projections2.forEach(function (projection2) {
      proj_transforms.add(projection1, projection2, forwardTransform);
      proj_transforms.add(projection2, projection1, inverseTransform);
    });
  });
};

/**
 * Add a Projection object to the list of supported projections that can be
 * looked up by their code.
 *
 * @param {ol.proj.Projection} projection Projection instance.
 * @api
 */
_ol_proj_.addProjection = function (projection) {
  proj_projections.add(projection.getCode(), projection);
  proj_transforms.add(projection, projection, _ol_proj_.cloneTransform);
};

/**
 * @param {Array.<ol.proj.Projection>} projections Projections.
 */
_ol_proj_.addProjections = function (projections) {
  projections.forEach(_ol_proj_.addProjection);
};

/**
 * Clear all cached projections and transforms.
 */
_ol_proj_.clearAllProjections = function () {
  proj_projections.clear();
  proj_transforms.clear();
};

/**
 * @param {ol.proj.Projection|string|undefined} projection Projection.
 * @param {string} defaultCode Default code.
 * @return {ol.proj.Projection} Projection.
 */
_ol_proj_.createProjection = function (projection, defaultCode) {
  if (!projection) {
    return _ol_proj_.get(defaultCode);
  } else if (typeof projection === 'string') {
    return _ol_proj_.get(projection);
  } else {
    return (/** @type {ol.proj.Projection} */projection
    );
  }
};

/**
 * Registers coordinate transform functions to convert coordinates between the
 * source projection and the destination projection.
 * The forward and inverse functions convert coordinate pairs; this function
 * converts these into the functions used internally which also handle
 * extents and coordinate arrays.
 *
 * @param {ol.ProjectionLike} source Source projection.
 * @param {ol.ProjectionLike} destination Destination projection.
 * @param {function(ol.Coordinate): ol.Coordinate} forward The forward transform
 *     function (that is, from the source projection to the destination
 *     projection) that takes a {@link ol.Coordinate} as argument and returns
 *     the transformed {@link ol.Coordinate}.
 * @param {function(ol.Coordinate): ol.Coordinate} inverse The inverse transform
 *     function (that is, from the destination projection to the source
 *     projection) that takes a {@link ol.Coordinate} as argument and returns
 *     the transformed {@link ol.Coordinate}.
 * @api
 */
_ol_proj_.addCoordinateTransforms = function (source, destination, forward, inverse) {
  var sourceProj = _ol_proj_.get(source);
  var destProj = _ol_proj_.get(destination);
  proj_transforms.add(sourceProj, destProj, _ol_proj_.createTransformFromCoordinateTransform(forward));
  proj_transforms.add(destProj, sourceProj, _ol_proj_.createTransformFromCoordinateTransform(inverse));
};

/**
 * Creates a {@link ol.TransformFunction} from a simple 2D coordinate transform
 * function.
 * @param {function(ol.Coordinate): ol.Coordinate} transform Coordinate
 *     transform.
 * @return {ol.TransformFunction} Transform function.
 */
_ol_proj_.createTransformFromCoordinateTransform = function (transform) {
  return (
    /**
     * @param {Array.<number>} input Input.
     * @param {Array.<number>=} opt_output Output.
     * @param {number=} opt_dimension Dimension.
     * @return {Array.<number>} Output.
     */
    function (input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension !== undefined ? opt_dimension : 2;
      var output = opt_output !== undefined ? opt_output : new Array(length);
      var point, i, j;
      for (i = 0; i < length; i += dimension) {
        point = transform([input[i], input[i + 1]]);
        output[i] = point[0];
        output[i + 1] = point[1];
        for (j = dimension - 1; j >= 2; --j) {
          output[i + j] = input[i + j];
        }
      }
      return output;
    }
  );
};

/**
 * Transforms a coordinate from longitude/latitude to a different projection.
 * @param {ol.Coordinate} coordinate Coordinate as longitude and latitude, i.e.
 *     an array with longitude as 1st and latitude as 2nd element.
 * @param {ol.ProjectionLike=} opt_projection Target projection. The
 *     default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {ol.Coordinate} Coordinate projected to the target projection.
 * @api
 */
_ol_proj_.fromLonLat = function (coordinate, opt_projection) {
  return _ol_proj_.transform(coordinate, 'EPSG:4326', opt_projection !== undefined ? opt_projection : 'EPSG:3857');
};

/**
 * Transforms a coordinate to longitude/latitude.
 * @param {ol.Coordinate} coordinate Projected coordinate.
 * @param {ol.ProjectionLike=} opt_projection Projection of the coordinate.
 *     The default is Web Mercator, i.e. 'EPSG:3857'.
 * @return {ol.Coordinate} Coordinate as longitude and latitude, i.e. an array
 *     with longitude as 1st and latitude as 2nd element.
 * @api
 */
_ol_proj_.toLonLat = function (coordinate, opt_projection) {
  var lonLat = _ol_proj_.transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');
  var lon = lonLat[0];
  if (lon < -180 || lon > 180) {
    lonLat[0] = math["a" /* default */].modulo(lon + 180, 360) - 180;
  }
  return lonLat;
};

/**
 * Fetches a Projection object for the code specified.
 *
 * @param {ol.ProjectionLike} projectionLike Either a code string which is
 *     a combination of authority and identifier such as "EPSG:4326", or an
 *     existing projection object, or undefined.
 * @return {ol.proj.Projection} Projection object, or null if not in list.
 * @api
 */
_ol_proj_.get = function (projectionLike) {
  var projection = null;
  if (projectionLike instanceof proj_projection) {
    projection = projectionLike;
  } else if (typeof projectionLike === 'string') {
    var code = projectionLike;
    projection = proj_projections.get(code);
    if (ol["a" /* default */].ENABLE_PROJ4JS && !projection) {
      var proj4js = proj_proj4.get();
      if (typeof proj4js == 'function' && proj4js.defs(code) !== undefined) {
        projection = new proj_projection({ code: code });
        _ol_proj_.addProjection(projection);
      }
    }
  }
  return projection;
};

/**
 * Checks if two projections are the same, that is every coordinate in one
 * projection does represent the same geographic point as the same coordinate in
 * the other projection.
 *
 * @param {ol.proj.Projection} projection1 Projection 1.
 * @param {ol.proj.Projection} projection2 Projection 2.
 * @return {boolean} Equivalent.
 * @api
 */
_ol_proj_.equivalent = function (projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  var equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  } else {
    var transformFn = _ol_proj_.getTransformFromProjections(projection1, projection2);
    return transformFn === _ol_proj_.cloneTransform && equalUnits;
  }
};

/**
 * Given the projection-like objects, searches for a transformation
 * function to convert a coordinates array from the source projection to the
 * destination projection.
 *
 * @param {ol.ProjectionLike} source Source.
 * @param {ol.ProjectionLike} destination Destination.
 * @return {ol.TransformFunction} Transform function.
 * @api
 */
_ol_proj_.getTransform = function (source, destination) {
  var sourceProjection = _ol_proj_.get(source);
  var destinationProjection = _ol_proj_.get(destination);
  return _ol_proj_.getTransformFromProjections(sourceProjection, destinationProjection);
};

/**
 * Searches in the list of transform functions for the function for converting
 * coordinates from the source projection to the destination projection.
 *
 * @param {ol.proj.Projection} sourceProjection Source Projection object.
 * @param {ol.proj.Projection} destinationProjection Destination Projection
 *     object.
 * @return {ol.TransformFunction} Transform function.
 */
_ol_proj_.getTransformFromProjections = function (sourceProjection, destinationProjection) {
  var sourceCode = sourceProjection.getCode();
  var destinationCode = destinationProjection.getCode();
  var transform = proj_transforms.get(sourceCode, destinationCode);
  if (ol["a" /* default */].ENABLE_PROJ4JS && !transform) {
    var proj4js = proj_proj4.get();
    if (typeof proj4js == 'function') {
      var sourceDef = proj4js.defs(sourceCode);
      var destinationDef = proj4js.defs(destinationCode);

      if (sourceDef !== undefined && destinationDef !== undefined) {
        if (sourceDef === destinationDef) {
          _ol_proj_.addEquivalentProjections([destinationProjection, sourceProjection]);
        } else {
          var proj4Transform = proj4js(destinationCode, sourceCode);
          _ol_proj_.addCoordinateTransforms(destinationProjection, sourceProjection, proj4Transform.forward, proj4Transform.inverse);
        }
        transform = proj_transforms.get(sourceCode, destinationCode);
      }
    }
  }
  if (!transform) {
    transform = _ol_proj_.identityTransform;
  }
  return transform;
};

/**
 * @param {Array.<number>} input Input coordinate array.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array.<number>} Input coordinate array (same array as input).
 */
_ol_proj_.identityTransform = function (input, opt_output, opt_dimension) {
  if (opt_output !== undefined && input !== opt_output) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    input = opt_output;
  }
  return input;
};

/**
 * @param {Array.<number>} input Input coordinate array.
 * @param {Array.<number>=} opt_output Output array of coordinate values.
 * @param {number=} opt_dimension Dimension.
 * @return {Array.<number>} Output coordinate array (new array, same coordinate
 *     values).
 */
_ol_proj_.cloneTransform = function (input, opt_output, opt_dimension) {
  var output;
  if (opt_output !== undefined) {
    for (var i = 0, ii = input.length; i < ii; ++i) {
      opt_output[i] = input[i];
    }
    output = opt_output;
  } else {
    output = input.slice();
  }
  return output;
};

/**
 * Transforms a coordinate from source projection to destination projection.
 * This returns a new coordinate (and does not modify the original).
 *
 * See {@link ol.proj.transformExtent} for extent transformation.
 * See the transform method of {@link ol.geom.Geometry} and its subclasses for
 * geometry transforms.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.ProjectionLike} source Source projection-like.
 * @param {ol.ProjectionLike} destination Destination projection-like.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */
_ol_proj_.transform = function (coordinate, source, destination) {
  var transformFn = _ol_proj_.getTransform(source, destination);
  return transformFn(coordinate, undefined, coordinate.length);
};

/**
 * Transforms an extent from source projection to destination projection.  This
 * returns a new extent (and does not modify the original).
 *
 * @param {ol.Extent} extent The extent to transform.
 * @param {ol.ProjectionLike} source Source projection-like.
 * @param {ol.ProjectionLike} destination Destination projection-like.
 * @return {ol.Extent} The transformed extent.
 * @api
 */
_ol_proj_.transformExtent = function (extent, source, destination) {
  var transformFn = _ol_proj_.getTransform(source, destination);
  return ol_extent["a" /* default */].applyTransform(extent, transformFn);
};

/**
 * Transforms the given point to the destination projection.
 *
 * @param {ol.Coordinate} point Point.
 * @param {ol.proj.Projection} sourceProjection Source projection.
 * @param {ol.proj.Projection} destinationProjection Destination projection.
 * @return {ol.Coordinate} Point.
 */
_ol_proj_.transformWithProjections = function (point, sourceProjection, destinationProjection) {
  var transformFn = _ol_proj_.getTransformFromProjections(sourceProjection, destinationProjection);
  return transformFn(point);
};

/**
 * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
 * by when this module is executed and should only need to be called again after
 * `ol.proj.clearAllProjections()` is called (e.g. in tests).
 */
_ol_proj_.addCommon = function () {
  // Add transformations that don't alter coordinates to convert within set of
  // projections with equal meaning.
  _ol_proj_.addEquivalentProjections(epsg3857.PROJECTIONS);
  _ol_proj_.addEquivalentProjections(epsg4326.PROJECTIONS);
  // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
  // coordinates and back.
  _ol_proj_.addEquivalentTransforms(epsg4326.PROJECTIONS, epsg3857.PROJECTIONS, epsg3857.fromEPSG4326, epsg3857.toEPSG4326);
};

_ol_proj_.addCommon();
/* harmony default export */ var proj = __webpack_exports__["default"] = (_ol_proj_);

/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @enum {number}
 */
var _ol_ViewHint_ = {
  ANIMATING: 0,
  INTERACTING: 1
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_ViewHint_);

/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @classdesc
 * Stripped down implementation of the W3C DOM Level 2 Event interface.
 * @see {@link https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface}
 *
 * This implementation only provides `type` and `target` properties, and
 * `stopPropagation` and `preventDefault` methods. It is meant as base class
 * for higher level events defined in the library, and works with
 * {@link ol.events.EventTarget}.
 *
 * @constructor
 * @implements {oli.events.Event}
 * @param {string} type Type.
 */
var _ol_events_Event_ = function _ol_events_Event_(type) {

  /**
   * @type {boolean}
   */
  this.propagationStopped;

  /**
   * The event type.
   * @type {string}
   * @api
   */
  this.type = type;

  /**
   * The event target.
   * @type {Object}
   * @api
   */
  this.target = null;
};

/**
 * Stop event propagation.
 * @function
 * @override
 * @api
 */
_ol_events_Event_.prototype.preventDefault =

/**
 * Stop event propagation.
 * @function
 * @override
 * @api
 */
_ol_events_Event_.prototype.stopPropagation = function () {
  this.propagationStopped = true;
};

/**
 * @param {Event|ol.events.Event} evt Event
 */
_ol_events_Event_.stopPropagation = function (evt) {
  evt.stopPropagation();
};

/**
 * @param {Event|ol.events.Event} evt Event
 */
_ol_events_Event_.preventDefault = function (evt) {
  evt.preventDefault();
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_events_Event_);

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__webgl_js__ = __webpack_require__(14);


var _ol_has_ = {};

var ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';

/**
 * User agent string says we are dealing with Firefox as browser.
 * @type {boolean}
 */
_ol_has_.FIREFOX = ua.indexOf('firefox') !== -1;

/**
 * User agent string says we are dealing with Safari as browser.
 * @type {boolean}
 */
_ol_has_.SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;

/**
 * User agent string says we are dealing with a WebKit engine.
 * @type {boolean}
 */
_ol_has_.WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;

/**
 * User agent string says we are dealing with a Mac as platform.
 * @type {boolean}
 */
_ol_has_.MAC = ua.indexOf('macintosh') !== -1;

/**
 * The ratio between physical pixels and device-independent pixels
 * (dips) on the device (`window.devicePixelRatio`).
 * @const
 * @type {number}
 * @api
 */
_ol_has_.DEVICE_PIXEL_RATIO = typeof window !== 'undefined' && window.devicePixelRatio || 1;

/**
 * True if the browser's Canvas implementation implements {get,set}LineDash.
 * @type {boolean}
 */
_ol_has_.CANVAS_LINE_DASH = false;

/**
 * True if both the library and browser support Canvas.  Always `false`
 * if `ol.ENABLE_CANVAS` is set to `false` at compile time.
 * @const
 * @type {boolean}
 * @api
 */
_ol_has_.CANVAS = __WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].ENABLE_CANVAS &&
/**
 * @return {boolean} Canvas supported.
 */
function () {
  if (typeof window !== 'undefined' && !('HTMLCanvasElement' in window)) {
    return false;
  }
  try {
    var context = document.createElement('CANVAS').getContext('2d');
    if (!context) {
      return false;
    } else {
      if (context.setLineDash !== undefined) {
        _ol_has_.CANVAS_LINE_DASH = true;
      }
      return true;
    }
  } catch (e) {
    return false;
  }
}();

/**
 * Indicates if DeviceOrientation is supported in the user's browser.
 * @const
 * @type {boolean}
 * @api
 */
_ol_has_.DEVICE_ORIENTATION = typeof window !== 'undefined' && 'DeviceOrientationEvent' in window;

/**
 * Is HTML5 geolocation supported in the current browser?
 * @const
 * @type {boolean}
 * @api
 */
_ol_has_.GEOLOCATION = typeof navigator !== 'undefined' && 'geolocation' in navigator;

/**
 * True if browser supports touch events.
 * @const
 * @type {boolean}
 * @api
 */
_ol_has_.TOUCH = __WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].ASSUME_TOUCH || typeof window !== 'undefined' && 'ontouchstart' in window;

/**
 * True if browser supports pointer events.
 * @const
 * @type {boolean}
 */
_ol_has_.POINTER = typeof window !== 'undefined' && 'PointerEvent' in window;

/**
 * True if browser supports ms pointer events (IE 10).
 * @const
 * @type {boolean}
 */
_ol_has_.MSPOINTER = !!(typeof navigator !== 'undefined' && navigator.msPointerEnabled);

/**
 * True if both OpenLayers and browser support WebGL.  Always `false`
 * if `ol.ENABLE_WEBGL` is set to `false` at compile time.
 * @const
 * @type {boolean}
 * @api
 */
_ol_has_.WEBGL;

(function () {
  if (__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].ENABLE_WEBGL) {
    var hasWebGL = false;
    var textureSize;
    var /** @type {Array.<string>} */extensions = [];

    if (typeof window !== 'undefined' && 'WebGLRenderingContext' in window) {
      try {
        var canvas = /** @type {HTMLCanvasElement} */
        document.createElement('CANVAS');
        var gl = __WEBPACK_IMPORTED_MODULE_1__webgl_js__["a" /* default */].getContext(canvas, {
          failIfMajorPerformanceCaveat: true
        });
        if (gl) {
          hasWebGL = true;
          textureSize = /** @type {number} */
          gl.getParameter(gl.MAX_TEXTURE_SIZE);
          extensions = gl.getSupportedExtensions();
        }
      } catch (e) {
        // pass
      }
    }
    _ol_has_.WEBGL = hasWebGL;
    __WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].WEBGL_EXTENSIONS = extensions;
    __WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].WEBGL_MAX_TEXTURE_SIZE = textureSize;
  }
})();
/* harmony default export */ __webpack_exports__["a"] = (_ol_has_);

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @enum {number}
 */
var _ol_TileState_ = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3,
  EMPTY: 4,
  ABORT: 5
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_TileState_);

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__css_js__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__dom_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__obj_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__structs_lrucache_js__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__transform_js__ = __webpack_require__(11);





var _ol_render_canvas_ = {};

/**
 * @const
 * @type {string}
 */
_ol_render_canvas_.defaultFont = '10px sans-serif';

/**
 * @const
 * @type {ol.Color}
 */
_ol_render_canvas_.defaultFillStyle = [0, 0, 0, 1];

/**
 * @const
 * @type {string}
 */
_ol_render_canvas_.defaultLineCap = 'round';

/**
 * @const
 * @type {Array.<number>}
 */
_ol_render_canvas_.defaultLineDash = [];

/**
 * @const
 * @type {number}
 */
_ol_render_canvas_.defaultLineDashOffset = 0;

/**
 * @const
 * @type {string}
 */
_ol_render_canvas_.defaultLineJoin = 'round';

/**
 * @const
 * @type {number}
 */
_ol_render_canvas_.defaultMiterLimit = 10;

/**
 * @const
 * @type {ol.Color}
 */
_ol_render_canvas_.defaultStrokeStyle = [0, 0, 0, 1];

/**
 * @const
 * @type {string}
 */
_ol_render_canvas_.defaultTextAlign = 'center';

/**
 * @const
 * @type {string}
 */
_ol_render_canvas_.defaultTextBaseline = 'middle';

/**
 * @const
 * @type {Array.<number>}
 */
_ol_render_canvas_.defaultPadding = [0, 0, 0, 0];

/**
 * @const
 * @type {number}
 */
_ol_render_canvas_.defaultLineWidth = 1;

/**
 * @type {ol.structs.LRUCache.<HTMLCanvasElement>}
 */
_ol_render_canvas_.labelCache = new __WEBPACK_IMPORTED_MODULE_3__structs_lrucache_js__["a" /* default */]();

/**
 * @type {!Object.<string, number>}
 */
_ol_render_canvas_.checkedFonts_ = {};

/**
 * @type {CanvasRenderingContext2D}
 */
_ol_render_canvas_.measureContext_ = null;

/**
 * @type {!Object.<string, number>}
 */
_ol_render_canvas_.textHeights_ = {};

/**
 * Clears the label cache when a font becomes available.
 * @param {string} fontSpec CSS font spec.
 */
_ol_render_canvas_.checkFont = function () {
  var retries = 60;
  var checked = _ol_render_canvas_.checkedFonts_;
  var labelCache = _ol_render_canvas_.labelCache;
  var font = '32px monospace';
  var text = 'wmytzilWMYTZIL@#/&?$%10';
  var interval, referenceWidth;

  function isAvailable(fontFamily) {
    var context = _ol_render_canvas_.getMeasureContext();
    context.font = font;
    referenceWidth = context.measureText(text).width;
    var available = true;
    if (fontFamily != 'monospace') {
      context.font = '32px ' + fontFamily + ',monospace';
      var width = context.measureText(text).width;
      // If width and referenceWidth are the same, then the 'monospace'
      // fallback was used instead of the font we wanted, so the font is not
      // available.
      available = width != referenceWidth;
    }
    return available;
  }

  function check() {
    var done = true;
    for (var font in checked) {
      if (checked[font] < retries) {
        if (isAvailable(font)) {
          checked[font] = retries;
          __WEBPACK_IMPORTED_MODULE_2__obj_js__["a" /* default */].clear(_ol_render_canvas_.textHeights_);
          // Make sure that loaded fonts are picked up by Safari
          _ol_render_canvas_.measureContext_ = null;
          labelCache.clear();
        } else {
          ++checked[font];
          done = false;
        }
      }
    }
    if (done) {
      window.clearInterval(interval);
      interval = undefined;
    }
  }

  return function (fontSpec) {
    var fontFamilies = __WEBPACK_IMPORTED_MODULE_0__css_js__["a" /* default */].getFontFamilies(fontSpec);
    if (!fontFamilies) {
      return;
    }
    for (var i = 0, ii = fontFamilies.length; i < ii; ++i) {
      var fontFamily = fontFamilies[i];
      if (!(fontFamily in checked)) {
        checked[fontFamily] = retries;
        if (!isAvailable(fontFamily)) {
          checked[fontFamily] = 0;
          if (interval === undefined) {
            interval = window.setInterval(check, 32);
          }
        }
      }
    }
  };
}();

/**
 * @return {CanvasRenderingContext2D} Measure context.
 */
_ol_render_canvas_.getMeasureContext = function () {
  var context = _ol_render_canvas_.measureContext_;
  if (!context) {
    context = _ol_render_canvas_.measureContext_ = __WEBPACK_IMPORTED_MODULE_1__dom_js__["a" /* default */].createCanvasContext2D(1, 1);
  }
  return context;
};

/**
 * @param {string} font Font to use for measuring.
 * @return {ol.Size} Measurement.
 */
_ol_render_canvas_.measureTextHeight = function () {
  var span;
  var heights = _ol_render_canvas_.textHeights_;
  return function (font) {
    var height = heights[font];
    if (height == undefined) {
      if (!span) {
        span = document.createElement('span');
        span.textContent = 'M';
        span.style.margin = span.style.padding = '0 !important';
        span.style.position = 'absolute !important';
        span.style.left = '-99999px !important';
      }
      span.style.font = font;
      document.body.appendChild(span);
      height = heights[font] = span.offsetHeight;
      document.body.removeChild(span);
    }
    return height;
  };
}();

/**
 * @param {string} font Font.
 * @param {string} text Text.
 * @return {number} Width.
 */
_ol_render_canvas_.measureTextWidth = function (font, text) {
  var measureContext = _ol_render_canvas_.getMeasureContext();
  if (font != measureContext.font) {
    measureContext.font = font;
  }
  return measureContext.measureText(text).width;
};

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 * @param {number} offsetX X offset.
 * @param {number} offsetY Y offset.
 */
_ol_render_canvas_.rotateAtOffset = function (context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
};

_ol_render_canvas_.resetTransform_ = __WEBPACK_IMPORTED_MODULE_4__transform_js__["a" /* default */].create();

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform|null} transform Transform.
 * @param {number} opacity Opacity.
 * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} w Width.
 * @param {number} h Height.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} scale Scale.
 */
_ol_render_canvas_.drawImage = function (context, transform, opacity, image, originX, originY, w, h, x, y, scale) {
  var alpha;
  if (opacity != 1) {
    alpha = context.globalAlpha;
    context.globalAlpha = alpha * opacity;
  }
  if (transform) {
    context.setTransform.apply(context, transform);
  }

  context.drawImage(image, originX, originY, w, h, x, y, w * scale, h * scale);

  if (alpha) {
    context.globalAlpha = alpha;
  }
  if (transform) {
    context.setTransform.apply(context, _ol_render_canvas_.resetTransform_);
  }
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_render_canvas_);

/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__functions_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extent_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_geometry_js__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_geometrylayout_js__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_flat_transform_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__obj_js__ = __webpack_require__(2);








/**
 * @classdesc
 * Abstract base class; only used for creating subclasses; do not instantiate
 * in apps, as cannot be rendered.
 *
 * @constructor
 * @abstract
 * @extends {ol.geom.Geometry}
 * @api
 */
var _ol_geom_SimpleGeometry_ = function _ol_geom_SimpleGeometry_() {

  __WEBPACK_IMPORTED_MODULE_3__geom_geometry_js__["a" /* default */].call(this);

  /**
   * @protected
   * @type {ol.geom.GeometryLayout}
   */
  this.layout = __WEBPACK_IMPORTED_MODULE_4__geom_geometrylayout_js__["a" /* default */].XY;

  /**
   * @protected
   * @type {number}
   */
  this.stride = 2;

  /**
   * @protected
   * @type {Array.<number>}
   */
  this.flatCoordinates = null;
};

__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].inherits(_ol_geom_SimpleGeometry_, __WEBPACK_IMPORTED_MODULE_3__geom_geometry_js__["a" /* default */]);

/**
 * @param {number} stride Stride.
 * @private
 * @return {ol.geom.GeometryLayout} layout Layout.
 */
_ol_geom_SimpleGeometry_.getLayoutForStride_ = function (stride) {
  var layout;
  if (stride == 2) {
    layout = __WEBPACK_IMPORTED_MODULE_4__geom_geometrylayout_js__["a" /* default */].XY;
  } else if (stride == 3) {
    layout = __WEBPACK_IMPORTED_MODULE_4__geom_geometrylayout_js__["a" /* default */].XYZ;
  } else if (stride == 4) {
    layout = __WEBPACK_IMPORTED_MODULE_4__geom_geometrylayout_js__["a" /* default */].XYZM;
  }
  return (/** @type {ol.geom.GeometryLayout} */layout
  );
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @return {number} Stride.
 */
_ol_geom_SimpleGeometry_.getStrideForLayout = function (layout) {
  var stride;
  if (layout == __WEBPACK_IMPORTED_MODULE_4__geom_geometrylayout_js__["a" /* default */].XY) {
    stride = 2;
  } else if (layout == __WEBPACK_IMPORTED_MODULE_4__geom_geometrylayout_js__["a" /* default */].XYZ || layout == __WEBPACK_IMPORTED_MODULE_4__geom_geometrylayout_js__["a" /* default */].XYM) {
    stride = 3;
  } else if (layout == __WEBPACK_IMPORTED_MODULE_4__geom_geometrylayout_js__["a" /* default */].XYZM) {
    stride = 4;
  }
  return (/** @type {number} */stride
  );
};

/**
 * @inheritDoc
 */
_ol_geom_SimpleGeometry_.prototype.containsXY = __WEBPACK_IMPORTED_MODULE_1__functions_js__["a" /* default */].FALSE;

/**
 * @inheritDoc
 */
_ol_geom_SimpleGeometry_.prototype.computeExtent = function (extent) {
  return __WEBPACK_IMPORTED_MODULE_2__extent_js__["a" /* default */].createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
};

/**
 * @abstract
 * @return {Array} Coordinates.
 */
_ol_geom_SimpleGeometry_.prototype.getCoordinates = function () {};

/**
 * Return the first coordinate of the geometry.
 * @return {ol.Coordinate} First coordinate.
 * @api
 */
_ol_geom_SimpleGeometry_.prototype.getFirstCoordinate = function () {
  return this.flatCoordinates.slice(0, this.stride);
};

/**
 * @return {Array.<number>} Flat coordinates.
 */
_ol_geom_SimpleGeometry_.prototype.getFlatCoordinates = function () {
  return this.flatCoordinates;
};

/**
 * Return the last coordinate of the geometry.
 * @return {ol.Coordinate} Last point.
 * @api
 */
_ol_geom_SimpleGeometry_.prototype.getLastCoordinate = function () {
  return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
};

/**
 * Return the {@link ol.geom.GeometryLayout layout} of the geometry.
 * @return {ol.geom.GeometryLayout} Layout.
 * @api
 */
_ol_geom_SimpleGeometry_.prototype.getLayout = function () {
  return this.layout;
};

/**
 * @inheritDoc
 */
_ol_geom_SimpleGeometry_.prototype.getSimplifiedGeometry = function (squaredTolerance) {
  if (this.simplifiedGeometryRevision != this.getRevision()) {
    __WEBPACK_IMPORTED_MODULE_6__obj_js__["a" /* default */].clear(this.simplifiedGeometryCache);
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    this.simplifiedGeometryRevision = this.getRevision();
  }
  // If squaredTolerance is negative or if we know that simplification will not
  // have any effect then just return this.
  if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
    return this;
  }
  var key = squaredTolerance.toString();
  if (this.simplifiedGeometryCache.hasOwnProperty(key)) {
    return this.simplifiedGeometryCache[key];
  } else {
    var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
    var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
    if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
      this.simplifiedGeometryCache[key] = simplifiedGeometry;
      return simplifiedGeometry;
    } else {
      // Simplification did not actually remove any coordinates.  We now know
      // that any calls to getSimplifiedGeometry with a squaredTolerance less
      // than or equal to the current squaredTolerance will also not have any
      // effect.  This allows us to short circuit simplification (saving CPU
      // cycles) and prevents the cache of simplified geometries from filling
      // up with useless identical copies of this geometry (saving memory).
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  }
};

/**
 * @param {number} squaredTolerance Squared tolerance.
 * @return {ol.geom.SimpleGeometry} Simplified geometry.
 * @protected
 */
_ol_geom_SimpleGeometry_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  return this;
};

/**
 * @return {number} Stride.
 */
_ol_geom_SimpleGeometry_.prototype.getStride = function () {
  return this.stride;
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @protected
 */
_ol_geom_SimpleGeometry_.prototype.setFlatCoordinatesInternal = function (layout, flatCoordinates) {
  this.stride = _ol_geom_SimpleGeometry_.getStrideForLayout(layout);
  this.layout = layout;
  this.flatCoordinates = flatCoordinates;
};

/**
 * @abstract
 * @param {Array} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 */
_ol_geom_SimpleGeometry_.prototype.setCoordinates = function (coordinates, opt_layout) {};

/**
 * @param {ol.geom.GeometryLayout|undefined} layout Layout.
 * @param {Array} coordinates Coordinates.
 * @param {number} nesting Nesting.
 * @protected
 */
_ol_geom_SimpleGeometry_.prototype.setLayout = function (layout, coordinates, nesting) {
  /** @type {number} */
  var stride;
  if (layout) {
    stride = _ol_geom_SimpleGeometry_.getStrideForLayout(layout);
  } else {
    var i;
    for (i = 0; i < nesting; ++i) {
      if (coordinates.length === 0) {
        this.layout = __WEBPACK_IMPORTED_MODULE_4__geom_geometrylayout_js__["a" /* default */].XY;
        this.stride = 2;
        return;
      } else {
        coordinates = /** @type {Array} */coordinates[0];
      }
    }
    stride = coordinates.length;
    layout = _ol_geom_SimpleGeometry_.getLayoutForStride_(stride);
  }
  this.layout = layout;
  this.stride = stride;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_SimpleGeometry_.prototype.applyTransform = function (transformFn) {
  if (this.flatCoordinates) {
    transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
    this.changed();
  }
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_SimpleGeometry_.prototype.rotate = function (angle, anchor) {
  var flatCoordinates = this.getFlatCoordinates();
  if (flatCoordinates) {
    var stride = this.getStride();
    __WEBPACK_IMPORTED_MODULE_5__geom_flat_transform_js__["a" /* default */].rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
    this.changed();
  }
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_SimpleGeometry_.prototype.scale = function (sx, opt_sy, opt_anchor) {
  var sy = opt_sy;
  if (sy === undefined) {
    sy = sx;
  }
  var anchor = opt_anchor;
  if (!anchor) {
    anchor = __WEBPACK_IMPORTED_MODULE_2__extent_js__["a" /* default */].getCenter(this.getExtent());
  }
  var flatCoordinates = this.getFlatCoordinates();
  if (flatCoordinates) {
    var stride = this.getStride();
    __WEBPACK_IMPORTED_MODULE_5__geom_flat_transform_js__["a" /* default */].scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
    this.changed();
  }
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_SimpleGeometry_.prototype.translate = function (deltaX, deltaY) {
  var flatCoordinates = this.getFlatCoordinates();
  if (flatCoordinates) {
    var stride = this.getStride();
    __WEBPACK_IMPORTED_MODULE_5__geom_flat_transform_js__["a" /* default */].translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
    this.changed();
  }
};

/**
 * @param {ol.geom.SimpleGeometry} simpleGeometry Simple geometry.
 * @param {ol.Transform} transform Transform.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed flat coordinates.
 */
_ol_geom_SimpleGeometry_.transform2D = function (simpleGeometry, transform, opt_dest) {
  var flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  } else {
    var stride = simpleGeometry.getStride();
    return __WEBPACK_IMPORTED_MODULE_5__geom_flat_transform_js__["a" /* default */].transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);
  }
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_geom_SimpleGeometry_);

/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/ol/index.js
var ol = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ol/object.js
var object = __webpack_require__(15);

// EXTERNAL MODULE: ./node_modules/ol/easing.js
var easing = __webpack_require__(29);

// CONCATENATED MODULE: ./node_modules/ol/interaction/property.js
/**
 * @enum {string}
 */
var _ol_interaction_Property_ = {
  ACTIVE: 'active'
};

/* harmony default export */ var property = (_ol_interaction_Property_);
// EXTERNAL MODULE: ./node_modules/ol/math.js
var math = __webpack_require__(6);

// CONCATENATED MODULE: ./node_modules/ol/interaction/interaction.js
// FIXME factor out key precondition (shift et. al)







/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * User actions that change the state of the map. Some are similar to controls,
 * but are not associated with a DOM element.
 * For example, {@link ol.interaction.KeyboardZoom} is functionally the same as
 * {@link ol.control.Zoom}, but triggered by a keyboard event not a button
 * element event.
 * Although interactions do not have a DOM element, some of them do render
 * vectors and so are visible on the screen.
 *
 * @constructor
 * @param {olx.interaction.InteractionOptions} options Options.
 * @extends {ol.Object}
 * @api
 */
var interaction__ol_interaction_Interaction_ = function _ol_interaction_Interaction_(options) {

  object["a" /* default */].call(this);

  /**
   * @private
   * @type {ol.PluggableMap}
   */
  this.map_ = null;

  this.setActive(true);

  /**
   * @type {function(ol.MapBrowserEvent):boolean}
   */
  this.handleEvent = options.handleEvent;
};

ol["a" /* default */].inherits(interaction__ol_interaction_Interaction_, object["a" /* default */]);

/**
 * Return whether the interaction is currently active.
 * @return {boolean} `true` if the interaction is active, `false` otherwise.
 * @observable
 * @api
 */
interaction__ol_interaction_Interaction_.prototype.getActive = function () {
  return (
    /** @type {boolean} */this.get(property.ACTIVE)
  );
};

/**
 * Get the map associated with this interaction.
 * @return {ol.PluggableMap} Map.
 * @api
 */
interaction__ol_interaction_Interaction_.prototype.getMap = function () {
  return this.map_;
};

/**
 * Activate or deactivate the interaction.
 * @param {boolean} active Active.
 * @observable
 * @api
 */
interaction__ol_interaction_Interaction_.prototype.setActive = function (active) {
  this.set(property.ACTIVE, active);
};

/**
 * Remove the interaction from its current map and attach it to the new map.
 * Subclasses may set up event handlers to get notified about changes to
 * the map here.
 * @param {ol.PluggableMap} map Map.
 */
interaction__ol_interaction_Interaction_.prototype.setMap = function (map) {
  this.map_ = map;
};

/**
 * @param {ol.View} view View.
 * @param {ol.Coordinate} delta Delta.
 * @param {number=} opt_duration Duration.
 */
interaction__ol_interaction_Interaction_.pan = function (view, delta, opt_duration) {
  var currentCenter = view.getCenter();
  if (currentCenter) {
    var center = view.constrainCenter([currentCenter[0] + delta[0], currentCenter[1] + delta[1]]);
    if (opt_duration) {
      view.animate({
        duration: opt_duration,
        easing: easing["a" /* default */].linear,
        center: center
      });
    } else {
      view.setCenter(center);
    }
  }
};

/**
 * @param {ol.View} view View.
 * @param {number|undefined} rotation Rotation.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
interaction__ol_interaction_Interaction_.rotate = function (view, rotation, opt_anchor, opt_duration) {
  rotation = view.constrainRotation(rotation, 0);
  interaction__ol_interaction_Interaction_.rotateWithoutConstraints(view, rotation, opt_anchor, opt_duration);
};

/**
 * @param {ol.View} view View.
 * @param {number|undefined} rotation Rotation.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
interaction__ol_interaction_Interaction_.rotateWithoutConstraints = function (view, rotation, opt_anchor, opt_duration) {
  if (rotation !== undefined) {
    var currentRotation = view.getRotation();
    var currentCenter = view.getCenter();
    if (currentRotation !== undefined && currentCenter && opt_duration > 0) {
      view.animate({
        rotation: rotation,
        anchor: opt_anchor,
        duration: opt_duration,
        easing: easing["a" /* default */].easeOut
      });
    } else {
      view.rotate(rotation, opt_anchor);
    }
  }
};

/**
 * @param {ol.View} view View.
 * @param {number|undefined} resolution Resolution to go to.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 * @param {number=} opt_direction Zooming direction; > 0 indicates
 *     zooming out, in which case the constraints system will select
 *     the largest nearest resolution; < 0 indicates zooming in, in
 *     which case the constraints system will select the smallest
 *     nearest resolution; == 0 indicates that the zooming direction
 *     is unknown/not relevant, in which case the constraints system
 *     will select the nearest resolution. If not defined 0 is
 *     assumed.
 */
interaction__ol_interaction_Interaction_.zoom = function (view, resolution, opt_anchor, opt_duration, opt_direction) {
  resolution = view.constrainResolution(resolution, 0, opt_direction);
  interaction__ol_interaction_Interaction_.zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
};

/**
 * @param {ol.View} view View.
 * @param {number} delta Delta from previous zoom level.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
interaction__ol_interaction_Interaction_.zoomByDelta = function (view, delta, opt_anchor, opt_duration) {
  var currentResolution = view.getResolution();
  var resolution = view.constrainResolution(currentResolution, delta, 0);

  if (resolution !== undefined) {
    var resolutions = view.getResolutions();
    resolution = math["a" /* default */].clamp(resolution, view.getMinResolution() || resolutions[resolutions.length - 1], view.getMaxResolution() || resolutions[0]);
  }

  // If we have a constraint on center, we need to change the anchor so that the
  // new center is within the extent. We first calculate the new center, apply
  // the constraint to it, and then calculate back the anchor
  if (opt_anchor && resolution !== undefined && resolution !== currentResolution) {
    var currentCenter = view.getCenter();
    var center = view.calculateCenterZoom(resolution, opt_anchor);
    center = view.constrainCenter(center);

    opt_anchor = [(resolution * currentCenter[0] - currentResolution * center[0]) / (resolution - currentResolution), (resolution * currentCenter[1] - currentResolution * center[1]) / (resolution - currentResolution)];
  }

  interaction__ol_interaction_Interaction_.zoomWithoutConstraints(view, resolution, opt_anchor, opt_duration);
};

/**
 * @param {ol.View} view View.
 * @param {number|undefined} resolution Resolution to go to.
 * @param {ol.Coordinate=} opt_anchor Anchor coordinate.
 * @param {number=} opt_duration Duration.
 */
interaction__ol_interaction_Interaction_.zoomWithoutConstraints = function (view, resolution, opt_anchor, opt_duration) {
  if (resolution) {
    var currentResolution = view.getResolution();
    var currentCenter = view.getCenter();
    if (currentResolution !== undefined && currentCenter && resolution !== currentResolution && opt_duration) {
      view.animate({
        resolution: resolution,
        anchor: opt_anchor,
        duration: opt_duration,
        easing: easing["a" /* default */].easeOut
      });
    } else {
      if (opt_anchor) {
        var center = view.calculateCenterZoom(resolution, opt_anchor);
        view.setCenter(center);
      }
      view.setResolution(resolution);
    }
  }
};
/* harmony default export */ var interaction = __webpack_exports__["a"] = (interaction__ol_interaction_Interaction_);

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A layer type used when creating layer renderers.
 * @enum {string}
 */
var _ol_LayerType_ = {
  IMAGE: 'IMAGE',
  TILE: 'TILE',
  VECTOR_TILE: 'VECTOR_TILE',
  VECTOR: 'VECTOR'
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_LayerType_);

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _ol_geom_flat_transform_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Transform} transform Transform.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */
_ol_geom_flat_transform_.transform2D = function (flatCoordinates, offset, end, stride, transform, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  var j;
  for (j = offset; j < end; j += stride) {
    var x = flatCoordinates[j];
    var y = flatCoordinates[j + 1];
    dest[i++] = transform[0] * x + transform[2] * y + transform[4];
    dest[i++] = transform[1] * x + transform[3] * y + transform[5];
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} angle Angle.
 * @param {Array.<number>} anchor Rotation anchor point.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */
_ol_geom_flat_transform_.rotate = function (flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var cos = Math.cos(angle);
  var sin = Math.sin(angle);
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
};

/**
 * Scale the coordinates.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} sx Scale factor in the x-direction.
 * @param {number} sy Scale factor in the y-direction.
 * @param {Array.<number>} anchor Scale anchor point.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */
_ol_geom_flat_transform_.scale = function (flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var anchorX = anchor[0];
  var anchorY = anchor[1];
  var i = 0;
  for (var j = offset; j < end; j += stride) {
    var deltaX = flatCoordinates[j] - anchorX;
    var deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (var k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Transformed coordinates.
 */
_ol_geom_flat_transform_.translate = function (flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
  var dest = opt_dest ? opt_dest : [];
  var i = 0;
  var j, k;
  for (j = offset; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (opt_dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_geom_flat_transform_);

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
 * `'us-ft'`.
 * @enum {string}
 */
var _ol_proj_Units_ = {
  DEGREES: 'degrees',
  FEET: 'ft',
  METERS: 'm',
  PIXELS: 'pixels',
  TILE_PIXELS: 'tile-pixels',
  USFEET: 'us-ft'
};

/**
 * Meters per unit lookup table.
 * @const
 * @type {Object.<ol.proj.Units, number>}
 * @api
 */
_ol_proj_Units_.METERS_PER_UNIT = {};
// use the radius of the Normal sphere
_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.DEGREES] = 2 * Math.PI * 6370997 / 360;
_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.FEET] = 0.3048;
_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.METERS] = 1;
_ol_proj_Units_.METERS_PER_UNIT[_ol_proj_Units_.USFEET] = 1200 / 3937;
/* harmony default export */ __webpack_exports__["a"] = (_ol_proj_Units_);

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__asserts_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__math_js__ = __webpack_require__(6);


var _ol_color_ = {};

/**
 * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
 * @const
 * @type {RegExp}
 * @private
 */
_ol_color_.HEX_COLOR_RE_ = /^#(?:[0-9a-f]{3,4}){1,2}$/i;

/**
 * Regular expression for matching potential named color style strings.
 * @const
 * @type {RegExp}
 * @private
 */
_ol_color_.NAMED_COLOR_RE_ = /^([a-z]*)$/i;

/**
 * Return the color as an array. This function maintains a cache of calculated
 * arrays which means the result should not be modified.
 * @param {ol.Color|string} color Color.
 * @return {ol.Color} Color.
 * @api
 */
_ol_color_.asArray = function (color) {
  if (Array.isArray(color)) {
    return color;
  } else {
    return _ol_color_.fromString( /** @type {string} */color);
  }
};

/**
 * Return the color as an rgba string.
 * @param {ol.Color|string} color Color.
 * @return {string} Rgba string.
 * @api
 */
_ol_color_.asString = function (color) {
  if (typeof color === 'string') {
    return color;
  } else {
    return _ol_color_.toString(color);
  }
};

/**
 * Return named color as an rgba string.
 * @param {string} color Named color.
 * @return {string} Rgb string.
 */
_ol_color_.fromNamed = function (color) {
  var el = document.createElement('div');
  el.style.color = color;
  document.body.appendChild(el);
  var rgb = getComputedStyle(el).color;
  document.body.removeChild(el);
  return rgb;
};

/**
 * @param {string} s String.
 * @return {ol.Color} Color.
 */
_ol_color_.fromString = function () {

  // We maintain a small cache of parsed strings.  To provide cheap LRU-like
  // semantics, whenever the cache grows too large we simply delete an
  // arbitrary 25% of the entries.

  /**
   * @const
   * @type {number}
   */
  var MAX_CACHE_SIZE = 1024;

  /**
   * @type {Object.<string, ol.Color>}
   */
  var cache = {};

  /**
   * @type {number}
   */
  var cacheSize = 0;

  return (
    /**
     * @param {string} s String.
     * @return {ol.Color} Color.
     */
    function (s) {
      var color;
      if (cache.hasOwnProperty(s)) {
        color = cache[s];
      } else {
        if (cacheSize >= MAX_CACHE_SIZE) {
          var i = 0;
          var key;
          for (key in cache) {
            if ((i++ & 3) === 0) {
              delete cache[key];
              --cacheSize;
            }
          }
        }
        color = _ol_color_.fromStringInternal_(s);
        cache[s] = color;
        ++cacheSize;
      }
      return color;
    }
  );
}();

/**
 * @param {string} s String.
 * @private
 * @return {ol.Color} Color.
 */
_ol_color_.fromStringInternal_ = function (s) {
  var r, g, b, a, color, parts;

  if (_ol_color_.NAMED_COLOR_RE_.exec(s)) {
    s = _ol_color_.fromNamed(s);
  }

  if (_ol_color_.HEX_COLOR_RE_.exec(s)) {
    // hex
    var n = s.length - 1; // number of hex digits
    var d; // number of digits per channel
    if (n <= 4) {
      d = 1;
    } else {
      d = 2;
    }
    var hasAlpha = n === 4 || n === 8;
    r = parseInt(s.substr(1 + 0 * d, d), 16);
    g = parseInt(s.substr(1 + 1 * d, d), 16);
    b = parseInt(s.substr(1 + 2 * d, d), 16);
    if (hasAlpha) {
      a = parseInt(s.substr(1 + 3 * d, d), 16);
    } else {
      a = 255;
    }
    if (d == 1) {
      r = (r << 4) + r;
      g = (g << 4) + g;
      b = (b << 4) + b;
      if (hasAlpha) {
        a = (a << 4) + a;
      }
    }
    color = [r, g, b, a / 255];
  } else if (s.indexOf('rgba(') == 0) {
    // rgba()
    parts = s.slice(5, -1).split(',').map(Number);
    color = _ol_color_.normalize(parts);
  } else if (s.indexOf('rgb(') == 0) {
    // rgb()
    parts = s.slice(4, -1).split(',').map(Number);
    parts.push(1);
    color = _ol_color_.normalize(parts);
  } else {
    __WEBPACK_IMPORTED_MODULE_0__asserts_js__["a" /* default */].assert(false, 14); // Invalid color
  }
  return (/** @type {ol.Color} */color
  );
};

/**
 * @param {ol.Color} color Color.
 * @param {ol.Color=} opt_color Color.
 * @return {ol.Color} Clamped color.
 */
_ol_color_.normalize = function (color, opt_color) {
  var result = opt_color || [];
  result[0] = __WEBPACK_IMPORTED_MODULE_1__math_js__["a" /* default */].clamp(color[0] + 0.5 | 0, 0, 255);
  result[1] = __WEBPACK_IMPORTED_MODULE_1__math_js__["a" /* default */].clamp(color[1] + 0.5 | 0, 0, 255);
  result[2] = __WEBPACK_IMPORTED_MODULE_1__math_js__["a" /* default */].clamp(color[2] + 0.5 | 0, 0, 255);
  result[3] = __WEBPACK_IMPORTED_MODULE_1__math_js__["a" /* default */].clamp(color[3], 0, 1);
  return result;
};

/**
 * @param {ol.Color} color Color.
 * @return {string} String.
 */
_ol_color_.toString = function (color) {
  var r = color[0];
  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }
  var g = color[1];
  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }
  var b = color[2];
  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }
  var a = color[3] === undefined ? 1 : color[3];
  return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_color_);

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
 * or measure ('M') coordinate is available. Supported values are `'XY'`,
 * `'XYZ'`, `'XYM'`, `'XYZM'`.
 * @enum {string}
 */
var _ol_geom_GeometryLayout_ = {
  XY: 'XY',
  XYZ: 'XYZ',
  XYM: 'XYM',
  XYZM: 'XYZM'
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_geom_GeometryLayout_);

/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _ol_easing_ = {};

/**
 * Start slow and speed up.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
_ol_easing_.easeIn = function (t) {
  return Math.pow(t, 3);
};

/**
 * Start fast and slow down.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
_ol_easing_.easeOut = function (t) {
  return 1 - _ol_easing_.easeIn(1 - t);
};

/**
 * Start slow, speed up, and then slow down again.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
_ol_easing_.inAndOut = function (t) {
  return 3 * t * t - 2 * t * t * t;
};

/**
 * Maintain a constant speed over time.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
_ol_easing_.linear = function (t) {
  return t;
};

/**
 * Start slow, speed up, and at the very end slow down again.  This has the
 * same general behavior as {@link ol.easing.inAndOut}, but the final slowdown
 * is delayed.
 * @param {number} t Input between 0 and 1.
 * @return {number} Output between 0 and 1.
 * @api
 */
_ol_easing_.upAndDown = function (t) {
  if (t < 0.5) {
    return _ol_easing_.inAndOut(2 * t);
  } else {
    return 1 - _ol_easing_.inAndOut(2 * (t - 0.5));
  }
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_easing_);

/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = require("babel-runtime/regenerator");

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__disposable_js__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__events_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__events_event_js__ = __webpack_require__(18);





/**
 * @classdesc
 * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
 * @see {@link https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget}
 *
 * There are two important simplifications compared to the specification:
 *
 * 1. The handling of `useCapture` in `addEventListener` and
 *    `removeEventListener`. There is no real capture model.
 * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
 *    There is no event target hierarchy. When a listener calls
 *    `stopPropagation` or `preventDefault` on an event object, it means that no
 *    more listeners after this one will be called. Same as when the listener
 *    returns false.
 *
 * @constructor
 * @extends {ol.Disposable}
 */
var _ol_events_EventTarget_ = function _ol_events_EventTarget_() {

  __WEBPACK_IMPORTED_MODULE_1__disposable_js__["a" /* default */].call(this);

  /**
   * @private
   * @type {!Object.<string, number>}
   */
  this.pendingRemovals_ = {};

  /**
   * @private
   * @type {!Object.<string, number>}
   */
  this.dispatching_ = {};

  /**
   * @private
   * @type {!Object.<string, Array.<ol.EventsListenerFunctionType>>}
   */
  this.listeners_ = {};
};

__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].inherits(_ol_events_EventTarget_, __WEBPACK_IMPORTED_MODULE_1__disposable_js__["a" /* default */]);

/**
 * @param {string} type Type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 */
_ol_events_EventTarget_.prototype.addEventListener = function (type, listener) {
  var listeners = this.listeners_[type];
  if (!listeners) {
    listeners = this.listeners_[type] = [];
  }
  if (listeners.indexOf(listener) === -1) {
    listeners.push(listener);
  }
};

/**
 * @param {{type: string,
 *     target: (EventTarget|ol.events.EventTarget|undefined)}|ol.events.Event|
 *     string} event Event or event type.
 * @return {boolean|undefined} `false` if anyone called preventDefault on the
 *     event object or if any of the listeners returned false.
 */
_ol_events_EventTarget_.prototype.dispatchEvent = function (event) {
  var evt = typeof event === 'string' ? new __WEBPACK_IMPORTED_MODULE_3__events_event_js__["a" /* default */](event) : event;
  var type = evt.type;
  evt.target = this;
  var listeners = this.listeners_[type];
  var propagate;
  if (listeners) {
    if (!(type in this.dispatching_)) {
      this.dispatching_[type] = 0;
      this.pendingRemovals_[type] = 0;
    }
    ++this.dispatching_[type];
    for (var i = 0, ii = listeners.length; i < ii; ++i) {
      if (listeners[i].call(this, evt) === false || evt.propagationStopped) {
        propagate = false;
        break;
      }
    }
    --this.dispatching_[type];
    if (this.dispatching_[type] === 0) {
      var pendingRemovals = this.pendingRemovals_[type];
      delete this.pendingRemovals_[type];
      while (pendingRemovals--) {
        this.removeEventListener(type, __WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].nullFunction);
      }
      delete this.dispatching_[type];
    }
    return propagate;
  }
};

/**
 * @inheritDoc
 */
_ol_events_EventTarget_.prototype.disposeInternal = function () {
  __WEBPACK_IMPORTED_MODULE_2__events_js__["a" /* default */].unlistenAll(this);
};

/**
 * Get the listeners for a specified event type. Listeners are returned in the
 * order that they will be called in.
 *
 * @param {string} type Type.
 * @return {Array.<ol.EventsListenerFunctionType>} Listeners.
 */
_ol_events_EventTarget_.prototype.getListeners = function (type) {
  return this.listeners_[type];
};

/**
 * @param {string=} opt_type Type. If not provided,
 *     `true` will be returned if this EventTarget has any listeners.
 * @return {boolean} Has listeners.
 */
_ol_events_EventTarget_.prototype.hasListener = function (opt_type) {
  return opt_type ? opt_type in this.listeners_ : Object.keys(this.listeners_).length > 0;
};

/**
 * @param {string} type Type.
 * @param {ol.EventsListenerFunctionType} listener Listener.
 */
_ol_events_EventTarget_.prototype.removeEventListener = function (type, listener) {
  var listeners = this.listeners_[type];
  if (listeners) {
    var index = listeners.indexOf(listener);
    if (type in this.pendingRemovals_) {
      // make listener a no-op, and remove later in #dispatchEvent()
      listeners[index] = __WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].nullFunction;
      ++this.pendingRemovals_[type];
    } else {
      listeners.splice(index, 1);
      if (listeners.length === 0) {
        delete this.listeners_[type];
      }
    }
  }
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_events_EventTarget_);

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _ol_css_ = {};

/**
 * The CSS class for hidden feature.
 *
 * @const
 * @type {string}
 */
_ol_css_.CLASS_HIDDEN = 'ol-hidden';

/**
 * The CSS class that we'll give the DOM elements to have them selectable.
 *
 * @const
 * @type {string}
 */
_ol_css_.CLASS_SELECTABLE = 'ol-selectable';

/**
 * The CSS class that we'll give the DOM elements to have them unselectable.
 *
 * @const
 * @type {string}
 */
_ol_css_.CLASS_UNSELECTABLE = 'ol-unselectable';

/**
 * The CSS class for unsupported feature.
 *
 * @const
 * @type {string}
 */
_ol_css_.CLASS_UNSUPPORTED = 'ol-unsupported';

/**
 * The CSS class for controls.
 *
 * @const
 * @type {string}
 */
_ol_css_.CLASS_CONTROL = 'ol-control';

/**
 * Get the list of font families from a font spec.  Note that this doesn't work
 * for font families that have commas in them.
 * @param {string} The CSS font property.
 * @return {Object.<string>} The font families (or null if the input spec is invalid).
 */
_ol_css_.getFontFamilies = function () {
  var style;
  var cache = {};
  return function (font) {
    if (!style) {
      style = document.createElement('div').style;
    }
    if (!(font in cache)) {
      style.font = font;
      var family = style.fontFamily;
      style.font = '';
      if (!family) {
        return null;
      }
      cache[font] = family.split(/,\s?/);
    }
    return cache[font];
  };
}();
/* harmony default export */ __webpack_exports__["a"] = (_ol_css_);

/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _ol_geom_flat_deflate_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
_ol_geom_flat_deflate_.coordinate = function (flatCoordinates, offset, coordinate, stride) {
  var i, ii;
  for (i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset++] = coordinate[i];
  }
  return offset;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {number} stride Stride.
 * @return {number} offset Offset.
 */
_ol_geom_flat_deflate_.coordinates = function (flatCoordinates, offset, coordinates, stride) {
  var i, ii;
  for (i = 0, ii = coordinates.length; i < ii; ++i) {
    var coordinate = coordinates[i];
    var j;
    for (j = 0; j < stride; ++j) {
      flatCoordinates[offset++] = coordinate[j];
    }
  }
  return offset;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<ol.Coordinate>>} coordinatess Coordinatess.
 * @param {number} stride Stride.
 * @param {Array.<number>=} opt_ends Ends.
 * @return {Array.<number>} Ends.
 */
_ol_geom_flat_deflate_.coordinatess = function (flatCoordinates, offset, coordinatess, stride, opt_ends) {
  var ends = opt_ends ? opt_ends : [];
  var i = 0;
  var j, jj;
  for (j = 0, jj = coordinatess.length; j < jj; ++j) {
    var end = _ol_geom_flat_deflate_.coordinates(flatCoordinates, offset, coordinatess[j], stride);
    ends[i++] = end;
    offset = end;
  }
  ends.length = i;
  return ends;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinatesss Coordinatesss.
 * @param {number} stride Stride.
 * @param {Array.<Array.<number>>=} opt_endss Endss.
 * @return {Array.<Array.<number>>} Endss.
 */
_ol_geom_flat_deflate_.coordinatesss = function (flatCoordinates, offset, coordinatesss, stride, opt_endss) {
  var endss = opt_endss ? opt_endss : [];
  var i = 0;
  var j, jj;
  for (j = 0, jj = coordinatesss.length; j < jj; ++j) {
    var ends = _ol_geom_flat_deflate_.coordinatess(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
    endss[i++] = ends;
    offset = ends[ends.length - 1];
  }
  endss.length = i;
  return endss;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_geom_flat_deflate_);

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _ol_geom_flat_inflate_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {Array.<ol.Coordinate>=} opt_coordinates Coordinates.
 * @return {Array.<ol.Coordinate>} Coordinates.
 */
_ol_geom_flat_inflate_.coordinates = function (flatCoordinates, offset, end, stride, opt_coordinates) {
  var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
  var i = 0;
  var j;
  for (j = offset; j < end; j += stride) {
    coordinates[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates.length = i;
  return coordinates;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array.<Array.<ol.Coordinate>>=} opt_coordinatess Coordinatess.
 * @return {Array.<Array.<ol.Coordinate>>} Coordinatess.
 */
_ol_geom_flat_inflate_.coordinatess = function (flatCoordinates, offset, ends, stride, opt_coordinatess) {
  var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
  var i = 0;
  var j, jj;
  for (j = 0, jj = ends.length; j < jj; ++j) {
    var end = ends[j];
    coordinatess[i++] = _ol_geom_flat_inflate_.coordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
    offset = end;
  }
  coordinatess.length = i;
  return coordinatess;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array.<Array.<Array.<ol.Coordinate>>>=} opt_coordinatesss
 *     Coordinatesss.
 * @return {Array.<Array.<Array.<ol.Coordinate>>>} Coordinatesss.
 */
_ol_geom_flat_inflate_.coordinatesss = function (flatCoordinates, offset, endss, stride, opt_coordinatesss) {
  var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
  var i = 0;
  var j, jj;
  for (j = 0, jj = endss.length; j < jj; ++j) {
    var ends = endss[j];
    coordinatesss[i++] = _ol_geom_flat_inflate_.coordinatess(flatCoordinates, offset, ends, stride, coordinatesss[i]);
    offset = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_geom_flat_inflate_);

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
 * @enum {string}
 */
var _ol_source_State_ = {
  UNDEFINED: 'undefined',
  LOADING: 'loading',
  READY: 'ready',
  ERROR: 'error'
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_source_State_);

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mapbrowsereventtype_js__ = __webpack_require__(52);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__asserts_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__functions_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__has_js__ = __webpack_require__(19);




var _ol_events_condition_ = {};

/**
 * Return `true` if only the alt-key is pressed, `false` otherwise (e.g. when
 * additionally the shift-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt key is pressed.
 * @api
 */
_ol_events_condition_.altKeyOnly = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};

/**
 * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
 * (e.g. when additionally the platform-modifier-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the alt and shift keys are pressed.
 * @api
 */
_ol_events_condition_.altShiftKeysOnly = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};

/**
 * Return always true.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True.
 * @function
 * @api
 */
_ol_events_condition_.always = __WEBPACK_IMPORTED_MODULE_2__functions_js__["a" /* default */].TRUE;

/**
 * Return `true` if the event is a `click` event, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `click` event.
 * @api
 */
_ol_events_condition_.click = function (mapBrowserEvent) {
  return mapBrowserEvent.type == __WEBPACK_IMPORTED_MODULE_0__mapbrowsereventtype_js__["a" /* default */].CLICK;
};

/**
 * Return `true` if the event has an "action"-producing mouse button.
 *
 * By definition, this includes left-click on windows/linux, and left-click
 * without the ctrl key on Macs.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} The result.
 */
_ol_events_condition_.mouseActionButton = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return originalEvent.button == 0 && !(__WEBPACK_IMPORTED_MODULE_3__has_js__["a" /* default */].WEBKIT && __WEBPACK_IMPORTED_MODULE_3__has_js__["a" /* default */].MAC && originalEvent.ctrlKey);
};

/**
 * Return always false.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} False.
 * @function
 * @api
 */
_ol_events_condition_.never = __WEBPACK_IMPORTED_MODULE_2__functions_js__["a" /* default */].FALSE;

/**
 * Return `true` if the browser event is a `pointermove` event, `false`
 * otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the browser event is a `pointermove` event.
 * @api
 */
_ol_events_condition_.pointerMove = function (mapBrowserEvent) {
  return mapBrowserEvent.type == 'pointermove';
};

/**
 * Return `true` if the event is a map `singleclick` event, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `singleclick` event.
 * @api
 */
_ol_events_condition_.singleClick = function (mapBrowserEvent) {
  return mapBrowserEvent.type == __WEBPACK_IMPORTED_MODULE_0__mapbrowsereventtype_js__["a" /* default */].SINGLECLICK;
};

/**
 * Return `true` if the event is a map `dblclick` event, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event is a map `dblclick` event.
 * @api
 */
_ol_events_condition_.doubleClick = function (mapBrowserEvent) {
  return mapBrowserEvent.type == __WEBPACK_IMPORTED_MODULE_0__mapbrowsereventtype_js__["a" /* default */].DBLCLICK;
};

/**
 * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
 * pressed.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True only if there no modifier keys are pressed.
 * @api
 */
_ol_events_condition_.noModifierKeys = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};

/**
 * Return `true` if only the platform-modifier-key (the meta-key on Mac,
 * ctrl-key otherwise) is pressed, `false` otherwise (e.g. when additionally
 * the shift-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the platform modifier key is pressed.
 * @api
 */
_ol_events_condition_.platformModifierKeyOnly = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && (__WEBPACK_IMPORTED_MODULE_3__has_js__["a" /* default */].MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};

/**
 * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
 * additionally the alt-key is pressed).
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if only the shift key is pressed.
 * @api
 */
_ol_events_condition_.shiftKeyOnly = function (mapBrowserEvent) {
  var originalEvent = mapBrowserEvent.originalEvent;
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};

/**
 * Return `true` if the target element is not editable, i.e. not a `<input>`-,
 * `<select>`- or `<textarea>`-element, `false` otherwise.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True only if the target element is not editable.
 * @api
 */
_ol_events_condition_.targetNotEditable = function (mapBrowserEvent) {
  var target = mapBrowserEvent.originalEvent.target;
  var tagName = target.tagName;
  return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA';
};

/**
 * Return `true` if the event originates from a mouse device.
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a mouse device.
 * @api
 */
_ol_events_condition_.mouseOnly = function (mapBrowserEvent) {
  __WEBPACK_IMPORTED_MODULE_1__asserts_js__["a" /* default */].assert(mapBrowserEvent.pointerEvent, 56); // mapBrowserEvent must originate from a pointer event
  // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
  return (/** @type {ol.MapBrowserEvent} */mapBrowserEvent.pointerEvent.pointerType == 'mouse'
  );
};

/**
 * Return `true` if the event originates from a primary pointer in
 * contact with the surface or if the left mouse button is pressed.
 * @see http://www.w3.org/TR/pointerevents/#button-states
 *
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} True if the event originates from a primary pointer.
 * @api
 */
_ol_events_condition_.primaryAction = function (mapBrowserEvent) {
  var pointerEvent = mapBrowserEvent.pointerEvent;
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_events_condition_);

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_semantic_ui_react__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_semantic_ui_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_semantic_ui_react__);
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




var dropdownStyle = {
    background: 'black !important',
    color: 'white !important',
    textTransform: 'capitalize !important'
};

var HeaderMenu = function (_React$Component) {
    _inherits(HeaderMenu, _React$Component);

    function HeaderMenu(props) {
        var _ref;

        _classCallCheck(this, HeaderMenu);

        var _this = _possibleConstructorReturn(this, (HeaderMenu.__proto__ || Object.getPrototypeOf(HeaderMenu)).call(this, props));

        var topics = [];
        if (props.topics) {
            topics = props.topics.map(function (topic) {
                return {
                    key: topic.name_id,
                    name: topic.name,
                    href: '/topics/' + topic.name_id
                };
            });
        }

        var homeTab = { key: 'home', name: 'Home', as: 'a', href: '/' };
        // let aboutTab = {key: 'about', name: 'about', as: 'a', href: '/about'};
        var items = (_ref = [homeTab]).concat.apply(_ref, _toConsumableArray(topics));

        if (props.addItems) {
            items = items.concat(props.addItems);
        }

        var activeIndex;
        if (props.activeItem) {
            var keys = items.map(function (item) {
                return item.key;
            });
            activeIndex = keys.indexOf(props.activeItem);
        }

        _this.state = {
            activeIndex: activeIndex || 0,
            items: items,
            topics: topics
        };
        return _this;
    }

    _createClass(HeaderMenu, [{
        key: 'render',
        value: function render() {
            var _this2 = this;

            var children = this.props.children;


            return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
                'div',
                null,
                __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1_semantic_ui_react__["Menu"], {
                    className: 'desktop-menu',
                    fixed: 'top',
                    inverted: true,
                    pointing: true,
                    items: this.state.items,
                    activeIndex: this.state.activeIndex }),
                __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
                    __WEBPACK_IMPORTED_MODULE_1_semantic_ui_react__["Menu"],
                    {
                        className: 'mobile-menu',
                        fixed: 'top',
                        inverted: true,
                        icon: true },
                    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
                        __WEBPACK_IMPORTED_MODULE_1_semantic_ui_react__["Dropdown"],
                        { item: true, icon: 'bars', className: 'left', style: dropdownStyle },
                        __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
                            __WEBPACK_IMPORTED_MODULE_1_semantic_ui_react__["Dropdown"].Menu,
                            { style: dropdownStyle },
                            this.state.items.map(function (item, index) {
                                if (_this2.state.activeIndex !== index) {
                                    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(__WEBPACK_IMPORTED_MODULE_1_semantic_ui_react__["Dropdown"].Item, {
                                        key: item.key,
                                        text: item.name,
                                        as: 'a',
                                        href: item.href,
                                        style: dropdownStyle
                                    });
                                }
                            })
                        )
                    ),
                    __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(
                        __WEBPACK_IMPORTED_MODULE_1_semantic_ui_react__["Menu"].Menu,
                        { position: 'right', className: 'right' },
                        children
                    )
                )
            );
        }
    }]);

    return HeaderMenu;
}(__WEBPACK_IMPORTED_MODULE_0_react___default.a.Component);

;

/* harmony default export */ __webpack_exports__["a"] = (HeaderMenu);

/***/ }),
/* 38 */
/***/ (function(module, exports) {

module.exports = require("styled-jsx/style");

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__asserts_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__style_circle_js__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__style_fill_js__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__style_stroke_js__ = __webpack_require__(57);






/**
 * @classdesc
 * Container for vector feature rendering styles. Any changes made to the style
 * or its children through `set*()` methods will not take effect until the
 * feature or layer that uses the style is re-rendered.
 *
 * @constructor
 * @struct
 * @param {olx.style.StyleOptions=} opt_options Style options.
 * @api
 */
var _ol_style_Style_ = function _ol_style_Style_(opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {string|ol.geom.Geometry|ol.StyleGeometryFunction}
   */
  this.geometry_ = null;

  /**
   * @private
   * @type {!ol.StyleGeometryFunction}
   */
  this.geometryFunction_ = _ol_style_Style_.defaultGeometryFunction;

  if (options.geometry !== undefined) {
    this.setGeometry(options.geometry);
  }

  /**
   * @private
   * @type {ol.style.Fill}
   */
  this.fill_ = options.fill !== undefined ? options.fill : null;

  /**
   * @private
   * @type {ol.style.Image}
   */
  this.image_ = options.image !== undefined ? options.image : null;

  /**
   * @private
   * @type {ol.StyleRenderFunction|null}
   */
  this.renderer_ = options.renderer !== undefined ? options.renderer : null;

  /**
   * @private
   * @type {ol.style.Stroke}
   */
  this.stroke_ = options.stroke !== undefined ? options.stroke : null;

  /**
   * @private
   * @type {ol.style.Text}
   */
  this.text_ = options.text !== undefined ? options.text : null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.zIndex_ = options.zIndex;
};

/**
 * Clones the style.
 * @return {ol.style.Style} The cloned style.
 * @api
 */
_ol_style_Style_.prototype.clone = function () {
  var geometry = this.getGeometry();
  if (geometry && geometry.clone) {
    geometry = geometry.clone();
  }
  return new _ol_style_Style_({
    geometry: geometry,
    fill: this.getFill() ? this.getFill().clone() : undefined,
    image: this.getImage() ? this.getImage().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    text: this.getText() ? this.getText().clone() : undefined,
    zIndex: this.getZIndex()
  });
};

/**
 * Get the custom renderer function that was configured with
 * {@link #setRenderer} or the `renderer` constructor option.
 * @return {ol.StyleRenderFunction|null} Custom renderer function.
 * @api
 */
_ol_style_Style_.prototype.getRenderer = function () {
  return this.renderer_;
};

/**
 * Sets a custom renderer function for this style. When set, `fill`, `stroke`
 * and `image` options of the style will be ignored.
 * @param {ol.StyleRenderFunction|null} renderer Custom renderer function.
 * @api
 */
_ol_style_Style_.prototype.setRenderer = function (renderer) {
  this.renderer_ = renderer;
};

/**
 * Get the geometry to be rendered.
 * @return {string|ol.geom.Geometry|ol.StyleGeometryFunction}
 * Feature property or geometry or function that returns the geometry that will
 * be rendered with this style.
 * @api
 */
_ol_style_Style_.prototype.getGeometry = function () {
  return this.geometry_;
};

/**
 * Get the function used to generate a geometry for rendering.
 * @return {!ol.StyleGeometryFunction} Function that is called with a feature
 * and returns the geometry to render instead of the feature's geometry.
 * @api
 */
_ol_style_Style_.prototype.getGeometryFunction = function () {
  return this.geometryFunction_;
};

/**
 * Get the fill style.
 * @return {ol.style.Fill} Fill style.
 * @api
 */
_ol_style_Style_.prototype.getFill = function () {
  return this.fill_;
};

/**
 * Set the fill style.
 * @param {ol.style.Fill} fill Fill style.
 * @api
 */
_ol_style_Style_.prototype.setFill = function (fill) {
  this.fill_ = fill;
};

/**
 * Get the image style.
 * @return {ol.style.Image} Image style.
 * @api
 */
_ol_style_Style_.prototype.getImage = function () {
  return this.image_;
};

/**
 * Set the image style.
 * @param {ol.style.Image} image Image style.
 * @api
 */
_ol_style_Style_.prototype.setImage = function (image) {
  this.image_ = image;
};

/**
 * Get the stroke style.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */
_ol_style_Style_.prototype.getStroke = function () {
  return this.stroke_;
};

/**
 * Set the stroke style.
 * @param {ol.style.Stroke} stroke Stroke style.
 * @api
 */
_ol_style_Style_.prototype.setStroke = function (stroke) {
  this.stroke_ = stroke;
};

/**
 * Get the text style.
 * @return {ol.style.Text} Text style.
 * @api
 */
_ol_style_Style_.prototype.getText = function () {
  return this.text_;
};

/**
 * Set the text style.
 * @param {ol.style.Text} text Text style.
 * @api
 */
_ol_style_Style_.prototype.setText = function (text) {
  this.text_ = text;
};

/**
 * Get the z-index for the style.
 * @return {number|undefined} ZIndex.
 * @api
 */
_ol_style_Style_.prototype.getZIndex = function () {
  return this.zIndex_;
};

/**
 * Set a geometry that is rendered instead of the feature's geometry.
 *
 * @param {string|ol.geom.Geometry|ol.StyleGeometryFunction} geometry
 *     Feature property or geometry or function returning a geometry to render
 *     for this style.
 * @api
 */
_ol_style_Style_.prototype.setGeometry = function (geometry) {
  if (typeof geometry === 'function') {
    this.geometryFunction_ = geometry;
  } else if (typeof geometry === 'string') {
    this.geometryFunction_ = function (feature) {
      return (/** @type {ol.geom.Geometry} */feature.get(geometry)
      );
    };
  } else if (!geometry) {
    this.geometryFunction_ = _ol_style_Style_.defaultGeometryFunction;
  } else if (geometry !== undefined) {
    this.geometryFunction_ = function () {
      return (/** @type {ol.geom.Geometry} */geometry
      );
    };
  }
  this.geometry_ = geometry;
};

/**
 * Set the z-index.
 *
 * @param {number|undefined} zIndex ZIndex.
 * @api
 */
_ol_style_Style_.prototype.setZIndex = function (zIndex) {
  this.zIndex_ = zIndex;
};

/**
 * Convert the provided object into a style function.  Functions passed through
 * unchanged.  Arrays of ol.style.Style or single style objects wrapped in a
 * new style function.
 * @param {ol.StyleFunction|Array.<ol.style.Style>|ol.style.Style} obj
 *     A style function, a single style, or an array of styles.
 * @return {ol.StyleFunction} A style function.
 */
_ol_style_Style_.createFunction = function (obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    styleFunction = obj;
  } else {
    /**
     * @type {Array.<ol.style.Style>}
     */
    var styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      __WEBPACK_IMPORTED_MODULE_0__asserts_js__["a" /* default */].assert(obj instanceof _ol_style_Style_, 41); // Expected an `ol.style.Style` or an array of `ol.style.Style`
      styles = [obj];
    }
    styleFunction = function styleFunction() {
      return styles;
    };
  }
  return styleFunction;
};

/**
 * @type {Array.<ol.style.Style>}
 * @private
 */
_ol_style_Style_.default_ = null;

/**
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {number} resolution Resolution.
 * @return {Array.<ol.style.Style>} Style.
 */
_ol_style_Style_.defaultFunction = function (feature, resolution) {
  // We don't use an immediately-invoked function
  // and a closure so we don't get an error at script evaluation time in
  // browsers that do not support Canvas. (ol.style.Circle does
  // canvas.getContext('2d') at construction time, which will cause an.error
  // in such browsers.)
  if (!_ol_style_Style_.default_) {
    var fill = new __WEBPACK_IMPORTED_MODULE_3__style_fill_js__["default"]({
      color: 'rgba(255,255,255,0.4)'
    });
    var stroke = new __WEBPACK_IMPORTED_MODULE_4__style_stroke_js__["default"]({
      color: '#3399CC',
      width: 1.25
    });
    _ol_style_Style_.default_ = [new _ol_style_Style_({
      image: new __WEBPACK_IMPORTED_MODULE_2__style_circle_js__["default"]({
        fill: fill,
        stroke: stroke,
        radius: 5
      }),
      fill: fill,
      stroke: stroke
    })];
  }
  return _ol_style_Style_.default_;
};

/**
 * Default styles for editing features.
 * @return {Object.<ol.geom.GeometryType, Array.<ol.style.Style>>} Styles
 */
_ol_style_Style_.createDefaultEditing = function () {
  /** @type {Object.<ol.geom.GeometryType, Array.<ol.style.Style>>} */
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[__WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__["a" /* default */].POLYGON] = [new _ol_style_Style_({
    fill: new __WEBPACK_IMPORTED_MODULE_3__style_fill_js__["default"]({
      color: [255, 255, 255, 0.5]
    })
  })];
  styles[__WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__["a" /* default */].MULTI_POLYGON] = styles[__WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__["a" /* default */].POLYGON];

  styles[__WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__["a" /* default */].LINE_STRING] = [new _ol_style_Style_({
    stroke: new __WEBPACK_IMPORTED_MODULE_4__style_stroke_js__["default"]({
      color: white,
      width: width + 2
    })
  }), new _ol_style_Style_({
    stroke: new __WEBPACK_IMPORTED_MODULE_4__style_stroke_js__["default"]({
      color: blue,
      width: width
    })
  })];
  styles[__WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__["a" /* default */].MULTI_LINE_STRING] = styles[__WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__["a" /* default */].LINE_STRING];

  styles[__WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__["a" /* default */].CIRCLE] = styles[__WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__["a" /* default */].POLYGON].concat(styles[__WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__["a" /* default */].LINE_STRING]);

  styles[__WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__["a" /* default */].POINT] = [new _ol_style_Style_({
    image: new __WEBPACK_IMPORTED_MODULE_2__style_circle_js__["default"]({
      radius: width * 2,
      fill: new __WEBPACK_IMPORTED_MODULE_3__style_fill_js__["default"]({
        color: blue
      }),
      stroke: new __WEBPACK_IMPORTED_MODULE_4__style_stroke_js__["default"]({
        color: white,
        width: width / 2
      })
    }),
    zIndex: Infinity
  })];
  styles[__WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__["a" /* default */].MULTI_POINT] = styles[__WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__["a" /* default */].POINT];

  styles[__WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__["a" /* default */].GEOMETRY_COLLECTION] = styles[__WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__["a" /* default */].POLYGON].concat(styles[__WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__["a" /* default */].LINE_STRING], styles[__WEBPACK_IMPORTED_MODULE_1__geom_geometrytype_js__["a" /* default */].POINT]);

  return styles;
};

/**
 * Function that is called with a feature and returns its default geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature to get the geometry
 *     for.
 * @return {ol.geom.Geometry|ol.render.Feature|undefined} Geometry to render.
 */
_ol_style_Style_.defaultGeometryFunction = function (feature) {
  return feature.getGeometry();
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_style_Style_);

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @enum {number}
 */
var _ol_ImageState_ = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  ERROR: 3
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_ImageState_);

/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_js__ = __webpack_require__(6);
// Based on simplify-js https://github.com/mourner/simplify-js
// Copyright (c) 2012, Vladimir Agafonkin
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
//
//    1. Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimer.
//
//    2. Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.


var _ol_geom_flat_simplify_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {boolean} highQuality Highest quality.
 * @param {Array.<number>=} opt_simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @return {Array.<number>} Simplified line string.
 */
_ol_geom_flat_simplify_.lineString = function (flatCoordinates, offset, end, stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {
  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ? opt_simplifiedFlatCoordinates : [];
  if (!highQuality) {
    end = _ol_geom_flat_simplify_.radialDistance(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
    flatCoordinates = simplifiedFlatCoordinates;
    offset = 0;
    stride = 2;
  }
  simplifiedFlatCoordinates.length = _ol_geom_flat_simplify_.douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  return simplifiedFlatCoordinates;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
_ol_geom_flat_simplify_.douglasPeucker = function (flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  var n = (end - offset) / stride;
  if (n < 3) {
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  /** @type {Array.<number>} */
  var markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  /** @type {Array.<number>} */
  var stack = [offset, end - stride];
  var index = 0;
  var i;
  while (stack.length > 0) {
    var last = stack.pop();
    var first = stack.pop();
    var maxSquaredDistance = 0;
    var x1 = flatCoordinates[first];
    var y1 = flatCoordinates[first + 1];
    var x2 = flatCoordinates[last];
    var y2 = flatCoordinates[last + 1];
    for (i = first + stride; i < last; i += stride) {
      var x = flatCoordinates[i];
      var y = flatCoordinates[i + 1];
      var squaredDistance = __WEBPACK_IMPORTED_MODULE_0__math_js__["a" /* default */].squaredSegmentDistance(x, y, x1, y1, x2, y2);
      if (squaredDistance > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + i * stride + 1];
    }
  }
  return simplifiedOffset;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
_ol_geom_flat_simplify_.douglasPeuckers = function (flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = _ol_geom_flat_simplify_.douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
_ol_geom_flat_simplify_.douglasPeuckerss = function (flatCoordinates, offset, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = _ol_geom_flat_simplify_.douglasPeuckers(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
_ol_geom_flat_simplify_.radialDistance = function (flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (end <= offset + stride) {
    // zero or one point, no simplification possible, so copy and return
    for (; offset < end; offset += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset + 1];
    }
    return simplifiedOffset;
  }
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  // copy first point
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  var x2 = x1;
  var y2 = y1;
  for (offset += stride; offset < end; offset += stride) {
    x2 = flatCoordinates[offset];
    y2 = flatCoordinates[offset + 1];
    if (__WEBPACK_IMPORTED_MODULE_0__math_js__["a" /* default */].squaredDistance(x1, y1, x2, y2) > squaredTolerance) {
      // copy point at offset
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }
  if (x2 != x1 || y2 != y1) {
    // copy last point
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }
  return simplifiedOffset;
};

/**
 * @param {number} value Value.
 * @param {number} tolerance Tolerance.
 * @return {number} Rounded value.
 */
_ol_geom_flat_simplify_.snap = function (value, tolerance) {
  return tolerance * Math.round(value / tolerance);
};

/**
 * Simplifies a line string using an algorithm designed by Tim Schaub.
 * Coordinates are snapped to the nearest value in a virtual grid and
 * consecutive duplicate coordinates are discarded.  This effectively preserves
 * topology as the simplification of any subsection of a line string is
 * independent of the rest of the line string.  This means that, for examples,
 * the common edge between two polygons will be simplified to the same line
 * string independently in both polygons.  This implementation uses a single
 * pass over the coordinates and eliminates intermediate collinear points.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @return {number} Simplified offset.
 */
_ol_geom_flat_simplify_.quantize = function (flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  // do nothing if the line is empty
  if (offset == end) {
    return simplifiedOffset;
  }
  // snap the first coordinate (P1)
  var x1 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);
  var y1 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);
  offset += stride;
  // add the first coordinate to the output
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  // find the next coordinate that does not snap to the same value as the first
  // coordinate (P2)
  var x2, y2;
  do {
    x2 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);
    y2 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    if (offset == end) {
      // all coordinates snap to the same value, the line collapses to a point
      // push the last snapped value anyway to ensure that the output contains
      // at least two points
      // FIXME should we really return at least two points anyway?
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset < end) {
    var x3, y3;
    // snap the next coordinate (P3)
    x3 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset], tolerance);
    y3 = _ol_geom_flat_simplify_.snap(flatCoordinates[offset + 1], tolerance);
    offset += stride;
    // skip P3 if it is equal to P2
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    // calculate the delta between P1 and P2
    var dx1 = x2 - x1;
    var dy1 = y2 - y1;
    // calculate the delta between P3 and P1
    var dx2 = x3 - x1;
    var dy2 = y3 - y1;
    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
    // P1 in the same direction then P2 is on the straight line between P1 and
    // P3
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      // discard P2 and set P2 = P3
      x2 = x3;
      y2 = y3;
      continue;
    }
    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
    // between P3 and P1 or on the opposite half of the line to P2.  add P2,
    // and continue with P1 = P2 and P2 = P3
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  // add the last point (P2)
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<number>} simplifiedEnds Simplified ends.
 * @return {number} Simplified offset.
 */
_ol_geom_flat_simplify_.quantizes = function (flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    simplifiedOffset = _ol_geom_flat_simplify_.quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
    simplifiedEnds.push(simplifiedOffset);
    offset = end;
  }
  return simplifiedOffset;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} tolerance Tolerance.
 * @param {Array.<number>} simplifiedFlatCoordinates Simplified flat
 *     coordinates.
 * @param {number} simplifiedOffset Simplified offset.
 * @param {Array.<Array.<number>>} simplifiedEndss Simplified endss.
 * @return {number} Simplified offset.
 */
_ol_geom_flat_simplify_.quantizess = function (flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    var simplifiedEnds = [];
    simplifiedOffset = _ol_geom_flat_simplify_.quantizes(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
    simplifiedEndss.push(simplifiedEnds);
    offset = ends[ends.length - 1];
  }
  return simplifiedOffset;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_geom_flat_simplify_);

/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__events_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__events_eventtype_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__index_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__object_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__layer_base_js__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__layer_property_js__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__obj_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__render_eventtype_js__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__source_state_js__ = __webpack_require__(35);










/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * A visual representation of raster or vector map data.
 * Layers group together those properties that pertain to how the data is to be
 * displayed, irrespective of the source of that data.
 *
 * Layers are usually added to a map with {@link ol.Map#addLayer}. Components
 * like {@link ol.interaction.Select} use unmanaged layers internally. These
 * unmanaged layers are associated with the map using
 * {@link ol.layer.Layer#setMap} instead.
 *
 * A generic `change` event is fired when the state of the source changes.
 *
 * @constructor
 * @abstract
 * @extends {ol.layer.Base}
 * @fires ol.render.Event
 * @param {olx.layer.LayerOptions} options Layer options.
 * @api
 */
var _ol_layer_Layer_ = function _ol_layer_Layer_(options) {

  var baseOptions = __WEBPACK_IMPORTED_MODULE_6__obj_js__["a" /* default */].assign({}, options);
  delete baseOptions.source;

  __WEBPACK_IMPORTED_MODULE_4__layer_base_js__["a" /* default */].call(this, /** @type {olx.layer.BaseOptions} */baseOptions);

  /**
   * @private
   * @type {?ol.EventsKey}
   */
  this.mapPrecomposeKey_ = null;

  /**
   * @private
   * @type {?ol.EventsKey}
   */
  this.mapRenderKey_ = null;

  /**
   * @private
   * @type {?ol.EventsKey}
   */
  this.sourceChangeKey_ = null;

  if (options.map) {
    this.setMap(options.map);
  }

  __WEBPACK_IMPORTED_MODULE_0__events_js__["a" /* default */].listen(this, __WEBPACK_IMPORTED_MODULE_3__object_js__["a" /* default */].getChangeEventType(__WEBPACK_IMPORTED_MODULE_5__layer_property_js__["a" /* default */].SOURCE), this.handleSourcePropertyChange_, this);

  var source = options.source ? options.source : null;
  this.setSource(source);
};

__WEBPACK_IMPORTED_MODULE_2__index_js__["a" /* default */].inherits(_ol_layer_Layer_, __WEBPACK_IMPORTED_MODULE_4__layer_base_js__["a" /* default */]);

/**
 * Return `true` if the layer is visible, and if the passed resolution is
 * between the layer's minResolution and maxResolution. The comparison is
 * inclusive for `minResolution` and exclusive for `maxResolution`.
 * @param {ol.LayerState} layerState Layer state.
 * @param {number} resolution Resolution.
 * @return {boolean} The layer is visible at the given resolution.
 */
_ol_layer_Layer_.visibleAtResolution = function (layerState, resolution) {
  return layerState.visible && resolution >= layerState.minResolution && resolution < layerState.maxResolution;
};

/**
 * @inheritDoc
 */
_ol_layer_Layer_.prototype.getLayersArray = function (opt_array) {
  var array = opt_array ? opt_array : [];
  array.push(this);
  return array;
};

/**
 * @inheritDoc
 */
_ol_layer_Layer_.prototype.getLayerStatesArray = function (opt_states) {
  var states = opt_states ? opt_states : [];
  states.push(this.getLayerState());
  return states;
};

/**
 * Get the layer source.
 * @return {ol.source.Source} The layer source (or `null` if not yet set).
 * @observable
 * @api
 */
_ol_layer_Layer_.prototype.getSource = function () {
  var source = this.get(__WEBPACK_IMPORTED_MODULE_5__layer_property_js__["a" /* default */].SOURCE);
  return (/** @type {ol.source.Source} */source || null
  );
};

/**
  * @inheritDoc
  */
_ol_layer_Layer_.prototype.getSourceState = function () {
  var source = this.getSource();
  return !source ? __WEBPACK_IMPORTED_MODULE_8__source_state_js__["a" /* default */].UNDEFINED : source.getState();
};

/**
 * @private
 */
_ol_layer_Layer_.prototype.handleSourceChange_ = function () {
  this.changed();
};

/**
 * @private
 */
_ol_layer_Layer_.prototype.handleSourcePropertyChange_ = function () {
  if (this.sourceChangeKey_) {
    __WEBPACK_IMPORTED_MODULE_0__events_js__["a" /* default */].unlistenByKey(this.sourceChangeKey_);
    this.sourceChangeKey_ = null;
  }
  var source = this.getSource();
  if (source) {
    this.sourceChangeKey_ = __WEBPACK_IMPORTED_MODULE_0__events_js__["a" /* default */].listen(source, __WEBPACK_IMPORTED_MODULE_1__events_eventtype_js__["a" /* default */].CHANGE, this.handleSourceChange_, this);
  }
  this.changed();
};

/**
 * Sets the layer to be rendered on top of other layers on a map. The map will
 * not manage this layer in its layers collection, and the callback in
 * {@link ol.Map#forEachLayerAtPixel} will receive `null` as layer. This
 * is useful for temporary layers. To remove an unmanaged layer from the map,
 * use `#setMap(null)`.
 *
 * To add the layer to a map and have it managed by the map, use
 * {@link ol.Map#addLayer} instead.
 * @param {ol.PluggableMap} map Map.
 * @api
 */
_ol_layer_Layer_.prototype.setMap = function (map) {
  if (this.mapPrecomposeKey_) {
    __WEBPACK_IMPORTED_MODULE_0__events_js__["a" /* default */].unlistenByKey(this.mapPrecomposeKey_);
    this.mapPrecomposeKey_ = null;
  }
  if (!map) {
    this.changed();
  }
  if (this.mapRenderKey_) {
    __WEBPACK_IMPORTED_MODULE_0__events_js__["a" /* default */].unlistenByKey(this.mapRenderKey_);
    this.mapRenderKey_ = null;
  }
  if (map) {
    this.mapPrecomposeKey_ = __WEBPACK_IMPORTED_MODULE_0__events_js__["a" /* default */].listen(map, __WEBPACK_IMPORTED_MODULE_7__render_eventtype_js__["a" /* default */].PRECOMPOSE, function (evt) {
      var layerState = this.getLayerState();
      layerState.managed = false;
      layerState.zIndex = Infinity;
      evt.frameState.layerStatesArray.push(layerState);
      evt.frameState.layerStates[__WEBPACK_IMPORTED_MODULE_2__index_js__["a" /* default */].getUid(this)] = layerState;
    }, this);
    this.mapRenderKey_ = __WEBPACK_IMPORTED_MODULE_0__events_js__["a" /* default */].listen(this, __WEBPACK_IMPORTED_MODULE_1__events_eventtype_js__["a" /* default */].CHANGE, map.render, map);
    this.changed();
  }
};

/**
 * Set the layer source.
 * @param {ol.source.Source} source The layer source.
 * @observable
 * @api
 */
_ol_layer_Layer_.prototype.setSource = function (source) {
  this.set(__WEBPACK_IMPORTED_MODULE_5__layer_property_js__["a" /* default */].SOURCE, source);
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_layer_Layer_);

/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @enum {string}
 */
var _ol_render_EventType_ = {
  /**
   * @event ol.render.Event#postcompose
   * @api
   */
  POSTCOMPOSE: 'postcompose',
  /**
   * @event ol.render.Event#precompose
   * @api
   */
  PRECOMPOSE: 'precompose',
  /**
   * @event ol.render.Event#render
   * @api
   */
  RENDER: 'render'
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_render_EventType_);

/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _ol_tilecoord_ = {};

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {ol.TileCoord=} opt_tileCoord Tile coordinate.
 * @return {ol.TileCoord} Tile coordinate.
 */
_ol_tilecoord_.createOrUpdate = function (z, x, y, opt_tileCoord) {
  if (opt_tileCoord !== undefined) {
    opt_tileCoord[0] = z;
    opt_tileCoord[1] = x;
    opt_tileCoord[2] = y;
    return opt_tileCoord;
  } else {
    return [z, x, y];
  }
};

/**
 * @param {number} z Z.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {string} Key.
 */
_ol_tilecoord_.getKeyZXY = function (z, x, y) {
  return z + '/' + x + '/' + y;
};

/**
 * Get the key for a tile coord.
 * @param {ol.TileCoord} tileCoord The tile coord.
 * @return {string} Key.
 */
_ol_tilecoord_.getKey = function (tileCoord) {
  return _ol_tilecoord_.getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
};

/**
 * Get a tile coord given a key.
 * @param {string} key The tile coord key.
 * @return {ol.TileCoord} The tile coord.
 */
_ol_tilecoord_.fromKey = function (key) {
  return key.split('/').map(Number);
};

/**
 * @param {ol.TileCoord} tileCoord Tile coord.
 * @return {number} Hash.
 */
_ol_tilecoord_.hash = function (tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
};

/**
 * @param {ol.TileCoord} tileCoord Tile coord.
 * @return {string} Quad key.
 */
_ol_tilecoord_.quadKey = function (tileCoord) {
  var z = tileCoord[0];
  var digits = new Array(z);
  var mask = 1 << z - 1;
  var i, charCode;
  for (i = 0; i < z; ++i) {
    // 48 is charCode for 0 - '0'.charCodeAt(0)
    charCode = 48;
    if (tileCoord[1] & mask) {
      charCode += 1;
    }
    if (tileCoord[2] & mask) {
      charCode += 2;
    }
    digits[i] = String.fromCharCode(charCode);
    mask >>= 1;
  }
  return digits.join('');
};

/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {!ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {boolean} Tile coordinate is within extent and zoom level range.
 */
_ol_tilecoord_.withinExtentAndZ = function (tileCoord, tileGrid) {
  var z = tileCoord[0];
  var x = tileCoord[1];
  var y = tileCoord[2];

  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  var extent = tileGrid.getExtent();
  var tileRange;
  if (!extent) {
    tileRange = tileGrid.getFullTileRange(z);
  } else {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  }
  if (!tileRange) {
    return true;
  } else {
    return tileRange.containsXY(x, y);
  }
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_tilecoord_);

/***/ }),
/* 45 */
/***/ (function(module, exports) {

module.exports = require("isomorphic-unfetch");

/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__color_js__ = __webpack_require__(27);

var _ol_colorlike_ = {};

/**
 * @param {ol.Color|ol.ColorLike} color Color.
 * @return {ol.ColorLike} The color as an ol.ColorLike
 * @api
 */
_ol_colorlike_.asColorLike = function (color) {
  if (_ol_colorlike_.isColorLike(color)) {
    return (/** @type {string|CanvasPattern|CanvasGradient} */color
    );
  } else {
    return __WEBPACK_IMPORTED_MODULE_0__color_js__["a" /* default */].asString( /** @type {ol.Color} */color);
  }
};

/**
 * @param {?} color The value that is potentially an ol.ColorLike
 * @return {boolean} Whether the color is an ol.ColorLike
 */
_ol_colorlike_.isColorLike = function (color) {
  return typeof color === 'string' || typeof window !== 'undefined' && (color instanceof CanvasPattern || color instanceof CanvasGradient);
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_colorlike_);

/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_js__ = __webpack_require__(6);

var _ol_geom_flat_closest_ = {};

/**
 * Returns the point on the 2D line segment flatCoordinates[offset1] to
 * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
 * dimensions are linearly interpolated.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset1 Offset 1.
 * @param {number} offset2 Offset 2.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 */
_ol_geom_flat_closest_.point = function (flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  var x1 = flatCoordinates[offset1];
  var y1 = flatCoordinates[offset1 + 1];
  var dx = flatCoordinates[offset2] - x1;
  var dy = flatCoordinates[offset2 + 1] - y1;
  var i, offset;
  if (dx === 0 && dy === 0) {
    offset = offset1;
  } else {
    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset = offset2;
    } else if (t > 0) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = __WEBPACK_IMPORTED_MODULE_0__math_js__["a" /* default */].lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
      }
      closestPoint.length = stride;
      return;
    } else {
      offset = offset1;
    }
  }
  for (i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset + i];
  }
  closestPoint.length = stride;
};

/**
 * Return the squared of the largest distance between any pair of consecutive
 * coordinates.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxSquaredDelta Max squared delta.
 * @return {number} Max squared delta.
 */
_ol_geom_flat_closest_.getMaxSquaredDelta = function (flatCoordinates, offset, end, stride, maxSquaredDelta) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  for (offset += stride; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    var squaredDelta = __WEBPACK_IMPORTED_MODULE_0__math_js__["a" /* default */].squaredDistance(x1, y1, x2, y2);
    if (squaredDelta > maxSquaredDelta) {
      maxSquaredDelta = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return maxSquaredDelta;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxSquaredDelta Max squared delta.
 * @return {number} Max squared delta.
 */
_ol_geom_flat_closest_.getsMaxSquaredDelta = function (flatCoordinates, offset, ends, stride, maxSquaredDelta) {
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    maxSquaredDelta = _ol_geom_flat_closest_.getMaxSquaredDelta(flatCoordinates, offset, end, stride, maxSquaredDelta);
    offset = end;
  }
  return maxSquaredDelta;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxSquaredDelta Max squared delta.
 * @return {number} Max squared delta.
 */
_ol_geom_flat_closest_.getssMaxSquaredDelta = function (flatCoordinates, offset, endss, stride, maxSquaredDelta) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    maxSquaredDelta = _ol_geom_flat_closest_.getsMaxSquaredDelta(flatCoordinates, offset, ends, stride, maxSquaredDelta);
    offset = ends[ends.length - 1];
  }
  return maxSquaredDelta;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */
_ol_geom_flat_closest_.getClosestPoint = function (flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  if (offset == end) {
    return minSquaredDistance;
  }
  var i, squaredDistance;
  if (maxDelta === 0) {
    // All points are identical, so just test the first point.
    squaredDistance = __WEBPACK_IMPORTED_MODULE_0__math_js__["a" /* default */].squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
    if (squaredDistance < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
      return squaredDistance;
    } else {
      return minSquaredDistance;
    }
  }
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var index = offset + stride;
  while (index < end) {
    _ol_geom_flat_closest_.point(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
    squaredDistance = __WEBPACK_IMPORTED_MODULE_0__math_js__["a" /* default */].squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      // Skip ahead multiple points, because we know that all the skipped
      // points cannot be any closer than the closest point we have found so
      // far.  We know this because we know how close the current point is, how
      // close the closest point we have found so far is, and the maximum
      // distance between consecutive points.  For example, if we're currently
      // at distance 10, the best we've found so far is 3, and that the maximum
      // distance between consecutive points is 2, then we'll need to skip at
      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
      // finding a closer point.  We use Math.max(..., 1) to ensure that we
      // always advance at least one point, to avoid an infinite loop.
      index += stride * Math.max((Math.sqrt(squaredDistance) - Math.sqrt(minSquaredDistance)) / maxDelta | 0, 1);
    }
  }
  if (isRing) {
    // Check the closing segment.
    _ol_geom_flat_closest_.point(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
    squaredDistance = __WEBPACK_IMPORTED_MODULE_0__math_js__["a" /* default */].squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */
_ol_geom_flat_closest_.getsClosestPoint = function (flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    minSquaredDistance = _ol_geom_flat_closest_.getClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = end;
  }
  return minSquaredDistance;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} maxDelta Max delta.
 * @param {boolean} isRing Is ring.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {Array.<number>} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @param {Array.<number>=} opt_tmpPoint Temporary point object.
 * @return {number} Minimum squared distance.
 */
_ol_geom_flat_closest_.getssClosestPoint = function (flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    minSquaredDistance = _ol_geom_flat_closest_.getsClosestPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
    offset = ends[ends.length - 1];
  }
  return minSquaredDistance;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_geom_flat_closest_);

/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extent_js__ = __webpack_require__(1);

var _ol_geom_flat_contains_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} Contains extent.
 */
_ol_geom_flat_contains_.linearRingContainsExtent = function (flatCoordinates, offset, end, stride, extent) {
  var outside = __WEBPACK_IMPORTED_MODULE_0__extent_js__["a" /* default */].forEachCorner(extent,
  /**
   * @param {ol.Coordinate} coordinate Coordinate.
   * @return {boolean} Contains (x, y).
   */
  function (coordinate) {
    return !_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
  });
  return !outside;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
_ol_geom_flat_contains_.linearRingContainsXY = function (flatCoordinates, offset, end, stride, x, y) {
  // http://geomalgorithms.com/a03-_inclusion.html
  // Copyright 2000 softSurfer, 2012 Dan Sunday
  // This code may be freely used and modified for any purpose
  // providing that this copyright notice is included with it.
  // SoftSurfer makes no warranty for this code, and cannot be held
  // liable for any real or imagined damage resulting from its use.
  // Users of this code must verify correctness for their application.
  var wn = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
_ol_geom_flat_contains_.linearRingsContainsXY = function (flatCoordinates, offset, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
    return false;
  }
  var i, ii;
  for (i = 1, ii = ends.length; i < ii; ++i) {
    if (_ol_geom_flat_contains_.linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
_ol_geom_flat_contains_.linearRingssContainsXY = function (flatCoordinates, offset, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (_ol_geom_flat_contains_.linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_geom_flat_contains_);

/***/ }),
/* 49 */
/***/ (function(module, exports) {

module.exports = require("moment");

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__assertionerror_js__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__collectioneventtype_js__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__object_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__events_event_js__ = __webpack_require__(18);
/**
 * An implementation of Google Maps' MVCArray.
 * @see https://developers.google.com/maps/documentation/javascript/reference
 */







/**
 * @classdesc
 * An expanded version of standard JS Array, adding convenience methods for
 * manipulation. Add and remove changes to the Collection trigger a Collection
 * event. Note that this does not cover changes to the objects _within_ the
 * Collection; they trigger events on the appropriate object, not on the
 * Collection as a whole.
 *
 * @constructor
 * @extends {ol.Object}
 * @fires ol.Collection.Event
 * @param {Array.<T>=} opt_array Array.
 * @param {olx.CollectionOptions=} opt_options Collection options.
 * @template T
 * @api
 */
var _ol_Collection_ = function _ol_Collection_(opt_array, opt_options) {

  __WEBPACK_IMPORTED_MODULE_3__object_js__["a" /* default */].call(this);

  var options = opt_options || {};

  /**
   * @private
   * @type {boolean}
   */
  this.unique_ = !!options.unique;

  /**
   * @private
   * @type {!Array.<T>}
   */
  this.array_ = opt_array ? opt_array : [];

  if (this.unique_) {
    for (var i = 0, ii = this.array_.length; i < ii; ++i) {
      this.assertUnique_(this.array_[i], i);
    }
  }

  this.updateLength_();
};

__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].inherits(_ol_Collection_, __WEBPACK_IMPORTED_MODULE_3__object_js__["a" /* default */]);

/**
 * Remove all elements from the collection.
 * @api
 */
_ol_Collection_.prototype.clear = function () {
  while (this.getLength() > 0) {
    this.pop();
  }
};

/**
 * Add elements to the collection.  This pushes each item in the provided array
 * to the end of the collection.
 * @param {!Array.<T>} arr Array.
 * @return {ol.Collection.<T>} This collection.
 * @api
 */
_ol_Collection_.prototype.extend = function (arr) {
  var i, ii;
  for (i = 0, ii = arr.length; i < ii; ++i) {
    this.push(arr[i]);
  }
  return this;
};

/**
 * Iterate over each element, calling the provided callback.
 * @param {function(this: S, T, number, Array.<T>): *} f The function to call
 *     for every element. This function takes 3 arguments (the element, the
 *     index and the array). The return value is ignored.
 * @param {S=} opt_this The object to use as `this` in `f`.
 * @template S
 * @api
 */
_ol_Collection_.prototype.forEach = function (f, opt_this) {
  var fn = opt_this ? f.bind(opt_this) : f;
  var array = this.array_;
  for (var i = 0, ii = array.length; i < ii; ++i) {
    fn(array[i], i, array);
  }
};

/**
 * Get a reference to the underlying Array object. Warning: if the array
 * is mutated, no events will be dispatched by the collection, and the
 * collection's "length" property won't be in sync with the actual length
 * of the array.
 * @return {!Array.<T>} Array.
 * @api
 */
_ol_Collection_.prototype.getArray = function () {
  return this.array_;
};

/**
 * Get the element at the provided index.
 * @param {number} index Index.
 * @return {T} Element.
 * @api
 */
_ol_Collection_.prototype.item = function (index) {
  return this.array_[index];
};

/**
 * Get the length of this collection.
 * @return {number} The length of the array.
 * @observable
 * @api
 */
_ol_Collection_.prototype.getLength = function () {
  return (
    /** @type {number} */this.get(_ol_Collection_.Property_.LENGTH)
  );
};

/**
 * Insert an element at the provided index.
 * @param {number} index Index.
 * @param {T} elem Element.
 * @api
 */
_ol_Collection_.prototype.insertAt = function (index, elem) {
  if (this.unique_) {
    this.assertUnique_(elem);
  }
  this.array_.splice(index, 0, elem);
  this.updateLength_();
  this.dispatchEvent(new _ol_Collection_.Event(__WEBPACK_IMPORTED_MODULE_2__collectioneventtype_js__["a" /* default */].ADD, elem));
};

/**
 * Remove the last element of the collection and return it.
 * Return `undefined` if the collection is empty.
 * @return {T|undefined} Element.
 * @api
 */
_ol_Collection_.prototype.pop = function () {
  return this.removeAt(this.getLength() - 1);
};

/**
 * Insert the provided element at the end of the collection.
 * @param {T} elem Element.
 * @return {number} New length of the collection.
 * @api
 */
_ol_Collection_.prototype.push = function (elem) {
  if (this.unique_) {
    this.assertUnique_(elem);
  }
  var n = this.getLength();
  this.insertAt(n, elem);
  return this.getLength();
};

/**
 * Remove the first occurrence of an element from the collection.
 * @param {T} elem Element.
 * @return {T|undefined} The removed element or undefined if none found.
 * @api
 */
_ol_Collection_.prototype.remove = function (elem) {
  var arr = this.array_;
  var i, ii;
  for (i = 0, ii = arr.length; i < ii; ++i) {
    if (arr[i] === elem) {
      return this.removeAt(i);
    }
  }
  return undefined;
};

/**
 * Remove the element at the provided index and return it.
 * Return `undefined` if the collection does not contain this index.
 * @param {number} index Index.
 * @return {T|undefined} Value.
 * @api
 */
_ol_Collection_.prototype.removeAt = function (index) {
  var prev = this.array_[index];
  this.array_.splice(index, 1);
  this.updateLength_();
  this.dispatchEvent(new _ol_Collection_.Event(__WEBPACK_IMPORTED_MODULE_2__collectioneventtype_js__["a" /* default */].REMOVE, prev));
  return prev;
};

/**
 * Set the element at the provided index.
 * @param {number} index Index.
 * @param {T} elem Element.
 * @api
 */
_ol_Collection_.prototype.setAt = function (index, elem) {
  var n = this.getLength();
  if (index < n) {
    if (this.unique_) {
      this.assertUnique_(elem, index);
    }
    var prev = this.array_[index];
    this.array_[index] = elem;
    this.dispatchEvent(new _ol_Collection_.Event(__WEBPACK_IMPORTED_MODULE_2__collectioneventtype_js__["a" /* default */].REMOVE, prev));
    this.dispatchEvent(new _ol_Collection_.Event(__WEBPACK_IMPORTED_MODULE_2__collectioneventtype_js__["a" /* default */].ADD, elem));
  } else {
    var j;
    for (j = n; j < index; ++j) {
      this.insertAt(j, undefined);
    }
    this.insertAt(index, elem);
  }
};

/**
 * @private
 */
_ol_Collection_.prototype.updateLength_ = function () {
  this.set(_ol_Collection_.Property_.LENGTH, this.array_.length);
};

/**
 * @private
 * @param {T} elem Element.
 * @param {number=} opt_except Optional index to ignore.
 */
_ol_Collection_.prototype.assertUnique_ = function (elem, opt_except) {
  for (var i = 0, ii = this.array_.length; i < ii; ++i) {
    if (this.array_[i] === elem && i !== opt_except) {
      throw new __WEBPACK_IMPORTED_MODULE_1__assertionerror_js__["a" /* default */](58);
    }
  }
};

/**
 * @enum {string}
 * @private
 */
_ol_Collection_.Property_ = {
  LENGTH: 'length'
};

/**
 * @classdesc
 * Events emitted by {@link ol.Collection} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.Collection.Event}
 * @param {ol.CollectionEventType} type Type.
 * @param {*=} opt_element Element.
 */
_ol_Collection_.Event = function (type, opt_element) {

  __WEBPACK_IMPORTED_MODULE_4__events_event_js__["a" /* default */].call(this, type);

  /**
   * The element that is added to or removed from the collection.
   * @type {*}
   * @api
   */
  this.element = opt_element;
};
__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].inherits(_ol_Collection_.Event, __WEBPACK_IMPORTED_MODULE_4__events_event_js__["a" /* default */]);
/* harmony default export */ __webpack_exports__["a"] = (_ol_Collection_);

/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @enum {string}
 */
var _ol_CollectionEventType_ = {
  /**
   * Triggered when an item is added to the collection.
   * @event ol.Collection.Event#add
   * @api
   */
  ADD: 'add',
  /**
   * Triggered when an item is removed from the collection.
   * @event ol.Collection.Event#remove
   * @api
   */
  REMOVE: 'remove'
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_CollectionEventType_);

/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__events_eventtype_js__ = __webpack_require__(4);


/**
 * Constants for event names.
 * @enum {string}
 */
var _ol_MapBrowserEventType_ = {

  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event ol.MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: 'singleclick',

  /**
   * A click with no dragging. A double click will fire two of this.
   * @event ol.MapBrowserEvent#click
   * @api
   */
  CLICK: __WEBPACK_IMPORTED_MODULE_0__events_eventtype_js__["a" /* default */].CLICK,

  /**
   * A true double click, with no dragging.
   * @event ol.MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: __WEBPACK_IMPORTED_MODULE_0__events_eventtype_js__["a" /* default */].DBLCLICK,

  /**
   * Triggered when a pointer is dragged.
   * @event ol.MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: 'pointerdrag',

  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event ol.MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: 'pointermove',

  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_MapBrowserEventType_);

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _ol_size_ = {};

/**
 * Returns a buffered size.
 * @param {ol.Size} size Size.
 * @param {number} buffer Buffer.
 * @param {ol.Size=} opt_size Optional reusable size array.
 * @return {ol.Size} The buffered size.
 */
_ol_size_.buffer = function (size, buffer, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] + 2 * buffer;
  opt_size[1] = size[1] + 2 * buffer;
  return opt_size;
};

/**
 * Determines if a size has a positive area.
 * @param {ol.Size} size The size to test.
 * @return {boolean} The size has a positive area.
 */
_ol_size_.hasArea = function (size) {
  return size[0] > 0 && size[1] > 0;
};

/**
 * Returns a size scaled by a ratio. The result will be an array of integers.
 * @param {ol.Size} size Size.
 * @param {number} ratio Ratio.
 * @param {ol.Size=} opt_size Optional reusable size array.
 * @return {ol.Size} The scaled size.
 */
_ol_size_.scale = function (size, ratio, opt_size) {
  if (opt_size === undefined) {
    opt_size = [0, 0];
  }
  opt_size[0] = size[0] * ratio + 0.5 | 0;
  opt_size[1] = size[1] * ratio + 0.5 | 0;
  return opt_size;
};

/**
 * Returns an `ol.Size` array for the passed in number (meaning: square) or
 * `ol.Size` array.
 * (meaning: non-square),
 * @param {number|ol.Size} size Width and height.
 * @param {ol.Size=} opt_size Optional reusable size array.
 * @return {ol.Size} Size.
 * @api
 */
_ol_size_.toSize = function (size, opt_size) {
  if (Array.isArray(size)) {
    return size;
  } else {
    if (opt_size === undefined) {
      opt_size = [size, size];
    } else {
      opt_size[0] = opt_size[1] = /** @type {number} */size;
    }
    return opt_size;
  }
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_size_);

/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @enum {string}
 */
var _ol_ObjectEventType_ = {
  /**
   * Triggered when a property is changed.
   * @event ol.Object.Event#propertychange
   * @api
   */
  PROPERTYCHANGE: 'propertychange'
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_ObjectEventType_);

/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);


/**
 * Objects that need to clean up after themselves.
 * @constructor
 */
var _ol_Disposable_ = function _ol_Disposable_() {};

/**
 * The object has already been disposed.
 * @type {boolean}
 * @private
 */
_ol_Disposable_.prototype.disposed_ = false;

/**
 * Clean up.
 */
_ol_Disposable_.prototype.dispose = function () {
  if (!this.disposed_) {
    this.disposed_ = true;
    this.disposeInternal();
  }
};

/**
 * Extension point for disposable objects.
 * @protected
 */
_ol_Disposable_.prototype.disposeInternal = __WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].nullFunction;
/* harmony default export */ __webpack_exports__["a"] = (_ol_Disposable_);

/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__object_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extent_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__functions_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_flat_transform_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__proj_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__proj_units_js__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__transform_js__ = __webpack_require__(11);









/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for vector geometries.
 *
 * To get notified of changes to the geometry, register a listener for the
 * generic `change` event on your geometry instance.
 *
 * @constructor
 * @abstract
 * @extends {ol.Object}
 * @api
 */
var _ol_geom_Geometry_ = function _ol_geom_Geometry_() {

  __WEBPACK_IMPORTED_MODULE_1__object_js__["a" /* default */].call(this);

  /**
   * @private
   * @type {ol.Extent}
   */
  this.extent_ = __WEBPACK_IMPORTED_MODULE_2__extent_js__["a" /* default */].createEmpty();

  /**
   * @private
   * @type {number}
   */
  this.extentRevision_ = -1;

  /**
   * @protected
   * @type {Object.<string, ol.geom.Geometry>}
   */
  this.simplifiedGeometryCache = {};

  /**
   * @protected
   * @type {number}
   */
  this.simplifiedGeometryMaxMinSquaredTolerance = 0;

  /**
   * @protected
   * @type {number}
   */
  this.simplifiedGeometryRevision = 0;

  /**
   * @private
   * @type {ol.Transform}
   */
  this.tmpTransform_ = __WEBPACK_IMPORTED_MODULE_7__transform_js__["a" /* default */].create();
};

__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].inherits(_ol_geom_Geometry_, __WEBPACK_IMPORTED_MODULE_1__object_js__["a" /* default */]);

/**
 * Make a complete copy of the geometry.
 * @abstract
 * @return {!ol.geom.Geometry} Clone.
 */
_ol_geom_Geometry_.prototype.clone = function () {};

/**
 * @abstract
 * @param {number} x X.
 * @param {number} y Y.
 * @param {ol.Coordinate} closestPoint Closest point.
 * @param {number} minSquaredDistance Minimum squared distance.
 * @return {number} Minimum squared distance.
 */
_ol_geom_Geometry_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {};

/**
 * Return the closest point of the geometry to the passed point as
 * {@link ol.Coordinate coordinate}.
 * @param {ol.Coordinate} point Point.
 * @param {ol.Coordinate=} opt_closestPoint Closest point.
 * @return {ol.Coordinate} Closest point.
 * @api
 */
_ol_geom_Geometry_.prototype.getClosestPoint = function (point, opt_closestPoint) {
  var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
  this.closestPointXY(point[0], point[1], closestPoint, Infinity);
  return closestPoint;
};

/**
 * Returns true if this geometry includes the specified coordinate. If the
 * coordinate is on the boundary of the geometry, returns false.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @return {boolean} Contains coordinate.
 * @api
 */
_ol_geom_Geometry_.prototype.intersectsCoordinate = function (coordinate) {
  return this.containsXY(coordinate[0], coordinate[1]);
};

/**
 * @abstract
 * @param {ol.Extent} extent Extent.
 * @protected
 * @return {ol.Extent} extent Extent.
 */
_ol_geom_Geometry_.prototype.computeExtent = function (extent) {};

/**
 * @param {number} x X.
 * @param {number} y Y.
 * @return {boolean} Contains (x, y).
 */
_ol_geom_Geometry_.prototype.containsXY = __WEBPACK_IMPORTED_MODULE_3__functions_js__["a" /* default */].FALSE;

/**
 * Get the extent of the geometry.
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} extent Extent.
 * @api
 */
_ol_geom_Geometry_.prototype.getExtent = function (opt_extent) {
  if (this.extentRevision_ != this.getRevision()) {
    this.extent_ = this.computeExtent(this.extent_);
    this.extentRevision_ = this.getRevision();
  }
  return __WEBPACK_IMPORTED_MODULE_2__extent_js__["a" /* default */].returnOrUpdate(this.extent_, opt_extent);
};

/**
 * Rotate the geometry around a given coordinate. This modifies the geometry
 * coordinates in place.
 * @abstract
 * @param {number} angle Rotation angle in radians.
 * @param {ol.Coordinate} anchor The rotation center.
 * @api
 */
_ol_geom_Geometry_.prototype.rotate = function (angle, anchor) {};

/**
 * Scale the geometry (with an optional origin).  This modifies the geometry
 * coordinates in place.
 * @abstract
 * @param {number} sx The scaling factor in the x-direction.
 * @param {number=} opt_sy The scaling factor in the y-direction (defaults to
 *     sx).
 * @param {ol.Coordinate=} opt_anchor The scale origin (defaults to the center
 *     of the geometry extent).
 * @api
 */
_ol_geom_Geometry_.prototype.scale = function (sx, opt_sy, opt_anchor) {};

/**
 * Create a simplified version of this geometry.  For linestrings, this uses
 * the the {@link
 * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
 * Douglas Peucker} algorithm.  For polygons, a quantization-based
 * simplification is used to preserve topology.
 * @function
 * @param {number} tolerance The tolerance distance for simplification.
 * @return {ol.geom.Geometry} A new, simplified version of the original
 *     geometry.
 * @api
 */
_ol_geom_Geometry_.prototype.simplify = function (tolerance) {
  return this.getSimplifiedGeometry(tolerance * tolerance);
};

/**
 * Create a simplified version of this geometry using the Douglas Peucker
 * algorithm.
 * @see https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm
 * @abstract
 * @param {number} squaredTolerance Squared tolerance.
 * @return {ol.geom.Geometry} Simplified geometry.
 */
_ol_geom_Geometry_.prototype.getSimplifiedGeometry = function (squaredTolerance) {};

/**
 * Get the type of this geometry.
 * @abstract
 * @return {ol.geom.GeometryType} Geometry type.
 */
_ol_geom_Geometry_.prototype.getType = function () {};

/**
 * Apply a transform function to each coordinate of the geometry.
 * The geometry is modified in place.
 * If you do not want the geometry modified in place, first `clone()` it and
 * then use this function on the clone.
 * @abstract
 * @param {ol.TransformFunction} transformFn Transform.
 */
_ol_geom_Geometry_.prototype.applyTransform = function (transformFn) {};

/**
 * Test if the geometry and the passed extent intersect.
 * @abstract
 * @param {ol.Extent} extent Extent.
 * @return {boolean} `true` if the geometry and the extent intersect.
 */
_ol_geom_Geometry_.prototype.intersectsExtent = function (extent) {};

/**
 * Translate the geometry.  This modifies the geometry coordinates in place.  If
 * instead you want a new geometry, first `clone()` this geometry.
 * @abstract
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 */
_ol_geom_Geometry_.prototype.translate = function (deltaX, deltaY) {};

/**
 * Transform each coordinate of the geometry from one coordinate reference
 * system to another. The geometry is modified in place.
 * For example, a line will be transformed to a line and a circle to a circle.
 * If you do not want the geometry modified in place, first `clone()` it and
 * then use this function on the clone.
 *
 * @param {ol.ProjectionLike} source The current projection.  Can be a
 *     string identifier or a {@link ol.proj.Projection} object.
 * @param {ol.ProjectionLike} destination The desired projection.  Can be a
 *     string identifier or a {@link ol.proj.Projection} object.
 * @return {ol.geom.Geometry} This geometry.  Note that original geometry is
 *     modified in place.
 * @api
 */
_ol_geom_Geometry_.prototype.transform = function (source, destination) {
  var tmpTransform = this.tmpTransform_;
  source = __WEBPACK_IMPORTED_MODULE_5__proj_js__["default"].get(source);
  var transformFn = source.getUnits() == __WEBPACK_IMPORTED_MODULE_6__proj_units_js__["a" /* default */].TILE_PIXELS ? function (inCoordinates, outCoordinates, stride) {
    var pixelExtent = source.getExtent();
    var projectedExtent = source.getWorldExtent();
    var scale = __WEBPACK_IMPORTED_MODULE_2__extent_js__["a" /* default */].getHeight(projectedExtent) / __WEBPACK_IMPORTED_MODULE_2__extent_js__["a" /* default */].getHeight(pixelExtent);
    __WEBPACK_IMPORTED_MODULE_7__transform_js__["a" /* default */].compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
    __WEBPACK_IMPORTED_MODULE_4__geom_flat_transform_js__["a" /* default */].transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
    return __WEBPACK_IMPORTED_MODULE_5__proj_js__["default"].getTransform(source, destination)(inCoordinates, outCoordinates, stride);
  } : __WEBPACK_IMPORTED_MODULE_5__proj_js__["default"].getTransform(source, destination);
  this.applyTransform(transformFn);
  return this;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_geom_Geometry_);

/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);


/**
 * @classdesc
 * Set stroke style for vector features.
 * Note that the defaults given are the Canvas defaults, which will be used if
 * option is not defined. The `get` functions return whatever was entered in
 * the options; they will not return the default.
 *
 * @constructor
 * @param {olx.style.StrokeOptions=} opt_options Options.
 * @api
 */
var _ol_style_Stroke_ = function _ol_style_Stroke_(opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {ol.Color|ol.ColorLike}
   */
  this.color_ = options.color !== undefined ? options.color : null;

  /**
   * @private
   * @type {string|undefined}
   */
  this.lineCap_ = options.lineCap;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.lineDashOffset_ = options.lineDashOffset;

  /**
   * @private
   * @type {string|undefined}
   */
  this.lineJoin_ = options.lineJoin;

  /**
   * @private
   * @type {number|undefined}
   */
  this.miterLimit_ = options.miterLimit;

  /**
   * @private
   * @type {number|undefined}
   */
  this.width_ = options.width;

  /**
   * @private
   * @type {string|undefined}
   */
  this.checksum_ = undefined;
};

/**
 * Clones the style.
 * @return {ol.style.Stroke} The cloned style.
 * @api
 */
_ol_style_Stroke_.prototype.clone = function () {
  var color = this.getColor();
  return new _ol_style_Stroke_({
    color: color && color.slice ? color.slice() : color || undefined,
    lineCap: this.getLineCap(),
    lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
    lineDashOffset: this.getLineDashOffset(),
    lineJoin: this.getLineJoin(),
    miterLimit: this.getMiterLimit(),
    width: this.getWidth()
  });
};

/**
 * Get the stroke color.
 * @return {ol.Color|ol.ColorLike} Color.
 * @api
 */
_ol_style_Stroke_.prototype.getColor = function () {
  return this.color_;
};

/**
 * Get the line cap type for the stroke.
 * @return {string|undefined} Line cap.
 * @api
 */
_ol_style_Stroke_.prototype.getLineCap = function () {
  return this.lineCap_;
};

/**
 * Get the line dash style for the stroke.
 * @return {Array.<number>} Line dash.
 * @api
 */
_ol_style_Stroke_.prototype.getLineDash = function () {
  return this.lineDash_;
};

/**
 * Get the line dash offset for the stroke.
 * @return {number|undefined} Line dash offset.
 * @api
 */
_ol_style_Stroke_.prototype.getLineDashOffset = function () {
  return this.lineDashOffset_;
};

/**
 * Get the line join type for the stroke.
 * @return {string|undefined} Line join.
 * @api
 */
_ol_style_Stroke_.prototype.getLineJoin = function () {
  return this.lineJoin_;
};

/**
 * Get the miter limit for the stroke.
 * @return {number|undefined} Miter limit.
 * @api
 */
_ol_style_Stroke_.prototype.getMiterLimit = function () {
  return this.miterLimit_;
};

/**
 * Get the stroke width.
 * @return {number|undefined} Width.
 * @api
 */
_ol_style_Stroke_.prototype.getWidth = function () {
  return this.width_;
};

/**
 * Set the color.
 *
 * @param {ol.Color|ol.ColorLike} color Color.
 * @api
 */
_ol_style_Stroke_.prototype.setColor = function (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};

/**
 * Set the line cap.
 *
 * @param {string|undefined} lineCap Line cap.
 * @api
 */
_ol_style_Stroke_.prototype.setLineCap = function (lineCap) {
  this.lineCap_ = lineCap;
  this.checksum_ = undefined;
};

/**
 * Set the line dash.
 *
 * Please note that Internet Explorer 10 and lower [do not support][mdn] the
 * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
 * property will have no visual effect in these browsers.
 *
 * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
 *
 * @param {Array.<number>} lineDash Line dash.
 * @api
 */
_ol_style_Stroke_.prototype.setLineDash = function (lineDash) {
  this.lineDash_ = lineDash;
  this.checksum_ = undefined;
};

/**
 * Set the line dash offset.
 *
 * @param {number|undefined} lineDashOffset Line dash offset.
 * @api
 */
_ol_style_Stroke_.prototype.setLineDashOffset = function (lineDashOffset) {
  this.lineDashOffset_ = lineDashOffset;
  this.checksum_ = undefined;
};

/**
 * Set the line join.
 *
 * @param {string|undefined} lineJoin Line join.
 * @api
 */
_ol_style_Stroke_.prototype.setLineJoin = function (lineJoin) {
  this.lineJoin_ = lineJoin;
  this.checksum_ = undefined;
};

/**
 * Set the miter limit.
 *
 * @param {number|undefined} miterLimit Miter limit.
 * @api
 */
_ol_style_Stroke_.prototype.setMiterLimit = function (miterLimit) {
  this.miterLimit_ = miterLimit;
  this.checksum_ = undefined;
};

/**
 * Set the width.
 *
 * @param {number|undefined} width Width.
 * @api
 */
_ol_style_Stroke_.prototype.setWidth = function (width) {
  this.width_ = width;
  this.checksum_ = undefined;
};

/**
 * @return {string} The checksum.
 */
_ol_style_Stroke_.prototype.getChecksum = function () {
  if (this.checksum_ === undefined) {
    this.checksum_ = 's';
    if (this.color_) {
      if (typeof this.color_ === 'string') {
        this.checksum_ += this.color_;
      } else {
        this.checksum_ += __WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].getUid(this.color_).toString();
      }
    } else {
      this.checksum_ += '-';
    }
    this.checksum_ += ',' + (this.lineCap_ !== undefined ? this.lineCap_.toString() : '-') + ',' + (this.lineDash_ ? this.lineDash_.toString() : '-') + ',' + (this.lineDashOffset_ !== undefined ? this.lineDashOffset_ : '-') + ',' + (this.lineJoin_ !== undefined ? this.lineJoin_ : '-') + ',' + (this.miterLimit_ !== undefined ? this.miterLimit_.toString() : '-') + ',' + (this.width_ !== undefined ? this.width_.toString() : '-');
  }

  return this.checksum_;
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_style_Stroke_);

/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__extent_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flat_contains_js__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__flat_segments_js__ = __webpack_require__(79);



var _ol_geom_flat_intersectsextent_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
_ol_geom_flat_intersectsextent_.lineString = function (flatCoordinates, offset, end, stride, extent) {
  var coordinatesExtent = __WEBPACK_IMPORTED_MODULE_0__extent_js__["a" /* default */].extendFlatCoordinates(__WEBPACK_IMPORTED_MODULE_0__extent_js__["a" /* default */].createEmpty(), flatCoordinates, offset, end, stride);
  if (!__WEBPACK_IMPORTED_MODULE_0__extent_js__["a" /* default */].intersects(extent, coordinatesExtent)) {
    return false;
  }
  if (__WEBPACK_IMPORTED_MODULE_0__extent_js__["a" /* default */].containsExtent(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return __WEBPACK_IMPORTED_MODULE_2__flat_segments_js__["a" /* default */].forEach(flatCoordinates, offset, end, stride,
  /**
   * @param {ol.Coordinate} point1 Start point.
   * @param {ol.Coordinate} point2 End point.
   * @return {boolean} `true` if the segment and the extent intersect,
   *     `false` otherwise.
   */
  function (point1, point2) {
    return __WEBPACK_IMPORTED_MODULE_0__extent_js__["a" /* default */].intersectsSegment(extent, point1, point2);
  });
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
_ol_geom_flat_intersectsextent_.lineStrings = function (flatCoordinates, offset, ends, stride, extent) {
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    if (_ol_geom_flat_intersectsextent_.lineString(flatCoordinates, offset, ends[i], stride, extent)) {
      return true;
    }
    offset = ends[i];
  }
  return false;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
_ol_geom_flat_intersectsextent_.linearRing = function (flatCoordinates, offset, end, stride, extent) {
  if (_ol_geom_flat_intersectsextent_.lineString(flatCoordinates, offset, end, stride, extent)) {
    return true;
  }
  if (__WEBPACK_IMPORTED_MODULE_1__flat_contains_js__["a" /* default */].linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
    return true;
  }
  if (__WEBPACK_IMPORTED_MODULE_1__flat_contains_js__["a" /* default */].linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
    return true;
  }
  if (__WEBPACK_IMPORTED_MODULE_1__flat_contains_js__["a" /* default */].linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
    return true;
  }
  if (__WEBPACK_IMPORTED_MODULE_1__flat_contains_js__["a" /* default */].linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
    return true;
  }
  return false;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
_ol_geom_flat_intersectsextent_.linearRings = function (flatCoordinates, offset, ends, stride, extent) {
  if (!_ol_geom_flat_intersectsextent_.linearRing(flatCoordinates, offset, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  var i, ii;
  for (i = 1, ii = ends.length; i < ii; ++i) {
    if (__WEBPACK_IMPORTED_MODULE_1__flat_contains_js__["a" /* default */].linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
      return false;
    }
  }
  return true;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {ol.Extent} extent Extent.
 * @return {boolean} True if the geometry and the extent intersect.
 */
_ol_geom_flat_intersectsextent_.linearRingss = function (flatCoordinates, offset, endss, stride, extent) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (_ol_geom_flat_intersectsextent_.linearRings(flatCoordinates, offset, ends, stride, extent)) {
      return true;
    }
    offset = ends[ends.length - 1];
  }
  return false;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_geom_flat_intersectsextent_);

/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/ol/index.js
var ol = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ol/array.js
var array = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__(1);

// EXTERNAL MODULE: ./node_modules/ol/geom/geometrylayout.js
var geometrylayout = __webpack_require__(28);

// EXTERNAL MODULE: ./node_modules/ol/geom/geometrytype.js
var geometrytype = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/ol/geom/simplegeometry.js
var simplegeometry = __webpack_require__(22);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/area.js
var flat_area = __webpack_require__(60);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/closest.js
var closest = __webpack_require__(47);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/deflate.js
var deflate = __webpack_require__(33);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/inflate.js
var inflate = __webpack_require__(34);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/simplify.js
var simplify = __webpack_require__(41);

// CONCATENATED MODULE: ./node_modules/ol/geom/linearring.js











/**
 * @classdesc
 * Linear ring geometry. Only used as part of polygon; cannot be rendered
 * on its own.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var linearring__ol_geom_LinearRing_ = function _ol_geom_LinearRing_(coordinates, opt_layout) {

  simplegeometry["a" /* default */].call(this);

  /**
   * @private
   * @type {number}
   */
  this.maxDelta_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.maxDeltaRevision_ = -1;

  this.setCoordinates(coordinates, opt_layout);
};

ol["a" /* default */].inherits(linearring__ol_geom_LinearRing_, simplegeometry["a" /* default */]);

/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.LinearRing} Clone.
 * @override
 * @api
 */
linearring__ol_geom_LinearRing_.prototype.clone = function () {
  var linearRing = new linearring__ol_geom_LinearRing_(null);
  linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return linearRing;
};

/**
 * @inheritDoc
 */
linearring__ol_geom_LinearRing_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < ol_extent["a" /* default */].closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(closest["a" /* default */].getMaxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }
  return closest["a" /* default */].getClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
};

/**
 * Return the area of the linear ring on projected plane.
 * @return {number} Area (on projected plane).
 * @api
 */
linearring__ol_geom_LinearRing_.prototype.getArea = function () {
  return flat_area["a" /* default */].linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};

/**
 * Return the coordinates of the linear ring.
 * @return {Array.<ol.Coordinate>} Coordinates.
 * @override
 * @api
 */
linearring__ol_geom_LinearRing_.prototype.getCoordinates = function () {
  return inflate["a" /* default */].coordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};

/**
 * @inheritDoc
 */
linearring__ol_geom_LinearRing_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  simplifiedFlatCoordinates.length = simplify["a" /* default */].douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  var simplifiedLinearRing = new linearring__ol_geom_LinearRing_(null);
  simplifiedLinearRing.setFlatCoordinates(geometrylayout["a" /* default */].XY, simplifiedFlatCoordinates);
  return simplifiedLinearRing;
};

/**
 * @inheritDoc
 * @api
 */
linearring__ol_geom_LinearRing_.prototype.getType = function () {
  return geometrytype["a" /* default */].LINEAR_RING;
};

/**
 * @inheritDoc
 */
linearring__ol_geom_LinearRing_.prototype.intersectsExtent = function (extent) {};

/**
 * Set the coordinates of the linear ring.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */
linearring__ol_geom_LinearRing_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(geometrylayout["a" /* default */].XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflate["a" /* default */].coordinates(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */
linearring__ol_geom_LinearRing_.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};
/* harmony default export */ var linearring = (linearring__ol_geom_LinearRing_);
// EXTERNAL MODULE: ./node_modules/ol/geom/point.js
var point = __webpack_require__(67);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/contains.js
var contains = __webpack_require__(48);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/interiorpoint.js
var interiorpoint = __webpack_require__(81);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/intersectsextent.js
var intersectsextent = __webpack_require__(58);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/orient.js + 1 modules
var orient = __webpack_require__(61);

// EXTERNAL MODULE: ./node_modules/ol/math.js
var math = __webpack_require__(6);

// CONCATENATED MODULE: ./node_modules/ol/geom/polygon.js



















/**
 * @classdesc
 * Polygon geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Array of linear
 *     rings that define the polygon. The first linear ring of the array
 *     defines the outer-boundary or surface of the polygon. Each subsequent
 *     linear ring defines a hole in the surface of the polygon. A linear ring
 *     is an array of vertices' coordinates where the first coordinate and the
 *     last are equivalent.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var polygon__ol_geom_Polygon_ = function _ol_geom_Polygon_(coordinates, opt_layout) {

  simplegeometry["a" /* default */].call(this);

  /**
   * @type {Array.<number>}
   * @private
   */
  this.ends_ = [];

  /**
   * @private
   * @type {number}
   */
  this.flatInteriorPointRevision_ = -1;

  /**
   * @private
   * @type {ol.Coordinate}
   */
  this.flatInteriorPoint_ = null;

  /**
   * @private
   * @type {number}
   */
  this.maxDelta_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.maxDeltaRevision_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.orientedRevision_ = -1;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.orientedFlatCoordinates_ = null;

  this.setCoordinates(coordinates, opt_layout);
};

ol["a" /* default */].inherits(polygon__ol_geom_Polygon_, simplegeometry["a" /* default */]);

/**
 * Append the passed linear ring to this polygon.
 * @param {ol.geom.LinearRing} linearRing Linear ring.
 * @api
 */
polygon__ol_geom_Polygon_.prototype.appendLinearRing = function (linearRing) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = linearRing.getFlatCoordinates().slice();
  } else {
    array["a" /* default */].extend(this.flatCoordinates, linearRing.getFlatCoordinates());
  }
  this.ends_.push(this.flatCoordinates.length);
  this.changed();
};

/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.Polygon} Clone.
 * @override
 * @api
 */
polygon__ol_geom_Polygon_.prototype.clone = function () {
  var polygon = new polygon__ol_geom_Polygon_(null);
  polygon.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), this.ends_.slice());
  return polygon;
};

/**
 * @inheritDoc
 */
polygon__ol_geom_Polygon_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < ol_extent["a" /* default */].closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(closest["a" /* default */].getsMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }
  return closest["a" /* default */].getsClosestPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
};

/**
 * @inheritDoc
 */
polygon__ol_geom_Polygon_.prototype.containsXY = function (x, y) {
  return contains["a" /* default */].linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
};

/**
 * Return the area of the polygon on projected plane.
 * @return {number} Area (on projected plane).
 * @api
 */
polygon__ol_geom_Polygon_.prototype.getArea = function () {
  return flat_area["a" /* default */].linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
};

/**
 * Get the coordinate array for this geometry.  This array has the structure
 * of a GeoJSON coordinate array for polygons.
 *
 * @param {boolean=} opt_right Orient coordinates according to the right-hand
 *     rule (counter-clockwise for exterior and clockwise for interior rings).
 *     If `false`, coordinates will be oriented according to the left-hand rule
 *     (clockwise for exterior and counter-clockwise for interior rings).
 *     By default, coordinate orientation will depend on how the geometry was
 *     constructed.
 * @return {Array.<Array.<ol.Coordinate>>} Coordinates.
 * @override
 * @api
 */
polygon__ol_geom_Polygon_.prototype.getCoordinates = function (opt_right) {
  var flatCoordinates;
  if (opt_right !== undefined) {
    flatCoordinates = this.getOrientedFlatCoordinates().slice();
    orient["a" /* default */].orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);
  } else {
    flatCoordinates = this.flatCoordinates;
  }

  return inflate["a" /* default */].coordinatess(flatCoordinates, 0, this.ends_, this.stride);
};

/**
 * @return {Array.<number>} Ends.
 */
polygon__ol_geom_Polygon_.prototype.getEnds = function () {
  return this.ends_;
};

/**
 * @return {Array.<number>} Interior point.
 */
polygon__ol_geom_Polygon_.prototype.getFlatInteriorPoint = function () {
  if (this.flatInteriorPointRevision_ != this.getRevision()) {
    var flatCenter = ol_extent["a" /* default */].getCenter(this.getExtent());
    this.flatInteriorPoint_ = interiorpoint["a" /* default */].linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
    this.flatInteriorPointRevision_ = this.getRevision();
  }
  return this.flatInteriorPoint_;
};

/**
 * Return an interior point of the polygon.
 * @return {ol.geom.Point} Interior point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 * @api
 */
polygon__ol_geom_Polygon_.prototype.getInteriorPoint = function () {
  return new point["a" /* default */](this.getFlatInteriorPoint(), geometrylayout["a" /* default */].XYM);
};

/**
 * Return the number of rings of the polygon,  this includes the exterior
 * ring and any interior rings.
 *
 * @return {number} Number of rings.
 * @api
 */
polygon__ol_geom_Polygon_.prototype.getLinearRingCount = function () {
  return this.ends_.length;
};

/**
 * Return the Nth linear ring of the polygon geometry. Return `null` if the
 * given index is out of range.
 * The exterior linear ring is available at index `0` and the interior rings
 * at index `1` and beyond.
 *
 * @param {number} index Index.
 * @return {ol.geom.LinearRing} Linear ring.
 * @api
 */
polygon__ol_geom_Polygon_.prototype.getLinearRing = function (index) {
  if (index < 0 || this.ends_.length <= index) {
    return null;
  }
  var linearRing = new linearring(null);
  linearRing.setFlatCoordinates(this.layout, this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));
  return linearRing;
};

/**
 * Return the linear rings of the polygon.
 * @return {Array.<ol.geom.LinearRing>} Linear rings.
 * @api
 */
polygon__ol_geom_Polygon_.prototype.getLinearRings = function () {
  var layout = this.layout;
  var flatCoordinates = this.flatCoordinates;
  var ends = this.ends_;
  var linearRings = [];
  var offset = 0;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var linearRing = new linearring(null);
    linearRing.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));
    linearRings.push(linearRing);
    offset = end;
  }
  return linearRings;
};

/**
 * @return {Array.<number>} Oriented flat coordinates.
 */
polygon__ol_geom_Polygon_.prototype.getOrientedFlatCoordinates = function () {
  if (this.orientedRevision_ != this.getRevision()) {
    var flatCoordinates = this.flatCoordinates;
    if (orient["a" /* default */].linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
      this.orientedFlatCoordinates_ = flatCoordinates;
    } else {
      this.orientedFlatCoordinates_ = flatCoordinates.slice();
      this.orientedFlatCoordinates_.length = orient["a" /* default */].orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
    }
    this.orientedRevision_ = this.getRevision();
  }
  return this.orientedFlatCoordinates_;
};

/**
 * @inheritDoc
 */
polygon__ol_geom_Polygon_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  var simplifiedEnds = [];
  simplifiedFlatCoordinates.length = simplify["a" /* default */].quantizes(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
  var simplifiedPolygon = new polygon__ol_geom_Polygon_(null);
  simplifiedPolygon.setFlatCoordinates(geometrylayout["a" /* default */].XY, simplifiedFlatCoordinates, simplifiedEnds);
  return simplifiedPolygon;
};

/**
 * @inheritDoc
 * @api
 */
polygon__ol_geom_Polygon_.prototype.getType = function () {
  return geometrytype["a" /* default */].POLYGON;
};

/**
 * @inheritDoc
 * @api
 */
polygon__ol_geom_Polygon_.prototype.intersectsExtent = function (extent) {
  return intersectsextent["a" /* default */].linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
};

/**
 * Set the coordinates of the polygon.
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */
polygon__ol_geom_Polygon_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(geometrylayout["a" /* default */].XY, null, this.ends_);
  } else {
    this.setLayout(opt_layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var ends = deflate["a" /* default */].coordinatess(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<number>} ends Ends.
 */
polygon__ol_geom_Polygon_.prototype.setFlatCoordinates = function (layout, flatCoordinates, ends) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.ends_ = ends;
  this.changed();
};

/**
 * Create an approximation of a circle on the surface of a sphere.
 * @param {ol.Sphere} sphere The sphere.
 * @param {ol.Coordinate} center Center (`[lon, lat]` in degrees).
 * @param {number} radius The great-circle distance from the center to
 *     the polygon vertices.
 * @param {number=} opt_n Optional number of vertices for the resulting
 *     polygon. Default is `32`.
 * @return {ol.geom.Polygon} The "circular" polygon.
 * @api
 */
polygon__ol_geom_Polygon_.circular = function (sphere, center, radius, opt_n) {
  var n = opt_n ? opt_n : 32;
  /** @type {Array.<number>} */
  var flatCoordinates = [];
  var i;
  for (i = 0; i < n; ++i) {
    array["a" /* default */].extend(flatCoordinates, sphere.offset(center, radius, 2 * Math.PI * i / n));
  }
  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  var polygon = new polygon__ol_geom_Polygon_(null);
  polygon.setFlatCoordinates(geometrylayout["a" /* default */].XY, flatCoordinates, [flatCoordinates.length]);
  return polygon;
};

/**
 * Create a polygon from an extent. The layout used is `XY`.
 * @param {ol.Extent} extent The extent.
 * @return {ol.geom.Polygon} The polygon.
 * @api
 */
polygon__ol_geom_Polygon_.fromExtent = function (extent) {
  var minX = extent[0];
  var minY = extent[1];
  var maxX = extent[2];
  var maxY = extent[3];
  var flatCoordinates = [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];
  var polygon = new polygon__ol_geom_Polygon_(null);
  polygon.setFlatCoordinates(geometrylayout["a" /* default */].XY, flatCoordinates, [flatCoordinates.length]);
  return polygon;
};

/**
 * Create a regular polygon from a circle.
 * @param {ol.geom.Circle} circle Circle geometry.
 * @param {number=} opt_sides Number of sides of the polygon. Default is 32.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 * @return {ol.geom.Polygon} Polygon geometry.
 * @api
 */
polygon__ol_geom_Polygon_.fromCircle = function (circle, opt_sides, opt_angle) {
  var sides = opt_sides ? opt_sides : 32;
  var stride = circle.getStride();
  var layout = circle.getLayout();
  var polygon = new polygon__ol_geom_Polygon_(null, layout);
  var arrayLength = stride * (sides + 1);
  var flatCoordinates = new Array(arrayLength);
  for (var i = 0; i < arrayLength; i++) {
    flatCoordinates[i] = 0;
  }
  var ends = [flatCoordinates.length];
  polygon.setFlatCoordinates(layout, flatCoordinates, ends);
  polygon__ol_geom_Polygon_.makeRegular(polygon, circle.getCenter(), circle.getRadius(), opt_angle);
  return polygon;
};

/**
 * Modify the coordinates of a polygon to make it a regular polygon.
 * @param {ol.geom.Polygon} polygon Polygon geometry.
 * @param {ol.Coordinate} center Center of the regular polygon.
 * @param {number} radius Radius of the regular polygon.
 * @param {number=} opt_angle Start angle for the first vertex of the polygon in
 *     radians. Default is 0.
 */
polygon__ol_geom_Polygon_.makeRegular = function (polygon, center, radius, opt_angle) {
  var flatCoordinates = polygon.getFlatCoordinates();
  var layout = polygon.getLayout();
  var stride = polygon.getStride();
  var ends = polygon.getEnds();
  var sides = flatCoordinates.length / stride - 1;
  var startAngle = opt_angle ? opt_angle : 0;
  var angle, offset;
  for (var i = 0; i <= sides; ++i) {
    offset = i * stride;
    angle = startAngle + math["a" /* default */].modulo(i, sides) * 2 * Math.PI / sides;
    flatCoordinates[offset] = center[0] + radius * Math.cos(angle);
    flatCoordinates[offset + 1] = center[1] + radius * Math.sin(angle);
  }
  polygon.setFlatCoordinates(layout, flatCoordinates, ends);
};
/* harmony default export */ var geom_polygon = __webpack_exports__["a"] = (polygon__ol_geom_Polygon_);

/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _ol_geom_flat_area_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
_ol_geom_flat_area_.linearRing = function (flatCoordinates, offset, end, stride) {
  var twiceArea = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
_ol_geom_flat_area_.linearRings = function (flatCoordinates, offset, ends, stride) {
  var area = 0;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    area += _ol_geom_flat_area_.linearRing(flatCoordinates, offset, end, stride);
    offset = end;
  }
  return area;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {number} Area.
 */
_ol_geom_flat_area_.linearRingss = function (flatCoordinates, offset, endss, stride) {
  var area = 0;
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    area += _ol_geom_flat_area_.linearRings(flatCoordinates, offset, ends, stride);
    offset = ends[ends.length - 1];
  }
  return area;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_geom_flat_area_);

/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/ol/geom/flat/reverse.js
var _ol_geom_flat_reverse_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
_ol_geom_flat_reverse_.coordinates = function (flatCoordinates, offset, end, stride) {
  while (offset < end - stride) {
    var i;
    for (i = 0; i < stride; ++i) {
      var tmp = flatCoordinates[offset + i];
      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset += stride;
    end -= stride;
  }
};
/* harmony default export */ var flat_reverse = (_ol_geom_flat_reverse_);
// CONCATENATED MODULE: ./node_modules/ol/geom/flat/orient.js

var _ol_geom_flat_orient_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} Is clockwise.
 */
_ol_geom_flat_orient_.linearRingIsClockwise = function (flatCoordinates, offset, end, stride) {
  // http://tinyurl.com/clockwise-method
  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp
  var edge = 0;
  var x1 = flatCoordinates[end - stride];
  var y1 = flatCoordinates[end - stride + 1];
  for (; offset < end; offset += stride) {
    var x2 = flatCoordinates[offset];
    var y2 = flatCoordinates[offset + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge > 0;
};

/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
_ol_geom_flat_orient_.linearRingsAreOriented = function (flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = _ol_geom_flat_orient_.linearRingIsClockwise(flatCoordinates, offset, end, stride);
    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset = end;
  }
  return true;
};

/**
 * Determines if linear rings are oriented.  By default, left-hand orientation
 * is tested (first ring must be clockwise, remaining rings counter-clockwise).
 * To test for right-hand orientation, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Test for right-hand orientation
 *     (counter-clockwise exterior ring and clockwise interior rings).
 * @return {boolean} Rings are correctly oriented.
 */
_ol_geom_flat_orient_.linearRingssAreOriented = function (flatCoordinates, offset, endss, stride, opt_right) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    if (!_ol_geom_flat_orient_.linearRingsAreOriented(flatCoordinates, offset, endss[i], stride, opt_right)) {
      return false;
    }
  }
  return true;
};

/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */
_ol_geom_flat_orient_.orientLinearRings = function (flatCoordinates, offset, ends, stride, opt_right) {
  var right = opt_right !== undefined ? opt_right : false;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var isClockwise = _ol_geom_flat_orient_.linearRingIsClockwise(flatCoordinates, offset, end, stride);
    var reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse) {
      flat_reverse.coordinates(flatCoordinates, offset, end, stride);
    }
    offset = end;
  }
  return offset;
};

/**
 * Orient coordinates in a flat array of linear rings.  By default, rings
 * are oriented following the left-hand rule (clockwise for exterior and
 * counter-clockwise for interior rings).  To orient according to the
 * right-hand rule, use the `opt_right` argument.
 *
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Array of array of end indexes.
 * @param {number} stride Stride.
 * @param {boolean=} opt_right Follow the right-hand rule for orientation.
 * @return {number} End.
 */
_ol_geom_flat_orient_.orientLinearRingss = function (flatCoordinates, offset, endss, stride, opt_right) {
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    offset = _ol_geom_flat_orient_.orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);
  }
  return offset;
};
/* harmony default export */ var orient = __webpack_exports__["a"] = (_ol_geom_flat_orient_);

/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/ol/math.js
var math = __webpack_require__(6);

// CONCATENATED MODULE: ./node_modules/ol/string.js
var _ol_string_ = {};

/**
 * @param {number} number Number to be formatted
 * @param {number} width The desired width
 * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)
 * @returns {string} Formatted string
*/
_ol_string_.padNumber = function (number, width, opt_precision) {
  var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;
  var decimal = numberString.indexOf('.');
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join('0') + numberString;
};

/**
 * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
 * @param {string|number} v1 First version
 * @param {string|number} v2 Second version
 * @returns {number} Value
 */
_ol_string_.compareVersions = function (v1, v2) {
  var s1 = ('' + v1).split('.');
  var s2 = ('' + v2).split('.');

  for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
    var n1 = parseInt(s1[i] || '0', 10);
    var n2 = parseInt(s2[i] || '0', 10);

    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }

  return 0;
};
/* harmony default export */ var string = (_ol_string_);
// CONCATENATED MODULE: ./node_modules/ol/coordinate.js


var _ol_coordinate_ = {};

/**
 * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     var coord = [7.85, 47.983333];
 *     ol.coordinate.add(coord, [-2, 4]);
 *     // coord is now [5.85, 51.983333]
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Coordinate} delta Delta.
 * @return {ol.Coordinate} The input coordinate adjusted by the given delta.
 * @api
 */
_ol_coordinate_.add = function (coordinate, delta) {
  coordinate[0] += delta[0];
  coordinate[1] += delta[1];
  return coordinate;
};

/**
 * Calculates the point closest to the passed coordinate on the passed circle.
 *
 * @param {ol.Coordinate} coordinate The coordinate.
 * @param {ol.geom.Circle} circle The circle.
 * @return {ol.Coordinate} Closest point on the circumference
 */
_ol_coordinate_.closestOnCircle = function (coordinate, circle) {
  var r = circle.getRadius();
  var center = circle.getCenter();
  var x0 = center[0];
  var y0 = center[1];
  var x1 = coordinate[0];
  var y1 = coordinate[1];

  var dx = x1 - x0;
  var dy = y1 - y0;
  if (dx === 0 && dy === 0) {
    dx = 1;
  }
  var d = Math.sqrt(dx * dx + dy * dy);

  var x, y;

  x = x0 + r * dx / d;
  y = y0 + r * dy / d;

  return [x, y];
};

/**
 * Calculates the point closest to the passed coordinate on the passed segment.
 * This is the foot of the perpendicular of the coordinate to the segment when
 * the foot is on the segment, or the closest segment coordinate when the foot
 * is outside the segment.
 *
 * @param {ol.Coordinate} coordinate The coordinate.
 * @param {Array.<ol.Coordinate>} segment The two coordinates of the segment.
 * @return {ol.Coordinate} The foot of the perpendicular of the coordinate to
 *     the segment.
 */
_ol_coordinate_.closestOnSegment = function (coordinate, segment) {
  var x0 = coordinate[0];
  var y0 = coordinate[1];
  var start = segment[0];
  var end = segment[1];
  var x1 = start[0];
  var y1 = start[1];
  var x2 = end[0];
  var y2 = end[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  var x, y;
  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }
  return [x, y];
};

/**
 * Returns a {@link ol.CoordinateFormatType} function that can be used to format
 * a {ol.Coordinate} to a string.
 *
 * Example without specifying the fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = ol.coordinate.createStringXY();
 *     var out = stringifyFunc(coord);
 *     // out is now '8, 48'
 *
 * Example with explicitly specifying 2 fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var stringifyFunc = ol.coordinate.createStringXY(2);
 *     var out = stringifyFunc(coord);
 *     // out is now '7.85, 47.98'
 *
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {ol.CoordinateFormatType} Coordinate format.
 * @api
 */
_ol_coordinate_.createStringXY = function (opt_fractionDigits) {
  return (
    /**
     * @param {ol.Coordinate|undefined} coordinate Coordinate.
     * @return {string} String XY.
     */
    function (coordinate) {
      return _ol_coordinate_.toStringXY(coordinate, opt_fractionDigits);
    }
  );
};

/**
 * @param {string} hemispheres Hemispheres.
 * @param {number} degrees Degrees.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} String.
 */
_ol_coordinate_.degreesToStringHDMS = function (hemispheres, degrees, opt_fractionDigits) {
  var normalizedDegrees = math["a" /* default */].modulo(degrees + 180, 360) - 180;
  var x = Math.abs(3600 * normalizedDegrees);
  var dflPrecision = opt_fractionDigits || 0;
  var precision = Math.pow(10, dflPrecision);

  var deg = Math.floor(x / 3600);
  var min = Math.floor((x - deg * 3600) / 60);
  var sec = x - deg * 3600 - min * 60;
  sec = Math.ceil(sec * precision) / precision;

  if (sec >= 60) {
    sec = 0;
    min += 1;
  }

  if (min >= 60) {
    min = 0;
    deg += 1;
  }

  return deg + '\xB0 ' + string.padNumber(min, 2) + '\u2032 ' + string.padNumber(sec, 2, dflPrecision) + '\u2033' + (normalizedDegrees == 0 ? '' : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0));
};

/**
 * Transforms the given {@link ol.Coordinate} to a string using the given string
 * template. The strings `{x}` and `{y}` in the template will be replaced with
 * the first and second coordinate values respectively.
 *
 * Example without specifying the fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = ol.coordinate.format(coord, template);
 *     // out is now 'Coordinate is (8|48).'
 *
 * Example explicitly specifying the fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var template = 'Coordinate is ({x}|{y}).';
 *     var out = ol.coordinate.format(coord, template, 2);
 *     // out is now 'Coordinate is (7.85|47.98).'
 *
 * @param {ol.Coordinate|undefined} coordinate Coordinate.
 * @param {string} template A template string with `{x}` and `{y}` placeholders
 *     that will be replaced by first and second coordinate values.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Formatted coordinate.
 * @api
 */
_ol_coordinate_.format = function (coordinate, template, opt_fractionDigits) {
  if (coordinate) {
    return template.replace('{x}', coordinate[0].toFixed(opt_fractionDigits)).replace('{y}', coordinate[1].toFixed(opt_fractionDigits));
  } else {
    return '';
  }
};

/**
 * @param {ol.Coordinate} coordinate1 First coordinate.
 * @param {ol.Coordinate} coordinate2 Second coordinate.
 * @return {boolean} Whether the passed coordinates are equal.
 */
_ol_coordinate_.equals = function (coordinate1, coordinate2) {
  var equals = true;
  for (var i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals = false;
      break;
    }
  }
  return equals;
};

/**
 * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
 * returned by the function.
 *
 * Example:
 *
 *     var coord = [7.85, 47.983333];
 *     var rotateRadians = Math.PI / 2; // 90 degrees
 *     ol.coordinate.rotate(coord, rotateRadians);
 *     // coord is now [-47.983333, 7.85]
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} angle Angle in radian.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */
_ol_coordinate_.rotate = function (coordinate, angle) {
  var cosAngle = Math.cos(angle);
  var sinAngle = Math.sin(angle);
  var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
};

/**
 * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
 * by the function.
 *
 * Example:
 *
 *     var coord = [7.85, 47.983333];
 *     var scale = 1.2;
 *     ol.coordinate.scale(coord, scale);
 *     // coord is now [9.42, 57.5799996]
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} scale Scale factor.
 * @return {ol.Coordinate} Coordinate.
 */
_ol_coordinate_.scale = function (coordinate, scale) {
  coordinate[0] *= scale;
  coordinate[1] *= scale;
  return coordinate;
};

/**
 * Subtract `delta` to `coordinate`. `coordinate` is modified in place and
 * returned by the function.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Coordinate} delta Delta.
 * @return {ol.Coordinate} Coordinate.
 */
_ol_coordinate_.sub = function (coordinate, delta) {
  coordinate[0] -= delta[0];
  coordinate[1] -= delta[1];
  return coordinate;
};

/**
 * @param {ol.Coordinate} coord1 First coordinate.
 * @param {ol.Coordinate} coord2 Second coordinate.
 * @return {number} Squared distance between coord1 and coord2.
 */
_ol_coordinate_.squaredDistance = function (coord1, coord2) {
  var dx = coord1[0] - coord2[0];
  var dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
};

/**
 * @param {ol.Coordinate} coord1 First coordinate.
 * @param {ol.Coordinate} coord2 Second coordinate.
 * @return {number} Distance between coord1 and coord2.
 */
_ol_coordinate_.distance = function (coord1, coord2) {
  return Math.sqrt(_ol_coordinate_.squaredDistance(coord1, coord2));
};

/**
 * Calculate the squared distance from a coordinate to a line segment.
 *
 * @param {ol.Coordinate} coordinate Coordinate of the point.
 * @param {Array.<ol.Coordinate>} segment Line segment (2 coordinates).
 * @return {number} Squared distance from the point to the line segment.
 */
_ol_coordinate_.squaredDistanceToSegment = function (coordinate, segment) {
  return _ol_coordinate_.squaredDistance(coordinate, _ol_coordinate_.closestOnSegment(coordinate, segment));
};

/**
 * Format a geographic coordinate with the hemisphere, degrees, minutes, and
 * seconds.
 *
 * Example without specifying fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringHDMS(coord);
 *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringHDMS(coord, 1);
 *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
 *
 * @param {ol.Coordinate|undefined} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} Hemisphere, degrees, minutes and seconds.
 * @api
 */
_ol_coordinate_.toStringHDMS = function (coordinate, opt_fractionDigits) {
  if (coordinate) {
    return _ol_coordinate_.degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) + ' ' + _ol_coordinate_.degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits);
  } else {
    return '';
  }
};

/**
 * Format a coordinate as a comma delimited string.
 *
 * Example without specifying fractional digits:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringXY(coord);
 *     // out is now '8, 48'
 *
 * Example explicitly specifying 1 fractional digit:
 *
 *     var coord = [7.85, 47.983333];
 *     var out = ol.coordinate.toStringXY(coord, 1);
 *     // out is now '7.8, 48.0'
 *
 * @param {ol.Coordinate|undefined} coordinate Coordinate.
 * @param {number=} opt_fractionDigits The number of digits to include
 *    after the decimal point. Default is `0`.
 * @return {string} XY.
 * @api
 */
_ol_coordinate_.toStringXY = function (coordinate, opt_fractionDigits) {
  return _ol_coordinate_.format(coordinate, '{x}, {y}', opt_fractionDigits);
};
/* harmony default export */ var coordinate = __webpack_exports__["a"] = (_ol_coordinate_);

/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * A representation of a contiguous block of tiles.  A tile range is specified
 * by its min/max tile coordinates and is inclusive of coordinates.
 *
 * @constructor
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @struct
 */
var _ol_TileRange_ = function _ol_TileRange_(minX, maxX, minY, maxY) {

  /**
   * @type {number}
   */
  this.minX = minX;

  /**
   * @type {number}
   */
  this.maxX = maxX;

  /**
   * @type {number}
   */
  this.minY = minY;

  /**
   * @type {number}
   */
  this.maxY = maxY;
};

/**
 * @param {number} minX Minimum X.
 * @param {number} maxX Maximum X.
 * @param {number} minY Minimum Y.
 * @param {number} maxY Maximum Y.
 * @param {ol.TileRange|undefined} tileRange TileRange.
 * @return {ol.TileRange} Tile range.
 */
_ol_TileRange_.createOrUpdate = function (minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== undefined) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  } else {
    return new _ol_TileRange_(minX, maxX, minY, maxY);
  }
};

/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @return {boolean} Contains tile coordinate.
 */
_ol_TileRange_.prototype.contains = function (tileCoord) {
  return this.containsXY(tileCoord[1], tileCoord[2]);
};

/**
 * @param {ol.TileRange} tileRange Tile range.
 * @return {boolean} Contains.
 */
_ol_TileRange_.prototype.containsTileRange = function (tileRange) {
  return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
};

/**
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @return {boolean} Contains coordinate.
 */
_ol_TileRange_.prototype.containsXY = function (x, y) {
  return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
};

/**
 * @param {ol.TileRange} tileRange Tile range.
 * @return {boolean} Equals.
 */
_ol_TileRange_.prototype.equals = function (tileRange) {
  return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
};

/**
 * @param {ol.TileRange} tileRange Tile range.
 */
_ol_TileRange_.prototype.extend = function (tileRange) {
  if (tileRange.minX < this.minX) {
    this.minX = tileRange.minX;
  }
  if (tileRange.maxX > this.maxX) {
    this.maxX = tileRange.maxX;
  }
  if (tileRange.minY < this.minY) {
    this.minY = tileRange.minY;
  }
  if (tileRange.maxY > this.maxY) {
    this.maxY = tileRange.maxY;
  }
};

/**
 * @return {number} Height.
 */
_ol_TileRange_.prototype.getHeight = function () {
  return this.maxY - this.minY + 1;
};

/**
 * @return {ol.Size} Size.
 */
_ol_TileRange_.prototype.getSize = function () {
  return [this.getWidth(), this.getHeight()];
};

/**
 * @return {number} Width.
 */
_ol_TileRange_.prototype.getWidth = function () {
  return this.maxX - this.minX + 1;
};

/**
 * @param {ol.TileRange} tileRange Tile range.
 * @return {boolean} Intersects.
 */
_ol_TileRange_.prototype.intersects = function (tileRange) {
  return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_TileRange_);

/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/ol/index.js
var ol = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ol/size.js
var ol_size = __webpack_require__(53);

// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__(1);

// EXTERNAL MODULE: ./node_modules/ol/extent/corner.js
var extent_corner = __webpack_require__(74);

// EXTERNAL MODULE: ./node_modules/ol/obj.js
var obj = __webpack_require__(2);

// EXTERNAL MODULE: ./node_modules/ol/proj.js + 7 modules
var proj = __webpack_require__(16);

// EXTERNAL MODULE: ./node_modules/ol/proj/units.js
var units = __webpack_require__(26);

// EXTERNAL MODULE: ./node_modules/ol/asserts.js
var asserts = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/ol/tilerange.js
var tilerange = __webpack_require__(63);

// EXTERNAL MODULE: ./node_modules/ol/array.js
var array = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/ol/math.js
var math = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/ol/tilecoord.js
var tilecoord = __webpack_require__(44);

// CONCATENATED MODULE: ./node_modules/ol/tilegrid/tilegrid.js









/**
 * @classdesc
 * Base class for setting the grid pattern for sources accessing tiled-image
 * servers.
 *
 * @constructor
 * @param {olx.tilegrid.TileGridOptions} options Tile grid options.
 * @struct
 * @api
 */
var tilegrid__ol_tilegrid_TileGrid_ = function _ol_tilegrid_TileGrid_(options) {

  /**
   * @protected
   * @type {number}
   */
  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;

  /**
   * @private
   * @type {!Array.<number>}
   */
  this.resolutions_ = options.resolutions;
  asserts["a" /* default */].assert(array["a" /* default */].isSorted(this.resolutions_, function (a, b) {
    return b - a;
  }, true), 17); // `resolutions` must be sorted in descending order


  // check if we've got a consistent zoom factor and origin
  var zoomFactor;
  if (!options.origins) {
    for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
      if (!zoomFactor) {
        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
      } else {
        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
          zoomFactor = undefined;
          break;
        }
      }
    }
  }

  /**
   * @private
   * @type {number|undefined}
   */
  this.zoomFactor_ = zoomFactor;

  /**
   * @protected
   * @type {number}
   */
  this.maxZoom = this.resolutions_.length - 1;

  /**
   * @private
   * @type {ol.Coordinate}
   */
  this.origin_ = options.origin !== undefined ? options.origin : null;

  /**
   * @private
   * @type {Array.<ol.Coordinate>}
   */
  this.origins_ = null;
  if (options.origins !== undefined) {
    this.origins_ = options.origins;
    asserts["a" /* default */].assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal
  }

  var extent = options.extent;

  if (extent !== undefined && !this.origin_ && !this.origins_) {
    this.origin_ = ol_extent["a" /* default */].getTopLeft(extent);
  }

  asserts["a" /* default */].assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, 18); // Either `origin` or `origins` must be configured, never both

  /**
   * @private
   * @type {Array.<number|ol.Size>}
   */
  this.tileSizes_ = null;
  if (options.tileSizes !== undefined) {
    this.tileSizes_ = options.tileSizes;
    asserts["a" /* default */].assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal
  }

  /**
   * @private
   * @type {number|ol.Size}
   */
  this.tileSize_ = options.tileSize !== undefined ? options.tileSize : !this.tileSizes_ ? ol["a" /* default */].DEFAULT_TILE_SIZE : null;
  asserts["a" /* default */].assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, 22); // Either `tileSize` or `tileSizes` must be configured, never both

  /**
   * @private
   * @type {ol.Extent}
   */
  this.extent_ = extent !== undefined ? extent : null;

  /**
   * @private
   * @type {Array.<ol.TileRange>}
   */
  this.fullTileRanges_ = null;

  /**
   * @private
   * @type {ol.Size}
   */
  this.tmpSize_ = [0, 0];

  if (options.sizes !== undefined) {
    this.fullTileRanges_ = options.sizes.map(function (size, z) {
      var tileRange = new tilerange["a" /* default */](Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
      return tileRange;
    }, this);
  } else if (extent) {
    this.calculateTileRanges_(extent);
  }
};

/**
 * @private
 * @type {ol.TileCoord}
 */
tilegrid__ol_tilegrid_TileGrid_.tmpTileCoord_ = [0, 0, 0];

/**
 * Call a function with each tile coordinate for a given extent and zoom level.
 *
 * @param {ol.Extent} extent Extent.
 * @param {number} zoom Integer zoom level.
 * @param {function(ol.TileCoord)} callback Function called with each tile coordinate.
 * @api
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.forEachTileCoord = function (extent, zoom, callback) {
  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
      callback([zoom, i, j]);
    }
  }
};

/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {function(this: T, number, ol.TileRange): boolean} callback Callback.
 * @param {T=} opt_this The object to use as `this` in `callback`.
 * @param {ol.TileRange=} opt_tileRange Temporary ol.TileRange object.
 * @param {ol.Extent=} opt_extent Temporary ol.Extent object.
 * @return {boolean} Callback succeeded.
 * @template T
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_this, opt_tileRange, opt_extent) {
  var tileRange, x, y;
  var tileCoordExtent = null;
  var z = tileCoord[0] - 1;
  if (this.zoomFactor_ === 2) {
    x = tileCoord[1];
    y = tileCoord[2];
  } else {
    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
  }
  while (z >= this.minZoom) {
    if (this.zoomFactor_ === 2) {
      x = Math.floor(x / 2);
      y = Math.floor(y / 2);
      tileRange = tilerange["a" /* default */].createOrUpdate(x, x, y, y, opt_tileRange);
    } else {
      tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
    }
    if (callback.call(opt_this, z, tileRange)) {
      return true;
    }
    --z;
  }
  return false;
};

/**
 * Get the extent for this tile grid, if it was configured.
 * @return {ol.Extent} Extent.
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getExtent = function () {
  return this.extent_;
};

/**
 * Get the maximum zoom level for the grid.
 * @return {number} Max zoom.
 * @api
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getMaxZoom = function () {
  return this.maxZoom;
};

/**
 * Get the minimum zoom level for the grid.
 * @return {number} Min zoom.
 * @api
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getMinZoom = function () {
  return this.minZoom;
};

/**
 * Get the origin for the grid at the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {ol.Coordinate} Origin.
 * @api
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getOrigin = function (z) {
  if (this.origin_) {
    return this.origin_;
  } else {
    return this.origins_[z];
  }
};

/**
 * Get the resolution for the given zoom level.
 * @param {number} z Integer zoom level.
 * @return {number} Resolution.
 * @api
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getResolution = function (z) {
  return this.resolutions_[z];
};

/**
 * Get the list of resolutions for the tile grid.
 * @return {Array.<number>} Resolutions.
 * @api
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getResolutions = function () {
  return this.resolutions_;
};

/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileRange=} opt_tileRange Temporary ol.TileRange object.
 * @param {ol.Extent=} opt_extent Temporary ol.Extent object.
 * @return {ol.TileRange} Tile range.
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {
  if (tileCoord[0] < this.maxZoom) {
    if (this.zoomFactor_ === 2) {
      var minX = tileCoord[1] * 2;
      var minY = tileCoord[2] * 2;
      return tilerange["a" /* default */].createOrUpdate(minX, minX + 1, minY, minY + 1, opt_tileRange);
    }
    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
  }
  return null;
};

/**
 * Get the extent for a tile range.
 * @param {number} z Integer zoom level.
 * @param {ol.TileRange} tileRange Tile range.
 * @param {ol.Extent=} opt_extent Temporary ol.Extent object.
 * @return {ol.Extent} Extent.
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = ol_size["a" /* default */].toSize(this.getTileSize(z), this.tmpSize_);
  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
  return ol_extent["a" /* default */].createOrUpdate(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Get a tile range for the given extent and integer zoom level.
 * @param {ol.Extent} extent Extent.
 * @param {number} z Integer zoom level.
 * @param {ol.TileRange=} opt_tileRange Temporary tile range object.
 * @return {ol.TileRange} Tile range.
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {
  var tileCoord = tilegrid__ol_tilegrid_TileGrid_.tmpTileCoord_;
  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);
  var minX = tileCoord[1];
  var minY = tileCoord[2];
  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);
  return tilerange["a" /* default */].createOrUpdate(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
};

/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @return {ol.Coordinate} Tile center.
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getTileCoordCenter = function (tileCoord) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = ol_size["a" /* default */].toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
  return [origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution, origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution];
};

/**
 * Get the extent of a tile coordinate.
 *
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.Extent=} opt_extent Temporary extent object.
 * @return {ol.Extent} Extent.
 * @api
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {
  var origin = this.getOrigin(tileCoord[0]);
  var resolution = this.getResolution(tileCoord[0]);
  var tileSize = ol_size["a" /* default */].toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;
  var maxX = minX + tileSize[0] * resolution;
  var maxY = minY + tileSize[1] * resolution;
  return ol_extent["a" /* default */].createOrUpdate(minX, minY, maxX, maxY, opt_extent);
};

/**
 * Get the tile coordinate for the given map coordinate and resolution.  This
 * method considers that coordinates that intersect tile boundaries should be
 * assigned the higher tile coordinate.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {ol.TileCoord=} opt_tileCoord Destination ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @api
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {
  return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
};

/**
 * Note that this method should not be called for resolutions that correspond
 * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {number} resolution Resolution (for a non-integer zoom level).
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *     intersections go to the higher tile coordinate, let edge intersections
 *     go to the lower tile coordinate.
 * @param {ol.TileCoord=} opt_tileCoord Temporary ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @private
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
  var z = this.getZForResolution(resolution);
  var scale = resolution / this.getResolution(z);
  var origin = this.getOrigin(z);
  var tileSize = ol_size["a" /* default */].toSize(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = scale * xFromOrigin / tileSize[0];
  var tileCoordY = scale * yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return tilecoord["a" /* default */].createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
};

/**
 * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
 * they should have separate implementations.  This method is for integer zoom
 * levels.  The other method should only be called for resolutions corresponding
 * to non-integer zoom levels.
 * @param {number} x Map x coordinate.
 * @param {number} y Map y coordinate.
 * @param {number} z Integer zoom level.
 * @param {boolean} reverseIntersectionPolicy Instead of letting edge
 *     intersections go to the higher tile coordinate, let edge intersections
 *     go to the lower tile coordinate.
 * @param {ol.TileCoord=} opt_tileCoord Temporary ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @private
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
  var origin = this.getOrigin(z);
  var resolution = this.getResolution(z);
  var tileSize = ol_size["a" /* default */].toSize(this.getTileSize(z), this.tmpSize_);

  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;
  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);
  var tileCoordX = xFromOrigin / tileSize[0];
  var tileCoordY = yFromOrigin / tileSize[1];

  if (reverseIntersectionPolicy) {
    tileCoordX = Math.ceil(tileCoordX) - 1;
    tileCoordY = Math.ceil(tileCoordY) - 1;
  } else {
    tileCoordX = Math.floor(tileCoordX);
    tileCoordY = Math.floor(tileCoordY);
  }

  return tilecoord["a" /* default */].createOrUpdate(z, tileCoordX, tileCoordY, opt_tileCoord);
};

/**
 * Get a tile coordinate given a map coordinate and zoom level.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} z Zoom level.
 * @param {ol.TileCoord=} opt_tileCoord Destination ol.TileCoord object.
 * @return {ol.TileCoord} Tile coordinate.
 * @api
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {
  return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
};

/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @return {number} Tile resolution.
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getTileCoordResolution = function (tileCoord) {
  return this.resolutions_[tileCoord[0]];
};

/**
 * Get the tile size for a zoom level. The type of the return value matches the
 * `tileSize` or `tileSizes` that the tile grid was configured with. To always
 * get an `ol.Size`, run the result through `ol.size.toSize()`.
 * @param {number} z Z.
 * @return {number|ol.Size} Tile size.
 * @api
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getTileSize = function (z) {
  if (this.tileSize_) {
    return this.tileSize_;
  } else {
    return this.tileSizes_[z];
  }
};

/**
 * @param {number} z Zoom level.
 * @return {ol.TileRange} Extent tile range for the specified zoom level.
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getFullTileRange = function (z) {
  if (!this.fullTileRanges_) {
    return null;
  } else {
    return this.fullTileRanges_[z];
  }
};

/**
 * @param {number} resolution Resolution.
 * @param {number=} opt_direction If 0, the nearest resolution will be used.
 *     If 1, the nearest lower resolution will be used. If -1, the nearest
 *     higher resolution will be used. Default is 0.
 * @return {number} Z.
 * @api
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.getZForResolution = function (resolution, opt_direction) {
  var z = array["a" /* default */].linearFindNearest(this.resolutions_, resolution, opt_direction || 0);
  return math["a" /* default */].clamp(z, this.minZoom, this.maxZoom);
};

/**
 * @param {!ol.Extent} extent Extent for this tile grid.
 * @private
 */
tilegrid__ol_tilegrid_TileGrid_.prototype.calculateTileRanges_ = function (extent) {
  var length = this.resolutions_.length;
  var fullTileRanges = new Array(length);
  for (var z = this.minZoom; z < length; ++z) {
    fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
  }
  this.fullTileRanges_ = fullTileRanges;
};
/* harmony default export */ var tilegrid = (tilegrid__ol_tilegrid_TileGrid_);
// CONCATENATED MODULE: ./node_modules/ol/tilegrid.js








var _ol_tilegrid_ = {};

/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {!ol.tilegrid.TileGrid} Default tile grid for the passed projection.
 */
_ol_tilegrid_.getForProjection = function (projection) {
  var tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = _ol_tilegrid_.createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
};

/**
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.TileCoord} Tile coordinate.
 */
_ol_tilegrid_.wrapX = function (tileGrid, tileCoord, projection) {
  var z = tileCoord[0];
  var center = tileGrid.getTileCoordCenter(tileCoord);
  var projectionExtent = _ol_tilegrid_.extentFromProjection(projection);
  if (!ol_extent["a" /* default */].containsCoordinate(projectionExtent, center)) {
    var worldWidth = ol_extent["a" /* default */].getWidth(projectionExtent);
    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  } else {
    return tileCoord;
  }
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     ol.DEFAULT_MAX_ZOOM).
 * @param {number|ol.Size=} opt_tileSize Tile size (default uses
 *     ol.DEFAULT_TILE_SIZE).
 * @param {ol.extent.Corner=} opt_corner Extent corner (default is
 *     ol.extent.Corner.TOP_LEFT).
 * @return {!ol.tilegrid.TileGrid} TileGrid instance.
 */
_ol_tilegrid_.createForExtent = function (extent, opt_maxZoom, opt_tileSize, opt_corner) {
  var corner = opt_corner !== undefined ? opt_corner : extent_corner["a" /* default */].TOP_LEFT;

  var resolutions = _ol_tilegrid_.resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);

  return new tilegrid({
    extent: extent,
    origin: ol_extent["a" /* default */].getCorner(extent, corner),
    resolutions: resolutions,
    tileSize: opt_tileSize
  });
};

/**
 * Creates a tile grid with a standard XYZ tiling scheme.
 * @param {olx.tilegrid.XYZOptions=} opt_options Tile grid options.
 * @return {!ol.tilegrid.TileGrid} Tile grid instance.
 * @api
 */
_ol_tilegrid_.createXYZ = function (opt_options) {
  var options = /** @type {olx.tilegrid.TileGridOptions} */{};
  obj["a" /* default */].assign(options, opt_options !== undefined ? opt_options : /** @type {olx.tilegrid.XYZOptions} */{});
  if (options.extent === undefined) {
    options.extent = proj["default"].get('EPSG:3857').getExtent();
  }
  options.resolutions = _ol_tilegrid_.resolutionsFromExtent(options.extent, options.maxZoom, options.tileSize);
  delete options.maxZoom;

  return new tilegrid(options);
};

/**
 * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
 * @param {ol.Extent} extent Extent.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     ol.DEFAULT_MAX_ZOOM).
 * @param {number|ol.Size=} opt_tileSize Tile size (default uses
 *     ol.DEFAULT_TILE_SIZE).
 * @return {!Array.<number>} Resolutions array.
 */
_ol_tilegrid_.resolutionsFromExtent = function (extent, opt_maxZoom, opt_tileSize) {
  var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : ol["a" /* default */].DEFAULT_MAX_ZOOM;

  var height = ol_extent["a" /* default */].getHeight(extent);
  var width = ol_extent["a" /* default */].getWidth(extent);

  var tileSize = ol_size["a" /* default */].toSize(opt_tileSize !== undefined ? opt_tileSize : ol["a" /* default */].DEFAULT_TILE_SIZE);
  var maxResolution = Math.max(width / tileSize[0], height / tileSize[1]);

  var length = maxZoom + 1;
  var resolutions = new Array(length);
  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
};

/**
 * @param {ol.ProjectionLike} projection Projection.
 * @param {number=} opt_maxZoom Maximum zoom level (default is
 *     ol.DEFAULT_MAX_ZOOM).
 * @param {number|ol.Size=} opt_tileSize Tile size (default uses
 *     ol.DEFAULT_TILE_SIZE).
 * @param {ol.extent.Corner=} opt_corner Extent corner (default is
 *     ol.extent.Corner.BOTTOM_LEFT).
 * @return {!ol.tilegrid.TileGrid} TileGrid instance.
 */
_ol_tilegrid_.createForProjection = function (projection, opt_maxZoom, opt_tileSize, opt_corner) {
  var extent = _ol_tilegrid_.extentFromProjection(projection);
  return _ol_tilegrid_.createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
};

/**
 * Generate a tile grid extent from a projection.  If the projection has an
 * extent, it is used.  If not, a global extent is assumed.
 * @param {ol.ProjectionLike} projection Projection.
 * @return {ol.Extent} Extent.
 */
_ol_tilegrid_.extentFromProjection = function (projection) {
  projection = proj["default"].get(projection);
  var extent = projection.getExtent();
  if (!extent) {
    var half = 180 * proj["default"].METERS_PER_UNIT[units["a" /* default */].DEGREES] / projection.getMetersPerUnit();
    extent = ol_extent["a" /* default */].createOrUpdate(-half, -half, half, half);
  }
  return extent;
};
/* harmony default export */ var ol_tilegrid = __webpack_exports__["a"] = (_ol_tilegrid_);

/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__asserts_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__events_eventtarget_js__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__events_eventtype_js__ = __webpack_require__(4);





/**
 * Implements a Least-Recently-Used cache where the keys do not conflict with
 * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
 * items from the cache is the responsibility of the user.
 * @constructor
 * @extends {ol.events.EventTarget}
 * @fires ol.events.Event
 * @struct
 * @template T
 * @param {number=} opt_highWaterMark High water mark.
 */
var _ol_structs_LRUCache_ = function _ol_structs_LRUCache_(opt_highWaterMark) {

  __WEBPACK_IMPORTED_MODULE_2__events_eventtarget_js__["a" /* default */].call(this);

  /**
   * @type {number}
   */
  this.highWaterMark = opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;

  /**
   * @private
   * @type {number}
   */
  this.count_ = 0;

  /**
   * @private
   * @type {!Object.<string, ol.LRUCacheEntry>}
   */
  this.entries_ = {};

  /**
   * @private
   * @type {?ol.LRUCacheEntry}
   */
  this.oldest_ = null;

  /**
   * @private
   * @type {?ol.LRUCacheEntry}
   */
  this.newest_ = null;
};

__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].inherits(_ol_structs_LRUCache_, __WEBPACK_IMPORTED_MODULE_2__events_eventtarget_js__["a" /* default */]);

/**
 * @return {boolean} Can expire cache.
 */
_ol_structs_LRUCache_.prototype.canExpireCache = function () {
  return this.getCount() > this.highWaterMark;
};

/**
 * FIXME empty description for jsdoc
 */
_ol_structs_LRUCache_.prototype.clear = function () {
  this.count_ = 0;
  this.entries_ = {};
  this.oldest_ = null;
  this.newest_ = null;
  this.dispatchEvent(__WEBPACK_IMPORTED_MODULE_3__events_eventtype_js__["a" /* default */].CLEAR);
};

/**
 * @param {string} key Key.
 * @return {boolean} Contains key.
 */
_ol_structs_LRUCache_.prototype.containsKey = function (key) {
  return this.entries_.hasOwnProperty(key);
};

/**
 * @param {function(this: S, T, string, ol.structs.LRUCache): ?} f The function
 *     to call for every entry from the oldest to the newer. This function takes
 *     3 arguments (the entry value, the entry key and the LRUCache object).
 *     The return value is ignored.
 * @param {S=} opt_this The object to use as `this` in `f`.
 * @template S
 */
_ol_structs_LRUCache_.prototype.forEach = function (f, opt_this) {
  var entry = this.oldest_;
  while (entry) {
    f.call(opt_this, entry.value_, entry.key_, this);
    entry = entry.newer;
  }
};

/**
 * @param {string} key Key.
 * @return {T} Value.
 */
_ol_structs_LRUCache_.prototype.get = function (key) {
  var entry = this.entries_[key];
  __WEBPACK_IMPORTED_MODULE_1__asserts_js__["a" /* default */].assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
  if (entry === this.newest_) {
    return entry.value_;
  } else if (entry === this.oldest_) {
    this.oldest_ = /** @type {ol.LRUCacheEntry} */this.oldest_.newer;
    this.oldest_.older = null;
  } else {
    entry.newer.older = entry.older;
    entry.older.newer = entry.newer;
  }
  entry.newer = null;
  entry.older = this.newest_;
  this.newest_.newer = entry;
  this.newest_ = entry;
  return entry.value_;
};

/**
 * Remove an entry from the cache.
 * @param {string} key The entry key.
 * @return {T} The removed entry.
 */
_ol_structs_LRUCache_.prototype.remove = function (key) {
  var entry = this.entries_[key];
  __WEBPACK_IMPORTED_MODULE_1__asserts_js__["a" /* default */].assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
  if (entry === this.newest_) {
    this.newest_ = /** @type {ol.LRUCacheEntry} */entry.older;
    if (this.newest_) {
      this.newest_.newer = null;
    }
  } else if (entry === this.oldest_) {
    this.oldest_ = /** @type {ol.LRUCacheEntry} */entry.newer;
    if (this.oldest_) {
      this.oldest_.older = null;
    }
  } else {
    entry.newer.older = entry.older;
    entry.older.newer = entry.newer;
  }
  delete this.entries_[key];
  --this.count_;
  return entry.value_;
};

/**
 * @return {number} Count.
 */
_ol_structs_LRUCache_.prototype.getCount = function () {
  return this.count_;
};

/**
 * @return {Array.<string>} Keys.
 */
_ol_structs_LRUCache_.prototype.getKeys = function () {
  var keys = new Array(this.count_);
  var i = 0;
  var entry;
  for (entry = this.newest_; entry; entry = entry.older) {
    keys[i++] = entry.key_;
  }
  return keys;
};

/**
 * @return {Array.<T>} Values.
 */
_ol_structs_LRUCache_.prototype.getValues = function () {
  var values = new Array(this.count_);
  var i = 0;
  var entry;
  for (entry = this.newest_; entry; entry = entry.older) {
    values[i++] = entry.value_;
  }
  return values;
};

/**
 * @return {T} Last value.
 */
_ol_structs_LRUCache_.prototype.peekLast = function () {
  return this.oldest_.value_;
};

/**
 * @return {string} Last key.
 */
_ol_structs_LRUCache_.prototype.peekLastKey = function () {
  return this.oldest_.key_;
};

/**
 * Get the key of the newest item in the cache.  Throws if the cache is empty.
 * @return {string} The newest key.
 */
_ol_structs_LRUCache_.prototype.peekFirstKey = function () {
  return this.newest_.key_;
};

/**
 * @return {T} value Value.
 */
_ol_structs_LRUCache_.prototype.pop = function () {
  var entry = this.oldest_;
  delete this.entries_[entry.key_];
  if (entry.newer) {
    entry.newer.older = null;
  }
  this.oldest_ = /** @type {ol.LRUCacheEntry} */entry.newer;
  if (!this.oldest_) {
    this.newest_ = null;
  }
  --this.count_;
  return entry.value_;
};

/**
 * @param {string} key Key.
 * @param {T} value Value.
 */
_ol_structs_LRUCache_.prototype.replace = function (key, value) {
  this.get(key); // update `newest_`
  this.entries_[key].value_ = value;
};

/**
 * @param {string} key Key.
 * @param {T} value Value.
 */
_ol_structs_LRUCache_.prototype.set = function (key, value) {
  __WEBPACK_IMPORTED_MODULE_1__asserts_js__["a" /* default */].assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already
  var entry = /** @type {ol.LRUCacheEntry} */{
    key_: key,
    newer: null,
    older: this.newest_,
    value_: value
  };
  if (!this.newest_) {
    this.oldest_ = entry;
  } else {
    this.newest_.newer = entry;
  }
  this.newest_ = entry;
  this.entries_[key] = entry;
  ++this.count_;
};

/**
 * Prune the cache.
 */
_ol_structs_LRUCache_.prototype.prune = function () {
  while (this.canExpireCache()) {
    this.pop();
  }
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_structs_LRUCache_);

/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color_js__ = __webpack_require__(27);



/**
 * @classdesc
 * Set fill style for vector features.
 *
 * @constructor
 * @param {olx.style.FillOptions=} opt_options Options.
 * @api
 */
var _ol_style_Fill_ = function _ol_style_Fill_(opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {ol.Color|ol.ColorLike}
   */
  this.color_ = options.color !== undefined ? options.color : null;

  /**
   * @private
   * @type {string|undefined}
   */
  this.checksum_ = undefined;
};

/**
 * Clones the style. The color is not cloned if it is an {@link ol.ColorLike}.
 * @return {ol.style.Fill} The cloned style.
 * @api
 */
_ol_style_Fill_.prototype.clone = function () {
  var color = this.getColor();
  return new _ol_style_Fill_({
    color: color && color.slice ? color.slice() : color || undefined
  });
};

/**
 * Get the fill color.
 * @return {ol.Color|ol.ColorLike} Color.
 * @api
 */
_ol_style_Fill_.prototype.getColor = function () {
  return this.color_;
};

/**
 * Set the color.
 *
 * @param {ol.Color|ol.ColorLike} color Color.
 * @api
 */
_ol_style_Fill_.prototype.setColor = function (color) {
  this.color_ = color;
  this.checksum_ = undefined;
};

/**
 * @return {string} The checksum.
 */
_ol_style_Fill_.prototype.getChecksum = function () {
  if (this.checksum_ === undefined) {
    if (this.color_ instanceof CanvasPattern || this.color_ instanceof CanvasGradient) {
      this.checksum_ = __WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].getUid(this.color_).toString();
    } else {
      this.checksum_ = 'f' + (this.color_ ? __WEBPACK_IMPORTED_MODULE_1__color_js__["a" /* default */].asString(this.color_) : '-');
    }
  }

  return this.checksum_;
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_style_Fill_);

/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__extent_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__geom_geometrylayout_js__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__geom_geometrytype_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_simplegeometry_js__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__geom_flat_deflate_js__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__math_js__ = __webpack_require__(6);








/**
 * @classdesc
 * Point geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {ol.Coordinate} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var _ol_geom_Point_ = function _ol_geom_Point_(coordinates, opt_layout) {
  __WEBPACK_IMPORTED_MODULE_4__geom_simplegeometry_js__["a" /* default */].call(this);
  this.setCoordinates(coordinates, opt_layout);
};

__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].inherits(_ol_geom_Point_, __WEBPACK_IMPORTED_MODULE_4__geom_simplegeometry_js__["a" /* default */]);

/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.Point} Clone.
 * @override
 * @api
 */
_ol_geom_Point_.prototype.clone = function () {
  var point = new _ol_geom_Point_(null);
  point.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return point;
};

/**
 * @inheritDoc
 */
_ol_geom_Point_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  var flatCoordinates = this.flatCoordinates;
  var squaredDistance = __WEBPACK_IMPORTED_MODULE_6__math_js__["a" /* default */].squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);
  if (squaredDistance < minSquaredDistance) {
    var stride = this.stride;
    var i;
    for (i = 0; i < stride; ++i) {
      closestPoint[i] = flatCoordinates[i];
    }
    closestPoint.length = stride;
    return squaredDistance;
  } else {
    return minSquaredDistance;
  }
};

/**
 * Return the coordinate of the point.
 * @return {ol.Coordinate} Coordinates.
 * @override
 * @api
 */
_ol_geom_Point_.prototype.getCoordinates = function () {
  return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
};

/**
 * @inheritDoc
 */
_ol_geom_Point_.prototype.computeExtent = function (extent) {
  return __WEBPACK_IMPORTED_MODULE_1__extent_js__["a" /* default */].createOrUpdateFromCoordinate(this.flatCoordinates, extent);
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_Point_.prototype.getType = function () {
  return __WEBPACK_IMPORTED_MODULE_3__geom_geometrytype_js__["a" /* default */].POINT;
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_Point_.prototype.intersectsExtent = function (extent) {
  return __WEBPACK_IMPORTED_MODULE_1__extent_js__["a" /* default */].containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
};

/**
 * @inheritDoc
 * @api
 */
_ol_geom_Point_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(__WEBPACK_IMPORTED_MODULE_2__geom_geometrylayout_js__["a" /* default */].XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 0);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = __WEBPACK_IMPORTED_MODULE_5__geom_flat_deflate_js__["a" /* default */].coordinate(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */
_ol_geom_Point_.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_geom_Point_);

/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @enum {string}
 */
var _ol_MapEventType_ = {

  /**
   * Triggered after a map frame is rendered.
   * @event ol.MapEvent#postrender
   * @api
   */
  POSTRENDER: 'postrender',

  /**
   * Triggered when the map starts moving.
   * @event ol.MapEvent#movestart
   * @api
   */
  MOVESTART: 'movestart',

  /**
   * Triggered after the map is moved.
   * @event ol.MapEvent#moveend
   * @api
   */
  MOVEEND: 'moveend'

};

/* harmony default export */ __webpack_exports__["a"] = (_ol_MapEventType_);

/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__math_js__ = __webpack_require__(6);

var _ol_RotationConstraint_ = {};

/**
 * @param {number|undefined} rotation Rotation.
 * @param {number} delta Delta.
 * @return {number|undefined} Rotation.
 */
_ol_RotationConstraint_.disable = function (rotation, delta) {
  if (rotation !== undefined) {
    return 0;
  } else {
    return undefined;
  }
};

/**
 * @param {number|undefined} rotation Rotation.
 * @param {number} delta Delta.
 * @return {number|undefined} Rotation.
 */
_ol_RotationConstraint_.none = function (rotation, delta) {
  if (rotation !== undefined) {
    return rotation + delta;
  } else {
    return undefined;
  }
};

/**
 * @param {number} n N.
 * @return {ol.RotationConstraintType} Rotation constraint.
 */
_ol_RotationConstraint_.createSnapToN = function (n) {
  var theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */
    function (rotation, delta) {
      if (rotation !== undefined) {
        rotation = Math.floor((rotation + delta) / theta + 0.5) * theta;
        return rotation;
      } else {
        return undefined;
      }
    }
  );
};

/**
 * @param {number=} opt_tolerance Tolerance.
 * @return {ol.RotationConstraintType} Rotation constraint.
 */
_ol_RotationConstraint_.createSnapToZero = function (opt_tolerance) {
  var tolerance = opt_tolerance || __WEBPACK_IMPORTED_MODULE_0__math_js__["a" /* default */].toRadians(5);
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {number} delta Delta.
     * @return {number|undefined} Rotation.
     */
    function (rotation, delta) {
      if (rotation !== undefined) {
        if (Math.abs(rotation + delta) <= tolerance) {
          return 0;
        } else {
          return rotation + delta;
        }
      } else {
        return undefined;
      }
    }
  );
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_RotationConstraint_);

/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = require("rbush");

/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/ol/index.js
var ol = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ol/asserts.js
var asserts = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/ol/events.js
var events = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/ol/events/eventtype.js
var eventtype = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/ol/object.js
var ol_object = __webpack_require__(15);

// EXTERNAL MODULE: ./node_modules/ol/geom/geometry.js
var geom_geometry = __webpack_require__(56);

// EXTERNAL MODULE: ./node_modules/ol/style/style.js
var style = __webpack_require__(39);

// CONCATENATED MODULE: ./node_modules/ol/feature.js








/**
 * @classdesc
 * A vector object for geographic features with a geometry and other
 * attribute properties, similar to the features in vector file formats like
 * GeoJSON.
 *
 * Features can be styled individually with `setStyle`; otherwise they use the
 * style of their vector layer.
 *
 * Note that attribute properties are set as {@link ol.Object} properties on
 * the feature object, so they are observable, and have get/set accessors.
 *
 * Typically, a feature has a single geometry property. You can set the
 * geometry using the `setGeometry` method and get it with `getGeometry`.
 * It is possible to store more than one geometry on a feature using attribute
 * properties. By default, the geometry used for rendering is identified by
 * the property name `geometry`. If you want to use another geometry property
 * for rendering, use the `setGeometryName` method to change the attribute
 * property associated with the geometry for the feature.  For example:
 *
 * ```js
 * var feature = new ol.Feature({
 *   geometry: new ol.geom.Polygon(polyCoords),
 *   labelPoint: new ol.geom.Point(labelCoords),
 *   name: 'My Polygon'
 * });
 *
 * // get the polygon geometry
 * var poly = feature.getGeometry();
 *
 * // Render the feature as a point using the coordinates from labelPoint
 * feature.setGeometryName('labelPoint');
 *
 * // get the point geometry
 * var point = feature.getGeometry();
 * ```
 *
 * @constructor
 * @extends {ol.Object}
 * @param {ol.geom.Geometry|Object.<string, *>=} opt_geometryOrProperties
 *     You may pass a Geometry object directly, or an object literal
 *     containing properties.  If you pass an object literal, you may
 *     include a Geometry associated with a `geometry` key.
 * @api
 */
var feature__ol_Feature_ = function _ol_Feature_(opt_geometryOrProperties) {

  ol_object["a" /* default */].call(this);

  /**
   * @private
   * @type {number|string|undefined}
   */
  this.id_ = undefined;

  /**
   * @type {string}
   * @private
   */
  this.geometryName_ = 'geometry';

  /**
   * User provided style.
   * @private
   * @type {ol.style.Style|Array.<ol.style.Style>|
   *     ol.FeatureStyleFunction}
   */
  this.style_ = null;

  /**
   * @private
   * @type {ol.FeatureStyleFunction|undefined}
   */
  this.styleFunction_ = undefined;

  /**
   * @private
   * @type {?ol.EventsKey}
   */
  this.geometryChangeKey_ = null;

  events["a" /* default */].listen(this, ol_object["a" /* default */].getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);

  if (opt_geometryOrProperties !== undefined) {
    if (opt_geometryOrProperties instanceof geom_geometry["a" /* default */] || !opt_geometryOrProperties) {
      var geometry = opt_geometryOrProperties;
      this.setGeometry(geometry);
    } else {
      /** @type {Object.<string, *>} */
      var properties = opt_geometryOrProperties;
      this.setProperties(properties);
    }
  }
};

ol["a" /* default */].inherits(feature__ol_Feature_, ol_object["a" /* default */]);

/**
 * Clone this feature. If the original feature has a geometry it
 * is also cloned. The feature id is not set in the clone.
 * @return {ol.Feature} The clone.
 * @api
 */
feature__ol_Feature_.prototype.clone = function () {
  var clone = new feature__ol_Feature_(this.getProperties());
  clone.setGeometryName(this.getGeometryName());
  var geometry = this.getGeometry();
  if (geometry) {
    clone.setGeometry(geometry.clone());
  }
  var style = this.getStyle();
  if (style) {
    clone.setStyle(style);
  }
  return clone;
};

/**
 * Get the feature's default geometry.  A feature may have any number of named
 * geometries.  The "default" geometry (the one that is rendered by default) is
 * set when calling {@link ol.Feature#setGeometry}.
 * @return {ol.geom.Geometry|undefined} The default geometry for the feature.
 * @api
 * @observable
 */
feature__ol_Feature_.prototype.getGeometry = function () {
  return (/** @type {ol.geom.Geometry|undefined} */this.get(this.geometryName_)
  );
};

/**
 * Get the feature identifier.  This is a stable identifier for the feature and
 * is either set when reading data from a remote source or set explicitly by
 * calling {@link ol.Feature#setId}.
 * @return {number|string|undefined} Id.
 * @api
 */
feature__ol_Feature_.prototype.getId = function () {
  return this.id_;
};

/**
 * Get the name of the feature's default geometry.  By default, the default
 * geometry is named `geometry`.
 * @return {string} Get the property name associated with the default geometry
 *     for this feature.
 * @api
 */
feature__ol_Feature_.prototype.getGeometryName = function () {
  return this.geometryName_;
};

/**
 * Get the feature's style. Will return what was provided to the
 * {@link ol.Feature#setStyle} method.
 * @return {ol.style.Style|Array.<ol.style.Style>|
 *     ol.FeatureStyleFunction|ol.StyleFunction} The feature style.
 * @api
 */
feature__ol_Feature_.prototype.getStyle = function () {
  return this.style_;
};

/**
 * Get the feature's style function.
 * @return {ol.FeatureStyleFunction|undefined} Return a function
 * representing the current style of this feature.
 * @api
 */
feature__ol_Feature_.prototype.getStyleFunction = function () {
  return this.styleFunction_;
};

/**
 * @private
 */
feature__ol_Feature_.prototype.handleGeometryChange_ = function () {
  this.changed();
};

/**
 * @private
 */
feature__ol_Feature_.prototype.handleGeometryChanged_ = function () {
  if (this.geometryChangeKey_) {
    events["a" /* default */].unlistenByKey(this.geometryChangeKey_);
    this.geometryChangeKey_ = null;
  }
  var geometry = this.getGeometry();
  if (geometry) {
    this.geometryChangeKey_ = events["a" /* default */].listen(geometry, eventtype["a" /* default */].CHANGE, this.handleGeometryChange_, this);
  }
  this.changed();
};

/**
 * Set the default geometry for the feature.  This will update the property
 * with the name returned by {@link ol.Feature#getGeometryName}.
 * @param {ol.geom.Geometry|undefined} geometry The new geometry.
 * @api
 * @observable
 */
feature__ol_Feature_.prototype.setGeometry = function (geometry) {
  this.set(this.geometryName_, geometry);
};

/**
 * Set the style for the feature.  This can be a single style object, an array
 * of styles, or a function that takes a resolution and returns an array of
 * styles. If it is `null` the feature has no style (a `null` style).
 * @param {ol.style.Style|Array.<ol.style.Style>|
 *     ol.FeatureStyleFunction|ol.StyleFunction} style Style for this feature.
 * @api
 * @fires ol.events.Event#event:change
 */
feature__ol_Feature_.prototype.setStyle = function (style) {
  this.style_ = style;
  this.styleFunction_ = !style ? undefined : feature__ol_Feature_.createStyleFunction(style);
  this.changed();
};

/**
 * Set the feature id.  The feature id is considered stable and may be used when
 * requesting features or comparing identifiers returned from a remote source.
 * The feature id can be used with the {@link ol.source.Vector#getFeatureById}
 * method.
 * @param {number|string|undefined} id The feature id.
 * @api
 * @fires ol.events.Event#event:change
 */
feature__ol_Feature_.prototype.setId = function (id) {
  this.id_ = id;
  this.changed();
};

/**
 * Set the property name to be used when getting the feature's default geometry.
 * When calling {@link ol.Feature#getGeometry}, the value of the property with
 * this name will be returned.
 * @param {string} name The property name of the default geometry.
 * @api
 */
feature__ol_Feature_.prototype.setGeometryName = function (name) {
  events["a" /* default */].unlisten(this, ol_object["a" /* default */].getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);
  this.geometryName_ = name;
  events["a" /* default */].listen(this, ol_object["a" /* default */].getChangeEventType(this.geometryName_), this.handleGeometryChanged_, this);
  this.handleGeometryChanged_();
};

/**
 * Convert the provided object into a feature style function.  Functions passed
 * through unchanged.  Arrays of ol.style.Style or single style objects wrapped
 * in a new feature style function.
 * @param {ol.FeatureStyleFunction|!Array.<ol.style.Style>|!ol.style.Style} obj
 *     A feature style function, a single style, or an array of styles.
 * @return {ol.FeatureStyleFunction} A style function.
 */
feature__ol_Feature_.createStyleFunction = function (obj) {
  var styleFunction;

  if (typeof obj === 'function') {
    if (obj.length == 2) {
      styleFunction = function styleFunction(resolution) {
        return (/** @type {ol.StyleFunction} */obj(this, resolution)
        );
      };
    } else {
      styleFunction = obj;
    }
  } else {
    /**
     * @type {Array.<ol.style.Style>}
     */
    var styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      asserts["a" /* default */].assert(obj instanceof style["default"], 41); // Expected an `ol.style.Style` or an array of `ol.style.Style`
      styles = [obj];
    }
    styleFunction = function styleFunction() {
      return styles;
    };
  }
  return styleFunction;
};
/* harmony default export */ var ol_feature = (feature__ol_Feature_);
// EXTERNAL MODULE: ./node_modules/ol/obj.js
var ol_obj = __webpack_require__(2);

// EXTERNAL MODULE: ./node_modules/ol/proj.js + 7 modules
var proj = __webpack_require__(16);

// CONCATENATED MODULE: ./node_modules/ol/format/feature.js




/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for feature formats.
 * {ol.format.Feature} subclasses provide the ability to decode and encode
 * {@link ol.Feature} objects from a variety of commonly used geospatial
 * file formats.  See the documentation for each format for more details.
 *
 * @constructor
 * @abstract
 * @api
 */
var _ol_format_Feature_ = function _ol_format_Feature_() {

  /**
   * @protected
   * @type {ol.proj.Projection}
   */
  this.defaultDataProjection = null;

  /**
   * @protected
   * @type {ol.proj.Projection}
   */
  this.defaultFeatureProjection = null;
};

/**
 * Adds the data projection to the read options.
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Options.
 * @return {olx.format.ReadOptions|undefined} Options.
 * @protected
 */
_ol_format_Feature_.prototype.getReadOptions = function (source, opt_options) {
  var options;
  if (opt_options) {
    options = {
      dataProjection: opt_options.dataProjection ? opt_options.dataProjection : this.readProjection(source),
      featureProjection: opt_options.featureProjection
    };
  }
  return this.adaptOptions(options);
};

/**
 * Sets the `defaultDataProjection` on the options, if no `dataProjection`
 * is set.
 * @param {olx.format.WriteOptions|olx.format.ReadOptions|undefined} options
 *     Options.
 * @protected
 * @return {olx.format.WriteOptions|olx.format.ReadOptions|undefined}
 *     Updated options.
 */
_ol_format_Feature_.prototype.adaptOptions = function (options) {
  return ol_obj["a" /* default */].assign({
    dataProjection: this.defaultDataProjection,
    featureProjection: this.defaultFeatureProjection
  }, options);
};

/**
 * Get the extent from the source of the last {@link readFeatures} call.
 * @return {ol.Extent} Tile extent.
 */
_ol_format_Feature_.prototype.getLastExtent = function () {
  return null;
};

/**
 * @abstract
 * @return {ol.format.FormatType} Format.
 */
_ol_format_Feature_.prototype.getType = function () {};

/**
 * Read a single feature from a source.
 *
 * @abstract
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.Feature} Feature.
 */
_ol_format_Feature_.prototype.readFeature = function (source, opt_options) {};

/**
 * Read all features from a source.
 *
 * @abstract
 * @param {Document|Node|ArrayBuffer|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {Array.<ol.Feature>} Features.
 */
_ol_format_Feature_.prototype.readFeatures = function (source, opt_options) {};

/**
 * Read a single geometry from a source.
 *
 * @abstract
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.geom.Geometry} Geometry.
 */
_ol_format_Feature_.prototype.readGeometry = function (source, opt_options) {};

/**
 * Read the projection from a source.
 *
 * @abstract
 * @param {Document|Node|Object|string} source Source.
 * @return {ol.proj.Projection} Projection.
 */
_ol_format_Feature_.prototype.readProjection = function (source) {};

/**
 * Encode a feature in this format.
 *
 * @abstract
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} Result.
 */
_ol_format_Feature_.prototype.writeFeature = function (feature, opt_options) {};

/**
 * Encode an array of features in this format.
 *
 * @abstract
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} Result.
 */
_ol_format_Feature_.prototype.writeFeatures = function (features, opt_options) {};

/**
 * Write a single geometry in this format.
 *
 * @abstract
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} Result.
 */
_ol_format_Feature_.prototype.writeGeometry = function (geometry, opt_options) {};

/**
 * @param {ol.geom.Geometry|ol.Extent} geometry Geometry.
 * @param {boolean} write Set to true for writing, false for reading.
 * @param {(olx.format.WriteOptions|olx.format.ReadOptions)=} opt_options
 *     Options.
 * @return {ol.geom.Geometry|ol.Extent} Transformed geometry.
 * @protected
 */
_ol_format_Feature_.transformWithOptions = function (geometry, write, opt_options) {
  var featureProjection = opt_options ? proj["default"].get(opt_options.featureProjection) : null;
  var dataProjection = opt_options ? proj["default"].get(opt_options.dataProjection) : null;
  /**
   * @type {ol.geom.Geometry|ol.Extent}
   */
  var transformed;
  if (featureProjection && dataProjection && !proj["default"].equivalent(featureProjection, dataProjection)) {
    if (geometry instanceof geom_geometry["a" /* default */]) {
      transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
    } else {
      // FIXME this is necessary because ol.format.GML treats extents
      // as geometries
      transformed = proj["default"].transformExtent(geometry, dataProjection, featureProjection);
    }
  } else {
    transformed = geometry;
  }
  if (write && opt_options && opt_options.decimals !== undefined) {
    var power = Math.pow(10, opt_options.decimals);
    // if decimals option on write, round each coordinate appropriately
    /**
     * @param {Array.<number>} coordinates Coordinates.
     * @return {Array.<number>} Transformed coordinates.
     */
    var transform = function transform(coordinates) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
        coordinates[i] = Math.round(coordinates[i] * power) / power;
      }
      return coordinates;
    };
    if (transformed === geometry) {
      transformed = transformed.clone();
    }
    transformed.applyTransform(transform);
  }
  return transformed;
};
/* harmony default export */ var format_feature = (_ol_format_Feature_);
// EXTERNAL MODULE: ./node_modules/ol/format/formattype.js
var formattype = __webpack_require__(78);

// CONCATENATED MODULE: ./node_modules/ol/format/jsonfeature.js




/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for JSON feature formats.
 *
 * @constructor
 * @abstract
 * @extends {ol.format.Feature}
 */
var jsonfeature__ol_format_JSONFeature_ = function _ol_format_JSONFeature_() {
  format_feature.call(this);
};

ol["a" /* default */].inherits(jsonfeature__ol_format_JSONFeature_, format_feature);

/**
 * @param {Document|Node|Object|string} source Source.
 * @private
 * @return {Object} Object.
 */
jsonfeature__ol_format_JSONFeature_.prototype.getObject_ = function (source) {
  if (typeof source === 'string') {
    var object = JSON.parse(source);
    return object ? /** @type {Object} */object : null;
  } else if (source !== null) {
    return source;
  } else {
    return null;
  }
};

/**
 * @inheritDoc
 */
jsonfeature__ol_format_JSONFeature_.prototype.getType = function () {
  return formattype["a" /* default */].JSON;
};

/**
 * @inheritDoc
 */
jsonfeature__ol_format_JSONFeature_.prototype.readFeature = function (source, opt_options) {
  return this.readFeatureFromObject(this.getObject_(source), this.getReadOptions(source, opt_options));
};

/**
 * @inheritDoc
 */
jsonfeature__ol_format_JSONFeature_.prototype.readFeatures = function (source, opt_options) {
  return this.readFeaturesFromObject(this.getObject_(source), this.getReadOptions(source, opt_options));
};

/**
 * @abstract
 * @param {Object} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @protected
 * @return {ol.Feature} Feature.
 */
jsonfeature__ol_format_JSONFeature_.prototype.readFeatureFromObject = function (object, opt_options) {};

/**
 * @abstract
 * @param {Object} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @protected
 * @return {Array.<ol.Feature>} Features.
 */
jsonfeature__ol_format_JSONFeature_.prototype.readFeaturesFromObject = function (object, opt_options) {};

/**
 * @inheritDoc
 */
jsonfeature__ol_format_JSONFeature_.prototype.readGeometry = function (source, opt_options) {
  return this.readGeometryFromObject(this.getObject_(source), this.getReadOptions(source, opt_options));
};

/**
 * @abstract
 * @param {Object} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @protected
 * @return {ol.geom.Geometry} Geometry.
 */
jsonfeature__ol_format_JSONFeature_.prototype.readGeometryFromObject = function (object, opt_options) {};

/**
 * @inheritDoc
 */
jsonfeature__ol_format_JSONFeature_.prototype.readProjection = function (source) {
  return this.readProjectionFromObject(this.getObject_(source));
};

/**
 * @abstract
 * @param {Object} object Object.
 * @protected
 * @return {ol.proj.Projection} Projection.
 */
jsonfeature__ol_format_JSONFeature_.prototype.readProjectionFromObject = function (object) {};

/**
 * @inheritDoc
 */
jsonfeature__ol_format_JSONFeature_.prototype.writeFeature = function (feature, opt_options) {
  return JSON.stringify(this.writeFeatureObject(feature, opt_options));
};

/**
 * @abstract
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {Object} Object.
 */
jsonfeature__ol_format_JSONFeature_.prototype.writeFeatureObject = function (feature, opt_options) {};

/**
 * @inheritDoc
 */
jsonfeature__ol_format_JSONFeature_.prototype.writeFeatures = function (features, opt_options) {
  return JSON.stringify(this.writeFeaturesObject(features, opt_options));
};

/**
 * @abstract
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {Object} Object.
 */
jsonfeature__ol_format_JSONFeature_.prototype.writeFeaturesObject = function (features, opt_options) {};

/**
 * @inheritDoc
 */
jsonfeature__ol_format_JSONFeature_.prototype.writeGeometry = function (geometry, opt_options) {
  return JSON.stringify(this.writeGeometryObject(geometry, opt_options));
};

/**
 * @abstract
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {Object} Object.
 */
jsonfeature__ol_format_JSONFeature_.prototype.writeGeometryObject = function (geometry, opt_options) {};
/* harmony default export */ var jsonfeature = (jsonfeature__ol_format_JSONFeature_);
// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__(1);

// EXTERNAL MODULE: ./node_modules/ol/geom/geometrytype.js
var geometrytype = __webpack_require__(10);

// CONCATENATED MODULE: ./node_modules/ol/geom/geometrycollection.js








/**
 * @classdesc
 * An array of {@link ol.geom.Geometry} objects.
 *
 * @constructor
 * @extends {ol.geom.Geometry}
 * @param {Array.<ol.geom.Geometry>=} opt_geometries Geometries.
 * @api
 */
var geometrycollection__ol_geom_GeometryCollection_ = function _ol_geom_GeometryCollection_(opt_geometries) {

  geom_geometry["a" /* default */].call(this);

  /**
   * @private
   * @type {Array.<ol.geom.Geometry>}
   */
  this.geometries_ = opt_geometries ? opt_geometries : null;

  this.listenGeometriesChange_();
};

ol["a" /* default */].inherits(geometrycollection__ol_geom_GeometryCollection_, geom_geometry["a" /* default */]);

/**
 * @param {Array.<ol.geom.Geometry>} geometries Geometries.
 * @private
 * @return {Array.<ol.geom.Geometry>} Cloned geometries.
 */
geometrycollection__ol_geom_GeometryCollection_.cloneGeometries_ = function (geometries) {
  var clonedGeometries = [];
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    clonedGeometries.push(geometries[i].clone());
  }
  return clonedGeometries;
};

/**
 * @private
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.unlistenGeometriesChange_ = function () {
  var i, ii;
  if (!this.geometries_) {
    return;
  }
  for (i = 0, ii = this.geometries_.length; i < ii; ++i) {
    events["a" /* default */].unlisten(this.geometries_[i], eventtype["a" /* default */].CHANGE, this.changed, this);
  }
};

/**
 * @private
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.listenGeometriesChange_ = function () {
  var i, ii;
  if (!this.geometries_) {
    return;
  }
  for (i = 0, ii = this.geometries_.length; i < ii; ++i) {
    events["a" /* default */].listen(this.geometries_[i], eventtype["a" /* default */].CHANGE, this.changed, this);
  }
};

/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.GeometryCollection} Clone.
 * @override
 * @api
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.clone = function () {
  var geometryCollection = new geometrycollection__ol_geom_GeometryCollection_(null);
  geometryCollection.setGeometries(this.geometries_);
  return geometryCollection;
};

/**
 * @inheritDoc
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < ol_extent["a" /* default */].closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  var geometries = this.geometries_;
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
  }
  return minSquaredDistance;
};

/**
 * @inheritDoc
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.containsXY = function (x, y) {
  var geometries = this.geometries_;
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    if (geometries[i].containsXY(x, y)) {
      return true;
    }
  }
  return false;
};

/**
 * @inheritDoc
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.computeExtent = function (extent) {
  ol_extent["a" /* default */].createOrUpdateEmpty(extent);
  var geometries = this.geometries_;
  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    ol_extent["a" /* default */].extend(extent, geometries[i].getExtent());
  }
  return extent;
};

/**
 * Return the geometries that make up this geometry collection.
 * @return {Array.<ol.geom.Geometry>} Geometries.
 * @api
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.getGeometries = function () {
  return geometrycollection__ol_geom_GeometryCollection_.cloneGeometries_(this.geometries_);
};

/**
 * @return {Array.<ol.geom.Geometry>} Geometries.
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.getGeometriesArray = function () {
  return this.geometries_;
};

/**
 * @inheritDoc
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.getSimplifiedGeometry = function (squaredTolerance) {
  if (this.simplifiedGeometryRevision != this.getRevision()) {
    ol_obj["a" /* default */].clear(this.simplifiedGeometryCache);
    this.simplifiedGeometryMaxMinSquaredTolerance = 0;
    this.simplifiedGeometryRevision = this.getRevision();
  }
  if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
    return this;
  }
  var key = squaredTolerance.toString();
  if (this.simplifiedGeometryCache.hasOwnProperty(key)) {
    return this.simplifiedGeometryCache[key];
  } else {
    var simplifiedGeometries = [];
    var geometries = this.geometries_;
    var simplified = false;
    var i, ii;
    for (i = 0, ii = geometries.length; i < ii; ++i) {
      var geometry = geometries[i];
      var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
      simplifiedGeometries.push(simplifiedGeometry);
      if (simplifiedGeometry !== geometry) {
        simplified = true;
      }
    }
    if (simplified) {
      var simplifiedGeometryCollection = new geometrycollection__ol_geom_GeometryCollection_(null);
      simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
      this.simplifiedGeometryCache[key] = simplifiedGeometryCollection;
      return simplifiedGeometryCollection;
    } else {
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
  }
};

/**
 * @inheritDoc
 * @api
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.getType = function () {
  return geometrytype["a" /* default */].GEOMETRY_COLLECTION;
};

/**
 * @inheritDoc
 * @api
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.intersectsExtent = function (extent) {
  var geometries = this.geometries_;
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    if (geometries[i].intersectsExtent(extent)) {
      return true;
    }
  }
  return false;
};

/**
 * @return {boolean} Is empty.
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.isEmpty = function () {
  return this.geometries_.length === 0;
};

/**
 * @inheritDoc
 * @api
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.rotate = function (angle, anchor) {
  var geometries = this.geometries_;
  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    geometries[i].rotate(angle, anchor);
  }
  this.changed();
};

/**
 * @inheritDoc
 * @api
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.scale = function (sx, opt_sy, opt_anchor) {
  var anchor = opt_anchor;
  if (!anchor) {
    anchor = ol_extent["a" /* default */].getCenter(this.getExtent());
  }
  var geometries = this.geometries_;
  for (var i = 0, ii = geometries.length; i < ii; ++i) {
    geometries[i].scale(sx, opt_sy, anchor);
  }
  this.changed();
};

/**
 * Set the geometries that make up this geometry collection.
 * @param {Array.<ol.geom.Geometry>} geometries Geometries.
 * @api
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.setGeometries = function (geometries) {
  this.setGeometriesArray(geometrycollection__ol_geom_GeometryCollection_.cloneGeometries_(geometries));
};

/**
 * @param {Array.<ol.geom.Geometry>} geometries Geometries.
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.setGeometriesArray = function (geometries) {
  this.unlistenGeometriesChange_();
  this.geometries_ = geometries;
  this.listenGeometriesChange_();
  this.changed();
};

/**
 * @inheritDoc
 * @api
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.applyTransform = function (transformFn) {
  var geometries = this.geometries_;
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    geometries[i].applyTransform(transformFn);
  }
  this.changed();
};

/**
 * Translate the geometry.
 * @param {number} deltaX Delta X.
 * @param {number} deltaY Delta Y.
 * @override
 * @api
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.translate = function (deltaX, deltaY) {
  var geometries = this.geometries_;
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    geometries[i].translate(deltaX, deltaY);
  }
  this.changed();
};

/**
 * @inheritDoc
 */
geometrycollection__ol_geom_GeometryCollection_.prototype.disposeInternal = function () {
  this.unlistenGeometriesChange_();
  geom_geometry["a" /* default */].prototype.disposeInternal.call(this);
};
/* harmony default export */ var geometrycollection = (geometrycollection__ol_geom_GeometryCollection_);
// EXTERNAL MODULE: ./node_modules/ol/array.js
var array = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/ol/geom/geometrylayout.js
var geometrylayout = __webpack_require__(28);

// EXTERNAL MODULE: ./node_modules/ol/geom/simplegeometry.js
var simplegeometry = __webpack_require__(22);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/closest.js
var closest = __webpack_require__(47);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/deflate.js
var deflate = __webpack_require__(33);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/inflate.js
var inflate = __webpack_require__(34);

// EXTERNAL MODULE: ./node_modules/ol/math.js
var math = __webpack_require__(6);

// CONCATENATED MODULE: ./node_modules/ol/geom/flat/interpolate.js


var _ol_geom_flat_interpolate_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} fraction Fraction.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Destination.
 */
_ol_geom_flat_interpolate_.lineString = function (flatCoordinates, offset, end, stride, fraction, opt_dest) {
  var pointX = NaN;
  var pointY = NaN;
  var n = (end - offset) / stride;
  if (n === 1) {
    pointX = flatCoordinates[offset];
    pointY = flatCoordinates[offset + 1];
  } else if (n == 2) {
    pointX = (1 - fraction) * flatCoordinates[offset] + fraction * flatCoordinates[offset + stride];
    pointY = (1 - fraction) * flatCoordinates[offset + 1] + fraction * flatCoordinates[offset + stride + 1];
  } else if (n !== 0) {
    var x1 = flatCoordinates[offset];
    var y1 = flatCoordinates[offset + 1];
    var length = 0;
    var cumulativeLengths = [0];
    var i;
    for (i = offset + stride; i < end; i += stride) {
      var x2 = flatCoordinates[i];
      var y2 = flatCoordinates[i + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length);
      x1 = x2;
      y1 = y2;
    }
    var target = fraction * length;
    var index = array["a" /* default */].binarySearch(cumulativeLengths, target);
    if (index < 0) {
      var t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      var o = offset + (-index - 2) * stride;
      pointX = math["a" /* default */].lerp(flatCoordinates[o], flatCoordinates[o + stride], t);
      pointY = math["a" /* default */].lerp(flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);
    } else {
      pointX = flatCoordinates[offset + index * stride];
      pointY = flatCoordinates[offset + index * stride + 1];
    }
  }
  if (opt_dest) {
    opt_dest[0] = pointX;
    opt_dest[1] = pointY;
    return opt_dest;
  } else {
    return [pointX, pointY];
  }
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @return {ol.Coordinate} Coordinate.
 */
_ol_geom_flat_interpolate_.lineStringCoordinateAtM = function (flatCoordinates, offset, end, stride, m, extrapolate) {
  if (end == offset) {
    return null;
  }
  var coordinate;
  if (m < flatCoordinates[offset + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset, offset + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  } else if (flatCoordinates[end - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  // FIXME use O(1) search
  if (m == flatCoordinates[offset + stride - 1]) {
    return flatCoordinates.slice(offset, offset + stride);
  }
  var lo = offset / stride;
  var hi = end / stride;
  while (lo < hi) {
    var mid = lo + hi >> 1;
    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  var m0 = flatCoordinates[lo * stride - 1];
  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  var m1 = flatCoordinates[(lo + 1) * stride - 1];
  var t = (m - m0) / (m1 - m0);
  coordinate = [];
  var i;
  for (i = 0; i < stride - 1; ++i) {
    coordinate.push(math["a" /* default */].lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
  }
  coordinate.push(m);
  return coordinate;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {number} m M.
 * @param {boolean} extrapolate Extrapolate.
 * @param {boolean} interpolate Interpolate.
 * @return {ol.Coordinate} Coordinate.
 */
_ol_geom_flat_interpolate_.lineStringsCoordinateAtM = function (flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
  if (interpolate) {
    return _ol_geom_flat_interpolate_.lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
  }
  var coordinate;
  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    } else {
      return null;
    }
  }
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    if (offset == end) {
      continue;
    }
    if (m < flatCoordinates[offset + stride - 1]) {
      return null;
    } else if (m <= flatCoordinates[end - 1]) {
      return _ol_geom_flat_interpolate_.lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
    }
    offset = end;
  }
  return null;
};
/* harmony default export */ var flat_interpolate = (_ol_geom_flat_interpolate_);
// EXTERNAL MODULE: ./node_modules/ol/geom/flat/intersectsextent.js
var intersectsextent = __webpack_require__(58);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/length.js
var flat_length = __webpack_require__(80);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/segments.js
var segments = __webpack_require__(79);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/simplify.js
var simplify = __webpack_require__(41);

// CONCATENATED MODULE: ./node_modules/ol/geom/linestring.js















/**
 * @classdesc
 * Linestring geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var linestring__ol_geom_LineString_ = function _ol_geom_LineString_(coordinates, opt_layout) {

  simplegeometry["a" /* default */].call(this);

  /**
   * @private
   * @type {ol.Coordinate}
   */
  this.flatMidpoint_ = null;

  /**
   * @private
   * @type {number}
   */
  this.flatMidpointRevision_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.maxDelta_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.maxDeltaRevision_ = -1;

  this.setCoordinates(coordinates, opt_layout);
};

ol["a" /* default */].inherits(linestring__ol_geom_LineString_, simplegeometry["a" /* default */]);

/**
 * Append the passed coordinate to the coordinates of the linestring.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @api
 */
linestring__ol_geom_LineString_.prototype.appendCoordinate = function (coordinate) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = coordinate.slice();
  } else {
    array["a" /* default */].extend(this.flatCoordinates, coordinate);
  }
  this.changed();
};

/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.LineString} Clone.
 * @override
 * @api
 */
linestring__ol_geom_LineString_.prototype.clone = function () {
  var lineString = new linestring__ol_geom_LineString_(null);
  lineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return lineString;
};

/**
 * @inheritDoc
 */
linestring__ol_geom_LineString_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < ol_extent["a" /* default */].closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(closest["a" /* default */].getMaxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }
  return closest["a" /* default */].getClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
};

/**
 * Iterate over each segment, calling the provided callback.
 * If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 *
 * @param {function(this: S, ol.Coordinate, ol.Coordinate): T} callback Function
 *     called for each segment.
 * @param {S=} opt_this The object to be used as the value of 'this'
 *     within callback.
 * @return {T|boolean} Value.
 * @template T,S
 * @api
 */
linestring__ol_geom_LineString_.prototype.forEachSegment = function (callback, opt_this) {
  return segments["a" /* default */].forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback, opt_this);
};

/**
 * Returns the coordinate at `m` using linear interpolation, or `null` if no
 * such coordinate exists.
 *
 * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
 * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
 * M will return the first coordinate and Ms greater than the last M will
 * return the last coordinate.
 *
 * @param {number} m M.
 * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */
linestring__ol_geom_LineString_.prototype.getCoordinateAtM = function (m, opt_extrapolate) {
  if (this.layout != geometrylayout["a" /* default */].XYM && this.layout != geometrylayout["a" /* default */].XYZM) {
    return null;
  }
  var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
  return flat_interpolate.lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
};

/**
 * Return the coordinates of the linestring.
 * @return {Array.<ol.Coordinate>} Coordinates.
 * @override
 * @api
 */
linestring__ol_geom_LineString_.prototype.getCoordinates = function () {
  return inflate["a" /* default */].coordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};

/**
 * Return the coordinate at the provided fraction along the linestring.
 * The `fraction` is a number between 0 and 1, where 0 is the start of the
 * linestring and 1 is the end.
 * @param {number} fraction Fraction.
 * @param {ol.Coordinate=} opt_dest Optional coordinate whose values will
 *     be modified. If not provided, a new coordinate will be returned.
 * @return {ol.Coordinate} Coordinate of the interpolated point.
 * @api
 */
linestring__ol_geom_LineString_.prototype.getCoordinateAt = function (fraction, opt_dest) {
  return flat_interpolate.lineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest);
};

/**
 * Return the length of the linestring on projected plane.
 * @return {number} Length (on projected plane).
 * @api
 */
linestring__ol_geom_LineString_.prototype.getLength = function () {
  return flat_length["a" /* default */].lineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};

/**
 * @return {Array.<number>} Flat midpoint.
 */
linestring__ol_geom_LineString_.prototype.getFlatMidpoint = function () {
  if (this.flatMidpointRevision_ != this.getRevision()) {
    this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
    this.flatMidpointRevision_ = this.getRevision();
  }
  return this.flatMidpoint_;
};

/**
 * @inheritDoc
 */
linestring__ol_geom_LineString_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  simplifiedFlatCoordinates.length = simplify["a" /* default */].douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
  var simplifiedLineString = new linestring__ol_geom_LineString_(null);
  simplifiedLineString.setFlatCoordinates(geometrylayout["a" /* default */].XY, simplifiedFlatCoordinates);
  return simplifiedLineString;
};

/**
 * @inheritDoc
 * @api
 */
linestring__ol_geom_LineString_.prototype.getType = function () {
  return geometrytype["a" /* default */].LINE_STRING;
};

/**
 * @inheritDoc
 * @api
 */
linestring__ol_geom_LineString_.prototype.intersectsExtent = function (extent) {
  return intersectsextent["a" /* default */].lineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
};

/**
 * Set the coordinates of the linestring.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */
linestring__ol_geom_LineString_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(geometrylayout["a" /* default */].XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflate["a" /* default */].coordinates(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */
linestring__ol_geom_LineString_.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};
/* harmony default export */ var linestring = (linestring__ol_geom_LineString_);
// CONCATENATED MODULE: ./node_modules/ol/geom/multilinestring.js














/**
 * @classdesc
 * Multi-linestring geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var multilinestring__ol_geom_MultiLineString_ = function _ol_geom_MultiLineString_(coordinates, opt_layout) {

  simplegeometry["a" /* default */].call(this);

  /**
   * @type {Array.<number>}
   * @private
   */
  this.ends_ = [];

  /**
   * @private
   * @type {number}
   */
  this.maxDelta_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.maxDeltaRevision_ = -1;

  this.setCoordinates(coordinates, opt_layout);
};

ol["a" /* default */].inherits(multilinestring__ol_geom_MultiLineString_, simplegeometry["a" /* default */]);

/**
 * Append the passed linestring to the multilinestring.
 * @param {ol.geom.LineString} lineString LineString.
 * @api
 */
multilinestring__ol_geom_MultiLineString_.prototype.appendLineString = function (lineString) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = lineString.getFlatCoordinates().slice();
  } else {
    array["a" /* default */].extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());
  }
  this.ends_.push(this.flatCoordinates.length);
  this.changed();
};

/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.MultiLineString} Clone.
 * @override
 * @api
 */
multilinestring__ol_geom_MultiLineString_.prototype.clone = function () {
  var multiLineString = new multilinestring__ol_geom_MultiLineString_(null);
  multiLineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), this.ends_.slice());
  return multiLineString;
};

/**
 * @inheritDoc
 */
multilinestring__ol_geom_MultiLineString_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < ol_extent["a" /* default */].closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(closest["a" /* default */].getsMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }
  return closest["a" /* default */].getsClosestPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
};

/**
 * Returns the coordinate at `m` using linear interpolation, or `null` if no
 * such coordinate exists.
 *
 * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
 * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
 * M will return the first coordinate and Ms greater than the last M will
 * return the last coordinate.
 *
 * `opt_interpolate` controls interpolation between consecutive LineStrings
 * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
 * will be linearly interpolated between the last coordinate of one LineString
 * and the first coordinate of the next LineString.  If `opt_interpolate` is
 * `false` then the function will return `null` for Ms falling between
 * LineStrings.
 *
 * @param {number} m M.
 * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
 * @param {boolean=} opt_interpolate Interpolate. Default is `false`.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */
multilinestring__ol_geom_MultiLineString_.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {
  if (this.layout != geometrylayout["a" /* default */].XYM && this.layout != geometrylayout["a" /* default */].XYZM || this.flatCoordinates.length === 0) {
    return null;
  }
  var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
  var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
  return flat_interpolate.lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
};

/**
 * Return the coordinates of the multilinestring.
 * @return {Array.<Array.<ol.Coordinate>>} Coordinates.
 * @override
 * @api
 */
multilinestring__ol_geom_MultiLineString_.prototype.getCoordinates = function () {
  return inflate["a" /* default */].coordinatess(this.flatCoordinates, 0, this.ends_, this.stride);
};

/**
 * @return {Array.<number>} Ends.
 */
multilinestring__ol_geom_MultiLineString_.prototype.getEnds = function () {
  return this.ends_;
};

/**
 * Return the linestring at the specified index.
 * @param {number} index Index.
 * @return {ol.geom.LineString} LineString.
 * @api
 */
multilinestring__ol_geom_MultiLineString_.prototype.getLineString = function (index) {
  if (index < 0 || this.ends_.length <= index) {
    return null;
  }
  var lineString = new linestring(null);
  lineString.setFlatCoordinates(this.layout, this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]));
  return lineString;
};

/**
 * Return the linestrings of this multilinestring.
 * @return {Array.<ol.geom.LineString>} LineStrings.
 * @api
 */
multilinestring__ol_geom_MultiLineString_.prototype.getLineStrings = function () {
  var flatCoordinates = this.flatCoordinates;
  var ends = this.ends_;
  var layout = this.layout;
  /** @type {Array.<ol.geom.LineString>} */
  var lineStrings = [];
  var offset = 0;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var lineString = new linestring(null);
    lineString.setFlatCoordinates(layout, flatCoordinates.slice(offset, end));
    lineStrings.push(lineString);
    offset = end;
  }
  return lineStrings;
};

/**
 * @return {Array.<number>} Flat midpoints.
 */
multilinestring__ol_geom_MultiLineString_.prototype.getFlatMidpoints = function () {
  var midpoints = [];
  var flatCoordinates = this.flatCoordinates;
  var offset = 0;
  var ends = this.ends_;
  var stride = this.stride;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var midpoint = flat_interpolate.lineString(flatCoordinates, offset, end, stride, 0.5);
    array["a" /* default */].extend(midpoints, midpoint);
    offset = end;
  }
  return midpoints;
};

/**
 * @inheritDoc
 */
multilinestring__ol_geom_MultiLineString_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  var simplifiedEnds = [];
  simplifiedFlatCoordinates.length = simplify["a" /* default */].douglasPeuckers(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
  var simplifiedMultiLineString = new multilinestring__ol_geom_MultiLineString_(null);
  simplifiedMultiLineString.setFlatCoordinates(geometrylayout["a" /* default */].XY, simplifiedFlatCoordinates, simplifiedEnds);
  return simplifiedMultiLineString;
};

/**
 * @inheritDoc
 * @api
 */
multilinestring__ol_geom_MultiLineString_.prototype.getType = function () {
  return geometrytype["a" /* default */].MULTI_LINE_STRING;
};

/**
 * @inheritDoc
 * @api
 */
multilinestring__ol_geom_MultiLineString_.prototype.intersectsExtent = function (extent) {
  return intersectsextent["a" /* default */].lineStrings(this.flatCoordinates, 0, this.ends_, this.stride, extent);
};

/**
 * Set the coordinates of the multilinestring.
 * @param {Array.<Array.<ol.Coordinate>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */
multilinestring__ol_geom_MultiLineString_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(geometrylayout["a" /* default */].XY, null, this.ends_);
  } else {
    this.setLayout(opt_layout, coordinates, 2);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var ends = deflate["a" /* default */].coordinatess(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
    this.changed();
  }
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<number>} ends Ends.
 */
multilinestring__ol_geom_MultiLineString_.prototype.setFlatCoordinates = function (layout, flatCoordinates, ends) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.ends_ = ends;
  this.changed();
};

/**
 * @param {Array.<ol.geom.LineString>} lineStrings LineStrings.
 */
multilinestring__ol_geom_MultiLineString_.prototype.setLineStrings = function (lineStrings) {
  var layout = this.getLayout();
  var flatCoordinates = [];
  var ends = [];
  var i, ii;
  for (i = 0, ii = lineStrings.length; i < ii; ++i) {
    var lineString = lineStrings[i];
    if (i === 0) {
      layout = lineString.getLayout();
    }
    array["a" /* default */].extend(flatCoordinates, lineString.getFlatCoordinates());
    ends.push(flatCoordinates.length);
  }
  this.setFlatCoordinates(layout, flatCoordinates, ends);
};
/* harmony default export */ var multilinestring = (multilinestring__ol_geom_MultiLineString_);
// EXTERNAL MODULE: ./node_modules/ol/geom/point.js
var geom_point = __webpack_require__(67);

// CONCATENATED MODULE: ./node_modules/ol/geom/multipoint.js











/**
 * @classdesc
 * Multi-point geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var multipoint__ol_geom_MultiPoint_ = function _ol_geom_MultiPoint_(coordinates, opt_layout) {
  simplegeometry["a" /* default */].call(this);
  this.setCoordinates(coordinates, opt_layout);
};

ol["a" /* default */].inherits(multipoint__ol_geom_MultiPoint_, simplegeometry["a" /* default */]);

/**
 * Append the passed point to this multipoint.
 * @param {ol.geom.Point} point Point.
 * @api
 */
multipoint__ol_geom_MultiPoint_.prototype.appendPoint = function (point) {
  if (!this.flatCoordinates) {
    this.flatCoordinates = point.getFlatCoordinates().slice();
  } else {
    array["a" /* default */].extend(this.flatCoordinates, point.getFlatCoordinates());
  }
  this.changed();
};

/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.MultiPoint} Clone.
 * @override
 * @api
 */
multipoint__ol_geom_MultiPoint_.prototype.clone = function () {
  var multiPoint = new multipoint__ol_geom_MultiPoint_(null);
  multiPoint.setFlatCoordinates(this.layout, this.flatCoordinates.slice());
  return multiPoint;
};

/**
 * @inheritDoc
 */
multipoint__ol_geom_MultiPoint_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < ol_extent["a" /* default */].closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  var flatCoordinates = this.flatCoordinates;
  var stride = this.stride;
  var i, ii, j;
  for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
    var squaredDistance = math["a" /* default */].squaredDistance(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
    if (squaredDistance < minSquaredDistance) {
      minSquaredDistance = squaredDistance;
      for (j = 0; j < stride; ++j) {
        closestPoint[j] = flatCoordinates[i + j];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
};

/**
 * Return the coordinates of the multipoint.
 * @return {Array.<ol.Coordinate>} Coordinates.
 * @override
 * @api
 */
multipoint__ol_geom_MultiPoint_.prototype.getCoordinates = function () {
  return inflate["a" /* default */].coordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
};

/**
 * Return the point at the specified index.
 * @param {number} index Index.
 * @return {ol.geom.Point} Point.
 * @api
 */
multipoint__ol_geom_MultiPoint_.prototype.getPoint = function (index) {
  var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;
  if (index < 0 || n <= index) {
    return null;
  }
  var point = new geom_point["a" /* default */](null);
  point.setFlatCoordinates(this.layout, this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride));
  return point;
};

/**
 * Return the points of this multipoint.
 * @return {Array.<ol.geom.Point>} Points.
 * @api
 */
multipoint__ol_geom_MultiPoint_.prototype.getPoints = function () {
  var flatCoordinates = this.flatCoordinates;
  var layout = this.layout;
  var stride = this.stride;
  /** @type {Array.<ol.geom.Point>} */
  var points = [];
  var i, ii;
  for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
    var point = new geom_point["a" /* default */](null);
    point.setFlatCoordinates(layout, flatCoordinates.slice(i, i + stride));
    points.push(point);
  }
  return points;
};

/**
 * @inheritDoc
 * @api
 */
multipoint__ol_geom_MultiPoint_.prototype.getType = function () {
  return geometrytype["a" /* default */].MULTI_POINT;
};

/**
 * @inheritDoc
 * @api
 */
multipoint__ol_geom_MultiPoint_.prototype.intersectsExtent = function (extent) {
  var flatCoordinates = this.flatCoordinates;
  var stride = this.stride;
  var i, ii, x, y;
  for (i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
    x = flatCoordinates[i];
    y = flatCoordinates[i + 1];
    if (ol_extent["a" /* default */].containsXY(extent, x, y)) {
      return true;
    }
  }
  return false;
};

/**
 * Set the coordinates of the multipoint.
 * @param {Array.<ol.Coordinate>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */
multipoint__ol_geom_MultiPoint_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(geometrylayout["a" /* default */].XY, null);
  } else {
    this.setLayout(opt_layout, coordinates, 1);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    this.flatCoordinates.length = deflate["a" /* default */].coordinates(this.flatCoordinates, 0, coordinates, this.stride);
    this.changed();
  }
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 */
multipoint__ol_geom_MultiPoint_.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.changed();
};
/* harmony default export */ var multipoint = (multipoint__ol_geom_MultiPoint_);
// EXTERNAL MODULE: ./node_modules/ol/geom/polygon.js + 1 modules
var geom_polygon = __webpack_require__(59);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/area.js
var flat_area = __webpack_require__(60);

// CONCATENATED MODULE: ./node_modules/ol/geom/flat/center.js

var _ol_geom_flat_center_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @return {Array.<number>} Flat centers.
 */
_ol_geom_flat_center_.linearRingss = function (flatCoordinates, offset, endss, stride) {
  var flatCenters = [];
  var i, ii;
  var extent = ol_extent["a" /* default */].createEmpty();
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    extent = ol_extent["a" /* default */].createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset = ends[ends.length - 1];
  }
  return flatCenters;
};
/* harmony default export */ var center = (_ol_geom_flat_center_);
// EXTERNAL MODULE: ./node_modules/ol/geom/flat/contains.js
var contains = __webpack_require__(48);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/interiorpoint.js
var interiorpoint = __webpack_require__(81);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/orient.js + 1 modules
var orient = __webpack_require__(61);

// CONCATENATED MODULE: ./node_modules/ol/geom/multipolygon.js



















/**
 * @classdesc
 * Multi-polygon geometry.
 *
 * @constructor
 * @extends {ol.geom.SimpleGeometry}
 * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @api
 */
var multipolygon__ol_geom_MultiPolygon_ = function _ol_geom_MultiPolygon_(coordinates, opt_layout) {

  simplegeometry["a" /* default */].call(this);

  /**
   * @type {Array.<Array.<number>>}
   * @private
   */
  this.endss_ = [];

  /**
   * @private
   * @type {number}
   */
  this.flatInteriorPointsRevision_ = -1;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.flatInteriorPoints_ = null;

  /**
   * @private
   * @type {number}
   */
  this.maxDelta_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.maxDeltaRevision_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.orientedRevision_ = -1;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.orientedFlatCoordinates_ = null;

  this.setCoordinates(coordinates, opt_layout);
};

ol["a" /* default */].inherits(multipolygon__ol_geom_MultiPolygon_, simplegeometry["a" /* default */]);

/**
 * Append the passed polygon to this multipolygon.
 * @param {ol.geom.Polygon} polygon Polygon.
 * @api
 */
multipolygon__ol_geom_MultiPolygon_.prototype.appendPolygon = function (polygon) {
  /** @type {Array.<number>} */
  var ends;
  if (!this.flatCoordinates) {
    this.flatCoordinates = polygon.getFlatCoordinates().slice();
    ends = polygon.getEnds().slice();
    this.endss_.push();
  } else {
    var offset = this.flatCoordinates.length;
    array["a" /* default */].extend(this.flatCoordinates, polygon.getFlatCoordinates());
    ends = polygon.getEnds().slice();
    var i, ii;
    for (i = 0, ii = ends.length; i < ii; ++i) {
      ends[i] += offset;
    }
  }
  this.endss_.push(ends);
  this.changed();
};

/**
 * Make a complete copy of the geometry.
 * @return {!ol.geom.MultiPolygon} Clone.
 * @override
 * @api
 */
multipolygon__ol_geom_MultiPolygon_.prototype.clone = function () {
  var multiPolygon = new multipolygon__ol_geom_MultiPolygon_(null);

  var len = this.endss_.length;
  var newEndss = new Array(len);
  for (var i = 0; i < len; ++i) {
    newEndss[i] = this.endss_[i].slice();
  }

  multiPolygon.setFlatCoordinates(this.layout, this.flatCoordinates.slice(), newEndss);
  return multiPolygon;
};

/**
 * @inheritDoc
 */
multipolygon__ol_geom_MultiPolygon_.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
  if (minSquaredDistance < ol_extent["a" /* default */].closestSquaredDistanceXY(this.getExtent(), x, y)) {
    return minSquaredDistance;
  }
  if (this.maxDeltaRevision_ != this.getRevision()) {
    this.maxDelta_ = Math.sqrt(closest["a" /* default */].getssMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));
    this.maxDeltaRevision_ = this.getRevision();
  }
  return closest["a" /* default */].getssClosestPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
};

/**
 * @inheritDoc
 */
multipolygon__ol_geom_MultiPolygon_.prototype.containsXY = function (x, y) {
  return contains["a" /* default */].linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
};

/**
 * Return the area of the multipolygon on projected plane.
 * @return {number} Area (on projected plane).
 * @api
 */
multipolygon__ol_geom_MultiPolygon_.prototype.getArea = function () {
  return flat_area["a" /* default */].linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
};

/**
 * Get the coordinate array for this geometry.  This array has the structure
 * of a GeoJSON coordinate array for multi-polygons.
 *
 * @param {boolean=} opt_right Orient coordinates according to the right-hand
 *     rule (counter-clockwise for exterior and clockwise for interior rings).
 *     If `false`, coordinates will be oriented according to the left-hand rule
 *     (clockwise for exterior and counter-clockwise for interior rings).
 *     By default, coordinate orientation will depend on how the geometry was
 *     constructed.
 * @return {Array.<Array.<Array.<ol.Coordinate>>>} Coordinates.
 * @override
 * @api
 */
multipolygon__ol_geom_MultiPolygon_.prototype.getCoordinates = function (opt_right) {
  var flatCoordinates;
  if (opt_right !== undefined) {
    flatCoordinates = this.getOrientedFlatCoordinates().slice();
    orient["a" /* default */].orientLinearRingss(flatCoordinates, 0, this.endss_, this.stride, opt_right);
  } else {
    flatCoordinates = this.flatCoordinates;
  }

  return inflate["a" /* default */].coordinatesss(flatCoordinates, 0, this.endss_, this.stride);
};

/**
 * @return {Array.<Array.<number>>} Endss.
 */
multipolygon__ol_geom_MultiPolygon_.prototype.getEndss = function () {
  return this.endss_;
};

/**
 * @return {Array.<number>} Flat interior points.
 */
multipolygon__ol_geom_MultiPolygon_.prototype.getFlatInteriorPoints = function () {
  if (this.flatInteriorPointsRevision_ != this.getRevision()) {
    var flatCenters = center.linearRingss(this.flatCoordinates, 0, this.endss_, this.stride);
    this.flatInteriorPoints_ = interiorpoint["a" /* default */].linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
    this.flatInteriorPointsRevision_ = this.getRevision();
  }
  return this.flatInteriorPoints_;
};

/**
 * Return the interior points as {@link ol.geom.MultiPoint multipoint}.
 * @return {ol.geom.MultiPoint} Interior points as XYM coordinates, where M is
 * the length of the horizontal intersection that the point belongs to.
 * @api
 */
multipolygon__ol_geom_MultiPolygon_.prototype.getInteriorPoints = function () {
  var interiorPoints = new multipoint(null);
  interiorPoints.setFlatCoordinates(geometrylayout["a" /* default */].XYM, this.getFlatInteriorPoints().slice());
  return interiorPoints;
};

/**
 * @return {Array.<number>} Oriented flat coordinates.
 */
multipolygon__ol_geom_MultiPolygon_.prototype.getOrientedFlatCoordinates = function () {
  if (this.orientedRevision_ != this.getRevision()) {
    var flatCoordinates = this.flatCoordinates;
    if (orient["a" /* default */].linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
      this.orientedFlatCoordinates_ = flatCoordinates;
    } else {
      this.orientedFlatCoordinates_ = flatCoordinates.slice();
      this.orientedFlatCoordinates_.length = orient["a" /* default */].orientLinearRingss(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
    }
    this.orientedRevision_ = this.getRevision();
  }
  return this.orientedFlatCoordinates_;
};

/**
 * @inheritDoc
 */
multipolygon__ol_geom_MultiPolygon_.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
  var simplifiedFlatCoordinates = [];
  var simplifiedEndss = [];
  simplifiedFlatCoordinates.length = simplify["a" /* default */].quantizess(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
  var simplifiedMultiPolygon = new multipolygon__ol_geom_MultiPolygon_(null);
  simplifiedMultiPolygon.setFlatCoordinates(geometrylayout["a" /* default */].XY, simplifiedFlatCoordinates, simplifiedEndss);
  return simplifiedMultiPolygon;
};

/**
 * Return the polygon at the specified index.
 * @param {number} index Index.
 * @return {ol.geom.Polygon} Polygon.
 * @api
 */
multipolygon__ol_geom_MultiPolygon_.prototype.getPolygon = function (index) {
  if (index < 0 || this.endss_.length <= index) {
    return null;
  }
  var offset;
  if (index === 0) {
    offset = 0;
  } else {
    var prevEnds = this.endss_[index - 1];
    offset = prevEnds[prevEnds.length - 1];
  }
  var ends = this.endss_[index].slice();
  var end = ends[ends.length - 1];
  if (offset !== 0) {
    var i, ii;
    for (i = 0, ii = ends.length; i < ii; ++i) {
      ends[i] -= offset;
    }
  }
  var polygon = new geom_polygon["a" /* default */](null);
  polygon.setFlatCoordinates(this.layout, this.flatCoordinates.slice(offset, end), ends);
  return polygon;
};

/**
 * Return the polygons of this multipolygon.
 * @return {Array.<ol.geom.Polygon>} Polygons.
 * @api
 */
multipolygon__ol_geom_MultiPolygon_.prototype.getPolygons = function () {
  var layout = this.layout;
  var flatCoordinates = this.flatCoordinates;
  var endss = this.endss_;
  var polygons = [];
  var offset = 0;
  var i, ii, j, jj;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i].slice();
    var end = ends[ends.length - 1];
    if (offset !== 0) {
      for (j = 0, jj = ends.length; j < jj; ++j) {
        ends[j] -= offset;
      }
    }
    var polygon = new geom_polygon["a" /* default */](null);
    polygon.setFlatCoordinates(layout, flatCoordinates.slice(offset, end), ends);
    polygons.push(polygon);
    offset = end;
  }
  return polygons;
};

/**
 * @inheritDoc
 * @api
 */
multipolygon__ol_geom_MultiPolygon_.prototype.getType = function () {
  return geometrytype["a" /* default */].MULTI_POLYGON;
};

/**
 * @inheritDoc
 * @api
 */
multipolygon__ol_geom_MultiPolygon_.prototype.intersectsExtent = function (extent) {
  return intersectsextent["a" /* default */].linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
};

/**
 * Set the coordinates of the multipolygon.
 * @param {Array.<Array.<Array.<ol.Coordinate>>>} coordinates Coordinates.
 * @param {ol.geom.GeometryLayout=} opt_layout Layout.
 * @override
 * @api
 */
multipolygon__ol_geom_MultiPolygon_.prototype.setCoordinates = function (coordinates, opt_layout) {
  if (!coordinates) {
    this.setFlatCoordinates(geometrylayout["a" /* default */].XY, null, this.endss_);
  } else {
    this.setLayout(opt_layout, coordinates, 3);
    if (!this.flatCoordinates) {
      this.flatCoordinates = [];
    }
    var endss = deflate["a" /* default */].coordinatesss(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
    if (endss.length === 0) {
      this.flatCoordinates.length = 0;
    } else {
      var lastEnds = endss[endss.length - 1];
      this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
    }
    this.changed();
  }
};

/**
 * @param {ol.geom.GeometryLayout} layout Layout.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<Array.<number>>} endss Endss.
 */
multipolygon__ol_geom_MultiPolygon_.prototype.setFlatCoordinates = function (layout, flatCoordinates, endss) {
  this.setFlatCoordinatesInternal(layout, flatCoordinates);
  this.endss_ = endss;
  this.changed();
};

/**
 * @param {Array.<ol.geom.Polygon>} polygons Polygons.
 */
multipolygon__ol_geom_MultiPolygon_.prototype.setPolygons = function (polygons) {
  var layout = this.getLayout();
  var flatCoordinates = [];
  var endss = [];
  var i, ii, ends;
  for (i = 0, ii = polygons.length; i < ii; ++i) {
    var polygon = polygons[i];
    if (i === 0) {
      layout = polygon.getLayout();
    }
    var offset = flatCoordinates.length;
    ends = polygon.getEnds();
    var j, jj;
    for (j = 0, jj = ends.length; j < jj; ++j) {
      ends[j] += offset;
    }
    array["a" /* default */].extend(flatCoordinates, polygon.getFlatCoordinates());
    endss.push(ends);
  }
  this.setFlatCoordinates(layout, flatCoordinates, endss);
};
/* harmony default export */ var multipolygon = (multipolygon__ol_geom_MultiPolygon_);
// CONCATENATED MODULE: ./node_modules/ol/format/geojson.js
// TODO: serialize dataProjection as crs member when writing
// see https://github.com/openlayers/openlayers/issues/2078
















/**
 * @classdesc
 * Feature format for reading and writing data in the GeoJSON format.
 *
 * @constructor
 * @extends {ol.format.JSONFeature}
 * @param {olx.format.GeoJSONOptions=} opt_options Options.
 * @api
 */
var geojson__ol_format_GeoJSON_ = function _ol_format_GeoJSON_(opt_options) {

  var options = opt_options ? opt_options : {};

  jsonfeature.call(this);

  /**
   * @inheritDoc
   */
  this.defaultDataProjection = proj["default"].get(options.defaultDataProjection ? options.defaultDataProjection : 'EPSG:4326');

  if (options.featureProjection) {
    this.defaultFeatureProjection = proj["default"].get(options.featureProjection);
  }

  /**
   * Name of the geometry attribute for features.
   * @type {string|undefined}
   * @private
   */
  this.geometryName_ = options.geometryName;

  /**
   * Look for the geometry name in the feature GeoJSON
   * @type {boolean|undefined}
   * @private
   */
  this.extractGeometryName_ = options.extractGeometryName;
};

ol["a" /* default */].inherits(geojson__ol_format_GeoJSON_, jsonfeature);

/**
 * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @private
 * @return {ol.geom.Geometry} Geometry.
 */
geojson__ol_format_GeoJSON_.readGeometry_ = function (object, opt_options) {
  if (!object) {
    return null;
  }
  var geometryReader = geojson__ol_format_GeoJSON_.GEOMETRY_READERS_[object.type];
  return (
    /** @type {ol.geom.Geometry} */format_feature.transformWithOptions(geometryReader(object), false, opt_options)
  );
};

/**
 * @param {GeoJSONGeometryCollection} object Object.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @private
 * @return {ol.geom.GeometryCollection} Geometry collection.
 */
geojson__ol_format_GeoJSON_.readGeometryCollectionGeometry_ = function (object, opt_options) {
  var geometries = object.geometries.map(
  /**
   * @param {GeoJSONGeometry} geometry Geometry.
   * @return {ol.geom.Geometry} geometry Geometry.
   */
  function (geometry) {
    return geojson__ol_format_GeoJSON_.readGeometry_(geometry, opt_options);
  });
  return new geometrycollection(geometries);
};

/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.Point} Point.
 */
geojson__ol_format_GeoJSON_.readPointGeometry_ = function (object) {
  return new geom_point["a" /* default */](object.coordinates);
};

/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.LineString} LineString.
 */
geojson__ol_format_GeoJSON_.readLineStringGeometry_ = function (object) {
  return new linestring(object.coordinates);
};

/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.MultiLineString} MultiLineString.
 */
geojson__ol_format_GeoJSON_.readMultiLineStringGeometry_ = function (object) {
  return new multilinestring(object.coordinates);
};

/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.MultiPoint} MultiPoint.
 */
geojson__ol_format_GeoJSON_.readMultiPointGeometry_ = function (object) {
  return new multipoint(object.coordinates);
};

/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.MultiPolygon} MultiPolygon.
 */
geojson__ol_format_GeoJSON_.readMultiPolygonGeometry_ = function (object) {
  return new multipolygon(object.coordinates);
};

/**
 * @param {GeoJSONGeometry} object Object.
 * @private
 * @return {ol.geom.Polygon} Polygon.
 */
geojson__ol_format_GeoJSON_.readPolygonGeometry_ = function (object) {
  return new geom_polygon["a" /* default */](object.coordinates);
};

/**
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry|GeoJSONGeometryCollection} GeoJSON geometry.
 */
geojson__ol_format_GeoJSON_.writeGeometry_ = function (geometry, opt_options) {
  var geometryWriter = geojson__ol_format_GeoJSON_.GEOMETRY_WRITERS_[geometry.getType()];
  return geometryWriter( /** @type {ol.geom.Geometry} */format_feature.transformWithOptions(geometry, true, opt_options), opt_options);
};

/**
 * @param {ol.geom.Geometry} geometry Geometry.
 * @private
 * @return {GeoJSONGeometryCollection} Empty GeoJSON geometry collection.
 */
geojson__ol_format_GeoJSON_.writeEmptyGeometryCollectionGeometry_ = function (geometry) {
  return (/** @type {GeoJSONGeometryCollection} */{
      type: 'GeometryCollection',
      geometries: []
    }
  );
};

/**
 * @param {ol.geom.GeometryCollection} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.
 */
geojson__ol_format_GeoJSON_.writeGeometryCollectionGeometry_ = function (geometry, opt_options) {
  var geometries = geometry.getGeometriesArray().map(function (geometry) {
    var options = ol_obj["a" /* default */].assign({}, opt_options);
    delete options.featureProjection;
    return geojson__ol_format_GeoJSON_.writeGeometry_(geometry, options);
  });
  return (/** @type {GeoJSONGeometryCollection} */{
      type: 'GeometryCollection',
      geometries: geometries
    }
  );
};

/**
 * @param {ol.geom.LineString} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
geojson__ol_format_GeoJSON_.writeLineStringGeometry_ = function (geometry, opt_options) {
  return (/** @type {GeoJSONGeometry} */{
      type: 'LineString',
      coordinates: geometry.getCoordinates()
    }
  );
};

/**
 * @param {ol.geom.MultiLineString} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
geojson__ol_format_GeoJSON_.writeMultiLineStringGeometry_ = function (geometry, opt_options) {
  return (/** @type {GeoJSONGeometry} */{
      type: 'MultiLineString',
      coordinates: geometry.getCoordinates()
    }
  );
};

/**
 * @param {ol.geom.MultiPoint} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
geojson__ol_format_GeoJSON_.writeMultiPointGeometry_ = function (geometry, opt_options) {
  return (/** @type {GeoJSONGeometry} */{
      type: 'MultiPoint',
      coordinates: geometry.getCoordinates()
    }
  );
};

/**
 * @param {ol.geom.MultiPolygon} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
geojson__ol_format_GeoJSON_.writeMultiPolygonGeometry_ = function (geometry, opt_options) {
  var right;
  if (opt_options) {
    right = opt_options.rightHanded;
  }
  return (/** @type {GeoJSONGeometry} */{
      type: 'MultiPolygon',
      coordinates: geometry.getCoordinates(right)
    }
  );
};

/**
 * @param {ol.geom.Point} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
geojson__ol_format_GeoJSON_.writePointGeometry_ = function (geometry, opt_options) {
  return (/** @type {GeoJSONGeometry} */{
      type: 'Point',
      coordinates: geometry.getCoordinates()
    }
  );
};

/**
 * @param {ol.geom.Polygon} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @private
 * @return {GeoJSONGeometry} GeoJSON geometry.
 */
geojson__ol_format_GeoJSON_.writePolygonGeometry_ = function (geometry, opt_options) {
  var right;
  if (opt_options) {
    right = opt_options.rightHanded;
  }
  return (/** @type {GeoJSONGeometry} */{
      type: 'Polygon',
      coordinates: geometry.getCoordinates(right)
    }
  );
};

/**
 * @const
 * @private
 * @type {Object.<string, function(GeoJSONObject): ol.geom.Geometry>}
 */
geojson__ol_format_GeoJSON_.GEOMETRY_READERS_ = {
  'Point': geojson__ol_format_GeoJSON_.readPointGeometry_,
  'LineString': geojson__ol_format_GeoJSON_.readLineStringGeometry_,
  'Polygon': geojson__ol_format_GeoJSON_.readPolygonGeometry_,
  'MultiPoint': geojson__ol_format_GeoJSON_.readMultiPointGeometry_,
  'MultiLineString': geojson__ol_format_GeoJSON_.readMultiLineStringGeometry_,
  'MultiPolygon': geojson__ol_format_GeoJSON_.readMultiPolygonGeometry_,
  'GeometryCollection': geojson__ol_format_GeoJSON_.readGeometryCollectionGeometry_
};

/**
 * @const
 * @private
 * @type {Object.<string, function(ol.geom.Geometry, olx.format.WriteOptions=): (GeoJSONGeometry|GeoJSONGeometryCollection)>}
 */
geojson__ol_format_GeoJSON_.GEOMETRY_WRITERS_ = {
  'Point': geojson__ol_format_GeoJSON_.writePointGeometry_,
  'LineString': geojson__ol_format_GeoJSON_.writeLineStringGeometry_,
  'Polygon': geojson__ol_format_GeoJSON_.writePolygonGeometry_,
  'MultiPoint': geojson__ol_format_GeoJSON_.writeMultiPointGeometry_,
  'MultiLineString': geojson__ol_format_GeoJSON_.writeMultiLineStringGeometry_,
  'MultiPolygon': geojson__ol_format_GeoJSON_.writeMultiPolygonGeometry_,
  'GeometryCollection': geojson__ol_format_GeoJSON_.writeGeometryCollectionGeometry_,
  'Circle': geojson__ol_format_GeoJSON_.writeEmptyGeometryCollectionGeometry_
};

/**
 * Read a feature from a GeoJSON Feature source.  Only works for Feature or
 * geometry types.  Use {@link ol.format.GeoJSON#readFeatures} to read
 * FeatureCollection source. If feature at source has an id, it will be used
 * as Feature id by calling {@link ol.Feature#setId} internally.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.Feature} Feature.
 * @api
 */
geojson__ol_format_GeoJSON_.prototype.readFeature;

/**
 * Read all features from a GeoJSON source.  Works for all GeoJSON types.
 * If the source includes only geometries, features will be created with those
 * geometries.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */
geojson__ol_format_GeoJSON_.prototype.readFeatures;

/**
 * @inheritDoc
 */
geojson__ol_format_GeoJSON_.prototype.readFeatureFromObject = function (object, opt_options) {
  /**
   * @type {GeoJSONFeature}
   */
  var geoJSONFeature = null;
  if (object.type === 'Feature') {
    geoJSONFeature = /** @type {GeoJSONFeature} */object;
  } else {
    geoJSONFeature = /** @type {GeoJSONFeature} */{
      type: 'Feature',
      geometry: /** @type {GeoJSONGeometry|GeoJSONGeometryCollection} */object
    };
  }

  var geometry = geojson__ol_format_GeoJSON_.readGeometry_(geoJSONFeature.geometry, opt_options);
  var feature = new ol_feature();
  if (this.geometryName_) {
    feature.setGeometryName(this.geometryName_);
  } else if (this.extractGeometryName_ && geoJSONFeature.geometry_name !== undefined) {
    feature.setGeometryName(geoJSONFeature.geometry_name);
  }
  feature.setGeometry(geometry);
  if (geoJSONFeature.id !== undefined) {
    feature.setId(geoJSONFeature.id);
  }
  if (geoJSONFeature.properties) {
    feature.setProperties(geoJSONFeature.properties);
  }
  return feature;
};

/**
 * @inheritDoc
 */
geojson__ol_format_GeoJSON_.prototype.readFeaturesFromObject = function (object, opt_options) {
  var geoJSONObject = /** @type {GeoJSONObject} */object;
  /** @type {Array.<ol.Feature>} */
  var features = null;
  if (geoJSONObject.type === 'FeatureCollection') {
    var geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */
    object;
    features = [];
    var geoJSONFeatures = geoJSONFeatureCollection.features;
    var i, ii;
    for (i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
      features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));
    }
  } else {
    features = [this.readFeatureFromObject(object, opt_options)];
  }
  return features;
};

/**
 * Read a geometry from a GeoJSON source.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @param {olx.format.ReadOptions=} opt_options Read options.
 * @return {ol.geom.Geometry} Geometry.
 * @api
 */
geojson__ol_format_GeoJSON_.prototype.readGeometry;

/**
 * @inheritDoc
 */
geojson__ol_format_GeoJSON_.prototype.readGeometryFromObject = function (object, opt_options) {
  return geojson__ol_format_GeoJSON_.readGeometry_(
  /** @type {GeoJSONGeometry} */object, opt_options);
};

/**
 * Read the projection from a GeoJSON source.
 *
 * @function
 * @param {Document|Node|Object|string} source Source.
 * @return {ol.proj.Projection} Projection.
 * @api
 */
geojson__ol_format_GeoJSON_.prototype.readProjection;

/**
 * @inheritDoc
 */
geojson__ol_format_GeoJSON_.prototype.readProjectionFromObject = function (object) {
  var geoJSONObject = /** @type {GeoJSONObject} */object;
  var crs = geoJSONObject.crs;
  var projection;
  if (crs) {
    if (crs.type == 'name') {
      projection = proj["default"].get(crs.properties.name);
    } else {
      asserts["a" /* default */].assert(false, 36); // Unknown SRS type
    }
  } else {
    projection = this.defaultDataProjection;
  }
  return (/** @type {ol.proj.Projection} */projection
  );
};

/**
 * Encode a feature as a GeoJSON Feature string.
 *
 * @function
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} GeoJSON.
 * @override
 * @api
 */
geojson__ol_format_GeoJSON_.prototype.writeFeature;

/**
 * Encode a feature as a GeoJSON Feature object.
 *
 * @param {ol.Feature} feature Feature.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {GeoJSONFeature} Object.
 * @override
 * @api
 */
geojson__ol_format_GeoJSON_.prototype.writeFeatureObject = function (feature, opt_options) {
  opt_options = this.adaptOptions(opt_options);

  var object = /** @type {GeoJSONFeature} */{
    'type': 'Feature'
  };
  var id = feature.getId();
  if (id !== undefined) {
    object.id = id;
  }
  var geometry = feature.getGeometry();
  if (geometry) {
    object.geometry = geojson__ol_format_GeoJSON_.writeGeometry_(geometry, opt_options);
  } else {
    object.geometry = null;
  }
  var properties = feature.getProperties();
  delete properties[feature.getGeometryName()];
  if (!ol_obj["a" /* default */].isEmpty(properties)) {
    object.properties = properties;
  } else {
    object.properties = null;
  }
  return object;
};

/**
 * Encode an array of features as GeoJSON.
 *
 * @function
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} GeoJSON.
 * @api
 */
geojson__ol_format_GeoJSON_.prototype.writeFeatures;

/**
 * Encode an array of features as a GeoJSON object.
 *
 * @param {Array.<ol.Feature>} features Features.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {GeoJSONFeatureCollection} GeoJSON Object.
 * @override
 * @api
 */
geojson__ol_format_GeoJSON_.prototype.writeFeaturesObject = function (features, opt_options) {
  opt_options = this.adaptOptions(opt_options);
  var objects = [];
  var i, ii;
  for (i = 0, ii = features.length; i < ii; ++i) {
    objects.push(this.writeFeatureObject(features[i], opt_options));
  }
  return (/** @type {GeoJSONFeatureCollection} */{
      type: 'FeatureCollection',
      features: objects
    }
  );
};

/**
 * Encode a geometry as a GeoJSON string.
 *
 * @function
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {string} GeoJSON.
 * @api
 */
geojson__ol_format_GeoJSON_.prototype.writeGeometry;

/**
 * Encode a geometry as a GeoJSON object.
 *
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {olx.format.WriteOptions=} opt_options Write options.
 * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
 * @override
 * @api
 */
geojson__ol_format_GeoJSON_.prototype.writeGeometryObject = function (geometry, opt_options) {
  return geojson__ol_format_GeoJSON_.writeGeometry_(geometry, this.adaptOptions(opt_options));
};
/* harmony default export */ var geojson = __webpack_exports__["default"] = (geojson__ol_format_GeoJSON_);

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);


/**
 * Error object thrown when an assertion failed. This is an ECMA-262 Error,
 * extended with a `code` property.
 * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}
 * @constructor
 * @extends {Error}
 * @implements {oli.AssertionError}
 * @param {number} code Error code.
 */
var _ol_AssertionError_ = function _ol_AssertionError_(code) {

  var path = __WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].VERSION ? __WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].VERSION.split('-')[0] : 'latest';

  /**
   * @type {string}
   */
  this.message = 'Assertion failed. See https://openlayers.org/en/' + path + '/doc/errors/#' + code + ' for details.';

  /**
   * Error code. The meaning of the code can be found on
   * {@link https://openlayers.org/en/latest/doc/errors/} (replace `latest` with
   * the version found in the OpenLayers script's header comment if a version
   * other than the latest is used).
   * @type {number}
   * @api
   */
  this.code = code;

  this.name = 'AssertionError';
};

__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].inherits(_ol_AssertionError_, Error);
/* harmony default export */ __webpack_exports__["a"] = (_ol_AssertionError_);

/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__events_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__events_eventtarget_js__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__events_eventtype_js__ = __webpack_require__(4);





/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * An event target providing convenient methods for listener registration
 * and unregistration. A generic `change` event is always available through
 * {@link ol.Observable#changed}.
 *
 * @constructor
 * @extends {ol.events.EventTarget}
 * @fires ol.events.Event
 * @struct
 * @api
 */
var _ol_Observable_ = function _ol_Observable_() {

  __WEBPACK_IMPORTED_MODULE_2__events_eventtarget_js__["a" /* default */].call(this);

  /**
   * @private
   * @type {number}
   */
  this.revision_ = 0;
};

__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].inherits(_ol_Observable_, __WEBPACK_IMPORTED_MODULE_2__events_eventtarget_js__["a" /* default */]);

/**
 * Removes an event listener using the key returned by `on()` or `once()`.
 * @param {ol.EventsKey|Array.<ol.EventsKey>} key The key returned by `on()`
 *     or `once()` (or an array of keys).
 * @api
 */
_ol_Observable_.unByKey = function (key) {
  if (Array.isArray(key)) {
    for (var i = 0, ii = key.length; i < ii; ++i) {
      __WEBPACK_IMPORTED_MODULE_1__events_js__["a" /* default */].unlistenByKey(key[i]);
    }
  } else {
    __WEBPACK_IMPORTED_MODULE_1__events_js__["a" /* default */].unlistenByKey( /** @type {ol.EventsKey} */key);
  }
};

/**
 * Increases the revision counter and dispatches a 'change' event.
 * @api
 */
_ol_Observable_.prototype.changed = function () {
  ++this.revision_;
  this.dispatchEvent(__WEBPACK_IMPORTED_MODULE_3__events_eventtype_js__["a" /* default */].CHANGE);
};

/**
 * Dispatches an event and calls all listeners listening for events
 * of this type. The event parameter can either be a string or an
 * Object with a `type` property.
 *
 * @param {{type: string,
 *     target: (EventTarget|ol.events.EventTarget|undefined)}|ol.events.Event|
 *     string} event Event object.
 * @function
 * @api
 */
_ol_Observable_.prototype.dispatchEvent;

/**
 * Get the version number for this object.  Each time the object is modified,
 * its version number will be incremented.
 * @return {number} Revision.
 * @api
 */
_ol_Observable_.prototype.getRevision = function () {
  return this.revision_;
};

/**
 * Listen for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @param {Object=} opt_this The object to use as `this` in `listener`.
 * @return {ol.EventsKey|Array.<ol.EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
_ol_Observable_.prototype.on = function (type, listener, opt_this) {
  if (Array.isArray(type)) {
    var len = type.length;
    var keys = new Array(len);
    for (var i = 0; i < len; ++i) {
      keys[i] = __WEBPACK_IMPORTED_MODULE_1__events_js__["a" /* default */].listen(this, type[i], listener, opt_this);
    }
    return keys;
  } else {
    return __WEBPACK_IMPORTED_MODULE_1__events_js__["a" /* default */].listen(this, /** @type {string} */type, listener, opt_this);
  }
};

/**
 * Listen once for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @param {Object=} opt_this The object to use as `this` in `listener`.
 * @return {ol.EventsKey|Array.<ol.EventsKey>} Unique key for the listener. If
 *     called with an array of event types as the first argument, the return
 *     will be an array of keys.
 * @api
 */
_ol_Observable_.prototype.once = function (type, listener, opt_this) {
  if (Array.isArray(type)) {
    var len = type.length;
    var keys = new Array(len);
    for (var i = 0; i < len; ++i) {
      keys[i] = __WEBPACK_IMPORTED_MODULE_1__events_js__["a" /* default */].listenOnce(this, type[i], listener, opt_this);
    }
    return keys;
  } else {
    return __WEBPACK_IMPORTED_MODULE_1__events_js__["a" /* default */].listenOnce(this, /** @type {string} */type, listener, opt_this);
  }
};

/**
 * Unlisten for a certain type of event.
 * @param {string|Array.<string>} type The event type or array of event types.
 * @param {function(?): ?} listener The listener function.
 * @param {Object=} opt_this The object which was used as `this` by the
 * `listener`.
 * @api
 */
_ol_Observable_.prototype.un = function (type, listener, opt_this) {
  if (Array.isArray(type)) {
    for (var i = 0, ii = type.length; i < ii; ++i) {
      __WEBPACK_IMPORTED_MODULE_1__events_js__["a" /* default */].unlisten(this, type[i], listener, opt_this);
    }
    return;
  } else {
    __WEBPACK_IMPORTED_MODULE_1__events_js__["a" /* default */].unlisten(this, /** @type {string} */type, listener, opt_this);
  }
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_Observable_);

/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Extent corner.
 * @enum {string}
 */
var _ol_extent_Corner_ = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_extent_Corner_);

/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * Relationship to an extent.
 * @enum {number}
 */
var _ol_extent_Relationship_ = {
  UNKNOWN: 0,
  INTERSECTING: 1,
  ABOVE: 2,
  RIGHT: 4,
  BELOW: 8,
  LEFT: 16
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_extent_Relationship_);

/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/ol/index.js
var ol = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ol/colorlike.js
var colorlike = __webpack_require__(46);

// EXTERNAL MODULE: ./node_modules/ol/dom.js
var dom = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/ol/has.js
var has = __webpack_require__(19);

// EXTERNAL MODULE: ./node_modules/ol/imagestate.js
var imagestate = __webpack_require__(40);

// EXTERNAL MODULE: ./node_modules/ol/render/canvas.js
var canvas = __webpack_require__(21);

// EXTERNAL MODULE: ./node_modules/ol/style/image.js
var style_image = __webpack_require__(77);

// CONCATENATED MODULE: ./node_modules/ol/style/regularshape.js








/**
 * @classdesc
 * Set regular shape style for vector features. The resulting shape will be
 * a regular polygon when `radius` is provided, or a star when `radius1` and
 * `radius2` are provided.
 *
 * @constructor
 * @param {olx.style.RegularShapeOptions} options Options.
 * @extends {ol.style.Image}
 * @api
 */
var regularshape__ol_style_RegularShape_ = function _ol_style_RegularShape_(options) {
  /**
   * @private
   * @type {Array.<string>}
   */
  this.checksums_ = null;

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = null;

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.hitDetectionCanvas_ = null;

  /**
   * @private
   * @type {ol.style.Fill}
   */
  this.fill_ = options.fill !== undefined ? options.fill : null;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.origin_ = [0, 0];

  /**
   * @private
   * @type {number}
   */
  this.points_ = options.points;

  /**
   * @protected
   * @type {number}
   */
  this.radius_ = /** @type {number} */options.radius !== undefined ? options.radius : options.radius1;

  /**
   * @private
   * @type {number|undefined}
   */
  this.radius2_ = options.radius2;

  /**
   * @private
   * @type {number}
   */
  this.angle_ = options.angle !== undefined ? options.angle : 0;

  /**
   * @private
   * @type {ol.style.Stroke}
   */
  this.stroke_ = options.stroke !== undefined ? options.stroke : null;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.anchor_ = null;

  /**
   * @private
   * @type {ol.Size}
   */
  this.size_ = null;

  /**
   * @private
   * @type {ol.Size}
   */
  this.imageSize_ = null;

  /**
   * @private
   * @type {ol.Size}
   */
  this.hitDetectionImageSize_ = null;

  /**
   * @protected
   * @type {ol.style.AtlasManager|undefined}
   */
  this.atlasManager_ = options.atlasManager;

  if (typeof window !== 'undefined') {
    this.render_(this.atlasManager_);
  }

  /**
   * @type {boolean}
   */
  var snapToPixel = options.snapToPixel !== undefined ? options.snapToPixel : true;

  /**
   * @type {boolean}
   */
  var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;

  style_image["a" /* default */].call(this, {
    opacity: 1,
    rotateWithView: rotateWithView,
    rotation: options.rotation !== undefined ? options.rotation : 0,
    scale: 1,
    snapToPixel: snapToPixel
  });
};

ol["a" /* default */].inherits(regularshape__ol_style_RegularShape_, style_image["a" /* default */]);

/**
 * Clones the style. If an atlasmanager was provided to the original style it will be used in the cloned style, too.
 * @return {ol.style.RegularShape} The cloned style.
 * @api
 */
regularshape__ol_style_RegularShape_.prototype.clone = function () {
  var style = new regularshape__ol_style_RegularShape_({
    fill: this.getFill() ? this.getFill().clone() : undefined,
    points: this.getPoints(),
    radius: this.getRadius(),
    radius2: this.getRadius2(),
    angle: this.getAngle(),
    snapToPixel: this.getSnapToPixel(),
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    rotation: this.getRotation(),
    rotateWithView: this.getRotateWithView(),
    atlasManager: this.atlasManager_
  });
  style.setOpacity(this.getOpacity());
  style.setScale(this.getScale());
  return style;
};

/**
 * @inheritDoc
 * @api
 */
regularshape__ol_style_RegularShape_.prototype.getAnchor = function () {
  return this.anchor_;
};

/**
 * Get the angle used in generating the shape.
 * @return {number} Shape's rotation in radians.
 * @api
 */
regularshape__ol_style_RegularShape_.prototype.getAngle = function () {
  return this.angle_;
};

/**
 * Get the fill style for the shape.
 * @return {ol.style.Fill} Fill style.
 * @api
 */
regularshape__ol_style_RegularShape_.prototype.getFill = function () {
  return this.fill_;
};

/**
 * @inheritDoc
 */
regularshape__ol_style_RegularShape_.prototype.getHitDetectionImage = function (pixelRatio) {
  return this.hitDetectionCanvas_;
};

/**
 * @inheritDoc
 * @api
 */
regularshape__ol_style_RegularShape_.prototype.getImage = function (pixelRatio) {
  return this.canvas_;
};

/**
 * @inheritDoc
 */
regularshape__ol_style_RegularShape_.prototype.getImageSize = function () {
  return this.imageSize_;
};

/**
 * @inheritDoc
 */
regularshape__ol_style_RegularShape_.prototype.getHitDetectionImageSize = function () {
  return this.hitDetectionImageSize_;
};

/**
 * @inheritDoc
 */
regularshape__ol_style_RegularShape_.prototype.getImageState = function () {
  return imagestate["a" /* default */].LOADED;
};

/**
 * @inheritDoc
 * @api
 */
regularshape__ol_style_RegularShape_.prototype.getOrigin = function () {
  return this.origin_;
};

/**
 * Get the number of points for generating the shape.
 * @return {number} Number of points for stars and regular polygons.
 * @api
 */
regularshape__ol_style_RegularShape_.prototype.getPoints = function () {
  return this.points_;
};

/**
 * Get the (primary) radius for the shape.
 * @return {number} Radius.
 * @api
 */
regularshape__ol_style_RegularShape_.prototype.getRadius = function () {
  return this.radius_;
};

/**
 * Get the secondary radius for the shape.
 * @return {number|undefined} Radius2.
 * @api
 */
regularshape__ol_style_RegularShape_.prototype.getRadius2 = function () {
  return this.radius2_;
};

/**
 * @inheritDoc
 * @api
 */
regularshape__ol_style_RegularShape_.prototype.getSize = function () {
  return this.size_;
};

/**
 * Get the stroke style for the shape.
 * @return {ol.style.Stroke} Stroke style.
 * @api
 */
regularshape__ol_style_RegularShape_.prototype.getStroke = function () {
  return this.stroke_;
};

/**
 * @inheritDoc
 */
regularshape__ol_style_RegularShape_.prototype.listenImageChange = function (listener, thisArg) {};

/**
 * @inheritDoc
 */
regularshape__ol_style_RegularShape_.prototype.load = function () {};

/**
 * @inheritDoc
 */
regularshape__ol_style_RegularShape_.prototype.unlistenImageChange = function (listener, thisArg) {};

/**
 * @protected
 * @param {ol.style.AtlasManager|undefined} atlasManager An atlas manager.
 */
regularshape__ol_style_RegularShape_.prototype.render_ = function (atlasManager) {
  var imageSize;
  var lineCap = '';
  var lineJoin = '';
  var miterLimit = 0;
  var lineDash = null;
  var lineDashOffset = 0;
  var strokeStyle;
  var strokeWidth = 0;

  if (this.stroke_) {
    strokeStyle = this.stroke_.getColor();
    if (strokeStyle === null) {
      strokeStyle = canvas["a" /* default */].defaultStrokeStyle;
    }
    strokeStyle = colorlike["a" /* default */].asColorLike(strokeStyle);
    strokeWidth = this.stroke_.getWidth();
    if (strokeWidth === undefined) {
      strokeWidth = canvas["a" /* default */].defaultLineWidth;
    }
    lineDash = this.stroke_.getLineDash();
    lineDashOffset = this.stroke_.getLineDashOffset();
    if (!has["a" /* default */].CANVAS_LINE_DASH) {
      lineDash = null;
      lineDashOffset = 0;
    }
    lineJoin = this.stroke_.getLineJoin();
    if (lineJoin === undefined) {
      lineJoin = canvas["a" /* default */].defaultLineJoin;
    }
    lineCap = this.stroke_.getLineCap();
    if (lineCap === undefined) {
      lineCap = canvas["a" /* default */].defaultLineCap;
    }
    miterLimit = this.stroke_.getMiterLimit();
    if (miterLimit === undefined) {
      miterLimit = canvas["a" /* default */].defaultMiterLimit;
    }
  }

  var size = 2 * (this.radius_ + strokeWidth) + 1;

  /** @type {ol.RegularShapeRenderOptions} */
  var renderOptions = {
    strokeStyle: strokeStyle,
    strokeWidth: strokeWidth,
    size: size,
    lineCap: lineCap,
    lineDash: lineDash,
    lineDashOffset: lineDashOffset,
    lineJoin: lineJoin,
    miterLimit: miterLimit
  };

  if (atlasManager === undefined) {
    // no atlas manager is used, create a new canvas
    var context = dom["a" /* default */].createCanvasContext2D(size, size);
    this.canvas_ = context.canvas;

    // canvas.width and height are rounded to the closest integer
    size = this.canvas_.width;
    imageSize = size;

    this.draw_(renderOptions, context, 0, 0);

    this.createHitDetectionCanvas_(renderOptions);
  } else {
    // an atlas manager is used, add the symbol to an atlas
    size = Math.round(size);

    var hasCustomHitDetectionImage = !this.fill_;
    var renderHitDetectionCallback;
    if (hasCustomHitDetectionImage) {
      // render the hit-detection image into a separate atlas image
      renderHitDetectionCallback = this.drawHitDetectionCanvas_.bind(this, renderOptions);
    }

    var id = this.getChecksum();
    var info = atlasManager.add(id, size, size, this.draw_.bind(this, renderOptions), renderHitDetectionCallback);

    this.canvas_ = info.image;
    this.origin_ = [info.offsetX, info.offsetY];
    imageSize = info.image.width;

    if (hasCustomHitDetectionImage) {
      this.hitDetectionCanvas_ = info.hitImage;
      this.hitDetectionImageSize_ = [info.hitImage.width, info.hitImage.height];
    } else {
      this.hitDetectionCanvas_ = this.canvas_;
      this.hitDetectionImageSize_ = [imageSize, imageSize];
    }
  }

  this.anchor_ = [size / 2, size / 2];
  this.size_ = [size, size];
  this.imageSize_ = [imageSize, imageSize];
};

/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 * @param {CanvasRenderingContext2D} context The rendering context.
 * @param {number} x The origin for the symbol (x).
 * @param {number} y The origin for the symbol (y).
 */
regularshape__ol_style_RegularShape_.prototype.draw_ = function (renderOptions, context, x, y) {
  var i, angle0, radiusC;
  // reset transform
  context.setTransform(1, 0, 0, 1, 0, 0);

  // then move to (x, y)
  context.translate(x, y);

  context.beginPath();

  var points = this.points_;
  if (points === Infinity) {
    context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
  } else {
    var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;
    if (radius2 !== this.radius_) {
      points = 2 * points;
    }
    for (i = 0; i <= points; i++) {
      angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
      radiusC = i % 2 === 0 ? this.radius_ : radius2;
      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
    }
  }

  if (this.fill_) {
    var color = this.fill_.getColor();
    if (color === null) {
      color = canvas["a" /* default */].defaultFillStyle;
    }
    context.fillStyle = colorlike["a" /* default */].asColorLike(color);
    context.fill();
  }
  if (this.stroke_) {
    context.strokeStyle = renderOptions.strokeStyle;
    context.lineWidth = renderOptions.strokeWidth;
    if (renderOptions.lineDash) {
      context.setLineDash(renderOptions.lineDash);
      context.lineDashOffset = renderOptions.lineDashOffset;
    }
    context.lineCap = renderOptions.lineCap;
    context.lineJoin = renderOptions.lineJoin;
    context.miterLimit = renderOptions.miterLimit;
    context.stroke();
  }
  context.closePath();
};

/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 */
regularshape__ol_style_RegularShape_.prototype.createHitDetectionCanvas_ = function (renderOptions) {
  this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];
  if (this.fill_) {
    this.hitDetectionCanvas_ = this.canvas_;
    return;
  }

  // if no fill style is set, create an extra hit-detection image with a
  // default fill style
  var context = dom["a" /* default */].createCanvasContext2D(renderOptions.size, renderOptions.size);
  this.hitDetectionCanvas_ = context.canvas;

  this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
};

/**
 * @private
 * @param {ol.RegularShapeRenderOptions} renderOptions Render options.
 * @param {CanvasRenderingContext2D} context The context.
 * @param {number} x The origin for the symbol (x).
 * @param {number} y The origin for the symbol (y).
 */
regularshape__ol_style_RegularShape_.prototype.drawHitDetectionCanvas_ = function (renderOptions, context, x, y) {
  // reset transform
  context.setTransform(1, 0, 0, 1, 0, 0);

  // then move to (x, y)
  context.translate(x, y);

  context.beginPath();

  var points = this.points_;
  if (points === Infinity) {
    context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
  } else {
    var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;
    if (radius2 !== this.radius_) {
      points = 2 * points;
    }
    var i, radiusC, angle0;
    for (i = 0; i <= points; i++) {
      angle0 = i * 2 * Math.PI / points - Math.PI / 2 + this.angle_;
      radiusC = i % 2 === 0 ? this.radius_ : radius2;
      context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
    }
  }

  context.fillStyle = canvas["a" /* default */].defaultFillStyle;
  context.fill();
  if (this.stroke_) {
    context.strokeStyle = renderOptions.strokeStyle;
    context.lineWidth = renderOptions.strokeWidth;
    if (renderOptions.lineDash) {
      context.setLineDash(renderOptions.lineDash);
      context.lineDashOffset = renderOptions.lineDashOffset;
    }
    context.stroke();
  }
  context.closePath();
};

/**
 * @return {string} The checksum.
 */
regularshape__ol_style_RegularShape_.prototype.getChecksum = function () {
  var strokeChecksum = this.stroke_ ? this.stroke_.getChecksum() : '-';
  var fillChecksum = this.fill_ ? this.fill_.getChecksum() : '-';

  var recalculate = !this.checksums_ || strokeChecksum != this.checksums_[1] || fillChecksum != this.checksums_[2] || this.radius_ != this.checksums_[3] || this.radius2_ != this.checksums_[4] || this.angle_ != this.checksums_[5] || this.points_ != this.checksums_[6];

  if (recalculate) {
    var checksum = 'r' + strokeChecksum + fillChecksum + (this.radius_ !== undefined ? this.radius_.toString() : '-') + (this.radius2_ !== undefined ? this.radius2_.toString() : '-') + (this.angle_ !== undefined ? this.angle_.toString() : '-') + (this.points_ !== undefined ? this.points_.toString() : '-');
    this.checksums_ = [checksum, strokeChecksum, fillChecksum, this.radius_, this.radius2_, this.angle_, this.points_];
  }

  return this.checksums_[0];
};
/* harmony default export */ var regularshape = (regularshape__ol_style_RegularShape_);
// CONCATENATED MODULE: ./node_modules/ol/style/circle.js



/**
 * @classdesc
 * Set circle style for vector features.
 *
 * @constructor
 * @param {olx.style.CircleOptions=} opt_options Options.
 * @extends {ol.style.RegularShape}
 * @api
 */
var circle__ol_style_Circle_ = function _ol_style_Circle_(opt_options) {

  var options = opt_options || {};

  regularshape.call(this, {
    points: Infinity,
    fill: options.fill,
    radius: options.radius,
    snapToPixel: options.snapToPixel,
    stroke: options.stroke,
    atlasManager: options.atlasManager
  });
};

ol["a" /* default */].inherits(circle__ol_style_Circle_, regularshape);

/**
 * Clones the style.  If an atlasmanager was provided to the original style it will be used in the cloned style, too.
 * @return {ol.style.Circle} The cloned style.
 * @override
 * @api
 */
circle__ol_style_Circle_.prototype.clone = function () {
  var style = new circle__ol_style_Circle_({
    fill: this.getFill() ? this.getFill().clone() : undefined,
    stroke: this.getStroke() ? this.getStroke().clone() : undefined,
    radius: this.getRadius(),
    snapToPixel: this.getSnapToPixel(),
    atlasManager: this.atlasManager_
  });
  style.setOpacity(this.getOpacity());
  style.setScale(this.getScale());
  return style;
};

/**
 * Set the circle radius.
 *
 * @param {number} radius Circle radius.
 * @api
 */
circle__ol_style_Circle_.prototype.setRadius = function (radius) {
  this.radius_ = radius;
  this.render_(this.atlasManager_);
};
/* harmony default export */ var circle = __webpack_exports__["default"] = (circle__ol_style_Circle_);

/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @classdesc
 * A base class used for creating subclasses and not instantiated in
 * apps. Base class for {@link ol.style.Icon}, {@link ol.style.Circle} and
 * {@link ol.style.RegularShape}.
 *
 * @constructor
 * @abstract
 * @param {ol.StyleImageOptions} options Options.
 * @api
 */
var _ol_style_Image_ = function _ol_style_Image_(options) {

  /**
   * @private
   * @type {number}
   */
  this.opacity_ = options.opacity;

  /**
   * @private
   * @type {boolean}
   */
  this.rotateWithView_ = options.rotateWithView;

  /**
   * @private
   * @type {number}
   */
  this.rotation_ = options.rotation;

  /**
   * @private
   * @type {number}
   */
  this.scale_ = options.scale;

  /**
   * @private
   * @type {boolean}
   */
  this.snapToPixel_ = options.snapToPixel;
};

/**
 * Get the symbolizer opacity.
 * @return {number} Opacity.
 * @api
 */
_ol_style_Image_.prototype.getOpacity = function () {
  return this.opacity_;
};

/**
 * Determine whether the symbolizer rotates with the map.
 * @return {boolean} Rotate with map.
 * @api
 */
_ol_style_Image_.prototype.getRotateWithView = function () {
  return this.rotateWithView_;
};

/**
 * Get the symoblizer rotation.
 * @return {number} Rotation.
 * @api
 */
_ol_style_Image_.prototype.getRotation = function () {
  return this.rotation_;
};

/**
 * Get the symbolizer scale.
 * @return {number} Scale.
 * @api
 */
_ol_style_Image_.prototype.getScale = function () {
  return this.scale_;
};

/**
 * Determine whether the symbolizer should be snapped to a pixel.
 * @return {boolean} The symbolizer should snap to a pixel.
 * @api
 */
_ol_style_Image_.prototype.getSnapToPixel = function () {
  return this.snapToPixel_;
};

/**
 * Get the anchor point in pixels. The anchor determines the center point for the
 * symbolizer.
 * @abstract
 * @return {Array.<number>} Anchor.
 */
_ol_style_Image_.prototype.getAnchor = function () {};

/**
 * Get the image element for the symbolizer.
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.
 */
_ol_style_Image_.prototype.getImage = function (pixelRatio) {};

/**
 * @abstract
 * @param {number} pixelRatio Pixel ratio.
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Image element.
 */
_ol_style_Image_.prototype.getHitDetectionImage = function (pixelRatio) {};

/**
 * @abstract
 * @return {ol.ImageState} Image state.
 */
_ol_style_Image_.prototype.getImageState = function () {};

/**
 * @abstract
 * @return {ol.Size} Image size.
 */
_ol_style_Image_.prototype.getImageSize = function () {};

/**
 * @abstract
 * @return {ol.Size} Size of the hit-detection image.
 */
_ol_style_Image_.prototype.getHitDetectionImageSize = function () {};

/**
 * Get the origin of the symbolizer.
 * @abstract
 * @return {Array.<number>} Origin.
 */
_ol_style_Image_.prototype.getOrigin = function () {};

/**
 * Get the size of the symbolizer (in pixels).
 * @abstract
 * @return {ol.Size} Size.
 */
_ol_style_Image_.prototype.getSize = function () {};

/**
 * Set the opacity.
 *
 * @param {number} opacity Opacity.
 * @api
 */
_ol_style_Image_.prototype.setOpacity = function (opacity) {
  this.opacity_ = opacity;
};

/**
 * Set whether to rotate the style with the view.
 *
 * @param {boolean} rotateWithView Rotate with map.
 */
_ol_style_Image_.prototype.setRotateWithView = function (rotateWithView) {
  this.rotateWithView_ = rotateWithView;
};

/**
 * Set the rotation.
 *
 * @param {number} rotation Rotation.
 * @api
 */
_ol_style_Image_.prototype.setRotation = function (rotation) {
  this.rotation_ = rotation;
};

/**
 * Set the scale.
 *
 * @param {number} scale Scale.
 * @api
 */
_ol_style_Image_.prototype.setScale = function (scale) {
  this.scale_ = scale;
};

/**
 * Set whether to snap the image to the closest pixel.
 *
 * @param {boolean} snapToPixel Snap to pixel?
 */
_ol_style_Image_.prototype.setSnapToPixel = function (snapToPixel) {
  this.snapToPixel_ = snapToPixel;
};

/**
 * @abstract
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {ol.EventsKey|undefined} Listener key.
 * @template T
 */
_ol_style_Image_.prototype.listenImageChange = function (listener, thisArg) {};

/**
 * Load not yet loaded URI.
 * @abstract
 */
_ol_style_Image_.prototype.load = function () {};

/**
 * @abstract
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @template T
 */
_ol_style_Image_.prototype.unlistenImageChange = function (listener, thisArg) {};
/* harmony default export */ __webpack_exports__["a"] = (_ol_style_Image_);

/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @enum {string}
 */
var _ol_format_FormatType_ = {
  ARRAY_BUFFER: 'arraybuffer',
  JSON: 'json',
  TEXT: 'text',
  XML: 'xml'
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_format_FormatType_);

/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _ol_geom_flat_segments_ = {};

/**
 * This function calls `callback` for each segment of the flat coordinates
 * array. If the callback returns a truthy value the function returns that
 * value immediately. Otherwise the function returns `false`.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {function(this: S, ol.Coordinate, ol.Coordinate): T} callback Function
 *     called for each segment.
 * @param {S=} opt_this The object to be used as the value of 'this'
 *     within callback.
 * @return {T|boolean} Value.
 * @template T,S
 */
_ol_geom_flat_segments_.forEach = function (flatCoordinates, offset, end, stride, callback, opt_this) {
  var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
  var point2 = [];
  var ret;
  for (; offset + stride < end; offset += stride) {
    point2[0] = flatCoordinates[offset + stride];
    point2[1] = flatCoordinates[offset + stride + 1];
    ret = callback.call(opt_this, point1, point2);
    if (ret) {
      return ret;
    }
    point1[0] = point2[0];
    point1[1] = point2[1];
  }
  return false;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_geom_flat_segments_);

/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var _ol_geom_flat_length_ = {};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Length.
 */
_ol_geom_flat_length_.lineString = function (flatCoordinates, offset, end, stride) {
  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  var length = 0;
  var i;
  for (i = offset + stride; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} Perimeter.
 */
_ol_geom_flat_length_.linearRing = function (flatCoordinates, offset, end, stride) {
  var perimeter = _ol_geom_flat_length_.lineString(flatCoordinates, offset, end, stride);
  var dx = flatCoordinates[end - stride] - flatCoordinates[offset];
  var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_geom_flat_length_);

/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__array_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__flat_contains_js__ = __webpack_require__(48);


var _ol_geom_flat_interiorpoint_ = {};

/**
 * Calculates a point that is likely to lie in the interior of the linear rings.
 * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array.<number>} flatCenters Flat centers.
 * @param {number} flatCentersOffset Flat center offset.
 * @param {Array.<number>=} opt_dest Destination.
 * @return {Array.<number>} Destination point as XYM coordinate, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
_ol_geom_flat_interiorpoint_.linearRings = function (flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
  var i, ii, x, x1, x2, y1, y2;
  var y = flatCenters[flatCentersOffset + 1];
  /** @type {Array.<number>} */
  var intersections = [];
  // Calculate intersections with the horizontal line
  for (var r = 0, rr = ends.length; r < rr; ++r) {
    var end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  // Find the longest segment of the horizontal line that has its center point
  // inside the linear ring.
  var pointX = NaN;
  var maxSegmentLength = -Infinity;
  intersections.sort(__WEBPACK_IMPORTED_MODULE_0__array_js__["a" /* default */].numberSafeCompareFunction);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    var segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (__WEBPACK_IMPORTED_MODULE_1__flat_contains_js__["a" /* default */].linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    // There is no horizontal line that has its center point inside the linear
    // ring.  Use the center of the the linear ring's extent.
    pointX = flatCenters[flatCentersOffset];
  }
  if (opt_dest) {
    opt_dest.push(pointX, y, maxSegmentLength);
    return opt_dest;
  } else {
    return [pointX, y, maxSegmentLength];
  }
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<Array.<number>>} endss Endss.
 * @param {number} stride Stride.
 * @param {Array.<number>} flatCenters Flat centers.
 * @return {Array.<number>} Interior points as XYM coordinates, where M is the
 * length of the horizontal intersection that the point belongs to.
 */
_ol_geom_flat_interiorpoint_.linearRingss = function (flatCoordinates, offset, endss, stride, flatCenters) {
  var interiorPoints = [];
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    interiorPoints = _ol_geom_flat_interiorpoint_.linearRings(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
    offset = ends[ends.length - 1];
  }
  return interiorPoints;
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_geom_flat_interiorpoint_);

/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/ol/color.js
var ol_color = __webpack_require__(27);

// CONCATENATED MODULE: ./node_modules/ol/style/iconimagecache.js


/**
 * Singleton class. Available through {@link ol.style.iconImageCache}.
 * @constructor
 */
var _ol_style_IconImageCache_ = function _ol_style_IconImageCache_() {

  /**
   * @type {Object.<string, ol.style.IconImage>}
   * @private
   */
  this.cache_ = {};

  /**
   * @type {number}
   * @private
   */
  this.cacheSize_ = 0;

  /**
   * @type {number}
   * @private
   */
  this.maxCacheSize_ = 32;
};

/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @return {string} Cache key.
 */
_ol_style_IconImageCache_.getKey = function (src, crossOrigin, color) {
  var colorString = color ? ol_color["a" /* default */].asString(color) : 'null';
  return crossOrigin + ':' + src + ':' + colorString;
};

/**
 * FIXME empty description for jsdoc
 */
_ol_style_IconImageCache_.prototype.clear = function () {
  this.cache_ = {};
  this.cacheSize_ = 0;
};

/**
 * FIXME empty description for jsdoc
 */
_ol_style_IconImageCache_.prototype.expire = function () {
  if (this.cacheSize_ > this.maxCacheSize_) {
    var i = 0;
    var key, iconImage;
    for (key in this.cache_) {
      iconImage = this.cache_[key];
      if ((i++ & 3) === 0 && !iconImage.hasListener()) {
        delete this.cache_[key];
        --this.cacheSize_;
      }
    }
  }
};

/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @return {ol.style.IconImage} Icon image.
 */
_ol_style_IconImageCache_.prototype.get = function (src, crossOrigin, color) {
  var key = _ol_style_IconImageCache_.getKey(src, crossOrigin, color);
  return key in this.cache_ ? this.cache_[key] : null;
};

/**
 * @param {string} src Src.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.Color} color Color.
 * @param {ol.style.IconImage} iconImage Icon image.
 */
_ol_style_IconImageCache_.prototype.set = function (src, crossOrigin, color, iconImage) {
  var key = _ol_style_IconImageCache_.getKey(src, crossOrigin, color);
  this.cache_[key] = iconImage;
  ++this.cacheSize_;
};

/**
 * Set the cache size of the icon cache. Default is `32`. Change this value when
 * your map uses more than 32 different icon images and you are not caching icon
 * styles on the application level.
 * @param {number} maxCacheSize Cache max size.
 * @api
 */
_ol_style_IconImageCache_.prototype.setSize = function (maxCacheSize) {
  this.maxCacheSize_ = maxCacheSize;
  this.expire();
};
/* harmony default export */ var iconimagecache = (_ol_style_IconImageCache_);
// CONCATENATED MODULE: ./node_modules/ol/style.js

var _ol_style_ = {};

/**
 * The {@link ol.style.IconImageCache} for {@link ol.style.Icon} images.
 * @api
 */
_ol_style_.iconImageCache = new iconimagecache();
/* harmony default export */ var style = __webpack_exports__["a"] = (_ol_style_);

/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/ol/index.js
var ol = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ol/math.js
var math = __webpack_require__(6);

// CONCATENATED MODULE: ./node_modules/ol/centerconstraint.js

var _ol_CenterConstraint_ = {};

/**
 * @param {ol.Extent} extent Extent.
 * @return {ol.CenterConstraintType} The constraint.
 */
_ol_CenterConstraint_.createExtent = function (extent) {
  return (
    /**
     * @param {ol.Coordinate|undefined} center Center.
     * @return {ol.Coordinate|undefined} Center.
     */
    function (center) {
      if (center) {
        return [math["a" /* default */].clamp(center[0], extent[0], extent[2]), math["a" /* default */].clamp(center[1], extent[1], extent[3])];
      } else {
        return undefined;
      }
    }
  );
};

/**
 * @param {ol.Coordinate|undefined} center Center.
 * @return {ol.Coordinate|undefined} Center.
 */
_ol_CenterConstraint_.none = function (center) {
  return center;
};
/* harmony default export */ var centerconstraint = (_ol_CenterConstraint_);
// EXTERNAL MODULE: ./node_modules/ol/object.js
var object = __webpack_require__(15);

// EXTERNAL MODULE: ./node_modules/ol/array.js
var array = __webpack_require__(5);

// CONCATENATED MODULE: ./node_modules/ol/resolutionconstraint.js


var _ol_ResolutionConstraint_ = {};

/**
 * @param {Array.<number>} resolutions Resolutions.
 * @return {ol.ResolutionConstraintType} Zoom function.
 */
_ol_ResolutionConstraint_.createSnapToResolutions = function (resolutions) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} delta Delta.
     * @param {number} direction Direction.
     * @return {number|undefined} Resolution.
     */
    function (resolution, delta, direction) {
      if (resolution !== undefined) {
        var z = array["a" /* default */].linearFindNearest(resolutions, resolution, direction);
        z = math["a" /* default */].clamp(z + delta, 0, resolutions.length - 1);
        var index = Math.floor(z);
        if (z != index && index < resolutions.length - 1) {
          var power = resolutions[index] / resolutions[index + 1];
          return resolutions[index] / Math.pow(power, z - index);
        } else {
          return resolutions[index];
        }
      } else {
        return undefined;
      }
    }
  );
};

/**
 * @param {number} power Power.
 * @param {number} maxResolution Maximum resolution.
 * @param {number=} opt_maxLevel Maximum level.
 * @return {ol.ResolutionConstraintType} Zoom function.
 */
_ol_ResolutionConstraint_.createSnapToPower = function (power, maxResolution, opt_maxLevel) {
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} delta Delta.
     * @param {number} direction Direction.
     * @return {number|undefined} Resolution.
     */
    function (resolution, delta, direction) {
      if (resolution !== undefined) {
        var offset = -direction / 2 + 0.5;
        var oldLevel = Math.floor(Math.log(maxResolution / resolution) / Math.log(power) + offset);
        var newLevel = Math.max(oldLevel + delta, 0);
        if (opt_maxLevel !== undefined) {
          newLevel = Math.min(newLevel, opt_maxLevel);
        }
        return maxResolution / Math.pow(power, newLevel);
      } else {
        return undefined;
      }
    }
  );
};
/* harmony default export */ var resolutionconstraint = (_ol_ResolutionConstraint_);
// EXTERNAL MODULE: ./node_modules/ol/rotationconstraint.js
var rotationconstraint = __webpack_require__(69);

// EXTERNAL MODULE: ./node_modules/ol/viewhint.js
var viewhint = __webpack_require__(17);

// CONCATENATED MODULE: ./node_modules/ol/viewproperty.js
/**
 * @enum {string}
 */
var _ol_ViewProperty_ = {
  CENTER: 'center',
  RESOLUTION: 'resolution',
  ROTATION: 'rotation'
};

/* harmony default export */ var viewproperty = (_ol_ViewProperty_);
// EXTERNAL MODULE: ./node_modules/ol/asserts.js
var asserts = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/ol/coordinate.js + 1 modules
var coordinate = __webpack_require__(62);

// EXTERNAL MODULE: ./node_modules/ol/easing.js
var easing = __webpack_require__(29);

// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__(1);

// EXTERNAL MODULE: ./node_modules/ol/geom/geometrytype.js
var geometrytype = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/ol/geom/polygon.js + 1 modules
var polygon = __webpack_require__(59);

// EXTERNAL MODULE: ./node_modules/ol/geom/simplegeometry.js
var simplegeometry = __webpack_require__(22);

// EXTERNAL MODULE: ./node_modules/ol/obj.js
var obj = __webpack_require__(2);

// EXTERNAL MODULE: ./node_modules/ol/proj.js + 7 modules
var proj = __webpack_require__(16);

// EXTERNAL MODULE: ./node_modules/ol/proj/units.js
var units = __webpack_require__(26);

// CONCATENATED MODULE: ./node_modules/ol/view.js




















/**
 * @classdesc
 * An ol.View object represents a simple 2D view of the map.
 *
 * This is the object to act upon to change the center, resolution,
 * and rotation of the map.
 *
 * ### The view states
 *
 * An `ol.View` is determined by three states: `center`, `resolution`,
 * and `rotation`. Each state has a corresponding getter and setter, e.g.
 * `getCenter` and `setCenter` for the `center` state.
 *
 * An `ol.View` has a `projection`. The projection determines the
 * coordinate system of the center, and its units determine the units of the
 * resolution (projection units per pixel). The default projection is
 * Spherical Mercator (EPSG:3857).
 *
 * ### The constraints
 *
 * `setCenter`, `setResolution` and `setRotation` can be used to change the
 * states of the view. Any value can be passed to the setters. And the value
 * that is passed to a setter will effectively be the value set in the view,
 * and returned by the corresponding getter.
 *
 * But an `ol.View` object also has a *resolution constraint*, a
 * *rotation constraint* and a *center constraint*.
 *
 * As said above, no constraints are applied when the setters are used to set
 * new states for the view. Applying constraints is done explicitly through
 * the use of the `constrain*` functions (`constrainResolution` and
 * `constrainRotation` and `constrainCenter`).
 *
 * The main users of the constraints are the interactions and the
 * controls. For example, double-clicking on the map changes the view to
 * the "next" resolution. And releasing the fingers after pinch-zooming
 * snaps to the closest resolution (with an animation).
 *
 * The *resolution constraint* snaps to specific resolutions. It is
 * determined by the following options: `resolutions`, `maxResolution`,
 * `maxZoom`, and `zoomFactor`. If `resolutions` is set, the other three
 * options are ignored. See documentation for each option for more
 * information.
 *
 * The *rotation constraint* snaps to specific angles. It is determined
 * by the following options: `enableRotation` and `constrainRotation`.
 * By default the rotation value is snapped to zero when approaching the
 * horizontal.
 *
 * The *center constraint* is determined by the `extent` option. By
 * default the center is not constrained at all.
 *
 * @constructor
 * @extends {ol.Object}
 * @param {olx.ViewOptions=} opt_options View options.
 * @api
 */
var view__ol_View_ = function _ol_View_(opt_options) {
  object["a" /* default */].call(this);

  var options = obj["a" /* default */].assign({}, opt_options);

  /**
   * @private
   * @type {Array.<number>}
   */
  this.hints_ = [0, 0];

  /**
   * @private
   * @type {Array.<Array.<ol.ViewAnimation>>}
   */
  this.animations_ = [];

  /**
   * @private
   * @type {number|undefined}
   */
  this.updateAnimationKey_;

  this.updateAnimations_ = this.updateAnimations_.bind(this);

  /**
   * @private
   * @const
   * @type {ol.proj.Projection}
   */
  this.projection_ = proj["default"].createProjection(options.projection, 'EPSG:3857');

  this.applyOptions_(options);
};

ol["a" /* default */].inherits(view__ol_View_, object["a" /* default */]);

/**
 * Set up the view with the given options.
 * @param {olx.ViewOptions} options View options.
 */
view__ol_View_.prototype.applyOptions_ = function (options) {

  /**
   * @type {Object.<string, *>}
   */
  var properties = {};
  properties[viewproperty.CENTER] = options.center !== undefined ? options.center : null;

  var resolutionConstraintInfo = view__ol_View_.createResolutionConstraint_(options);

  /**
   * @private
   * @type {number}
   */
  this.maxResolution_ = resolutionConstraintInfo.maxResolution;

  /**
   * @private
   * @type {number}
   */
  this.minResolution_ = resolutionConstraintInfo.minResolution;

  /**
   * @private
   * @type {number}
   */
  this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;

  /**
   * @private
   * @type {Array.<number>|undefined}
   */
  this.resolutions_ = options.resolutions;

  /**
   * @private
   * @type {number}
   */
  this.minZoom_ = resolutionConstraintInfo.minZoom;

  var centerConstraint = view__ol_View_.createCenterConstraint_(options);
  var resolutionConstraint = resolutionConstraintInfo.constraint;
  var rotationConstraint = view__ol_View_.createRotationConstraint_(options);

  /**
   * @private
   * @type {ol.Constraints}
   */
  this.constraints_ = {
    center: centerConstraint,
    resolution: resolutionConstraint,
    rotation: rotationConstraint
  };

  if (options.resolution !== undefined) {
    properties[viewproperty.RESOLUTION] = options.resolution;
  } else if (options.zoom !== undefined) {
    properties[viewproperty.RESOLUTION] = this.constrainResolution(this.maxResolution_, options.zoom - this.minZoom_);

    if (this.resolutions_) {
      // in case map zoom is out of min/max zoom range
      properties[viewproperty.RESOLUTION] = math["a" /* default */].clamp(Number(this.getResolution() || properties[viewproperty.RESOLUTION]), this.minResolution_, this.maxResolution_);
    }
  }
  properties[viewproperty.ROTATION] = options.rotation !== undefined ? options.rotation : 0;
  this.setProperties(properties);

  /**
   * @private
   * @type {olx.ViewOptions}
   */
  this.options_ = options;
};

/**
 * Get an updated version of the view options used to construct the view.  The
 * current resolution (or zoom), center, and rotation are applied to any stored
 * options.  The provided options can be uesd to apply new min/max zoom or
 * resolution limits.
 * @param {olx.ViewOptions} newOptions New options to be applied.
 * @return {olx.ViewOptions} New options updated with the current view state.
 */
view__ol_View_.prototype.getUpdatedOptions_ = function (newOptions) {
  var options = obj["a" /* default */].assign({}, this.options_);

  // preserve resolution (or zoom)
  if (options.resolution !== undefined) {
    options.resolution = this.getResolution();
  } else {
    options.zoom = this.getZoom();
  }

  // preserve center
  options.center = this.getCenter();

  // preserve rotation
  options.rotation = this.getRotation();

  return obj["a" /* default */].assign({}, options, newOptions);
};

/**
 * Animate the view.  The view's center, zoom (or resolution), and rotation
 * can be animated for smooth transitions between view states.  For example,
 * to animate the view to a new zoom level:
 *
 *     view.animate({zoom: view.getZoom() + 1});
 *
 * By default, the animation lasts one second and uses in-and-out easing.  You
 * can customize this behavior by including `duration` (in milliseconds) and
 * `easing` options (see {@link ol.easing}).
 *
 * To chain together multiple animations, call the method with multiple
 * animation objects.  For example, to first zoom and then pan:
 *
 *     view.animate({zoom: 10}, {center: [0, 0]});
 *
 * If you provide a function as the last argument to the animate method, it
 * will get called at the end of an animation series.  The callback will be
 * called with `true` if the animation series completed on its own or `false`
 * if it was cancelled.
 *
 * Animations are cancelled by user interactions (e.g. dragging the map) or by
 * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
 * (or another method that calls one of these).
 *
 * @param {...(olx.AnimationOptions|function(boolean))} var_args Animation
 *     options.  Multiple animations can be run in series by passing multiple
 *     options objects.  To run multiple animations in parallel, call the method
 *     multiple times.  An optional callback can be provided as a final
 *     argument.  The callback will be called with a boolean indicating whether
 *     the animation completed without being cancelled.
 * @api
 */
view__ol_View_.prototype.animate = function (var_args) {
  var animationCount = arguments.length;
  var callback;
  if (animationCount > 1 && typeof arguments[animationCount - 1] === 'function') {
    callback = arguments[animationCount - 1];
    --animationCount;
  }
  if (!this.isDef()) {
    // if view properties are not yet set, shortcut to the final state
    var state = arguments[animationCount - 1];
    if (state.center) {
      this.setCenter(state.center);
    }
    if (state.zoom !== undefined) {
      this.setZoom(state.zoom);
    }
    if (state.rotation !== undefined) {
      this.setRotation(state.rotation);
    }
    if (callback) {
      callback(true);
    }
    return;
  }
  var start = Date.now();
  var center = this.getCenter().slice();
  var resolution = this.getResolution();
  var rotation = this.getRotation();
  var series = [];
  for (var i = 0; i < animationCount; ++i) {
    var options = /** @type {olx.AnimationOptions} */arguments[i];

    var animation = /** @type {ol.ViewAnimation} */{
      start: start,
      complete: false,
      anchor: options.anchor,
      duration: options.duration !== undefined ? options.duration : 1000,
      easing: options.easing || easing["a" /* default */].inAndOut
    };

    if (options.center) {
      animation.sourceCenter = center;
      animation.targetCenter = options.center;
      center = animation.targetCenter;
    }

    if (options.zoom !== undefined) {
      animation.sourceResolution = resolution;
      animation.targetResolution = this.constrainResolution(this.maxResolution_, options.zoom - this.minZoom_, 0);
      resolution = animation.targetResolution;
    } else if (options.resolution) {
      animation.sourceResolution = resolution;
      animation.targetResolution = options.resolution;
      resolution = animation.targetResolution;
    }

    if (options.rotation !== undefined) {
      animation.sourceRotation = rotation;
      var delta = math["a" /* default */].modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
      animation.targetRotation = rotation + delta;
      rotation = animation.targetRotation;
    }

    animation.callback = callback;

    // check if animation is a no-op
    if (view__ol_View_.isNoopAnimation(animation)) {
      animation.complete = true;
      // we still push it onto the series for callback handling
    } else {
      start += animation.duration;
    }
    series.push(animation);
  }
  this.animations_.push(series);
  this.setHint(viewhint["a" /* default */].ANIMATING, 1);
  this.updateAnimations_();
};

/**
 * Determine if the view is being animated.
 * @return {boolean} The view is being animated.
 * @api
 */
view__ol_View_.prototype.getAnimating = function () {
  return this.hints_[viewhint["a" /* default */].ANIMATING] > 0;
};

/**
 * Determine if the user is interacting with the view, such as panning or zooming.
 * @return {boolean} The view is being interacted with.
 * @api
 */
view__ol_View_.prototype.getInteracting = function () {
  return this.hints_[viewhint["a" /* default */].INTERACTING] > 0;
};

/**
 * Cancel any ongoing animations.
 * @api
 */
view__ol_View_.prototype.cancelAnimations = function () {
  this.setHint(viewhint["a" /* default */].ANIMATING, -this.hints_[viewhint["a" /* default */].ANIMATING]);
  for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
    var series = this.animations_[i];
    if (series[0].callback) {
      series[0].callback(false);
    }
  }
  this.animations_.length = 0;
};

/**
 * Update all animations.
 */
view__ol_View_.prototype.updateAnimations_ = function () {
  if (this.updateAnimationKey_ !== undefined) {
    cancelAnimationFrame(this.updateAnimationKey_);
    this.updateAnimationKey_ = undefined;
  }
  if (!this.getAnimating()) {
    return;
  }
  var now = Date.now();
  var more = false;
  for (var i = this.animations_.length - 1; i >= 0; --i) {
    var series = this.animations_[i];
    var seriesComplete = true;
    for (var j = 0, jj = series.length; j < jj; ++j) {
      var animation = series[j];
      if (animation.complete) {
        continue;
      }
      var elapsed = now - animation.start;
      var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
      if (fraction >= 1) {
        animation.complete = true;
        fraction = 1;
      } else {
        seriesComplete = false;
      }
      var progress = animation.easing(fraction);
      if (animation.sourceCenter) {
        var x0 = animation.sourceCenter[0];
        var y0 = animation.sourceCenter[1];
        var x1 = animation.targetCenter[0];
        var y1 = animation.targetCenter[1];
        var x = x0 + progress * (x1 - x0);
        var y = y0 + progress * (y1 - y0);
        this.set(viewproperty.CENTER, [x, y]);
      }
      if (animation.sourceResolution && animation.targetResolution) {
        var resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
        if (animation.anchor) {
          this.set(viewproperty.CENTER, this.calculateCenterZoom(resolution, animation.anchor));
        }
        this.set(viewproperty.RESOLUTION, resolution);
      }
      if (animation.sourceRotation !== undefined && animation.targetRotation !== undefined) {
        var rotation = progress === 1 ? math["a" /* default */].modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
        if (animation.anchor) {
          this.set(viewproperty.CENTER, this.calculateCenterRotate(rotation, animation.anchor));
        }
        this.set(viewproperty.ROTATION, rotation);
      }
      more = true;
      if (!animation.complete) {
        break;
      }
    }
    if (seriesComplete) {
      this.animations_[i] = null;
      this.setHint(viewhint["a" /* default */].ANIMATING, -1);
      var callback = series[0].callback;
      if (callback) {
        callback(true);
      }
    }
  }
  // prune completed series
  this.animations_ = this.animations_.filter(Boolean);
  if (more && this.updateAnimationKey_ === undefined) {
    this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_);
  }
};

/**
 * @param {number} rotation Target rotation.
 * @param {ol.Coordinate} anchor Rotation anchor.
 * @return {ol.Coordinate|undefined} Center for rotation and anchor.
 */
view__ol_View_.prototype.calculateCenterRotate = function (rotation, anchor) {
  var center;
  var currentCenter = this.getCenter();
  if (currentCenter !== undefined) {
    center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
    coordinate["a" /* default */].rotate(center, rotation - this.getRotation());
    coordinate["a" /* default */].add(center, anchor);
  }
  return center;
};

/**
 * @param {number} resolution Target resolution.
 * @param {ol.Coordinate} anchor Zoom anchor.
 * @return {ol.Coordinate|undefined} Center for resolution and anchor.
 */
view__ol_View_.prototype.calculateCenterZoom = function (resolution, anchor) {
  var center;
  var currentCenter = this.getCenter();
  var currentResolution = this.getResolution();
  if (currentCenter !== undefined && currentResolution !== undefined) {
    var x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
    var y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
    center = [x, y];
  }
  return center;
};

/**
 * @private
 * @return {ol.Size} Viewport size or `[100, 100]` when no viewport is found.
 */
view__ol_View_.prototype.getSizeFromViewport_ = function () {
  var size = [100, 100];
  var selector = '.ol-viewport[data-view="' + ol["a" /* default */].getUid(this) + '"]';
  var element = document.querySelector(selector);
  if (element) {
    var metrics = getComputedStyle(element);
    size[0] = parseInt(metrics.width, 10);
    size[1] = parseInt(metrics.height, 10);
  }
  return size;
};

/**
 * Get the constrained center of this view.
 * @param {ol.Coordinate|undefined} center Center.
 * @return {ol.Coordinate|undefined} Constrained center.
 * @api
 */
view__ol_View_.prototype.constrainCenter = function (center) {
  return this.constraints_.center(center);
};

/**
 * Get the constrained resolution of this view.
 * @param {number|undefined} resolution Resolution.
 * @param {number=} opt_delta Delta. Default is `0`.
 * @param {number=} opt_direction Direction. Default is `0`.
 * @return {number|undefined} Constrained resolution.
 * @api
 */
view__ol_View_.prototype.constrainResolution = function (resolution, opt_delta, opt_direction) {
  var delta = opt_delta || 0;
  var direction = opt_direction || 0;
  return this.constraints_.resolution(resolution, delta, direction);
};

/**
 * Get the constrained rotation of this view.
 * @param {number|undefined} rotation Rotation.
 * @param {number=} opt_delta Delta. Default is `0`.
 * @return {number|undefined} Constrained rotation.
 * @api
 */
view__ol_View_.prototype.constrainRotation = function (rotation, opt_delta) {
  var delta = opt_delta || 0;
  return this.constraints_.rotation(rotation, delta);
};

/**
 * Get the view center.
 * @return {ol.Coordinate|undefined} The center of the view.
 * @observable
 * @api
 */
view__ol_View_.prototype.getCenter = function () {
  return (
    /** @type {ol.Coordinate|undefined} */this.get(viewproperty.CENTER)
  );
};

/**
 * @return {ol.Constraints} Constraints.
 */
view__ol_View_.prototype.getConstraints = function () {
  return this.constraints_;
};

/**
 * @param {Array.<number>=} opt_hints Destination array.
 * @return {Array.<number>} Hint.
 */
view__ol_View_.prototype.getHints = function (opt_hints) {
  if (opt_hints !== undefined) {
    opt_hints[0] = this.hints_[0];
    opt_hints[1] = this.hints_[1];
    return opt_hints;
  } else {
    return this.hints_.slice();
  }
};

/**
 * Calculate the extent for the current view state and the passed size.
 * The size is the pixel dimensions of the box into which the calculated extent
 * should fit. In most cases you want to get the extent of the entire map,
 * that is `map.getSize()`.
 * @param {ol.Size=} opt_size Box pixel size. If not provided, the size of the
 * first map that uses this view will be used.
 * @return {ol.Extent} Extent.
 * @api
 */
view__ol_View_.prototype.calculateExtent = function (opt_size) {
  var size = opt_size || this.getSizeFromViewport_();
  var center = /** @type {!ol.Coordinate} */this.getCenter();
  asserts["a" /* default */].assert(center, 1); // The view center is not defined
  var resolution = /** @type {!number} */this.getResolution();
  asserts["a" /* default */].assert(resolution !== undefined, 2); // The view resolution is not defined
  var rotation = /** @type {!number} */this.getRotation();
  asserts["a" /* default */].assert(rotation !== undefined, 3); // The view rotation is not defined

  return ol_extent["a" /* default */].getForViewAndSize(center, resolution, rotation, size);
};

/**
 * Get the maximum resolution of the view.
 * @return {number} The maximum resolution of the view.
 * @api
 */
view__ol_View_.prototype.getMaxResolution = function () {
  return this.maxResolution_;
};

/**
 * Get the minimum resolution of the view.
 * @return {number} The minimum resolution of the view.
 * @api
 */
view__ol_View_.prototype.getMinResolution = function () {
  return this.minResolution_;
};

/**
 * Get the maximum zoom level for the view.
 * @return {number} The maximum zoom level.
 * @api
 */
view__ol_View_.prototype.getMaxZoom = function () {
  return (/** @type {number} */this.getZoomForResolution(this.minResolution_)
  );
};

/**
 * Set a new maximum zoom level for the view.
 * @param {number} zoom The maximum zoom level.
 * @api
 */
view__ol_View_.prototype.setMaxZoom = function (zoom) {
  this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
};

/**
 * Get the minimum zoom level for the view.
 * @return {number} The minimum zoom level.
 * @api
 */
view__ol_View_.prototype.getMinZoom = function () {
  return (/** @type {number} */this.getZoomForResolution(this.maxResolution_)
  );
};

/**
 * Set a new minimum zoom level for the view.
 * @param {number} zoom The minimum zoom level.
 * @api
 */
view__ol_View_.prototype.setMinZoom = function (zoom) {
  this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
};

/**
 * Get the view projection.
 * @return {ol.proj.Projection} The projection of the view.
 * @api
 */
view__ol_View_.prototype.getProjection = function () {
  return this.projection_;
};

/**
 * Get the view resolution.
 * @return {number|undefined} The resolution of the view.
 * @observable
 * @api
 */
view__ol_View_.prototype.getResolution = function () {
  return (
    /** @type {number|undefined} */this.get(viewproperty.RESOLUTION)
  );
};

/**
 * Get the resolutions for the view. This returns the array of resolutions
 * passed to the constructor of the {ol.View}, or undefined if none were given.
 * @return {Array.<number>|undefined} The resolutions of the view.
 * @api
 */
view__ol_View_.prototype.getResolutions = function () {
  return this.resolutions_;
};

/**
 * Get the resolution for a provided extent (in map units) and size (in pixels).
 * @param {ol.Extent} extent Extent.
 * @param {ol.Size=} opt_size Box pixel size.
 * @return {number} The resolution at which the provided extent will render at
 *     the given size.
 * @api
 */
view__ol_View_.prototype.getResolutionForExtent = function (extent, opt_size) {
  var size = opt_size || this.getSizeFromViewport_();
  var xResolution = ol_extent["a" /* default */].getWidth(extent) / size[0];
  var yResolution = ol_extent["a" /* default */].getHeight(extent) / size[1];
  return Math.max(xResolution, yResolution);
};

/**
 * Return a function that returns a value between 0 and 1 for a
 * resolution. Exponential scaling is assumed.
 * @param {number=} opt_power Power.
 * @return {function(number): number} Resolution for value function.
 */
view__ol_View_.prototype.getResolutionForValueFunction = function (opt_power) {
  var power = opt_power || 2;
  var maxResolution = this.maxResolution_;
  var minResolution = this.minResolution_;
  var max = Math.log(maxResolution / minResolution) / Math.log(power);
  return (
    /**
     * @param {number} value Value.
     * @return {number} Resolution.
     */
    function (value) {
      var resolution = maxResolution / Math.pow(power, value * max);
      return resolution;
    }
  );
};

/**
 * Get the view rotation.
 * @return {number} The rotation of the view in radians.
 * @observable
 * @api
 */
view__ol_View_.prototype.getRotation = function () {
  return (
    /** @type {number} */this.get(viewproperty.ROTATION)
  );
};

/**
 * Return a function that returns a resolution for a value between
 * 0 and 1. Exponential scaling is assumed.
 * @param {number=} opt_power Power.
 * @return {function(number): number} Value for resolution function.
 */
view__ol_View_.prototype.getValueForResolutionFunction = function (opt_power) {
  var power = opt_power || 2;
  var maxResolution = this.maxResolution_;
  var minResolution = this.minResolution_;
  var max = Math.log(maxResolution / minResolution) / Math.log(power);
  return (
    /**
     * @param {number} resolution Resolution.
     * @return {number} Value.
     */
    function (resolution) {
      var value = Math.log(maxResolution / resolution) / Math.log(power) / max;
      return value;
    }
  );
};

/**
 * @return {olx.ViewState} View state.
 */
view__ol_View_.prototype.getState = function () {
  var center = /** @type {ol.Coordinate} */this.getCenter();
  var projection = this.getProjection();
  var resolution = /** @type {number} */this.getResolution();
  var rotation = this.getRotation();
  return (/** @type {olx.ViewState} */{
      center: center.slice(),
      projection: projection !== undefined ? projection : null,
      resolution: resolution,
      rotation: rotation,
      zoom: this.getZoom()
    }
  );
};

/**
 * Get the current zoom level.  If you configured your view with a resolutions
 * array (this is rare), this method may return non-integer zoom levels (so
 * the zoom level is not safe to use as an index into a resolutions array).
 * @return {number|undefined} Zoom.
 * @api
 */
view__ol_View_.prototype.getZoom = function () {
  var zoom;
  var resolution = this.getResolution();
  if (resolution !== undefined) {
    zoom = this.getZoomForResolution(resolution);
  }
  return zoom;
};

/**
 * Get the zoom level for a resolution.
 * @param {number} resolution The resolution.
 * @return {number|undefined} The zoom level for the provided resolution.
 * @api
 */
view__ol_View_.prototype.getZoomForResolution = function (resolution) {
  var offset = this.minZoom_ || 0;
  var max, zoomFactor;
  if (this.resolutions_) {
    var nearest = array["a" /* default */].linearFindNearest(this.resolutions_, resolution, 1);
    offset = nearest;
    max = this.resolutions_[nearest];
    if (nearest == this.resolutions_.length - 1) {
      zoomFactor = 2;
    } else {
      zoomFactor = max / this.resolutions_[nearest + 1];
    }
  } else {
    max = this.maxResolution_;
    zoomFactor = this.zoomFactor_;
  }
  return offset + Math.log(max / resolution) / Math.log(zoomFactor);
};

/**
 * Get the resolution for a zoom level.
 * @param {number} zoom Zoom level.
 * @return {number} The view resolution for the provided zoom level.
 * @api
 */
view__ol_View_.prototype.getResolutionForZoom = function (zoom) {
  return (/** @type {number} */this.constrainResolution(this.maxResolution_, zoom - this.minZoom_, 0)
  );
};

/**
 * Fit the given geometry or extent based on the given map size and border.
 * The size is pixel dimensions of the box to fit the extent into.
 * In most cases you will want to use the map size, that is `map.getSize()`.
 * Takes care of the map angle.
 * @param {ol.geom.SimpleGeometry|ol.Extent} geometryOrExtent The geometry or
 *     extent to fit the view to.
 * @param {olx.view.FitOptions=} opt_options Options.
 * @api
 */
view__ol_View_.prototype.fit = function (geometryOrExtent, opt_options) {
  var options = opt_options || {};
  var size = options.size;
  if (!size) {
    size = this.getSizeFromViewport_();
  }
  /** @type {ol.geom.SimpleGeometry} */
  var geometry;
  if (!(geometryOrExtent instanceof simplegeometry["a" /* default */])) {
    asserts["a" /* default */].assert(Array.isArray(geometryOrExtent), 24); // Invalid extent or geometry provided as `geometry`
    asserts["a" /* default */].assert(!ol_extent["a" /* default */].isEmpty(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`
    geometry = polygon["a" /* default */].fromExtent(geometryOrExtent);
  } else if (geometryOrExtent.getType() === geometrytype["a" /* default */].CIRCLE) {
    geometryOrExtent = geometryOrExtent.getExtent();
    geometry = polygon["a" /* default */].fromExtent(geometryOrExtent);
    geometry.rotate(this.getRotation(), ol_extent["a" /* default */].getCenter(geometryOrExtent));
  } else {
    geometry = geometryOrExtent;
  }

  var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
  var constrainResolution = options.constrainResolution !== undefined ? options.constrainResolution : true;
  var nearest = options.nearest !== undefined ? options.nearest : false;
  var minResolution;
  if (options.minResolution !== undefined) {
    minResolution = options.minResolution;
  } else if (options.maxZoom !== undefined) {
    minResolution = this.constrainResolution(this.maxResolution_, options.maxZoom - this.minZoom_, 0);
  } else {
    minResolution = 0;
  }
  var coords = geometry.getFlatCoordinates();

  // calculate rotated extent
  var rotation = this.getRotation();
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var minRotX = +Infinity;
  var minRotY = +Infinity;
  var maxRotX = -Infinity;
  var maxRotY = -Infinity;
  var stride = geometry.getStride();
  for (var i = 0, ii = coords.length; i < ii; i += stride) {
    var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
    var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
    minRotX = Math.min(minRotX, rotX);
    minRotY = Math.min(minRotY, rotY);
    maxRotX = Math.max(maxRotX, rotX);
    maxRotY = Math.max(maxRotY, rotY);
  }

  // calculate resolution
  var resolution = this.getResolutionForExtent([minRotX, minRotY, maxRotX, maxRotY], [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
  resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
  if (constrainResolution) {
    var constrainedResolution = this.constrainResolution(resolution, 0, 0);
    if (!nearest && constrainedResolution < resolution) {
      constrainedResolution = this.constrainResolution(constrainedResolution, -1, 0);
    }
    resolution = constrainedResolution;
  }

  // calculate center
  sinAngle = -sinAngle; // go back to original rotation
  var centerRotX = (minRotX + maxRotX) / 2;
  var centerRotY = (minRotY + maxRotY) / 2;
  centerRotX += (padding[1] - padding[3]) / 2 * resolution;
  centerRotY += (padding[0] - padding[2]) / 2 * resolution;
  var centerX = centerRotX * cosAngle - centerRotY * sinAngle;
  var centerY = centerRotY * cosAngle + centerRotX * sinAngle;
  var center = [centerX, centerY];
  var callback = options.callback ? options.callback : ol["a" /* default */].nullFunction;

  if (options.duration !== undefined) {
    this.animate({
      resolution: resolution,
      center: center,
      duration: options.duration,
      easing: options.easing
    }, callback);
  } else {
    this.setResolution(resolution);
    this.setCenter(center);
    setTimeout(callback.bind(undefined, true), 0);
  }
};

/**
 * Center on coordinate and view position.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.Size} size Box pixel size.
 * @param {ol.Pixel} position Position on the view to center on.
 * @api
 */
view__ol_View_.prototype.centerOn = function (coordinate, size, position) {
  // calculate rotated position
  var rotation = this.getRotation();
  var cosAngle = Math.cos(-rotation);
  var sinAngle = Math.sin(-rotation);
  var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  var resolution = this.getResolution();
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;

  // go back to original angle
  sinAngle = -sinAngle; // go back to original rotation
  var centerX = rotX * cosAngle - rotY * sinAngle;
  var centerY = rotY * cosAngle + rotX * sinAngle;

  this.setCenter([centerX, centerY]);
};

/**
 * @return {boolean} Is defined.
 */
view__ol_View_.prototype.isDef = function () {
  return !!this.getCenter() && this.getResolution() !== undefined;
};

/**
 * Rotate the view around a given coordinate.
 * @param {number} rotation New rotation value for the view.
 * @param {ol.Coordinate=} opt_anchor The rotation center.
 * @api
 */
view__ol_View_.prototype.rotate = function (rotation, opt_anchor) {
  if (opt_anchor !== undefined) {
    var center = this.calculateCenterRotate(rotation, opt_anchor);
    this.setCenter(center);
  }
  this.setRotation(rotation);
};

/**
 * Set the center of the current view.
 * @param {ol.Coordinate|undefined} center The center of the view.
 * @observable
 * @api
 */
view__ol_View_.prototype.setCenter = function (center) {
  this.set(viewproperty.CENTER, center);
  if (this.getAnimating()) {
    this.cancelAnimations();
  }
};

/**
 * @param {ol.ViewHint} hint Hint.
 * @param {number} delta Delta.
 * @return {number} New value.
 */
view__ol_View_.prototype.setHint = function (hint, delta) {
  this.hints_[hint] += delta;
  this.changed();
  return this.hints_[hint];
};

/**
 * Set the resolution for this view.
 * @param {number|undefined} resolution The resolution of the view.
 * @observable
 * @api
 */
view__ol_View_.prototype.setResolution = function (resolution) {
  this.set(viewproperty.RESOLUTION, resolution);
  if (this.getAnimating()) {
    this.cancelAnimations();
  }
};

/**
 * Set the rotation for this view.
 * @param {number} rotation The rotation of the view in radians.
 * @observable
 * @api
 */
view__ol_View_.prototype.setRotation = function (rotation) {
  this.set(viewproperty.ROTATION, rotation);
  if (this.getAnimating()) {
    this.cancelAnimations();
  }
};

/**
 * Zoom to a specific zoom level.
 * @param {number} zoom Zoom level.
 * @api
 */
view__ol_View_.prototype.setZoom = function (zoom) {
  this.setResolution(this.getResolutionForZoom(zoom));
};

/**
 * @param {olx.ViewOptions} options View options.
 * @private
 * @return {ol.CenterConstraintType} The constraint.
 */
view__ol_View_.createCenterConstraint_ = function (options) {
  if (options.extent !== undefined) {
    return centerconstraint.createExtent(options.extent);
  } else {
    return centerconstraint.none;
  }
};

/**
 * @private
 * @param {olx.ViewOptions} options View options.
 * @return {{constraint: ol.ResolutionConstraintType, maxResolution: number,
 *     minResolution: number, zoomFactor: number}} The constraint.
 */
view__ol_View_.createResolutionConstraint_ = function (options) {
  var resolutionConstraint;
  var maxResolution;
  var minResolution;

  // TODO: move these to be ol constants
  // see https://github.com/openlayers/openlayers/issues/2076
  var defaultMaxZoom = 28;
  var defaultZoomFactor = 2;

  var minZoom = options.minZoom !== undefined ? options.minZoom : ol["a" /* default */].DEFAULT_MIN_ZOOM;

  var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;

  var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;

  if (options.resolutions !== undefined) {
    var resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== undefined ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    resolutionConstraint = resolutionconstraint.createSnapToResolutions(resolutions);
  } else {
    // calculate the default min and max resolution
    var projection = proj["default"].createProjection(options.projection, 'EPSG:3857');
    var extent = projection.getExtent();
    var size = !extent ?
    // use an extent that can fit the whole world if need be
    360 * proj["default"].METERS_PER_UNIT[units["a" /* default */].DEGREES] / projection.getMetersPerUnit() : Math.max(ol_extent["a" /* default */].getWidth(extent), ol_extent["a" /* default */].getHeight(extent));

    var defaultMaxResolution = size / ol["a" /* default */].DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, ol["a" /* default */].DEFAULT_MIN_ZOOM);

    var defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - ol["a" /* default */].DEFAULT_MIN_ZOOM);

    // user provided maxResolution takes precedence
    maxResolution = options.maxResolution;
    if (maxResolution !== undefined) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }

    // user provided minResolution takes precedence
    minResolution = options.minResolution;
    if (minResolution === undefined) {
      if (options.maxZoom !== undefined) {
        if (options.maxResolution !== undefined) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }

    // given discrete zoom levels, minResolution may be different than provided
    maxZoom = minZoom + Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);

    resolutionConstraint = resolutionconstraint.createSnapToPower(zoomFactor, maxResolution, maxZoom - minZoom);
  }
  return { constraint: resolutionConstraint, maxResolution: maxResolution,
    minResolution: minResolution, minZoom: minZoom, zoomFactor: zoomFactor };
};

/**
 * @private
 * @param {olx.ViewOptions} options View options.
 * @return {ol.RotationConstraintType} Rotation constraint.
 */
view__ol_View_.createRotationConstraint_ = function (options) {
  var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;
  if (enableRotation) {
    var constrainRotation = options.constrainRotation;
    if (constrainRotation === undefined || constrainRotation === true) {
      return rotationconstraint["a" /* default */].createSnapToZero();
    } else if (constrainRotation === false) {
      return rotationconstraint["a" /* default */].none;
    } else if (typeof constrainRotation === 'number') {
      return rotationconstraint["a" /* default */].createSnapToN(constrainRotation);
    } else {
      return rotationconstraint["a" /* default */].none;
    }
  } else {
    return rotationconstraint["a" /* default */].disable;
  }
};

/**
 * Determine if an animation involves no view change.
 * @param {ol.ViewAnimation} animation The animation.
 * @return {boolean} The animation involves no view change.
 */
view__ol_View_.isNoopAnimation = function (animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!coordinate["a" /* default */].equals(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
};
/* harmony default export */ var view = __webpack_exports__["default"] = (view__ol_View_);

/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__object_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__layer_property_js__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__math_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__obj_js__ = __webpack_require__(2);






/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Note that with `ol.layer.Base` and all its subclasses, any property set in
 * the options is set as a {@link ol.Object} property on the layer object, so
 * is observable, and has get/set accessors.
 *
 * @constructor
 * @abstract
 * @extends {ol.Object}
 * @param {olx.layer.BaseOptions} options Layer options.
 * @api
 */
var _ol_layer_Base_ = function _ol_layer_Base_(options) {

  __WEBPACK_IMPORTED_MODULE_1__object_js__["a" /* default */].call(this);

  /**
   * @type {Object.<string, *>}
   */
  var properties = __WEBPACK_IMPORTED_MODULE_4__obj_js__["a" /* default */].assign({}, options);
  properties[__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].OPACITY] = options.opacity !== undefined ? options.opacity : 1;
  properties[__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].VISIBLE] = options.visible !== undefined ? options.visible : true;
  properties[__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].Z_INDEX] = options.zIndex !== undefined ? options.zIndex : 0;
  properties[__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].MAX_RESOLUTION] = options.maxResolution !== undefined ? options.maxResolution : Infinity;
  properties[__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].MIN_RESOLUTION] = options.minResolution !== undefined ? options.minResolution : 0;

  this.setProperties(properties);

  /**
   * @type {ol.LayerState}
   * @private
   */
  this.state_ = /** @type {ol.LayerState} */{
    layer: /** @type {ol.layer.Layer} */this,
    managed: true
  };

  /**
   * The layer type.
   * @type {ol.LayerType}
   * @protected;
   */
  this.type;
};

__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].inherits(_ol_layer_Base_, __WEBPACK_IMPORTED_MODULE_1__object_js__["a" /* default */]);

/**
 * Get the layer type (used when creating a layer renderer).
 * @return {ol.LayerType} The layer type.
 */
_ol_layer_Base_.prototype.getType = function () {
  return this.type;
};

/**
 * @return {ol.LayerState} Layer state.
 */
_ol_layer_Base_.prototype.getLayerState = function () {
  this.state_.opacity = __WEBPACK_IMPORTED_MODULE_3__math_js__["a" /* default */].clamp(this.getOpacity(), 0, 1);
  this.state_.sourceState = this.getSourceState();
  this.state_.visible = this.getVisible();
  this.state_.extent = this.getExtent();
  this.state_.zIndex = this.getZIndex();
  this.state_.maxResolution = this.getMaxResolution();
  this.state_.minResolution = Math.max(this.getMinResolution(), 0);

  return this.state_;
};

/**
 * @abstract
 * @param {Array.<ol.layer.Layer>=} opt_array Array of layers (to be
 *     modified in place).
 * @return {Array.<ol.layer.Layer>} Array of layers.
 */
_ol_layer_Base_.prototype.getLayersArray = function (opt_array) {};

/**
 * @abstract
 * @param {Array.<ol.LayerState>=} opt_states Optional list of layer
 *     states (to be modified in place).
 * @return {Array.<ol.LayerState>} List of layer states.
 */
_ol_layer_Base_.prototype.getLayerStatesArray = function (opt_states) {};

/**
 * Return the {@link ol.Extent extent} of the layer or `undefined` if it
 * will be visible regardless of extent.
 * @return {ol.Extent|undefined} The layer extent.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.getExtent = function () {
  return (
    /** @type {ol.Extent|undefined} */this.get(__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].EXTENT)
  );
};

/**
 * Return the maximum resolution of the layer.
 * @return {number} The maximum resolution of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.getMaxResolution = function () {
  return (
    /** @type {number} */this.get(__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].MAX_RESOLUTION)
  );
};

/**
 * Return the minimum resolution of the layer.
 * @return {number} The minimum resolution of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.getMinResolution = function () {
  return (
    /** @type {number} */this.get(__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].MIN_RESOLUTION)
  );
};

/**
 * Return the opacity of the layer (between 0 and 1).
 * @return {number} The opacity of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.getOpacity = function () {
  return (
    /** @type {number} */this.get(__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].OPACITY)
  );
};

/**
 * @abstract
 * @return {ol.source.State} Source state.
 */
_ol_layer_Base_.prototype.getSourceState = function () {};

/**
 * Return the visibility of the layer (`true` or `false`).
 * @return {boolean} The visibility of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.getVisible = function () {
  return (
    /** @type {boolean} */this.get(__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].VISIBLE)
  );
};

/**
 * Return the Z-index of the layer, which is used to order layers before
 * rendering. The default Z-index is 0.
 * @return {number} The Z-index of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.getZIndex = function () {
  return (
    /** @type {number} */this.get(__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].Z_INDEX)
  );
};

/**
 * Set the extent at which the layer is visible.  If `undefined`, the layer
 * will be visible at all extents.
 * @param {ol.Extent|undefined} extent The extent of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.setExtent = function (extent) {
  this.set(__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].EXTENT, extent);
};

/**
 * Set the maximum resolution at which the layer is visible.
 * @param {number} maxResolution The maximum resolution of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.setMaxResolution = function (maxResolution) {
  this.set(__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].MAX_RESOLUTION, maxResolution);
};

/**
 * Set the minimum resolution at which the layer is visible.
 * @param {number} minResolution The minimum resolution of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.setMinResolution = function (minResolution) {
  this.set(__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].MIN_RESOLUTION, minResolution);
};

/**
 * Set the opacity of the layer, allowed values range from 0 to 1.
 * @param {number} opacity The opacity of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.setOpacity = function (opacity) {
  this.set(__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].OPACITY, opacity);
};

/**
 * Set the visibility of the layer (`true` or `false`).
 * @param {boolean} visible The visibility of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.setVisible = function (visible) {
  this.set(__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].VISIBLE, visible);
};

/**
 * Set Z-index of the layer, which is used to order layers before rendering.
 * The default Z-index is 0.
 * @param {number} zindex The z-index of the layer.
 * @observable
 * @api
 */
_ol_layer_Base_.prototype.setZIndex = function (zindex) {
  this.set(__WEBPACK_IMPORTED_MODULE_2__layer_property_js__["a" /* default */].Z_INDEX, zindex);
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_layer_Base_);

/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @enum {string}
 */
var _ol_layer_Property_ = {
  OPACITY: 'opacity',
  VISIBLE: 'visible',
  EXTENT: 'extent',
  Z_INDEX: 'zIndex',
  MAX_RESOLUTION: 'maxResolution',
  MIN_RESOLUTION: 'minResolution',
  SOURCE: 'source'
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_layer_Property_);

/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * @enum {string}
 * Render mode for vector layers:
 *  * `'image'`: Vector layers are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'vector'`: Vector layers are rendered as vectors. Most accurate rendering
 *    even during animations, but slower performance.
 * @api
 */
var _ol_layer_VectorRenderType_ = {
  IMAGE: 'image',
  VECTOR: 'vector'
};

/* harmony default export */ __webpack_exports__["a"] = (_ol_layer_VectorRenderType_);

/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rbush__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_rbush___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_rbush__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__extent_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__obj_js__ = __webpack_require__(2);





/**
 * Wrapper around the RBush by Vladimir Agafonkin.
 *
 * @constructor
 * @param {number=} opt_maxEntries Max entries.
 * @see https://github.com/mourner/rbush
 * @struct
 * @template T
 */
var _ol_structs_RBush_ = function _ol_structs_RBush_(opt_maxEntries) {

  /**
   * @private
   */
  this.rbush_ = __WEBPACK_IMPORTED_MODULE_1_rbush___default()(opt_maxEntries);

  /**
   * A mapping between the objects added to this rbush wrapper
   * and the objects that are actually added to the internal rbush.
   * @private
   * @type {Object.<number, ol.RBushEntry>}
   */
  this.items_ = {};
};

/**
 * Insert a value into the RBush.
 * @param {ol.Extent} extent Extent.
 * @param {T} value Value.
 */
_ol_structs_RBush_.prototype.insert = function (extent, value) {
  /** @type {ol.RBushEntry} */
  var item = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3],
    value: value
  };

  this.rbush_.insert(item);
  this.items_[__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].getUid(value)] = item;
};

/**
 * Bulk-insert values into the RBush.
 * @param {Array.<ol.Extent>} extents Extents.
 * @param {Array.<T>} values Values.
 */
_ol_structs_RBush_.prototype.load = function (extents, values) {
  var items = new Array(values.length);
  for (var i = 0, l = values.length; i < l; i++) {
    var extent = extents[i];
    var value = values[i];

    /** @type {ol.RBushEntry} */
    var item = {
      minX: extent[0],
      minY: extent[1],
      maxX: extent[2],
      maxY: extent[3],
      value: value
    };
    items[i] = item;
    this.items_[__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].getUid(value)] = item;
  }
  this.rbush_.load(items);
};

/**
 * Remove a value from the RBush.
 * @param {T} value Value.
 * @return {boolean} Removed.
 */
_ol_structs_RBush_.prototype.remove = function (value) {
  var uid = __WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].getUid(value);

  // get the object in which the value was wrapped when adding to the
  // internal rbush. then use that object to do the removal.
  var item = this.items_[uid];
  delete this.items_[uid];
  return this.rbush_.remove(item) !== null;
};

/**
 * Update the extent of a value in the RBush.
 * @param {ol.Extent} extent Extent.
 * @param {T} value Value.
 */
_ol_structs_RBush_.prototype.update = function (extent, value) {
  var item = this.items_[__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].getUid(value)];
  var bbox = [item.minX, item.minY, item.maxX, item.maxY];
  if (!__WEBPACK_IMPORTED_MODULE_2__extent_js__["a" /* default */].equals(bbox, extent)) {
    this.remove(value);
    this.insert(extent, value);
  }
};

/**
 * Return all values in the RBush.
 * @return {Array.<T>} All.
 */
_ol_structs_RBush_.prototype.getAll = function () {
  var items = this.rbush_.all();
  return items.map(function (item) {
    return item.value;
  });
};

/**
 * Return all values in the given extent.
 * @param {ol.Extent} extent Extent.
 * @return {Array.<T>} All in extent.
 */
_ol_structs_RBush_.prototype.getInExtent = function (extent) {
  /** @type {ol.RBushEntry} */
  var bbox = {
    minX: extent[0],
    minY: extent[1],
    maxX: extent[2],
    maxY: extent[3]
  };
  var items = this.rbush_.search(bbox);
  return items.map(function (item) {
    return item.value;
  });
};

/**
 * Calls a callback function with each value in the tree.
 * If the callback returns a truthy value, this value is returned without
 * checking the rest of the tree.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */
_ol_structs_RBush_.prototype.forEach = function (callback, opt_this) {
  return this.forEach_(this.getAll(), callback, opt_this);
};

/**
 * Calls a callback function with each value in the provided extent.
 * @param {ol.Extent} extent Extent.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @return {*} Callback return value.
 * @template S
 */
_ol_structs_RBush_.prototype.forEachInExtent = function (extent, callback, opt_this) {
  return this.forEach_(this.getInExtent(extent), callback, opt_this);
};

/**
 * @param {Array.<T>} values Values.
 * @param {function(this: S, T): *} callback Callback.
 * @param {S=} opt_this The object to use as `this` in `callback`.
 * @private
 * @return {*} Callback return value.
 * @template S
 */
_ol_structs_RBush_.prototype.forEach_ = function (values, callback, opt_this) {
  var result;
  for (var i = 0, l = values.length; i < l; i++) {
    result = callback.call(opt_this, values[i]);
    if (result) {
      return result;
    }
  }
  return result;
};

/**
 * @return {boolean} Is empty.
 */
_ol_structs_RBush_.prototype.isEmpty = function () {
  return __WEBPACK_IMPORTED_MODULE_3__obj_js__["a" /* default */].isEmpty(this.items_);
};

/**
 * Remove all values from the RBush.
 */
_ol_structs_RBush_.prototype.clear = function () {
  this.rbush_.clear();
  this.items_ = {};
};

/**
 * @param {ol.Extent=} opt_extent Extent.
 * @return {ol.Extent} Extent.
 */
_ol_structs_RBush_.prototype.getExtent = function (opt_extent) {
  // FIXME add getExtent() to rbush
  var data = this.rbush_.data;
  return __WEBPACK_IMPORTED_MODULE_2__extent_js__["a" /* default */].createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
};

/**
 * @param {ol.structs.RBush} rbush R-Tree.
 */
_ol_structs_RBush_.prototype.concat = function (rbush) {
  this.rbush_.load(rbush.rbush_.all());
  for (var i in rbush.items_) {
    this.items_[i | 0] = rbush.items_[i | 0];
  }
};
/* harmony default export */ __webpack_exports__["a"] = (_ol_structs_RBush_);

/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__layertype_js__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__layer_layer_js__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__layer_vectorrendertype_js__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__obj_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__style_style_js__ = __webpack_require__(39);







/**
 * @classdesc
 * Vector data that is rendered client-side.
 * Note that any property set in the options is set as a {@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @constructor
 * @extends {ol.layer.Layer}
 * @fires ol.render.Event
 * @param {olx.layer.VectorOptions=} opt_options Options.
 * @api
 */
var _ol_layer_Vector_ = function _ol_layer_Vector_(opt_options) {
  var options = opt_options ? opt_options : /** @type {olx.layer.VectorOptions} */{};

  var baseOptions = __WEBPACK_IMPORTED_MODULE_4__obj_js__["a" /* default */].assign({}, options);

  delete baseOptions.style;
  delete baseOptions.renderBuffer;
  delete baseOptions.updateWhileAnimating;
  delete baseOptions.updateWhileInteracting;
  __WEBPACK_IMPORTED_MODULE_2__layer_layer_js__["a" /* default */].call(this, /** @type {olx.layer.LayerOptions} */baseOptions);

  /**
   * @private
   * @type {boolean}
   */
  this.declutter_ = options.declutter !== undefined ? options.declutter : false;

  /**
   * @type {number}
   * @private
   */
  this.renderBuffer_ = options.renderBuffer !== undefined ? options.renderBuffer : 100;

  /**
   * User provided style.
   * @type {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
   * @private
   */
  this.style_ = null;

  /**
   * Style function for use within the library.
   * @type {ol.StyleFunction|undefined}
   * @private
   */
  this.styleFunction_ = undefined;

  this.setStyle(options.style);

  /**
   * @type {boolean}
   * @private
   */
  this.updateWhileAnimating_ = options.updateWhileAnimating !== undefined ? options.updateWhileAnimating : false;

  /**
   * @type {boolean}
   * @private
   */
  this.updateWhileInteracting_ = options.updateWhileInteracting !== undefined ? options.updateWhileInteracting : false;

  /**
   * @private
   * @type {ol.layer.VectorTileRenderType|string}
   */
  this.renderMode_ = options.renderMode || __WEBPACK_IMPORTED_MODULE_3__layer_vectorrendertype_js__["a" /* default */].VECTOR;

  /**
   * The layer type.
   * @protected
   * @type {ol.LayerType}
   */
  this.type = __WEBPACK_IMPORTED_MODULE_1__layertype_js__["a" /* default */].VECTOR;
};

__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].inherits(_ol_layer_Vector_, __WEBPACK_IMPORTED_MODULE_2__layer_layer_js__["a" /* default */]);

/**
 * @return {boolean} Declutter.
 */
_ol_layer_Vector_.prototype.getDeclutter = function () {
  return this.declutter_;
};

/**
 * @param {boolean} declutter Declutter.
 */
_ol_layer_Vector_.prototype.setDeclutter = function (declutter) {
  this.declutter_ = declutter;
};

/**
 * @return {number|undefined} Render buffer.
 */
_ol_layer_Vector_.prototype.getRenderBuffer = function () {
  return this.renderBuffer_;
};

/**
 * @return {function(ol.Feature, ol.Feature): number|null|undefined} Render
 *     order.
 */
_ol_layer_Vector_.prototype.getRenderOrder = function () {
  return (
    /** @type {ol.RenderOrderFunction|null|undefined} */this.get(_ol_layer_Vector_.Property_.RENDER_ORDER)
  );
};

/**
 * Return the associated {@link ol.source.Vector vectorsource} of the layer.
 * @function
 * @return {ol.source.Vector} Source.
 * @api
 */
_ol_layer_Vector_.prototype.getSource;

/**
 * Get the style for features.  This returns whatever was passed to the `style`
 * option at construction or to the `setStyle` method.
 * @return {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction}
 *     Layer style.
 * @api
 */
_ol_layer_Vector_.prototype.getStyle = function () {
  return this.style_;
};

/**
 * Get the style function.
 * @return {ol.StyleFunction|undefined} Layer style function.
 * @api
 */
_ol_layer_Vector_.prototype.getStyleFunction = function () {
  return this.styleFunction_;
};

/**
 * @return {boolean} Whether the rendered layer should be updated while
 *     animating.
 */
_ol_layer_Vector_.prototype.getUpdateWhileAnimating = function () {
  return this.updateWhileAnimating_;
};

/**
 * @return {boolean} Whether the rendered layer should be updated while
 *     interacting.
 */
_ol_layer_Vector_.prototype.getUpdateWhileInteracting = function () {
  return this.updateWhileInteracting_;
};

/**
 * @param {ol.RenderOrderFunction|null|undefined} renderOrder
 *     Render order.
 */
_ol_layer_Vector_.prototype.setRenderOrder = function (renderOrder) {
  this.set(_ol_layer_Vector_.Property_.RENDER_ORDER, renderOrder);
};

/**
 * Set the style for features.  This can be a single style object, an array
 * of styles, or a function that takes a feature and resolution and returns
 * an array of styles. If it is `undefined` the default style is used. If
 * it is `null` the layer has no style (a `null` style), so only features
 * that have their own styles will be rendered in the layer. See
 * {@link ol.style} for information on the default style.
 * @param {ol.style.Style|Array.<ol.style.Style>|ol.StyleFunction|null|undefined}
 *     style Layer style.
 * @api
 */
_ol_layer_Vector_.prototype.setStyle = function (style) {
  this.style_ = style !== undefined ? style : __WEBPACK_IMPORTED_MODULE_5__style_style_js__["default"].defaultFunction;
  this.styleFunction_ = style === null ? undefined : __WEBPACK_IMPORTED_MODULE_5__style_style_js__["default"].createFunction(this.style_);
  this.changed();
};

/**
 * @return {ol.layer.VectorRenderType|string} The render mode.
 */
_ol_layer_Vector_.prototype.getRenderMode = function () {
  return this.renderMode_;
};

/**
 * @enum {string}
 * @private
 */
_ol_layer_Vector_.Property_ = {
  RENDER_ORDER: 'renderOrder'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_layer_Vector_);

/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/ol/index.js
var ol = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ol/collection.js
var ol_collection = __webpack_require__(50);

// EXTERNAL MODULE: ./node_modules/ol/collectioneventtype.js
var collectioneventtype = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/ol/objecteventtype.js
var objecteventtype = __webpack_require__(54);

// EXTERNAL MODULE: ./node_modules/ol/array.js
var ol_array = __webpack_require__(5);

// EXTERNAL MODULE: ./node_modules/ol/asserts.js
var asserts = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/ol/events.js
var events = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/ol/events/event.js
var events_event = __webpack_require__(18);

// EXTERNAL MODULE: ./node_modules/ol/events/eventtype.js
var eventtype = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__(1);

// EXTERNAL MODULE: ./node_modules/ol/format/formattype.js
var formattype = __webpack_require__(78);

// CONCATENATED MODULE: ./node_modules/ol/xml.js

var _ol_xml_ = {};

/**
 * This document should be used when creating nodes for XML serializations. This
 * document is also used by {@link ol.xml.createElementNS} and
 * {@link ol.xml.setAttributeNS}
 * @const
 * @type {Document}
 */
_ol_xml_.DOCUMENT = typeof document !== 'undefined' ? document.implementation.createDocument('', '', null) : null;

/**
 * @param {string} namespaceURI Namespace URI.
 * @param {string} qualifiedName Qualified name.
 * @return {Node} Node.
 */
_ol_xml_.createElementNS = function (namespaceURI, qualifiedName) {
  return _ol_xml_.DOCUMENT.createElementNS(namespaceURI, qualifiedName);
};

/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @return {string} All text content.
 * @api
 */
_ol_xml_.getAllTextContent = function (node, normalizeWhitespace) {
  return _ol_xml_.getAllTextContent_(node, normalizeWhitespace, []).join('');
};

/**
 * Recursively grab all text content of child nodes into a single string.
 * @param {Node} node Node.
 * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
 * breaks.
 * @param {Array.<string>} accumulator Accumulator.
 * @private
 * @return {Array.<string>} Accumulator.
 */
_ol_xml_.getAllTextContent_ = function (node, normalizeWhitespace, accumulator) {
  if (node.nodeType == Node.CDATA_SECTION_NODE || node.nodeType == Node.TEXT_NODE) {
    if (normalizeWhitespace) {
      accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
    } else {
      accumulator.push(node.nodeValue);
    }
  } else {
    var n;
    for (n = node.firstChild; n; n = n.nextSibling) {
      _ol_xml_.getAllTextContent_(n, normalizeWhitespace, accumulator);
    }
  }
  return accumulator;
};

/**
 * @param {?} value Value.
 * @return {boolean} Is document.
 */
_ol_xml_.isDocument = function (value) {
  return value instanceof Document;
};

/**
 * @param {?} value Value.
 * @return {boolean} Is node.
 */
_ol_xml_.isNode = function (value) {
  return value instanceof Node;
};

/**
 * @param {Node} node Node.
 * @param {?string} namespaceURI Namespace URI.
 * @param {string} name Attribute name.
 * @return {string} Value
 */
_ol_xml_.getAttributeNS = function (node, namespaceURI, name) {
  return node.getAttributeNS(namespaceURI, name) || '';
};

/**
 * @param {Node} node Node.
 * @param {?string} namespaceURI Namespace URI.
 * @param {string} name Attribute name.
 * @param {string|number} value Value.
 */
_ol_xml_.setAttributeNS = function (node, namespaceURI, name, value) {
  node.setAttributeNS(namespaceURI, name, value);
};

/**
 * Parse an XML string to an XML Document.
 * @param {string} xml XML.
 * @return {Document} Document.
 * @api
 */
_ol_xml_.parse = function (xml) {
  return new DOMParser().parseFromString(xml, 'application/xml');
};

/**
 * Make an array extender function for extending the array at the top of the
 * object stack.
 * @param {function(this: T, Node, Array.<*>): (Array.<*>|undefined)}
 *     valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */
_ol_xml_.makeArrayExtender = function (valueReader, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this, node, objectStack);
      if (value !== undefined) {
        var array = /** @type {Array.<*>} */
        objectStack[objectStack.length - 1];
        ol_array["a" /* default */].extend(array, value);
      }
    }
  );
};

/**
 * Make an array pusher function for pushing to the array at the top of the
 * object stack.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */
_ol_xml_.makeArrayPusher = function (valueReader, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
      if (value !== undefined) {
        var array = objectStack[objectStack.length - 1];
        array.push(value);
      }
    }
  );
};

/**
 * Make an object stack replacer function for replacing the object at the
 * top of the stack.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */
_ol_xml_.makeReplacer = function (valueReader, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
      if (value !== undefined) {
        objectStack[objectStack.length - 1] = value;
      }
    }
  );
};

/**
 * Make an object property pusher function for adding a property to the
 * object at the top of the stack.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {string=} opt_property Property.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */
_ol_xml_.makeObjectPropertyPusher = function (valueReader, opt_property, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
      if (value !== undefined) {
        var object = /** @type {Object} */
        objectStack[objectStack.length - 1];
        var property = opt_property !== undefined ? opt_property : node.localName;
        var array;
        if (property in object) {
          array = object[property];
        } else {
          array = object[property] = [];
        }
        array.push(value);
      }
    }
  );
};

/**
 * Make an object property setter function.
 * @param {function(this: T, Node, Array.<*>): *} valueReader Value reader.
 * @param {string=} opt_property Property.
 * @param {T=} opt_this The object to use as `this` in `valueReader`.
 * @return {ol.XmlParser} Parser.
 * @template T
 */
_ol_xml_.makeObjectPropertySetter = function (valueReader, opt_property, opt_this) {
  return (
    /**
     * @param {Node} node Node.
     * @param {Array.<*>} objectStack Object stack.
     */
    function (node, objectStack) {
      var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
      if (value !== undefined) {
        var object = /** @type {Object} */
        objectStack[objectStack.length - 1];
        var property = opt_property !== undefined ? opt_property : node.localName;
        object[property] = value;
      }
    }
  );
};

/**
 * Create a serializer that appends nodes written by its `nodeWriter` to its
 * designated parent. The parent is the `node` of the
 * {@link ol.XmlNodeStackItem} at the top of the `objectStack`.
 * @param {function(this: T, Node, V, Array.<*>)}
 *     nodeWriter Node writer.
 * @param {T=} opt_this The object to use as `this` in `nodeWriter`.
 * @return {ol.XmlSerializer} Serializer.
 * @template T, V
 */
_ol_xml_.makeChildAppender = function (nodeWriter, opt_this) {
  return function (node, value, objectStack) {
    nodeWriter.call(opt_this !== undefined ? opt_this : this, node, value, objectStack);
    var parent = objectStack[objectStack.length - 1];
    var parentNode = parent.node;
    parentNode.appendChild(node);
  };
};

/**
 * Create a serializer that calls the provided `nodeWriter` from
 * {@link ol.xml.serialize}. This can be used by the parent writer to have the
 * 'nodeWriter' called with an array of values when the `nodeWriter` was
 * designed to serialize a single item. An example would be a LineString
 * geometry writer, which could be reused for writing MultiLineString
 * geometries.
 * @param {function(this: T, Node, V, Array.<*>)}
 *     nodeWriter Node writer.
 * @param {T=} opt_this The object to use as `this` in `nodeWriter`.
 * @return {ol.XmlSerializer} Serializer.
 * @template T, V
 */
_ol_xml_.makeArraySerializer = function (nodeWriter, opt_this) {
  var serializersNS, nodeFactory;
  return function (node, value, objectStack) {
    if (serializersNS === undefined) {
      serializersNS = {};
      var serializers = {};
      serializers[node.localName] = nodeWriter;
      serializersNS[node.namespaceURI] = serializers;
      nodeFactory = _ol_xml_.makeSimpleNodeFactory(node.localName);
    }
    _ol_xml_.serialize(serializersNS, nodeFactory, value, objectStack);
  };
};

/**
 * Create a node factory which can use the `opt_keys` passed to
 * {@link ol.xml.serialize} or {@link ol.xml.pushSerializeAndPop} as node names,
 * or a fixed node name. The namespace of the created nodes can either be fixed,
 * or the parent namespace will be used.
 * @param {string=} opt_nodeName Fixed node name which will be used for all
 *     created nodes. If not provided, the 3rd argument to the resulting node
 *     factory needs to be provided and will be the nodeName.
 * @param {string=} opt_namespaceURI Fixed namespace URI which will be used for
 *     all created nodes. If not provided, the namespace of the parent node will
 *     be used.
 * @return {function(*, Array.<*>, string=): (Node|undefined)} Node factory.
 */
_ol_xml_.makeSimpleNodeFactory = function (opt_nodeName, opt_namespaceURI) {
  var fixedNodeName = opt_nodeName;
  return (
    /**
     * @param {*} value Value.
     * @param {Array.<*>} objectStack Object stack.
     * @param {string=} opt_nodeName Node name.
     * @return {Node} Node.
     */
    function (value, objectStack, opt_nodeName) {
      var context = objectStack[objectStack.length - 1];
      var node = context.node;
      var nodeName = fixedNodeName;
      if (nodeName === undefined) {
        nodeName = opt_nodeName;
      }
      var namespaceURI = opt_namespaceURI;
      if (opt_namespaceURI === undefined) {
        namespaceURI = node.namespaceURI;
      }
      return _ol_xml_.createElementNS(namespaceURI, /** @type {string} */nodeName);
    }
  );
};

/**
 * A node factory that creates a node using the parent's `namespaceURI` and the
 * `nodeName` passed by {@link ol.xml.serialize} or
 * {@link ol.xml.pushSerializeAndPop} to the node factory.
 * @const
 * @type {function(*, Array.<*>, string=): (Node|undefined)}
 */
_ol_xml_.OBJECT_PROPERTY_NODE_FACTORY = _ol_xml_.makeSimpleNodeFactory();

/**
 * Create an array of `values` to be used with {@link ol.xml.serialize} or
 * {@link ol.xml.pushSerializeAndPop}, where `orderedKeys` has to be provided as
 * `opt_key` argument.
 * @param {Object.<string, V>} object Key-value pairs for the sequence. Keys can
 *     be a subset of the `orderedKeys`.
 * @param {Array.<string>} orderedKeys Keys in the order of the sequence.
 * @return {Array.<V>} Values in the order of the sequence. The resulting array
 *     has the same length as the `orderedKeys` array. Values that are not
 *     present in `object` will be `undefined` in the resulting array.
 * @template V
 */
_ol_xml_.makeSequence = function (object, orderedKeys) {
  var length = orderedKeys.length;
  var sequence = new Array(length);
  for (var i = 0; i < length; ++i) {
    sequence[i] = object[orderedKeys[i]];
  }
  return sequence;
};

/**
 * Create a namespaced structure, using the same values for each namespace.
 * This can be used as a starting point for versioned parsers, when only a few
 * values are version specific.
 * @param {Array.<string>} namespaceURIs Namespace URIs.
 * @param {T} structure Structure.
 * @param {Object.<string, T>=} opt_structureNS Namespaced structure to add to.
 * @return {Object.<string, T>} Namespaced structure.
 * @template T
 */
_ol_xml_.makeStructureNS = function (namespaceURIs, structure, opt_structureNS) {
  /**
   * @type {Object.<string, *>}
   */
  var structureNS = opt_structureNS !== undefined ? opt_structureNS : {};
  var i, ii;
  for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {
    structureNS[namespaceURIs[i]] = structure;
  }
  return structureNS;
};

/**
 * Parse a node using the parsers and object stack.
 * @param {Object.<string, Object.<string, ol.XmlParser>>} parsersNS
 *     Parsers by namespace.
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @param {*=} opt_this The object to use as `this`.
 */
_ol_xml_.parseNode = function (parsersNS, node, objectStack, opt_this) {
  var n;
  for (n = node.firstElementChild; n; n = n.nextElementSibling) {
    var parsers = parsersNS[n.namespaceURI];
    if (parsers !== undefined) {
      var parser = parsers[n.localName];
      if (parser !== undefined) {
        parser.call(opt_this, n, objectStack);
      }
    }
  }
};

/**
 * Push an object on top of the stack, parse and return the popped object.
 * @param {T} object Object.
 * @param {Object.<string, Object.<string, ol.XmlParser>>} parsersNS
 *     Parsers by namespace.
 * @param {Node} node Node.
 * @param {Array.<*>} objectStack Object stack.
 * @param {*=} opt_this The object to use as `this`.
 * @return {T} Object.
 * @template T
 */
_ol_xml_.pushParseAndPop = function (object, parsersNS, node, objectStack, opt_this) {
  objectStack.push(object);
  _ol_xml_.parseNode(parsersNS, node, objectStack, opt_this);
  return objectStack.pop();
};

/**
 * Walk through an array of `values` and call a serializer for each value.
 * @param {Object.<string, Object.<string, ol.XmlSerializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array.<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array.<*>} values Values to serialize. An example would be an array
 *     of {@link ol.Feature} instances.
 * @param {Array.<*>} objectStack Node stack.
 * @param {Array.<string>=} opt_keys Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `opt_keys` has
 *     to match the length of `values`. For serializing a sequence, `opt_keys`
 *     determines the order of the sequence.
 * @param {T=} opt_this The object to use as `this` for the node factory and
 *     serializers.
 * @template T
 */
_ol_xml_.serialize = function (serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
  var length = (opt_keys !== undefined ? opt_keys : values).length;
  var value, node;
  for (var i = 0; i < length; ++i) {
    value = values[i];
    if (value !== undefined) {
      node = nodeFactory.call(opt_this, value, objectStack, opt_keys !== undefined ? opt_keys[i] : undefined);
      if (node !== undefined) {
        serializersNS[node.namespaceURI][node.localName].call(opt_this, node, value, objectStack);
      }
    }
  }
};

/**
 * @param {O} object Object.
 * @param {Object.<string, Object.<string, ol.XmlSerializer>>} serializersNS
 *     Namespaced serializers.
 * @param {function(this: T, *, Array.<*>, (string|undefined)): (Node|undefined)} nodeFactory
 *     Node factory. The `nodeFactory` creates the node whose namespace and name
 *     will be used to choose a node writer from `serializersNS`. This
 *     separation allows us to decide what kind of node to create, depending on
 *     the value we want to serialize. An example for this would be different
 *     geometry writers based on the geometry type.
 * @param {Array.<*>} values Values to serialize. An example would be an array
 *     of {@link ol.Feature} instances.
 * @param {Array.<*>} objectStack Node stack.
 * @param {Array.<string>=} opt_keys Keys of the `values`. Will be passed to the
 *     `nodeFactory`. This is used for serializing object literals where the
 *     node name relates to the property key. The array length of `opt_keys` has
 *     to match the length of `values`. For serializing a sequence, `opt_keys`
 *     determines the order of the sequence.
 * @param {T=} opt_this The object to use as `this` for the node factory and
 *     serializers.
 * @return {O|undefined} Object.
 * @template O, T
 */
_ol_xml_.pushSerializeAndPop = function (object, serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this) {
  objectStack.push(object);
  _ol_xml_.serialize(serializersNS, nodeFactory, values, objectStack, opt_keys, opt_this);
  return objectStack.pop();
};
/* harmony default export */ var xml = (_ol_xml_);
// CONCATENATED MODULE: ./node_modules/ol/featureloader.js



var _ol_featureloader_ = {};

/**
 * @param {string|ol.FeatureUrlFunction} url Feature URL service.
 * @param {ol.format.Feature} format Feature format.
 * @param {function(this:ol.VectorTile, Array.<ol.Feature>, ol.proj.Projection, ol.Extent)|function(this:ol.source.Vector, Array.<ol.Feature>)} success
 *     Function called with the loaded features and optionally with the data
 *     projection. Called with the vector tile or source as `this`.
 * @param {function(this:ol.VectorTile)|function(this:ol.source.Vector)} failure
 *     Function called when loading failed. Called with the vector tile or
 *     source as `this`.
 * @return {ol.FeatureLoader} The feature loader.
 */
_ol_featureloader_.loadFeaturesXhr = function (url, format, success, failure) {
  return (
    /**
     * @param {ol.Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {ol.proj.Projection} projection Projection.
     * @this {ol.source.Vector|ol.VectorTile}
     */
    function (extent, resolution, projection) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);
      if (format.getType() == formattype["a" /* default */].ARRAY_BUFFER) {
        xhr.responseType = 'arraybuffer';
      }
      /**
       * @param {Event} event Event.
       * @private
       */
      xhr.onload = function (event) {
        // status will be 0 for file:// urls
        if (!xhr.status || xhr.status >= 200 && xhr.status < 300) {
          var type = format.getType();
          /** @type {Document|Node|Object|string|undefined} */
          var source;
          if (type == formattype["a" /* default */].JSON || type == formattype["a" /* default */].TEXT) {
            source = xhr.responseText;
          } else if (type == formattype["a" /* default */].XML) {
            source = xhr.responseXML;
            if (!source) {
              source = xml.parse(xhr.responseText);
            }
          } else if (type == formattype["a" /* default */].ARRAY_BUFFER) {
            source = /** @type {ArrayBuffer} */xhr.response;
          }
          if (source) {
            success.call(this, format.readFeatures(source, { featureProjection: projection }), format.readProjection(source), format.getLastExtent());
          } else {
            failure.call(this);
          }
        } else {
          failure.call(this);
        }
      }.bind(this);
      /**
       * @private
       */
      xhr.onerror = function () {
        failure.call(this);
      }.bind(this);
      xhr.send();
    }
  );
};

/**
 * Create an XHR feature loader for a `url` and `format`. The feature loader
 * loads features (with XHR), parses the features, and adds them to the
 * vector source.
 * @param {string|ol.FeatureUrlFunction} url Feature URL service.
 * @param {ol.format.Feature} format Feature format.
 * @return {ol.FeatureLoader} The feature loader.
 * @api
 */
_ol_featureloader_.xhr = function (url, format) {
  return _ol_featureloader_.loadFeaturesXhr(url, format,
  /**
   * @param {Array.<ol.Feature>} features The loaded features.
   * @param {ol.proj.Projection} dataProjection Data projection.
   * @this {ol.source.Vector}
   */
  function (features, dataProjection) {
    this.addFeatures(features);
  }, /* FIXME handle error */ol["a" /* default */].nullFunction);
};
/* harmony default export */ var featureloader = (_ol_featureloader_);
// EXTERNAL MODULE: ./node_modules/ol/functions.js
var functions = __webpack_require__(13);

// CONCATENATED MODULE: ./node_modules/ol/loadingstrategy.js
var _ol_loadingstrategy_ = {};

/**
 * Strategy function for loading all features with a single request.
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array.<ol.Extent>} Extents.
 * @api
 */
_ol_loadingstrategy_.all = function (extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
};

/**
 * Strategy function for loading features based on the view's extent and
 * resolution.
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @return {Array.<ol.Extent>} Extents.
 * @api
 */
_ol_loadingstrategy_.bbox = function (extent, resolution) {
  return [extent];
};

/**
 * Creates a strategy function for loading features based on a tile grid.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {function(ol.Extent, number): Array.<ol.Extent>} Loading strategy.
 * @api
 */
_ol_loadingstrategy_.tile = function (tileGrid) {
  return (
    /**
         * @param {ol.Extent} extent Extent.
         * @param {number} resolution Resolution.
         * @return {Array.<ol.Extent>} Extents.
         */
    function (extent, resolution) {
      var z = tileGrid.getZForResolution(resolution);
      var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
      /** @type {Array.<ol.Extent>} */
      var extents = [];
      /** @type {ol.TileCoord} */
      var tileCoord = [z, 0, 0];
      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
          extents.push(tileGrid.getTileCoordExtent(tileCoord));
        }
      }
      return extents;
    }
  );
};
/* harmony default export */ var loadingstrategy = (_ol_loadingstrategy_);
// EXTERNAL MODULE: ./node_modules/ol/obj.js
var ol_obj = __webpack_require__(2);

// EXTERNAL MODULE: ./node_modules/ol/source/source.js + 1 modules
var source_source = __webpack_require__(90);

// EXTERNAL MODULE: ./node_modules/ol/source/state.js
var state = __webpack_require__(35);

// CONCATENATED MODULE: ./node_modules/ol/source/vectoreventtype.js
/**
 * @enum {string}
 */
var _ol_source_VectorEventType_ = {
  /**
   * Triggered when a feature is added to the source.
   * @event ol.source.Vector.Event#addfeature
   * @api
   */
  ADDFEATURE: 'addfeature',

  /**
   * Triggered when a feature is updated.
   * @event ol.source.Vector.Event#changefeature
   * @api
   */
  CHANGEFEATURE: 'changefeature',

  /**
   * Triggered when the clear method is called on the source.
   * @event ol.source.Vector.Event#clear
   * @api
   */
  CLEAR: 'clear',

  /**
   * Triggered when a feature is removed from the source.
   * See {@link ol.source.Vector#clear source.clear()} for exceptions.
   * @event ol.source.Vector.Event#removefeature
   * @api
   */
  REMOVEFEATURE: 'removefeature'
};

/* harmony default export */ var vectoreventtype = (_ol_source_VectorEventType_);
// EXTERNAL MODULE: ./node_modules/ol/structs/rbush.js
var rbush = __webpack_require__(87);

// CONCATENATED MODULE: ./node_modules/ol/source/vector.js
// FIXME bulk feature upload - suppress events
// FIXME make change-detection more refined (notably, geometry hint)




















/**
 * @classdesc
 * Provides a source of features for vector layers. Vector features provided
 * by this source are suitable for editing. See {@link ol.source.VectorTile} for
 * vector data that is optimized for rendering.
 *
 * @constructor
 * @extends {ol.source.Source}
 * @fires ol.source.Vector.Event
 * @param {olx.source.VectorOptions=} opt_options Vector source options.
 * @api
 */
var vector__ol_source_Vector_ = function _ol_source_Vector_(opt_options) {

  var options = opt_options || {};

  source_source["a" /* default */].call(this, {
    attributions: options.attributions,
    logo: options.logo,
    projection: undefined,
    state: state["a" /* default */].READY,
    wrapX: options.wrapX !== undefined ? options.wrapX : true
  });

  /**
   * @private
   * @type {ol.FeatureLoader}
   */
  this.loader_ = ol["a" /* default */].nullFunction;

  /**
   * @private
   * @type {ol.format.Feature|undefined}
   */
  this.format_ = options.format;

  /**
   * @private
   * @type {boolean}
   */
  this.overlaps_ = options.overlaps == undefined ? true : options.overlaps;

  /**
   * @private
   * @type {string|ol.FeatureUrlFunction|undefined}
   */
  this.url_ = options.url;

  if (options.loader !== undefined) {
    this.loader_ = options.loader;
  } else if (this.url_ !== undefined) {
    asserts["a" /* default */].assert(this.format_, 7); // `format` must be set when `url` is set
    // create a XHR feature loader for "url" and "format"
    this.loader_ = featureloader.xhr(this.url_, /** @type {ol.format.Feature} */this.format_);
  }

  /**
   * @private
   * @type {ol.LoadingStrategy}
   */
  this.strategy_ = options.strategy !== undefined ? options.strategy : loadingstrategy.all;

  var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;

  /**
   * @private
   * @type {ol.structs.RBush.<ol.Feature>}
   */
  this.featuresRtree_ = useSpatialIndex ? new rbush["a" /* default */]() : null;

  /**
   * @private
   * @type {ol.structs.RBush.<{extent: ol.Extent}>}
   */
  this.loadedExtentsRtree_ = new rbush["a" /* default */]();

  /**
   * @private
   * @type {Object.<string, ol.Feature>}
   */
  this.nullGeometryFeatures_ = {};

  /**
   * A lookup of features by id (the return from feature.getId()).
   * @private
   * @type {Object.<string, ol.Feature>}
   */
  this.idIndex_ = {};

  /**
   * A lookup of features without id (keyed by ol.getUid(feature)).
   * @private
   * @type {Object.<string, ol.Feature>}
   */
  this.undefIdIndex_ = {};

  /**
   * @private
   * @type {Object.<string, Array.<ol.EventsKey>>}
   */
  this.featureChangeKeys_ = {};

  /**
   * @private
   * @type {ol.Collection.<ol.Feature>}
   */
  this.featuresCollection_ = null;

  var collection, features;
  if (options.features instanceof ol_collection["a" /* default */]) {
    collection = options.features;
    features = collection.getArray();
  } else if (Array.isArray(options.features)) {
    features = options.features;
  }
  if (!useSpatialIndex && collection === undefined) {
    collection = new ol_collection["a" /* default */](features);
  }
  if (features !== undefined) {
    this.addFeaturesInternal(features);
  }
  if (collection !== undefined) {
    this.bindFeaturesCollection_(collection);
  }
};

ol["a" /* default */].inherits(vector__ol_source_Vector_, source_source["a" /* default */]);

/**
 * Add a single feature to the source.  If you want to add a batch of features
 * at once, call {@link ol.source.Vector#addFeatures source.addFeatures()}
 * instead. A feature will not be added to the source if feature with
 * the same id is already there. The reason for this behavior is to avoid
 * feature duplication when using bbox or tile loading strategies.
 * @param {ol.Feature} feature Feature to add.
 * @api
 */
vector__ol_source_Vector_.prototype.addFeature = function (feature) {
  this.addFeatureInternal(feature);
  this.changed();
};

/**
 * Add a feature without firing a `change` event.
 * @param {ol.Feature} feature Feature.
 * @protected
 */
vector__ol_source_Vector_.prototype.addFeatureInternal = function (feature) {
  var featureKey = ol["a" /* default */].getUid(feature).toString();

  if (!this.addToIndex_(featureKey, feature)) {
    return;
  }

  this.setupChangeEvents_(featureKey, feature);

  var geometry = feature.getGeometry();
  if (geometry) {
    var extent = geometry.getExtent();
    if (this.featuresRtree_) {
      this.featuresRtree_.insert(extent, feature);
    }
  } else {
    this.nullGeometryFeatures_[featureKey] = feature;
  }

  this.dispatchEvent(new vector__ol_source_Vector_.Event(vectoreventtype.ADDFEATURE, feature));
};

/**
 * @param {string} featureKey Unique identifier for the feature.
 * @param {ol.Feature} feature The feature.
 * @private
 */
vector__ol_source_Vector_.prototype.setupChangeEvents_ = function (featureKey, feature) {
  this.featureChangeKeys_[featureKey] = [events["a" /* default */].listen(feature, eventtype["a" /* default */].CHANGE, this.handleFeatureChange_, this), events["a" /* default */].listen(feature, objecteventtype["a" /* default */].PROPERTYCHANGE, this.handleFeatureChange_, this)];
};

/**
 * @param {string} featureKey Unique identifier for the feature.
 * @param {ol.Feature} feature The feature.
 * @return {boolean} The feature is "valid", in the sense that it is also a
 *     candidate for insertion into the Rtree.
 * @private
 */
vector__ol_source_Vector_.prototype.addToIndex_ = function (featureKey, feature) {
  var valid = true;
  var id = feature.getId();
  if (id !== undefined) {
    if (!(id.toString() in this.idIndex_)) {
      this.idIndex_[id.toString()] = feature;
    } else {
      valid = false;
    }
  } else {
    asserts["a" /* default */].assert(!(featureKey in this.undefIdIndex_), 30); // The passed `feature` was already added to the source
    this.undefIdIndex_[featureKey] = feature;
  }
  return valid;
};

/**
 * Add a batch of features to the source.
 * @param {Array.<ol.Feature>} features Features to add.
 * @api
 */
vector__ol_source_Vector_.prototype.addFeatures = function (features) {
  this.addFeaturesInternal(features);
  this.changed();
};

/**
 * Add features without firing a `change` event.
 * @param {Array.<ol.Feature>} features Features.
 * @protected
 */
vector__ol_source_Vector_.prototype.addFeaturesInternal = function (features) {
  var featureKey, i, length, feature;

  var extents = [];
  var newFeatures = [];
  var geometryFeatures = [];

  for (i = 0, length = features.length; i < length; i++) {
    feature = features[i];
    featureKey = ol["a" /* default */].getUid(feature).toString();
    if (this.addToIndex_(featureKey, feature)) {
      newFeatures.push(feature);
    }
  }

  for (i = 0, length = newFeatures.length; i < length; i++) {
    feature = newFeatures[i];
    featureKey = ol["a" /* default */].getUid(feature).toString();
    this.setupChangeEvents_(featureKey, feature);

    var geometry = feature.getGeometry();
    if (geometry) {
      var extent = geometry.getExtent();
      extents.push(extent);
      geometryFeatures.push(feature);
    } else {
      this.nullGeometryFeatures_[featureKey] = feature;
    }
  }
  if (this.featuresRtree_) {
    this.featuresRtree_.load(extents, geometryFeatures);
  }

  for (i = 0, length = newFeatures.length; i < length; i++) {
    this.dispatchEvent(new vector__ol_source_Vector_.Event(vectoreventtype.ADDFEATURE, newFeatures[i]));
  }
};

/**
 * @param {!ol.Collection.<ol.Feature>} collection Collection.
 * @private
 */
vector__ol_source_Vector_.prototype.bindFeaturesCollection_ = function (collection) {
  var modifyingCollection = false;
  events["a" /* default */].listen(this, vectoreventtype.ADDFEATURE, function (evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      collection.push(evt.feature);
      modifyingCollection = false;
    }
  });
  events["a" /* default */].listen(this, vectoreventtype.REMOVEFEATURE, function (evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      collection.remove(evt.feature);
      modifyingCollection = false;
    }
  });
  events["a" /* default */].listen(collection, collectioneventtype["a" /* default */].ADD, function (evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      this.addFeature( /** @type {ol.Feature} */evt.element);
      modifyingCollection = false;
    }
  }, this);
  events["a" /* default */].listen(collection, collectioneventtype["a" /* default */].REMOVE, function (evt) {
    if (!modifyingCollection) {
      modifyingCollection = true;
      this.removeFeature( /** @type {ol.Feature} */evt.element);
      modifyingCollection = false;
    }
  }, this);
  this.featuresCollection_ = collection;
};

/**
 * Remove all features from the source.
 * @param {boolean=} opt_fast Skip dispatching of {@link removefeature} events.
 * @api
 */
vector__ol_source_Vector_.prototype.clear = function (opt_fast) {
  if (opt_fast) {
    for (var featureId in this.featureChangeKeys_) {
      var keys = this.featureChangeKeys_[featureId];
      keys.forEach(events["a" /* default */].unlistenByKey);
    }
    if (!this.featuresCollection_) {
      this.featureChangeKeys_ = {};
      this.idIndex_ = {};
      this.undefIdIndex_ = {};
    }
  } else {
    if (this.featuresRtree_) {
      this.featuresRtree_.forEach(this.removeFeatureInternal, this);
      for (var id in this.nullGeometryFeatures_) {
        this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
      }
    }
  }
  if (this.featuresCollection_) {
    this.featuresCollection_.clear();
  }

  if (this.featuresRtree_) {
    this.featuresRtree_.clear();
  }
  this.loadedExtentsRtree_.clear();
  this.nullGeometryFeatures_ = {};

  var clearEvent = new vector__ol_source_Vector_.Event(vectoreventtype.CLEAR);
  this.dispatchEvent(clearEvent);
  this.changed();
};

/**
 * Iterate through all features on the source, calling the provided callback
 * with each one.  If the callback returns any "truthy" value, iteration will
 * stop and the function will return the same value.
 *
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     on the source.  Return a truthy value to stop iteration.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 * @api
 */
vector__ol_source_Vector_.prototype.forEachFeature = function (callback, opt_this) {
  if (this.featuresRtree_) {
    return this.featuresRtree_.forEach(callback, opt_this);
  } else if (this.featuresCollection_) {
    return this.featuresCollection_.forEach(callback, opt_this);
  }
};

/**
 * Iterate through all features whose geometries contain the provided
 * coordinate, calling the callback with each feature.  If the callback returns
 * a "truthy" value, iteration will stop and the function will return the same
 * value.
 *
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     whose goemetry contains the provided coordinate.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 */
vector__ol_source_Vector_.prototype.forEachFeatureAtCoordinateDirect = function (coordinate, callback, opt_this) {
  var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
  return this.forEachFeatureInExtent(extent, function (feature) {
    var geometry = feature.getGeometry();
    if (geometry.intersectsCoordinate(coordinate)) {
      return callback.call(opt_this, feature);
    } else {
      return undefined;
    }
  });
};

/**
 * Iterate through all features whose bounding box intersects the provided
 * extent (note that the feature's geometry may not intersect the extent),
 * calling the callback with each feature.  If the callback returns a "truthy"
 * value, iteration will stop and the function will return the same value.
 *
 * If you are interested in features whose geometry intersects an extent, call
 * the {@link ol.source.Vector#forEachFeatureIntersectingExtent
 * source.forEachFeatureIntersectingExtent()} method instead.
 *
 * When `useSpatialIndex` is set to false, this method will loop through all
 * features, equivalent to {@link ol.source.Vector#forEachFeature}.
 *
 * @param {ol.Extent} extent Extent.
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     whose bounding box intersects the provided extent.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 * @api
 */
vector__ol_source_Vector_.prototype.forEachFeatureInExtent = function (extent, callback, opt_this) {
  if (this.featuresRtree_) {
    return this.featuresRtree_.forEachInExtent(extent, callback, opt_this);
  } else if (this.featuresCollection_) {
    return this.featuresCollection_.forEach(callback, opt_this);
  }
};

/**
 * Iterate through all features whose geometry intersects the provided extent,
 * calling the callback with each feature.  If the callback returns a "truthy"
 * value, iteration will stop and the function will return the same value.
 *
 * If you only want to test for bounding box intersection, call the
 * {@link ol.source.Vector#forEachFeatureInExtent
 * source.forEachFeatureInExtent()} method instead.
 *
 * @param {ol.Extent} extent Extent.
 * @param {function(this: T, ol.Feature): S} callback Called with each feature
 *     whose geometry intersects the provided extent.
 * @param {T=} opt_this The object to use as `this` in the callback.
 * @return {S|undefined} The return value from the last call to the callback.
 * @template T,S
 * @api
 */
vector__ol_source_Vector_.prototype.forEachFeatureIntersectingExtent = function (extent, callback, opt_this) {
  return this.forEachFeatureInExtent(extent,
  /**
   * @param {ol.Feature} feature Feature.
   * @return {S|undefined} The return value from the last call to the callback.
   * @template S
   */
  function (feature) {
    var geometry = feature.getGeometry();
    if (geometry.intersectsExtent(extent)) {
      var result = callback.call(opt_this, feature);
      if (result) {
        return result;
      }
    }
  });
};

/**
 * Get the features collection associated with this source. Will be `null`
 * unless the source was configured with `useSpatialIndex` set to `false`, or
 * with an {@link ol.Collection} as `features`.
 * @return {ol.Collection.<ol.Feature>} The collection of features.
 * @api
 */
vector__ol_source_Vector_.prototype.getFeaturesCollection = function () {
  return this.featuresCollection_;
};

/**
 * Get all features on the source in random order.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */
vector__ol_source_Vector_.prototype.getFeatures = function () {
  var features;
  if (this.featuresCollection_) {
    features = this.featuresCollection_.getArray();
  } else if (this.featuresRtree_) {
    features = this.featuresRtree_.getAll();
    if (!ol_obj["a" /* default */].isEmpty(this.nullGeometryFeatures_)) {
      ol_array["a" /* default */].extend(features, ol_obj["a" /* default */].getValues(this.nullGeometryFeatures_));
    }
  }
  return (/** @type {Array.<ol.Feature>} */features
  );
};

/**
 * Get all features whose geometry intersects the provided coordinate.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */
vector__ol_source_Vector_.prototype.getFeaturesAtCoordinate = function (coordinate) {
  var features = [];
  this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {
    features.push(feature);
  });
  return features;
};

/**
 * Get all features in the provided extent.  Note that this returns an array of
 * all features intersecting the given extent in random order (so it may include
 * features whose geometries do not intersect the extent).
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {ol.Extent} extent Extent.
 * @return {Array.<ol.Feature>} Features.
 * @api
 */
vector__ol_source_Vector_.prototype.getFeaturesInExtent = function (extent) {
  return this.featuresRtree_.getInExtent(extent);
};

/**
 * Get the closest feature to the provided coordinate.
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {function(ol.Feature):boolean=} opt_filter Feature filter function.
 *     The filter function will receive one argument, the {@link ol.Feature feature}
 *     and it should return a boolean value. By default, no filtering is made.
 * @return {ol.Feature} Closest feature.
 * @api
 */
vector__ol_source_Vector_.prototype.getClosestFeatureToCoordinate = function (coordinate, opt_filter) {
  // Find the closest feature using branch and bound.  We start searching an
  // infinite extent, and find the distance from the first feature found.  This
  // becomes the closest feature.  We then compute a smaller extent which any
  // closer feature must intersect.  We continue searching with this smaller
  // extent, trying to find a closer feature.  Every time we find a closer
  // feature, we update the extent being searched so that any even closer
  // feature must intersect it.  We continue until we run out of features.
  var x = coordinate[0];
  var y = coordinate[1];
  var closestFeature = null;
  var closestPoint = [NaN, NaN];
  var minSquaredDistance = Infinity;
  var extent = [-Infinity, -Infinity, Infinity, Infinity];
  var filter = opt_filter ? opt_filter : functions["a" /* default */].TRUE;
  this.featuresRtree_.forEachInExtent(extent,
  /**
   * @param {ol.Feature} feature Feature.
   */
  function (feature) {
    if (filter(feature)) {
      var geometry = feature.getGeometry();
      var previousMinSquaredDistance = minSquaredDistance;
      minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
      if (minSquaredDistance < previousMinSquaredDistance) {
        closestFeature = feature;
        // This is sneaky.  Reduce the extent that it is currently being
        // searched while the R-Tree traversal using this same extent object
        // is still in progress.  This is safe because the new extent is
        // strictly contained by the old extent.
        var minDistance = Math.sqrt(minSquaredDistance);
        extent[0] = x - minDistance;
        extent[1] = y - minDistance;
        extent[2] = x + minDistance;
        extent[3] = y + minDistance;
      }
    }
  });
  return closestFeature;
};

/**
 * Get the extent of the features currently in the source.
 *
 * This method is not available when the source is configured with
 * `useSpatialIndex` set to `false`.
 * @param {ol.Extent=} opt_extent Destination extent. If provided, no new extent
 *     will be created. Instead, that extent's coordinates will be overwritten.
 * @return {ol.Extent} Extent.
 * @api
 */
vector__ol_source_Vector_.prototype.getExtent = function (opt_extent) {
  return this.featuresRtree_.getExtent(opt_extent);
};

/**
 * Get a feature by its identifier (the value returned by feature.getId()).
 * Note that the index treats string and numeric identifiers as the same.  So
 * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
 *
 * @param {string|number} id Feature identifier.
 * @return {ol.Feature} The feature (or `null` if not found).
 * @api
 */
vector__ol_source_Vector_.prototype.getFeatureById = function (id) {
  var feature = this.idIndex_[id.toString()];
  return feature !== undefined ? feature : null;
};

/**
 * Get the format associated with this source.
 *
 * @return {ol.format.Feature|undefined} The feature format.
 * @api
 */
vector__ol_source_Vector_.prototype.getFormat = function () {
  return this.format_;
};

/**
 * @return {boolean} The source can have overlapping geometries.
 */
vector__ol_source_Vector_.prototype.getOverlaps = function () {
  return this.overlaps_;
};

/**
 * @override
 */
vector__ol_source_Vector_.prototype.getResolutions = function () {};

/**
 * Get the url associated with this source.
 *
 * @return {string|ol.FeatureUrlFunction|undefined} The url.
 * @api
 */
vector__ol_source_Vector_.prototype.getUrl = function () {
  return this.url_;
};

/**
 * @param {ol.events.Event} event Event.
 * @private
 */
vector__ol_source_Vector_.prototype.handleFeatureChange_ = function (event) {
  var feature = /** @type {ol.Feature} */event.target;
  var featureKey = ol["a" /* default */].getUid(feature).toString();
  var geometry = feature.getGeometry();
  if (!geometry) {
    if (!(featureKey in this.nullGeometryFeatures_)) {
      if (this.featuresRtree_) {
        this.featuresRtree_.remove(feature);
      }
      this.nullGeometryFeatures_[featureKey] = feature;
    }
  } else {
    var extent = geometry.getExtent();
    if (featureKey in this.nullGeometryFeatures_) {
      delete this.nullGeometryFeatures_[featureKey];
      if (this.featuresRtree_) {
        this.featuresRtree_.insert(extent, feature);
      }
    } else {
      if (this.featuresRtree_) {
        this.featuresRtree_.update(extent, feature);
      }
    }
  }
  var id = feature.getId();
  if (id !== undefined) {
    var sid = id.toString();
    if (featureKey in this.undefIdIndex_) {
      delete this.undefIdIndex_[featureKey];
      this.idIndex_[sid] = feature;
    } else {
      if (this.idIndex_[sid] !== feature) {
        this.removeFromIdIndex_(feature);
        this.idIndex_[sid] = feature;
      }
    }
  } else {
    if (!(featureKey in this.undefIdIndex_)) {
      this.removeFromIdIndex_(feature);
      this.undefIdIndex_[featureKey] = feature;
    }
  }
  this.changed();
  this.dispatchEvent(new vector__ol_source_Vector_.Event(vectoreventtype.CHANGEFEATURE, feature));
};

/**
 * @return {boolean} Is empty.
 */
vector__ol_source_Vector_.prototype.isEmpty = function () {
  return this.featuresRtree_.isEmpty() && ol_obj["a" /* default */].isEmpty(this.nullGeometryFeatures_);
};

/**
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {ol.proj.Projection} projection Projection.
 */
vector__ol_source_Vector_.prototype.loadFeatures = function (extent, resolution, projection) {
  var loadedExtentsRtree = this.loadedExtentsRtree_;
  var extentsToLoad = this.strategy_(extent, resolution);
  var i, ii;
  for (i = 0, ii = extentsToLoad.length; i < ii; ++i) {
    var extentToLoad = extentsToLoad[i];
    var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad,
    /**
     * @param {{extent: ol.Extent}} object Object.
     * @return {boolean} Contains.
     */
    function (object) {
      return ol_extent["a" /* default */].containsExtent(object.extent, extentToLoad);
    });
    if (!alreadyLoaded) {
      this.loader_.call(this, extentToLoad, resolution, projection);
      loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
    }
  }
};

/**
 * Remove an extent from the list of loaded extents.
 * @param {ol.Extent} extent Extent.
 * @api
 */
vector__ol_source_Vector_.prototype.removeLoadedExtent = function (extent) {
  var loadedExtentsRtree = this.loadedExtentsRtree_;
  var obj;
  loadedExtentsRtree.forEachInExtent(extent, function (object) {
    if (ol_extent["a" /* default */].equals(object.extent, extent)) {
      obj = object;
      return true;
    }
  });
  if (obj) {
    loadedExtentsRtree.remove(obj);
  }
};

/**
 * Remove a single feature from the source.  If you want to remove all features
 * at once, use the {@link ol.source.Vector#clear source.clear()} method
 * instead.
 * @param {ol.Feature} feature Feature to remove.
 * @api
 */
vector__ol_source_Vector_.prototype.removeFeature = function (feature) {
  var featureKey = ol["a" /* default */].getUid(feature).toString();
  if (featureKey in this.nullGeometryFeatures_) {
    delete this.nullGeometryFeatures_[featureKey];
  } else {
    if (this.featuresRtree_) {
      this.featuresRtree_.remove(feature);
    }
  }
  this.removeFeatureInternal(feature);
  this.changed();
};

/**
 * Remove feature without firing a `change` event.
 * @param {ol.Feature} feature Feature.
 * @protected
 */
vector__ol_source_Vector_.prototype.removeFeatureInternal = function (feature) {
  var featureKey = ol["a" /* default */].getUid(feature).toString();
  this.featureChangeKeys_[featureKey].forEach(events["a" /* default */].unlistenByKey);
  delete this.featureChangeKeys_[featureKey];
  var id = feature.getId();
  if (id !== undefined) {
    delete this.idIndex_[id.toString()];
  } else {
    delete this.undefIdIndex_[featureKey];
  }
  this.dispatchEvent(new vector__ol_source_Vector_.Event(vectoreventtype.REMOVEFEATURE, feature));
};

/**
 * Remove a feature from the id index.  Called internally when the feature id
 * may have changed.
 * @param {ol.Feature} feature The feature.
 * @return {boolean} Removed the feature from the index.
 * @private
 */
vector__ol_source_Vector_.prototype.removeFromIdIndex_ = function (feature) {
  var removed = false;
  for (var id in this.idIndex_) {
    if (this.idIndex_[id] === feature) {
      delete this.idIndex_[id];
      removed = true;
      break;
    }
  }
  return removed;
};

/**
 * Set the new loader of the source. The next loadFeatures call will use the
 * new loader.
 * @param {ol.FeatureLoader} loader The loader to set.
 * @api
 */
vector__ol_source_Vector_.prototype.setLoader = function (loader) {
  this.loader_ = loader;
};

/**
 * @classdesc
 * Events emitted by {@link ol.source.Vector} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.source.Vector.Event}
 * @param {string} type Type.
 * @param {ol.Feature=} opt_feature Feature.
 */
vector__ol_source_Vector_.Event = function (type, opt_feature) {

  events_event["a" /* default */].call(this, type);

  /**
   * The feature being added or removed.
   * @type {ol.Feature|undefined}
   * @api
   */
  this.feature = opt_feature;
};
ol["a" /* default */].inherits(vector__ol_source_Vector_.Event, events_event["a" /* default */]);
/* harmony default export */ var vector = __webpack_exports__["default"] = (vector__ol_source_Vector_);

/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXTERNAL MODULE: ./node_modules/ol/index.js
var ol = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ol/tilerange.js
var tilerange = __webpack_require__(63);

// EXTERNAL MODULE: ./node_modules/ol/math.js
var math = __webpack_require__(6);

// EXTERNAL MODULE: ./node_modules/ol/tilegrid.js + 1 modules
var tilegrid = __webpack_require__(64);

// CONCATENATED MODULE: ./node_modules/ol/attribution.js




/**
 * @classdesc
 * An attribution for a layer source.
 *
 * Example:
 *
 *     source: new ol.source.OSM({
 *       attributions: [
 *         new ol.Attribution({
 *           html: 'All maps &copy; ' +
 *               '<a href="https://www.opencyclemap.org/">OpenCycleMap</a>'
 *         }),
 *         ol.source.OSM.ATTRIBUTION
 *       ],
 *     ..
 *
 * @constructor
 * @deprecated This class is deprecated and will removed in the next major release.
 * @param {olx.AttributionOptions} options Attribution options.
 * @struct
 * @api
 */
var _ol_Attribution_ = function _ol_Attribution_(options) {

  /**
   * @private
   * @type {string}
   */
  this.html_ = options.html;

  /**
   * @private
   * @type {Object.<string, Array.<ol.TileRange>>}
   */
  this.tileRanges_ = options.tileRanges ? options.tileRanges : null;
};

/**
 * Get the attribution markup.
 * @return {string} The attribution HTML.
 * @api
 */
_ol_Attribution_.prototype.getHTML = function () {
  return this.html_;
};

/**
 * @param {Object.<string, ol.TileRange>} tileRanges Tile ranges.
 * @param {!ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @param {!ol.proj.Projection} projection Projection.
 * @return {boolean} Intersects any tile range.
 */
_ol_Attribution_.prototype.intersectsAnyTileRange = function (tileRanges, tileGrid, projection) {
  if (!this.tileRanges_) {
    return true;
  }
  var i, ii, tileRange, zKey;
  for (zKey in tileRanges) {
    if (!(zKey in this.tileRanges_)) {
      continue;
    }
    tileRange = tileRanges[zKey];
    var testTileRange;
    for (i = 0, ii = this.tileRanges_[zKey].length; i < ii; ++i) {
      testTileRange = this.tileRanges_[zKey][i];
      if (testTileRange.intersects(tileRange)) {
        return true;
      }
      var extentTileRange = tileGrid.getTileRangeForExtentAndZ(tilegrid["a" /* default */].extentFromProjection(projection), parseInt(zKey, 10));
      var width = extentTileRange.getWidth();
      if (tileRange.minX < extentTileRange.minX || tileRange.maxX > extentTileRange.maxX) {
        if (testTileRange.intersects(new tilerange["a" /* default */](math["a" /* default */].modulo(tileRange.minX, width), math["a" /* default */].modulo(tileRange.maxX, width), tileRange.minY, tileRange.maxY))) {
          return true;
        }
        if (tileRange.getWidth() > width && testTileRange.intersects(extentTileRange)) {
          return true;
        }
      }
    }
  }
  return false;
};
/* harmony default export */ var ol_attribution = (_ol_Attribution_);
// EXTERNAL MODULE: ./node_modules/ol/object.js
var object = __webpack_require__(15);

// EXTERNAL MODULE: ./node_modules/ol/proj.js + 7 modules
var proj = __webpack_require__(16);

// EXTERNAL MODULE: ./node_modules/ol/source/state.js
var state = __webpack_require__(35);

// CONCATENATED MODULE: ./node_modules/ol/source/source.js






/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for {@link ol.layer.Layer} sources.
 *
 * A generic `change` event is triggered when the state of the source changes.
 *
 * @constructor
 * @abstract
 * @extends {ol.Object}
 * @param {ol.SourceSourceOptions} options Source options.
 * @api
 */
var source__ol_source_Source_ = function _ol_source_Source_(options) {

  object["a" /* default */].call(this);

  /**
   * @private
   * @type {ol.proj.Projection}
   */
  this.projection_ = proj["default"].get(options.projection);

  /**
   * @private
   * @type {Array.<ol.Attribution>}
   */
  this.attributions_ = null;

  /**
   * @private
   * @type {?ol.Attribution2}
   */
  this.attributions2_ = this.adaptAttributions_(options.attributions);

  /**
   * @private
   * @type {string|olx.LogoOptions|undefined}
   */
  this.logo_ = options.logo;

  /**
   * @private
   * @type {ol.source.State}
   */
  this.state_ = options.state !== undefined ? options.state : state["a" /* default */].READY;

  /**
   * @private
   * @type {boolean}
   */
  this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
};

ol["a" /* default */].inherits(source__ol_source_Source_, object["a" /* default */]);

/**
 * Turns the attributions option into an attributions function.
 * @suppress {deprecated}
 * @param {ol.AttributionLike|undefined} attributionLike The attribution option.
 * @return {?ol.Attribution2} An attribution function (or null).
 */
source__ol_source_Source_.prototype.adaptAttributions_ = function (attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (attributionLike instanceof ol_attribution) {

    // TODO: remove attributions_ in next major release
    this.attributions_ = [attributionLike];

    return function (frameState) {
      return [attributionLike.getHTML()];
    };
  }
  if (Array.isArray(attributionLike)) {
    if (attributionLike[0] instanceof ol_attribution) {

      // TODO: remove attributions_ in next major release
      this.attributions_ = attributionLike;

      var attributions = attributionLike.map(function (attribution) {
        return attribution.getHTML();
      });
      return function (frameState) {
        return attributions;
      };
    }

    // TODO: remove attributions_ in next major release
    this.attributions_ = attributionLike.map(function (attribution) {
      return new ol_attribution({ html: attribution });
    });

    return function (frameState) {
      return attributionLike;
    };
  }

  if (typeof attributionLike === 'function') {
    return attributionLike;
  }

  // TODO: remove attributions_ in next major release
  this.attributions_ = [new ol_attribution({ html: attributionLike })];

  return function (frameState) {
    return [attributionLike];
  };
};

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {Object.<string, boolean>} skippedFeatureUids Skipped feature uids.
 * @param {function((ol.Feature|ol.render.Feature)): T} callback Feature
 *     callback.
 * @return {T|undefined} Callback result.
 * @template T
 */
source__ol_source_Source_.prototype.forEachFeatureAtCoordinate = ol["a" /* default */].nullFunction;

/**
 * Get the attributions of the source.
 * @return {Array.<ol.Attribution>} Attributions.
 * @api
 */
source__ol_source_Source_.prototype.getAttributions = function () {
  return this.attributions_;
};

/**
 * Get the attribution function for the source.
 * @return {?ol.Attribution2} Attribution function.
 */
source__ol_source_Source_.prototype.getAttributions2 = function () {
  return this.attributions2_;
};

/**
 * Get the logo of the source.
 * @return {string|olx.LogoOptions|undefined} Logo.
 * @api
 */
source__ol_source_Source_.prototype.getLogo = function () {
  return this.logo_;
};

/**
 * Get the projection of the source.
 * @return {ol.proj.Projection} Projection.
 * @api
 */
source__ol_source_Source_.prototype.getProjection = function () {
  return this.projection_;
};

/**
 * @abstract
 * @return {Array.<number>|undefined} Resolutions.
 */
source__ol_source_Source_.prototype.getResolutions = function () {};

/**
 * Get the state of the source, see {@link ol.source.State} for possible states.
 * @return {ol.source.State} State.
 * @api
 */
source__ol_source_Source_.prototype.getState = function () {
  return this.state_;
};

/**
 * @return {boolean|undefined} Wrap X.
 */
source__ol_source_Source_.prototype.getWrapX = function () {
  return this.wrapX_;
};

/**
 * Refreshes the source and finally dispatches a 'change' event.
 * @api
 */
source__ol_source_Source_.prototype.refresh = function () {
  this.changed();
};

/**
 * Set the attributions of the source.
 * @param {ol.AttributionLike|undefined} attributions Attributions.
 *     Can be passed as `string`, `Array<string>`, `{@link ol.Attribution2}`,
 *     or `undefined`.
 * @api
 */
source__ol_source_Source_.prototype.setAttributions = function (attributions) {
  this.attributions2_ = this.adaptAttributions_(attributions);
  this.changed();
};

/**
 * Set the logo of the source.
 * @param {string|olx.LogoOptions|undefined} logo Logo.
 */
source__ol_source_Source_.prototype.setLogo = function (logo) {
  this.logo_ = logo;
};

/**
 * Set the state of the source.
 * @param {ol.source.State} state State.
 * @protected
 */
source__ol_source_Source_.prototype.setState = function (state) {
  this.state_ = state;
  this.changed();
};
/* harmony default export */ var source = __webpack_exports__["a"] = (source__ol_source_Source_);

/***/ }),
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(99);


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: external "babel-runtime/regenerator"
var regenerator_ = __webpack_require__(30);
var regenerator__default = /*#__PURE__*/__webpack_require__.n(regenerator_);

// EXTERNAL MODULE: external "react"
var external__react_ = __webpack_require__(7);
var external__react__default = /*#__PURE__*/__webpack_require__.n(external__react_);

// EXTERNAL MODULE: ./components/HeaderMenu.js
var HeaderMenu = __webpack_require__(37);

// EXTERNAL MODULE: external "styled-jsx/style"
var style_ = __webpack_require__(38);
var style__default = /*#__PURE__*/__webpack_require__.n(style_);

// EXTERNAL MODULE: ./node_modules/ol/format/geojson.js + 10 modules
var geojson = __webpack_require__(71);

// EXTERNAL MODULE: ./node_modules/ol/style/style.js
var style_style = __webpack_require__(39);

// EXTERNAL MODULE: ./node_modules/ol/index.js
var ol = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ol/imagestate.js
var imagestate = __webpack_require__(40);

// EXTERNAL MODULE: ./node_modules/ol/asserts.js
var asserts = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/ol/color.js
var ol_color = __webpack_require__(27);

// EXTERNAL MODULE: ./node_modules/ol/events.js
var events = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/ol/events/eventtype.js
var eventtype = __webpack_require__(4);

// CONCATENATED MODULE: ./node_modules/ol/style/iconanchorunits.js
/**
 * Icon anchor units. One of 'fraction', 'pixels'.
 * @enum {string}
 */
var _ol_style_IconAnchorUnits_ = {
  FRACTION: 'fraction',
  PIXELS: 'pixels'
};

/* harmony default export */ var iconanchorunits = (_ol_style_IconAnchorUnits_);
// EXTERNAL MODULE: ./node_modules/ol/dom.js
var dom = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/ol/events/eventtarget.js
var eventtarget = __webpack_require__(31);

// EXTERNAL MODULE: ./node_modules/ol/style.js + 1 modules
var ol_style = __webpack_require__(82);

// CONCATENATED MODULE: ./node_modules/ol/style/iconimage.js








/**
 * @constructor
 * @param {Image|HTMLCanvasElement} image Image.
 * @param {string|undefined} src Src.
 * @param {ol.Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.ImageState} imageState Image state.
 * @param {ol.Color} color Color.
 * @extends {ol.events.EventTarget}
 */
var iconimage__ol_style_IconImage_ = function _ol_style_IconImage_(image, src, size, crossOrigin, imageState, color) {

  eventtarget["a" /* default */].call(this);

  /**
   * @private
   * @type {Image|HTMLCanvasElement}
   */
  this.hitDetectionImage_ = null;

  /**
   * @private
   * @type {Image|HTMLCanvasElement}
   */
  this.image_ = !image ? new Image() : image;

  if (crossOrigin !== null) {
    this.image_.crossOrigin = crossOrigin;
  }

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = color ?
  /** @type {HTMLCanvasElement} */document.createElement('CANVAS') : null;

  /**
   * @private
   * @type {ol.Color}
   */
  this.color_ = color;

  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */
  this.imageListenerKeys_ = null;

  /**
   * @private
   * @type {ol.ImageState}
   */
  this.imageState_ = imageState;

  /**
   * @private
   * @type {ol.Size}
   */
  this.size_ = size;

  /**
   * @private
   * @type {string|undefined}
   */
  this.src_ = src;

  /**
   * @private
   * @type {boolean}
   */
  this.tainting_ = false;
  if (this.imageState_ == imagestate["a" /* default */].LOADED) {
    this.determineTainting_();
  }
};

ol["a" /* default */].inherits(iconimage__ol_style_IconImage_, eventtarget["a" /* default */]);

/**
 * @param {Image|HTMLCanvasElement} image Image.
 * @param {string} src Src.
 * @param {ol.Size} size Size.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.ImageState} imageState Image state.
 * @param {ol.Color} color Color.
 * @return {ol.style.IconImage} Icon image.
 */
iconimage__ol_style_IconImage_.get = function (image, src, size, crossOrigin, imageState, color) {
  var iconImageCache = ol_style["a" /* default */].iconImageCache;
  var iconImage = iconImageCache.get(src, crossOrigin, color);
  if (!iconImage) {
    iconImage = new iconimage__ol_style_IconImage_(image, src, size, crossOrigin, imageState, color);
    iconImageCache.set(src, crossOrigin, color, iconImage);
  }
  return iconImage;
};

/**
 * @private
 */
iconimage__ol_style_IconImage_.prototype.determineTainting_ = function () {
  var context = dom["a" /* default */].createCanvasContext2D(1, 1);
  try {
    context.drawImage(this.image_, 0, 0);
    context.getImageData(0, 0, 1, 1);
  } catch (e) {
    this.tainting_ = true;
  }
};

/**
 * @private
 */
iconimage__ol_style_IconImage_.prototype.dispatchChangeEvent_ = function () {
  this.dispatchEvent(eventtype["a" /* default */].CHANGE);
};

/**
 * @private
 */
iconimage__ol_style_IconImage_.prototype.handleImageError_ = function () {
  this.imageState_ = imagestate["a" /* default */].ERROR;
  this.unlistenImage_();
  this.dispatchChangeEvent_();
};

/**
 * @private
 */
iconimage__ol_style_IconImage_.prototype.handleImageLoad_ = function () {
  this.imageState_ = imagestate["a" /* default */].LOADED;
  if (this.size_) {
    this.image_.width = this.size_[0];
    this.image_.height = this.size_[1];
  }
  this.size_ = [this.image_.width, this.image_.height];
  this.unlistenImage_();
  this.determineTainting_();
  this.replaceColor_();
  this.dispatchChangeEvent_();
};

/**
 * @param {number} pixelRatio Pixel ratio.
 * @return {Image|HTMLCanvasElement} Image or Canvas element.
 */
iconimage__ol_style_IconImage_.prototype.getImage = function (pixelRatio) {
  return this.canvas_ ? this.canvas_ : this.image_;
};

/**
 * @return {ol.ImageState} Image state.
 */
iconimage__ol_style_IconImage_.prototype.getImageState = function () {
  return this.imageState_;
};

/**
 * @param {number} pixelRatio Pixel ratio.
 * @return {Image|HTMLCanvasElement} Image element.
 */
iconimage__ol_style_IconImage_.prototype.getHitDetectionImage = function (pixelRatio) {
  if (!this.hitDetectionImage_) {
    if (this.tainting_) {
      var width = this.size_[0];
      var height = this.size_[1];
      var context = dom["a" /* default */].createCanvasContext2D(width, height);
      context.fillRect(0, 0, width, height);
      this.hitDetectionImage_ = context.canvas;
    } else {
      this.hitDetectionImage_ = this.image_;
    }
  }
  return this.hitDetectionImage_;
};

/**
 * @return {ol.Size} Image size.
 */
iconimage__ol_style_IconImage_.prototype.getSize = function () {
  return this.size_;
};

/**
 * @return {string|undefined} Image src.
 */
iconimage__ol_style_IconImage_.prototype.getSrc = function () {
  return this.src_;
};

/**
 * Load not yet loaded URI.
 */
iconimage__ol_style_IconImage_.prototype.load = function () {
  if (this.imageState_ == imagestate["a" /* default */].IDLE) {
    this.imageState_ = imagestate["a" /* default */].LOADING;
    this.imageListenerKeys_ = [events["a" /* default */].listenOnce(this.image_, eventtype["a" /* default */].ERROR, this.handleImageError_, this), events["a" /* default */].listenOnce(this.image_, eventtype["a" /* default */].LOAD, this.handleImageLoad_, this)];
    try {
      this.image_.src = this.src_;
    } catch (e) {
      this.handleImageError_();
    }
  }
};

/**
 * @private
 */
iconimage__ol_style_IconImage_.prototype.replaceColor_ = function () {
  if (this.tainting_ || this.color_ === null) {
    return;
  }

  this.canvas_.width = this.image_.width;
  this.canvas_.height = this.image_.height;

  var ctx = this.canvas_.getContext('2d');
  ctx.drawImage(this.image_, 0, 0);

  var imgData = ctx.getImageData(0, 0, this.image_.width, this.image_.height);
  var data = imgData.data;
  var r = this.color_[0] / 255.0;
  var g = this.color_[1] / 255.0;
  var b = this.color_[2] / 255.0;

  for (var i = 0, ii = data.length; i < ii; i += 4) {
    data[i] *= r;
    data[i + 1] *= g;
    data[i + 2] *= b;
  }
  ctx.putImageData(imgData, 0, 0);
};

/**
 * Discards event handlers which listen for load completion or errors.
 *
 * @private
 */
iconimage__ol_style_IconImage_.prototype.unlistenImage_ = function () {
  this.imageListenerKeys_.forEach(events["a" /* default */].unlistenByKey);
  this.imageListenerKeys_ = null;
};
/* harmony default export */ var iconimage = (iconimage__ol_style_IconImage_);
// CONCATENATED MODULE: ./node_modules/ol/style/iconorigin.js
/**
 * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
 * @enum {string}
 */
var _ol_style_IconOrigin_ = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right'
};

/* harmony default export */ var iconorigin = (_ol_style_IconOrigin_);
// EXTERNAL MODULE: ./node_modules/ol/style/image.js
var style_image = __webpack_require__(77);

// CONCATENATED MODULE: ./node_modules/ol/style/icon.js











/**
 * @classdesc
 * Set icon style for vector features.
 *
 * @constructor
 * @param {olx.style.IconOptions=} opt_options Options.
 * @extends {ol.style.Image}
 * @api
 */
var icon__ol_style_Icon_ = function _ol_style_Icon_(opt_options) {

  var options = opt_options || {};

  /**
   * @private
   * @type {Array.<number>}
   */
  this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];

  /**
   * @private
   * @type {Array.<number>}
   */
  this.normalizedAnchor_ = null;

  /**
   * @private
   * @type {ol.style.IconOrigin}
   */
  this.anchorOrigin_ = options.anchorOrigin !== undefined ? options.anchorOrigin : iconorigin.TOP_LEFT;

  /**
   * @private
   * @type {ol.style.IconAnchorUnits}
   */
  this.anchorXUnits_ = options.anchorXUnits !== undefined ? options.anchorXUnits : iconanchorunits.FRACTION;

  /**
   * @private
   * @type {ol.style.IconAnchorUnits}
   */
  this.anchorYUnits_ = options.anchorYUnits !== undefined ? options.anchorYUnits : iconanchorunits.FRACTION;

  /**
   * @private
   * @type {?string}
   */
  this.crossOrigin_ = options.crossOrigin !== undefined ? options.crossOrigin : null;

  /**
   * @type {Image|HTMLCanvasElement}
   */
  var image = options.img !== undefined ? options.img : null;

  /**
   * @type {ol.Size}
   */
  var imgSize = options.imgSize !== undefined ? options.imgSize : null;

  /**
   * @type {string|undefined}
   */
  var src = options.src;

  asserts["a" /* default */].assert(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time
  asserts["a" /* default */].assert(!image || image && imgSize, 5); // `imgSize` must be set when `image` is provided

  if ((src === undefined || src.length === 0) && image) {
    src = image.src || ol["a" /* default */].getUid(image).toString();
  }
  asserts["a" /* default */].assert(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided

  /**
   * @type {ol.ImageState}
   */
  var imageState = options.src !== undefined ? imagestate["a" /* default */].IDLE : imagestate["a" /* default */].LOADED;

  /**
   * @private
   * @type {ol.Color}
   */
  this.color_ = options.color !== undefined ? ol_color["a" /* default */].asArray(options.color) : null;

  /**
   * @private
   * @type {ol.style.IconImage}
   */
  this.iconImage_ = typeof window !== 'undefined' ? iconimage.get(image, /** @type {string} */src, imgSize, this.crossOrigin_, imageState, this.color_) : null;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.offset_ = options.offset !== undefined ? options.offset : [0, 0];

  /**
   * @private
   * @type {ol.style.IconOrigin}
   */
  this.offsetOrigin_ = options.offsetOrigin !== undefined ? options.offsetOrigin : iconorigin.TOP_LEFT;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.origin_ = null;

  /**
   * @private
   * @type {ol.Size}
   */
  this.size_ = options.size !== undefined ? options.size : null;

  /**
   * @type {number}
   */
  var opacity = options.opacity !== undefined ? options.opacity : 1;

  /**
   * @type {boolean}
   */
  var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;

  /**
   * @type {number}
   */
  var rotation = options.rotation !== undefined ? options.rotation : 0;

  /**
   * @type {number}
   */
  var scale = options.scale !== undefined ? options.scale : 1;

  /**
   * @type {boolean}
   */
  var snapToPixel = options.snapToPixel !== undefined ? options.snapToPixel : true;

  style_image["a" /* default */].call(this, {
    opacity: opacity,
    rotation: rotation,
    scale: scale,
    snapToPixel: snapToPixel,
    rotateWithView: rotateWithView
  });
};

ol["a" /* default */].inherits(icon__ol_style_Icon_, style_image["a" /* default */]);

/**
 * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
 * @return {ol.style.Icon} The cloned style.
 * @api
 */
icon__ol_style_Icon_.prototype.clone = function () {
  return new icon__ol_style_Icon_({
    anchor: this.anchor_.slice(),
    anchorOrigin: this.anchorOrigin_,
    anchorXUnits: this.anchorXUnits_,
    anchorYUnits: this.anchorYUnits_,
    crossOrigin: this.crossOrigin_,
    color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || undefined,
    src: this.getSrc(),
    offset: this.offset_.slice(),
    offsetOrigin: this.offsetOrigin_,
    size: this.size_ !== null ? this.size_.slice() : undefined,
    opacity: this.getOpacity(),
    scale: this.getScale(),
    snapToPixel: this.getSnapToPixel(),
    rotation: this.getRotation(),
    rotateWithView: this.getRotateWithView()
  });
};

/**
 * @inheritDoc
 * @api
 */
icon__ol_style_Icon_.prototype.getAnchor = function () {
  if (this.normalizedAnchor_) {
    return this.normalizedAnchor_;
  }
  var anchor = this.anchor_;
  var size = this.getSize();
  if (this.anchorXUnits_ == iconanchorunits.FRACTION || this.anchorYUnits_ == iconanchorunits.FRACTION) {
    if (!size) {
      return null;
    }
    anchor = this.anchor_.slice();
    if (this.anchorXUnits_ == iconanchorunits.FRACTION) {
      anchor[0] *= size[0];
    }
    if (this.anchorYUnits_ == iconanchorunits.FRACTION) {
      anchor[1] *= size[1];
    }
  }

  if (this.anchorOrigin_ != iconorigin.TOP_LEFT) {
    if (!size) {
      return null;
    }
    if (anchor === this.anchor_) {
      anchor = this.anchor_.slice();
    }
    if (this.anchorOrigin_ == iconorigin.TOP_RIGHT || this.anchorOrigin_ == iconorigin.BOTTOM_RIGHT) {
      anchor[0] = -anchor[0] + size[0];
    }
    if (this.anchorOrigin_ == iconorigin.BOTTOM_LEFT || this.anchorOrigin_ == iconorigin.BOTTOM_RIGHT) {
      anchor[1] = -anchor[1] + size[1];
    }
  }
  this.normalizedAnchor_ = anchor;
  return this.normalizedAnchor_;
};

/**
 * Get the icon color.
 * @return {ol.Color} Color.
 * @api
 */
icon__ol_style_Icon_.prototype.getColor = function () {
  return this.color_;
};

/**
 * Get the image icon.
 * @param {number} pixelRatio Pixel ratio.
 * @return {Image|HTMLCanvasElement} Image or Canvas element.
 * @override
 * @api
 */
icon__ol_style_Icon_.prototype.getImage = function (pixelRatio) {
  return this.iconImage_.getImage(pixelRatio);
};

/**
 * @override
 */
icon__ol_style_Icon_.prototype.getImageSize = function () {
  return this.iconImage_.getSize();
};

/**
 * @override
 */
icon__ol_style_Icon_.prototype.getHitDetectionImageSize = function () {
  return this.getImageSize();
};

/**
 * @override
 */
icon__ol_style_Icon_.prototype.getImageState = function () {
  return this.iconImage_.getImageState();
};

/**
 * @override
 */
icon__ol_style_Icon_.prototype.getHitDetectionImage = function (pixelRatio) {
  return this.iconImage_.getHitDetectionImage(pixelRatio);
};

/**
 * @inheritDoc
 * @api
 */
icon__ol_style_Icon_.prototype.getOrigin = function () {
  if (this.origin_) {
    return this.origin_;
  }
  var offset = this.offset_;

  if (this.offsetOrigin_ != iconorigin.TOP_LEFT) {
    var size = this.getSize();
    var iconImageSize = this.iconImage_.getSize();
    if (!size || !iconImageSize) {
      return null;
    }
    offset = offset.slice();
    if (this.offsetOrigin_ == iconorigin.TOP_RIGHT || this.offsetOrigin_ == iconorigin.BOTTOM_RIGHT) {
      offset[0] = iconImageSize[0] - size[0] - offset[0];
    }
    if (this.offsetOrigin_ == iconorigin.BOTTOM_LEFT || this.offsetOrigin_ == iconorigin.BOTTOM_RIGHT) {
      offset[1] = iconImageSize[1] - size[1] - offset[1];
    }
  }
  this.origin_ = offset;
  return this.origin_;
};

/**
 * Get the image URL.
 * @return {string|undefined} Image src.
 * @api
 */
icon__ol_style_Icon_.prototype.getSrc = function () {
  return this.iconImage_.getSrc();
};

/**
 * @inheritDoc
 * @api
 */
icon__ol_style_Icon_.prototype.getSize = function () {
  return !this.size_ ? this.iconImage_.getSize() : this.size_;
};

/**
 * @override
 */
icon__ol_style_Icon_.prototype.listenImageChange = function (listener, thisArg) {
  return events["a" /* default */].listen(this.iconImage_, eventtype["a" /* default */].CHANGE, listener, thisArg);
};

/**
 * Load not yet loaded URI.
 * When rendering a feature with an icon style, the vector renderer will
 * automatically call this method. However, you might want to call this
 * method yourself for preloading or other purposes.
 * @override
 * @api
 */
icon__ol_style_Icon_.prototype.load = function () {
  this.iconImage_.load();
};

/**
 * @override
 */
icon__ol_style_Icon_.prototype.unlistenImageChange = function (listener, thisArg) {
  events["a" /* default */].unlisten(this.iconImage_, eventtype["a" /* default */].CHANGE, listener, thisArg);
};
/* harmony default export */ var icon = (icon__ol_style_Icon_);
// CONCATENATED MODULE: ./node_modules/gis4dis-generalizer/src/cg/symbolizers/Symbolizer.js
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }




/* Constants of position of symbols */
var PRECIPITATION = [1, 1];
var AIR_TEMPERATURE = [0, 0];
var PM10 = [1, 0];
var STREAM_FLOW = [0, 1];

var SYMBOL_PATH = '/static/symbolization';

var MIN_RANGE = 0.2;
var MAX_RANGE = 0.6;

/** Represents Symbolizer for features. Contains set of operations including creating styles */

var Symbolizer_Symbolizer = function () {

    /**
     * Instantiating of Symbolizer object
     * @constructor
     * @param {String} primary_property - value selected by user
     *  (https://github.com/gis4dis/mc-client/blob/e7e4654dbd4f4b3fb468d4b4a21cadcb1fbbc0cf/static/data/properties.json)
     * @param {Object} properties - object of properties
     * @param {ol.Feature} feature - represented as one feature from an Array of GeoJSON Features, each of them includes attributes
     *  (https://github.com/gis4dis/cg/blob/master/data/example.json)
     * @param {number} valueIdx - an index of value that should be used for generalization
     * @param {number} resolution - number, represents projection units per pixel (the projection is EPSG:3857)
     * @param {Object.<array>} minMaxValues - minimum and maximum values (min and max property values, min and max anomaly rates)
     *  (https://github.com/gis4dis/poster/wiki/Interface-between-MC-client-&-CG)
     */
    function Symbolizer(primary_property, properties, feature, valueIdx, resolution, minMaxValues) {
        _classCallCheck(this, Symbolizer);

        this.primary_property = primary_property;
        this.properties = properties;
        this.feature = feature;
        this.valueIdx = valueIdx;
        this.resolution = resolution;
        this.minMaxValues = minMaxValues;
    }

    /**
     * Returning max value from geojson array with specific key
     * @param {ol.Feature} features - array of OL features
     * @param {String} name_id - name_id of property
     * @returns {number} - Max value from array
     */


    _createClass(Symbolizer, [{
        key: 'buildStyle',


        /**
         * Building SVG icon based on property_value and property_anomaly_rates
         * @param {String} property - name of the property (air_temperature...)
         * @param {Array.<number>} coordinates - coordinates of position of symbol
         * @param {Number} normalizedPropertyValue - normalized property (to a range MIN_RANGE and MAX_RANGE) value from values array from feature
         * @returns {_ol_style_Style_} OpenLayers style object
         */
        value: function buildStyle(property, coordinates, normalizedPropertyValue) {
            var propertyAnomalyValue = 0;
            var anomalyInterval = '';

            propertyAnomalyValue = this.feature.values_[property]['anomaly_rates'][this.valueIdx];
            anomalyInterval = Symbolizer.getAnomalyInterval(propertyAnomalyValue);

            return new style_style["default"]({
                image: new icon({
                    anchor: coordinates,
                    opacity: 1,
                    src: SYMBOL_PATH + '/' + property + '_' + anomalyInterval + '.svg',
                    scale: normalizedPropertyValue
                })
            });
        }

        /**
         * Return primary OL style. Primary property is selected by user in MC client
         * @param {Array.<number>} coordinates - coordinates of position of symbol
         * @param {Number} normalizedPropertyValue - normalized property (to a range MIN_RANGE and MAX_RANGE) value from values array from feature
         * @returns {_ol_style_Style_} OpenLayers style object
         */

    }, {
        key: 'addPrimaryStyle',
        value: function addPrimaryStyle(coordinates, normalizedPropertyValue) {
            return new style_style["default"]({
                image: new icon({
                    anchor: coordinates,
                    opacity: 1,
                    src: SYMBOL_PATH + '/primary.svg',
                    scale: normalizedPropertyValue
                })
            });
        }

        /**
         * Function computes normalizedPropertyValue of specific feature
         * @param {String} property - name of the property (air_temperature...)
         * @returns {Number} Normalized property value used for size of symbol
         */

    }, {
        key: 'getNormalizedPropertyValue',
        value: function getNormalizedPropertyValue(property) {
            var normalizedPropertyValue = 0;

            // Value of property (e.g. air_temperature) is normalized from 0 to 1
            return Symbolizer.normalize(this.feature.values_[property]['values'][this.valueIdx], this.minMaxValues[property]['min'], this.minMaxValues[property]['max']);
        }

        /**
         * Creates array of OL styles objects based on property name_id value
         * @returns {Array} styles - array of OL styles
         */

    }, {
        key: 'createSymbol',
        value: function createSymbol() {
            var styles = [];

            for (var i in this.properties) {
                if (this.feature.values_.hasOwnProperty(this.properties[i].name_id)) {
                    var property = this.properties[i].name_id;
                    var normalizedPropertyValue = 0;

                    switch (property) {
                        case 'precipitation':
                            normalizedPropertyValue = this.getNormalizedPropertyValue(property);

                            if (this.primary_property === property) {
                                styles.push(this.addPrimaryStyle(PRECIPITATION, normalizedPropertyValue));
                            }

                            styles.push(this.buildStyle(property, PRECIPITATION, normalizedPropertyValue));
                            break;
                        case 'air_temperature':
                            normalizedPropertyValue = this.getNormalizedPropertyValue(property);

                            if (this.primary_property === property) {
                                styles.push(this.addPrimaryStyle(AIR_TEMPERATURE, normalizedPropertyValue));
                            }

                            styles.push(this.buildStyle(property, AIR_TEMPERATURE, normalizedPropertyValue));
                            break;
                        case 'pm10':
                            normalizedPropertyValue = this.getNormalizedPropertyValue(property);

                            if (this.primary_property === property) {
                                styles.push(this.addPrimaryStyle(PM10, normalizedPropertyValue));
                            }

                            styles.push(this.buildStyle(property, PM10, normalizedPropertyValue));
                            break;
                        case 'stream_flow':
                            normalizedPropertyValue = this.getNormalizedPropertyValue(property);

                            if (this.primary_property === property) {
                                styles.push(this.addPrimaryStyle(STREAM_FLOW, normalizedPropertyValue));
                            }

                            styles.push(this.buildStyle(property, STREAM_FLOW, normalizedPropertyValue));
                            break;
                    }
                }
            }
            //console.log(styles);

            return styles;
        }
    }], [{
        key: 'getMaxValue',
        value: function getMaxValue(features, name_id) {
            var maxValue = null;

            features.forEach(function (feature) {
                if (feature.values_.hasOwnProperty(name_id)) {
                    if (maxValue === null || maxValue < Math.max.apply(Math, _toConsumableArray(feature.values_[name_id]['values']))) {
                        maxValue = Math.max.apply(Math, _toConsumableArray(feature.values_[name_id]['values']));
                    }
                }
            });

            return maxValue;
        }

        /**
         * Returning min value from geojson array with specific key
         * @param {ol.Feature} features - array of OL features
         * @param {String} name_id - name_id of property
         * @returns {number} - Min value from array
         */

    }, {
        key: 'getMinValue',
        value: function getMinValue(features, name_id) {
            var minValue = null;

            features.forEach(function (feature) {
                if (feature.values_.hasOwnProperty(name_id)) {
                    if (minValue === null || minValue > Math.min.apply(Math, _toConsumableArray(feature.values_[name_id]['values']))) {
                        minValue = Math.min.apply(Math, _toConsumableArray(feature.values_[name_id]['values']));
                    }
                }
            });

            return minValue;
        }

        /**
         * Normalize value to 0-1 range
         * @param {number} value - value for normalization
         * @param {number} min - minimum value of array
         * @param {number} max - maximum value of array
         * @returns {number} normalized value
         */

    }, {
        key: 'normalize',
        value: function normalize(value, min, max) {
            return (value - min) / (max - min) * (MAX_RANGE - MIN_RANGE) + MIN_RANGE;
        }

        /**
         * Creating hash based on values of SVG parameters
         * @param {String} featureId - ID of feature
         * @param {String} primary_property - primary property selected by user in MC client
         * @param {Number} indexId - index for selecting value and anomaly rates from arrays
         * @returns {string} hash
         */

    }, {
        key: 'createHash',
        value: function createHash(featureId, primary_property, indexId) {
            return 'featureid' + featureId + 'primaryproperty' + primary_property + 'index' + indexId;
        }

        /**
         * Returning name of the interval base on anomaly rate value
         * @returns {String} interval - interval (low, middle or high) of anomaly rate
         * */

    }, {
        key: 'getAnomalyInterval',
        value: function getAnomalyInterval(value) {
            if (value < 2.5) {
                return 'middle';
            } else if (value < 1) {
                return 'low';
            }
            return 'high';
        }
    }]);

    return Symbolizer;
}();

/* harmony default export */ var symbolizers_Symbolizer = (Symbolizer_Symbolizer);
// EXTERNAL MODULE: ./node_modules/ol/style/stroke.js
var stroke = __webpack_require__(57);

// EXTERNAL MODULE: ./node_modules/ol/style/fill.js
var fill = __webpack_require__(66);

// CONCATENATED MODULE: ./node_modules/gis4dis-generalizer/src/cg/symbolizers/PolygonSymbolizer.js
var PolygonSymbolizer__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function PolygonSymbolizer__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }







/** Represents Symbolizer for features. Contains set of operations including creating styles */

var PolygonSymbolizer_PolygonSymbolizer = function () {

    /**
     * Instantiating of Symbolizer object
     * @constructor
     * @param {Object.<string, string>} property - values selected by user
     *  (https://github.com/gis4dis/mc-client/blob/e7e4654dbd4f4b3fb468d4b4a21cadcb1fbbc0cf/static/data/properties.json)
     * @param {Object.GeoJSON} feature - represented as one feature from an Array of GeoJSON Features, each of them includes attributes
     *  (https://github.com/gis4dis/cg/blob/master/data/example.json)
     * @param {number} valueIdx - an index of value that should be used for generalization
     * @param {number} resolution - number, represents projection units per pixel (the projection is EPSG:3857)
     * @param {number} maxPropertyValue - max value from property values
     * @param {number} minPropertyValue - min value from property values
     * @param {number} maxAnomalyValue - max value from property anomaly rates
     * @param {number} minAnomalyValue - min value from property anomaly rates
     *  (https://github.com/gis4dis/poster/wiki/Interface-between-MC-client-&-CG)
     */
    function PolygonSymbolizer(property, feature, valueIdx, resolution, maxPropertyValue, minPropertyValue, maxAnomalyValue, minAnomalyValue) {
        PolygonSymbolizer__classCallCheck(this, PolygonSymbolizer);
    }

    /**
     * Creating _ol_style_Style_ object
     * @returns {_ol_style_Style_} built style for styleFunction
     */


    PolygonSymbolizer__createClass(PolygonSymbolizer, [{
        key: 'buildStyle',
        value: function buildStyle() {
            var _myStroke = new stroke["default"]({
                color: 'rgba(255,0,0,1.0)',
                width: 1
            });

            var _myFill = new fill["default"]({
                color: 'rgba(255,0,0,1.0)'
            });

            return new style_style["default"]({
                stroke: _myStroke,
                fill: _myFill
            });
        }

        /**
         * Creating default _ol_style_Style_ object. Prepared to the future
         * @returns {_ol_style_Style_} default style
         */

    }, {
        key: 'buildDefaultStyle',
        value: function buildDefaultStyle() {
            return this.buildStyle();
        }

        /**
         * Creating style based on property value.
         *  (https://github.com/gis4dis/poster/wiki/Interface-between-MC-client-&-CG)
         * @returns {_ol_style_Style_} built style for vector layer
         */
        //TODO change with different styles for different properties

    }, {
        key: 'styleBasedOnProperty',
        value: function styleBasedOnProperty() {
            switch (this.property.name_id) {
                case 'air_temperature':
                    return this.buildStyle();
                case 'ground_air_temperature':
                    return this.buildStyle();
                case 'soil_temperature':
                    return this.buildStyle();
                case 'precipitation':
                    return this.buildStyle();
                case 'air_humidity':
                    return this.buildStyle();
                default:
                    return this.buildDefaultStyle();
            }
        }
    }]);

    return PolygonSymbolizer;
}();

/* harmony default export */ var symbolizers_PolygonSymbolizer = (PolygonSymbolizer_PolygonSymbolizer);
// CONCATENATED MODULE: ./node_modules/gis4dis-generalizer/src/cg/generalize.js



var turfhelper = __webpack_require__(100);
var turfbuffer = __webpack_require__(101);
var turfprojection = __webpack_require__(102);

/**
 * Main generalization function
 * https://github.com/gis4dis/poster/wiki/Interface-between-MC-client-&-CG-v2
 * @param {Object.<string, string>} topic - topic that is selected by user, e.g. drought or flood
 * @param {Object.<string>} primary_property - name_id of one of properties that is selected by the user
 * @param {Object.<string, string, string>} properties - properties related to the topic whose timeseries are contained within features
 * @param {Object.GeoJSON} features - represented as Array of GeoJSON Features, each of them includes attributes
 *  (https://github.com/gis4dis/poster/wiki/Interface-between-MC-client-&-MC-server-v2#timeseries)
 * @param {number} value_idx - an index of value that should be used for generalization
 * @param {number} resolution - number, represents projection units per pixel (the projection is EPSG:3857)
 *  (https://github.com/gis4dis/poster/wiki/Interface-between-MC-client-&-CG)
 * @returns {{features: Array.<_ol_feature>, style: _ol_StyleFunction}}
 */
var cachedFeatureStyles = {};

/* harmony default export */ var generalize = (function (_ref) {
    var topic = _ref.topic,
        primary_property = _ref.primary_property,
        properties = _ref.properties,
        features = _ref.features,
        value_idx = _ref.value_idx,
        resolution = _ref.resolution;


    // Assurance checks
    if (primary_property === null) {
        throw new Error('Property not provided');
    }

    if (resolution === null) {
        throw new Error('Resolution not provided');
    }

    if (features === null) {
        return {
            features: [],
            style: null
        };
    }

    if (value_idx < 0) {
        throw new Error('Value_idx values must be >= 0');
    }

    //TODO create tests for property_values and property_anomaly_rates
    // features.features.forEach(function (feature) {
    //     if (feature.properties.property_values.length !== feature.properties.property_anomaly_rates.length) {
    //         throw new Error('Property values and property anomaly rates has different length');
    //     }
    //
    //     if (feature.properties.value_index_shift < 0) {
    //         throw new Error('Value index shift must be >= 0');
    //     }
    // });

    if (value_idx < 0) {
        throw new Error('Value_idx values must be >= 0');
    }

    var parsedFeatures = new geojson["default"]().readFeatures(features, {
        dataProjection: 'EPSG:3857',
        featureProjection: 'EPSG:3857'
    });

    console.log('FEATURE');
    console.log(turfhelper.point([-75.343, 39.984]));
    console.log(turfhelper.point([1847520.94, 6309563.27]));

    console.log(turfbuffer.default(turfhelper.point([-75.343, 39.984]), 500, { units: 'kilometers' }));
    console.log(turfbuffer.default(turfprojection.toWgs84(turfhelper.point([1847520.94, 6309563.27])), 500, { units: 'kilometers' }));

    // Adding geometry in WGS84 to OL feature because of computing using turf.js
    for (var i in parsedFeatures) {
        parsedFeatures[i].setProperties({ 'WGS84': turfprojection.toWgs84(parsedFeatures[i].getGeometry().getCoordinates()) });
        parsedFeatures[i].setProperties({ 'turf_geometry': turfhelper.point(turfprojection.toWgs84(parsedFeatures[i].getGeometry().getCoordinates())) });
    }

    console.log('Parsed features');
    console.log(parsedFeatures);

    // Min and max values for normalization
    var minMaxValues = {};

    properties.forEach(function (property) {
        minMaxValues[property.name_id] = {};
        minMaxValues[property.name_id]['min'] = symbolizers_Symbolizer.getMinValue(parsedFeatures, property.name_id);
        minMaxValues[property.name_id]['max'] = symbolizers_Symbolizer.getMaxValue(parsedFeatures, property.name_id);
    });
    console.log('MAXMINVALUES');
    console.log(minMaxValues);

    //console.log(parsedFeatures);

    // Caching the styles
    if (Object.keys(cachedFeatureStyles).length === 0) {
        var length = 0;
        parsedFeatures.forEach(function (feature) {

            properties.forEach(function (property) {
                if (feature.values_.hasOwnProperty(property.name_id)) {
                    length = feature.values_[property.name_id].values.length;
                }
            });

            for (var _i = 0; _i < length; _i++) {
                var symbolizer = new symbolizers_Symbolizer(primary_property, properties, feature, _i, resolution, minMaxValues);
                var featureStyle = symbolizer.createSymbol();
                //console.log(featureStyle);
                var hash = symbolizers_Symbolizer.createHash(feature.id_, primary_property, _i);
                if (featureStyle instanceof Array) {
                    for (var j in featureStyle) {
                        featureStyle[j].getImage().load();
                    }
                } else {
                    featureStyle.getImage().load();
                }
                cachedFeatureStyles[hash] = featureStyle;
                //console.log('CACHED styles');
                //console.log(cachedFeatureStyles);
            }
        });
    }

    return {
        features: new geojson["default"]().readFeatures(features, {
            dataProjection: 'EPSG:3857',
            featureProjection: 'EPSG:3857'
        }),
        style: function style(feature, resolution) {
            var hash = symbolizers_Symbolizer.createHash(feature.id_, primary_property, value_idx);
            //console.log('hash');
            //console.log(hash);

            if (cachedFeatureStyles.hasOwnProperty(hash)) {
                //console.log('Vracim cachovany styl');
                //console.log(hash);
                return cachedFeatureStyles[hash];
            } else {
                //console.log('Necachovany styl');
                var symbolizer = new symbolizers_Symbolizer(primary_property, properties, feature, value_idx, resolution, minMaxValues);
                return symbolizer.createSymbol();
            }
        }
    };
});
// EXTERNAL MODULE: external "moment"
var external__moment_ = __webpack_require__(49);
var external__moment__default = /*#__PURE__*/__webpack_require__.n(external__moment_);

// EXTERNAL MODULE: external "semantic-ui-react"
var external__semantic_ui_react_ = __webpack_require__(12);
var external__semantic_ui_react__default = /*#__PURE__*/__webpack_require__.n(external__semantic_ui_react_);

// EXTERNAL MODULE: external "recharts"
var external__recharts_ = __webpack_require__(103);
var external__recharts__default = /*#__PURE__*/__webpack_require__.n(external__recharts_);

// CONCATENATED MODULE: ./components/FeatureCharts.js
var FeatureCharts__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



function FeatureCharts__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var getTime = function getTime(timeSettings, i) {
    var from = timeSettings.from;
    var frequency = timeSettings.frequency;

    var time = from.unix() + frequency * i;
    return time;
};

var FeatureCharts_getChartTicks = function getChartTicks(timeSettings, left, right) {
    var allTicks = [];

    var indexTime = timeSettings.from.unix();
    while (indexTime < timeSettings.to.unix() && (right === 'dataMax' || indexTime < right)) {
        if (left === 'dataMin' || left < indexTime) {
            allTicks.push(indexTime);
        }
        indexTime += timeSettings.frequency;
    }

    if (FeatureCharts_shouldShowOnlyDates(timeSettings, left, right)) {
        return allTicks.filter(function (tick) {
            var time = external__moment__default.a.unix(tick).utcOffset(timeSettings.timeZone);
            var startOfDay = time.clone().startOf('day');

            return time.isSame(startOfDay);
        });
    }
    return allTicks;
};

var FeatureCharts_getTimeFormatter = function getTimeFormatter(timeZone, format) {
    return function (time) {
        var timeDate = external__moment__default.a.unix(time).utcOffset(timeZone);
        var timeStr = timeDate.format(format);

        var regExp = new RegExp('[^\.]?' + timeDate.format('YYYY') + '.?');
        timeStr = timeStr.replace(new RegExp('[^\.]?' + timeDate.format('YYYY') + '.?'), '');

        return timeStr;
    };
};

var getDatesDiff = function getDatesDiff(timeSettings) {
    var from = timeSettings.from;
    var to = timeSettings.to;
    return to.diff(from, 'days');
};

var FeatureCharts_shouldShowOnlyDates = function shouldShowOnlyDates(timeSettings, left, right) {
    var isZoomedIn = left !== 'dataMin' || right !== 'dataMax';

    var leftDate = left === 'dataMin' ? timeSettings.from : external__moment__default.a.unix(left).utcOffset(timeSettings.timeZone);
    var rightDate = right === 'dataMax' ? timeSettings.to : external__moment__default.a.unix(right).utcOffset(timeSettings.timeZone);
    return isZoomedIn ? rightDate.diff(leftDate, 'days') > 1 : getDatesDiff(timeSettings) > 1;
};

/********************* zooming ***********************/
var initialState = {
    left: 'dataMin',
    right: 'dataMax',
    refAreaLeft: '',
    refAreaRight: '',
    animation: true
};

/********************* zooming ***********************/

var getData = function getData(feature, property, time) {
    if (feature && property) {

        var propertyData = feature.get(property.name_id);

        if (propertyData) {
            var data = [];
            var shift = propertyData.value_index_shift;
            for (var i = 0; i < shift; i++) {
                data.push({
                    time: getTime(time, i),
                    value: null,
                    anomaly_rate: null
                });
            }

            var propertyValues = propertyData.values;
            var anomalyRates = propertyData.anomaly_rates;

            var count = propertyValues.length;
            for (var _i = 0; _i < count; _i++) {
                var dataObject = {
                    time: getTime(time, _i + shift),
                    value: propertyValues[_i],
                    anomaly_rate: anomalyRates[_i]
                };
                data.push(dataObject);
            }
            return data;
        } else {
            return null;
        }
    }
    return null;
};

var getTimeRangeString = function getTimeRangeString(timeSettings) {
    if (timeSettings.from && timeSettings.to) {
        return timeSettings.from.format('L') + ' - ' + timeSettings.to.format('L');
    }
    return null;
};

var FeatureCharts_FeatureCharts = function (_React$Component) {
    _inherits(FeatureCharts, _React$Component);

    function FeatureCharts(props) {
        FeatureCharts__classCallCheck(this, FeatureCharts);

        var _this = _possibleConstructorReturn(this, (FeatureCharts.__proto__ || Object.getPrototypeOf(FeatureCharts)).call(this, props));

        var title = _this.props.feature ? _this.props.feature.get('name') : null;
        var subtitle = getTimeRangeString(_this.props.timeSettings);
        var data = getData(_this.props.feature, _this.props.property, _this.props.timeSettings);

        var timeFormatter = void 0;
        if (data) {
            var format = getDatesDiff(_this.props.timeSettings) > 1 ? 'L' : 'LT';
            timeFormatter = FeatureCharts_getTimeFormatter(_this.props.timeSettings.timeZone, format);
        }

        _this.state = Object.assign(initialState, {
            data: data,
            title: title,
            subtitle: subtitle,
            timeFormatter: timeFormatter
        });

        return _this;
    }

    FeatureCharts__createClass(FeatureCharts, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            var title = nextProps.feature ? nextProps.feature.get('name') : null;
            var subtitle = getTimeRangeString(this.props.timeSettings);
            var data = getData(nextProps.feature, nextProps.property, nextProps.timeSettings);

            var timeFormatter = void 0;
            if (data) {
                var format = getDatesDiff(nextProps.timeSettings) > 1 ? 'L' : 'LT';
                timeFormatter = FeatureCharts_getTimeFormatter(nextProps.timeSettings.timeZone, format);
            }

            this.setState(Object.assign(initialState, {
                data: data,
                title: title,
                subtitle: subtitle,
                timeFormatter: timeFormatter
            }));
        }
    }, {
        key: '_onMouseDown',
        value: function _onMouseDown(evt) {
            if (evt) {
                this.setState({
                    refAreaLeft: evt.activeLabel
                });
            }
        }
    }, {
        key: '_onMouseMove',
        value: function _onMouseMove(evt) {
            if (this.state.refAreaLeft) {
                this.setState({
                    refAreaRight: evt.activeLabel
                });
            }
        }
    }, {
        key: 'zoomIn',
        value: function zoomIn() {
            var _state = this.state,
                refAreaLeft = _state.refAreaLeft,
                refAreaRight = _state.refAreaRight;


            if (refAreaLeft === refAreaRight || refAreaRight === '') {
                this.setState({
                    refAreaLeft: '',
                    refAreaRight: ''
                });
                return;
            }

            if (refAreaLeft > refAreaRight) {
                ;

                var _ref = [refAreaRight, refAreaLeft];
                refAreaLeft = _ref[0];
                refAreaRight = _ref[1];
            }var format = FeatureCharts_shouldShowOnlyDates(this.props.timeSettings, refAreaLeft, refAreaRight) ? 'L' : 'LT';
            var timeFormatter = FeatureCharts_getTimeFormatter(this.props.timeSettings.timeZone, format);

            this.setState(function () {
                return {
                    timeFormatter: timeFormatter,
                    refAreaLeft: '',
                    refAreaRight: '',
                    left: refAreaLeft,
                    right: refAreaRight
                };
            });
        }
    }, {
        key: 'zoomOut',
        value: function zoomOut() {
            var format = getDatesDiff(this.props.timeSettings) > 1 ? 'L' : 'LT';
            var timeFormatter = FeatureCharts_getTimeFormatter(this.props.timeSettings.timeZone, format);

            this.setState({
                timeFormatter: timeFormatter,
                refAreaLeft: '',
                refAreaRight: '',
                left: 'dataMin',
                right: 'dataMax'
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var _state2 = this.state,
                data = _state2.data,
                title = _state2.title,
                subtitle = _state2.subtitle,
                timeFormatter = _state2.timeFormatter,
                left = _state2.left,
                right = _state2.right,
                refAreaLeft = _state2.refAreaLeft,
                refAreaRight = _state2.refAreaRight;

            var isZoomedIn = left !== 'dataMin' || right !== 'dataMax';

            var valueAxisLabel = void 0;
            if (this.props.property) {
                valueAxisLabel = {
                    value: /*this.props.property.name + */' [' + this.props.property.unit + ']',
                    angle: -90,
                    offset: 10,
                    position: 'insideLeft'
                };
            }

            var headerHeight = 54;
            var height = (this.props.height || 286) - headerHeight;
            var width = this.props.width || 500;

            return external__react__default.a.createElement(
                'div',
                {
                    className: 'jsx-845302506'
                },
                title && external__react__default.a.createElement(
                    'div',
                    {
                        className: 'jsx-845302506' + ' ' + 'title'
                    },
                    title
                ),
                external__react__default.a.createElement(
                    'div',
                    { style: { height: '36px' }, className: 'jsx-845302506'
                    },
                    subtitle && external__react__default.a.createElement(
                        'div',
                        {
                            className: 'jsx-845302506' + ' ' + 'subtitle'
                        },
                        subtitle
                    ),
                    isZoomedIn && external__react__default.a.createElement(
                        external__semantic_ui_react_["Button"],
                        {
                            inverted: true,
                            color: 'blue',
                            onClick: this.zoomOut.bind(this),
                            style: { float: 'right' } },
                        'Zoom Out'
                    )
                ),
                data && external__react__default.a.createElement(
                    external__recharts_["AreaChart"],
                    {
                        height: height,
                        width: width,
                        data: data,
                        onMouseDown: this._onMouseDown.bind(this),
                        onMouseMove: this._onMouseMove.bind(this),
                        onMouseUp: this.zoomIn.bind(this),
                        margin: { top: 10, right: 0, left: 0, bottom: 0 } },
                    external__react__default.a.createElement(
                        'defs',
                        {
                            className: 'jsx-845302506'
                        },
                        external__react__default.a.createElement(
                            'linearGradient',
                            { id: 'colorValues', x1: '0', y1: '0', x2: '0', y2: '1', className: 'jsx-845302506'
                            },
                            external__react__default.a.createElement('stop', { offset: '5%', stopColor: '#0000ff', stopOpacity: 0.8, className: 'jsx-845302506'
                            }),
                            external__react__default.a.createElement('stop', { offset: '95%', stopColor: '#0000ff', stopOpacity: 0, className: 'jsx-845302506'
                            })
                        ),
                        external__react__default.a.createElement(
                            'linearGradient',
                            { id: 'colorAnomalies', x1: '0', y1: '0', x2: '0', y2: '1', className: 'jsx-845302506'
                            },
                            external__react__default.a.createElement('stop', { offset: '5%', stopColor: '#ff0000', stopOpacity: 0.8, className: 'jsx-845302506'
                            }),
                            external__react__default.a.createElement('stop', { offset: '95%', stopColor: '#ff0000', stopOpacity: 0, className: 'jsx-845302506'
                            })
                        )
                    ),
                    external__react__default.a.createElement(external__recharts_["XAxis"], { dataKey: 'time',
                        allowDataOverflow: true,
                        domain: [left, right],
                        scale: 'time',
                        ticks: FeatureCharts_getChartTicks(this.props.timeSettings, left, right),
                        type: 'number',
                        tickFormatter: timeFormatter }),
                    external__react__default.a.createElement(external__recharts_["YAxis"], { yAxisId: 'values', label: valueAxisLabel }),
                    external__react__default.a.createElement(external__recharts_["YAxis"], { yAxisId: 'anomalies', orientation: 'right' }),
                    external__react__default.a.createElement(external__recharts_["Tooltip"], { labelFormatter: FeatureCharts_getTimeFormatter(this.props.timeSettings.timeZone, 'LT L') }),
                    external__react__default.a.createElement(external__recharts_["Area"], { yAxisId: 'values',
                        type: 'monotone',
                        dataKey: 'value',
                        stroke: '#0000ff',
                        fillOpacity: 1,
                        fill: 'url(#colorValues)' }),
                    external__react__default.a.createElement(external__recharts_["Area"], { yAxisId: 'anomalies',
                        type: 'monotone',
                        dataKey: 'anomaly_rate',
                        stroke: '#ff0000',
                        fillOpacity: 1,
                        fill: 'url(#colorAnomalies)' }),
                    refAreaLeft && refAreaRight && external__react__default.a.createElement(external__recharts_["ReferenceArea"], {
                        yAxisId: 'values',
                        x1: refAreaLeft,
                        x2: refAreaRight,
                        strokeOpacity: 0.3 })
                ),
                external__react__default.a.createElement(style__default.a, {
                    styleId: '845302506',
                    css: ['.title.jsx-845302506{font-size:18px;font-weight:bold;margin-bottom:4px;}', '.subtitle.jsx-845302506{display:inline-block;margin-right:4px;}']
                })
            );
        }
    }]);

    return FeatureCharts;
}(external__react__default.a.Component);

/* harmony default export */ var components_FeatureCharts = (FeatureCharts_FeatureCharts);
// CONCATENATED MODULE: ./components/FullscreenFeatureCharts.js
var FullscreenFeatureCharts__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



function FullscreenFeatureCharts__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function FullscreenFeatureCharts__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function FullscreenFeatureCharts__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var FullscreenFeatureCharts_FullscreenFeatureCharts = function (_Component) {
    FullscreenFeatureCharts__inherits(FullscreenFeatureCharts, _Component);

    function FullscreenFeatureCharts(props) {
        FullscreenFeatureCharts__classCallCheck(this, FullscreenFeatureCharts);

        var _this = FullscreenFeatureCharts__possibleConstructorReturn(this, (FullscreenFeatureCharts.__proto__ || Object.getPrototypeOf(FullscreenFeatureCharts)).call(this, props));

        _this.state = {
            height: 0,
            width: 0
        };
        return _this;
    }

    FullscreenFeatureCharts__createClass(FullscreenFeatureCharts, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            this.setSize();
            window.addEventListener('resize', this.setSize.bind(this));
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            window.removeEventListener('resize', this.setSize.bind(this));
        }
    }, {
        key: 'setSize',
        value: function setSize() {
            this.setState({
                height: window.innerHeight,
                width: window.innerWidth
            });
        }
    }, {
        key: 'render',
        value: function render() {
            return external__react__default.a.createElement(
                external__semantic_ui_react_["Dimmer"],
                { active: this.props.active, page: true, onClickOutside: this.props.onClose },
                external__react__default.a.createElement(
                    'div',
                    {
                        className: 'jsx-520489485' + ' ' + 'popup fullscreen'
                    },
                    external__react__default.a.createElement('a', { href: '#', onClick: this.props.onClose, className: 'jsx-520489485' + ' ' + 'popup-closer'
                    }),
                    external__react__default.a.createElement(components_FeatureCharts, {
                        height: this.state.height - 50,
                        width: this.state.width,
                        feature: this.props.feature,
                        property: this.props.property,
                        timeSettings: this.props.timeSettings })
                ),
                external__react__default.a.createElement(style__default.a, {
                    styleId: '520489485',
                    css: ['.popup.jsx-520489485{background-color:white;color:#000;padding:15px;}', '.popup.fullscreen.jsx-520489485{overflow:hidden;padding:25px 0;position:relative;width:100%;}', '.popup-closer.jsx-520489485{-webkit-text-decoration:none;text-decoration:none;position:absolute;top:2px;right:8px;}', '.popup-closer.jsx-520489485:after{content:"\u2716";}', '.popup.fullscreen.jsx-520489485 .popup-closer.jsx-520489485{top:8px;right:8px;}']
                })
            );
        }
    }]);

    return FullscreenFeatureCharts;
}(external__react_["Component"]);

/* harmony default export */ var components_FullscreenFeatureCharts = (FullscreenFeatureCharts_FullscreenFeatureCharts);
// CONCATENATED MODULE: ./components/Map.js
var Map__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



function Map__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Map__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Map__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var ol_Map = void 0;
var ol_View = void 0;
var ol_layer_Tile = void 0;
var ol_layer_Vector = void 0;
var ol_source_Vector = void 0;
var ol_format_GeoJSON = void 0;
var ol_proj = void 0;
var ol_source_OSM = void 0;
var ol_style_Circle = void 0;
var ol_style_Fill = void 0;
var ol_style_Stroke = void 0;
var ol_style_Style = void 0;
var ol_interaction_Select = void 0;
var ol_Overlay = void 0;

var projection = void 0;

var configuration = {
    projection: 'EPSG:3857'
};

var getBaseLayer = function getBaseLayer() {
    var baseLayer = new ol_layer_Tile({
        source: new ol_source_OSM()
    });

    baseLayer.on('precompose', function (evt) {
        var ctx = evt.context;
        ctx.fillStyle = '#dddddd';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    });

    baseLayer.on('postcompose', function (evt) {
        var ctx = evt.context;
        evt.context.globalCompositeOperation = 'color';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        evt.fillStyle = '#000000';
        evt.context.globalCompositeOperation = 'source-over';
    });

    return baseLayer;
};

var getGeojsonLayer = function getGeojsonLayer(geojson) {
    var geojsonLayer = new ol_layer_Vector({
        source: new ol_source_Vector({
            projection: 'EPSG:4326'
        })
    });

    return geojsonLayer;
};

var Map_Map = function (_React$Component) {
    Map__inherits(Map, _React$Component);

    function Map(props) {
        Map__classCallCheck(this, Map);

        var _this = Map__possibleConstructorReturn(this, (Map.__proto__ || Object.getPrototypeOf(Map)).call(this, props));

        _this.state = {
            map: null,
            fullscreenFeatureCharts: false
        };
        return _this;
    }

    Map__createClass(Map, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            ol_Map = __webpack_require__(104).default;
            ol_View = __webpack_require__(83).default;
            ol_layer_Tile = __webpack_require__(105).default;
            ol_layer_Vector = __webpack_require__(88).default;
            ol_source_Vector = __webpack_require__(89).default;
            ol_format_GeoJSON = __webpack_require__(71).default;
            ol_proj = __webpack_require__(16).default;
            ol_source_OSM = __webpack_require__(106).default;
            ol_style_Circle = __webpack_require__(76).default;
            ol_style_Fill = __webpack_require__(66).default;
            ol_style_Stroke = __webpack_require__(57).default;
            ol_style_Style = __webpack_require__(39).default;
            ol_interaction_Select = __webpack_require__(107).default;
            ol_Overlay = __webpack_require__(108).default;

            projection = ol_proj.get(configuration.projection);

            var view = new ol_View({
                projection: projection,
                center: ol_proj.transform([16.62, 49.2], 'EPSG:4326', projection),
                zoom: 13
            });

            var baseLayer = getBaseLayer();

            this.geojsonLayer = getGeojsonLayer();

            var map = new ol_Map({
                target: this.mapElement,
                layers: [baseLayer, this.geojsonLayer],
                view: view
            });

            var overlay = this.createOverlay();
            map.addOverlay(overlay);

            var selectInteraction = new ol_interaction_Select({
                style: function (feature, resolution) {
                    var style = this.geojsonLayer.getStyle();
                    return style(feature, resolution);
                }.bind(this)
            });
            selectInteraction.on('select', function (evt) {
                var coordinate = evt.mapBrowserEvent.coordinate;

                var feature = evt.target.getFeatures().item(0);
                this.setState({
                    selectedFeature: feature
                });

                overlay.setPosition(feature && !this.props.isSmall ? coordinate : undefined);
                this._setOverlayVisible(!!feature);
            }.bind(this));
            map.addInteraction(selectInteraction);
            this._selectInteraction = selectInteraction;

            this.setState({
                map: map
            });
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            var popup = document.getElementById('popup');
            popup.removeEventListener('mouseenter', this._onOverlayMouseEnter.bind(this));
            popup.removeEventListener('mouseout', this._onOverlayMouseLeave.bind(this));
        }
    }, {
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (nextProps.isDataValid) {
                var view = this.state.map.getView();
                var resolution = view.getResolution();
                var featureCollection = nextProps.data.feature_collection;
                var options = {
                    topic: nextProps.topic,
                    properties: nextProps.properties,
                    primary_property: nextProps.primaryProperty.name_id,
                    features: featureCollection,
                    value_idx: nextProps.index,
                    resolution: resolution
                };
                var generalization = generalize(options);

                if (generalization && this.geojsonLayer) {
                    var isDataChange = this.props.data !== nextProps.data;
                    var isPropertyChange = this.props.primaryProperty !== nextProps.primaryProperty;
                    this._updateFeatures(generalization.features, isDataChange || isPropertyChange);

                    this.geojsonLayer.setStyle(generalization.style);
                }
            } else {
                this._clearFeatures();
            }
        }
    }, {
        key: 'updateMapSize',
        value: function updateMapSize() {
            var map = this.state.map;
            if (map) {
                map.updateSize();
            }
        }

        /************************* overlay ***********************************************************/

    }, {
        key: 'createOverlay',
        value: function createOverlay() {
            var popup = document.getElementById('popup');
            popup.style.display = 'none';
            popup.addEventListener('mouseenter', this._onOverlayMouseEnter.bind(this));
            popup.addEventListener('mouseleave', this._onOverlayMouseLeave.bind(this));

            var overlay = new ol_Overlay({
                id: 'featurePopup',
                element: popup,
                autoPan: true,
                autoPanAnimation: {
                    duration: 250
                },
                stopEvent: false
            });

            return overlay;
        }
    }, {
        key: '_closeOverlay',
        value: function _closeOverlay(event) {
            var map = this.state.map;
            if (map) {
                var overlay = map.getOverlayById('featurePopup');

                overlay.setPosition(undefined);

                this._setOverlayVisible(false);
                this._setMapInteractionsActive(true);
                this._selectInteraction.getFeatures().clear();
            }
            event.target.blur();
        }
    }, {
        key: '_onOverlayMouseEnter',
        value: function _onOverlayMouseEnter() {
            this._setMapInteractionsActive(false);
        }
    }, {
        key: '_onOverlayMouseLeave',
        value: function _onOverlayMouseLeave() {
            this._setMapInteractionsActive(true);
        }
    }, {
        key: '_setOverlayVisible',
        value: function _setOverlayVisible(visible) {
            var popup = document.getElementById('popup');
            popup.style.display = visible && !this.props.isSmall ? 'block' : 'none';

            this.setState({
                fullscreenFeatureCharts: visible && this.props.isSmall
            });
        }
        /************************* overlay ***********************************************************/

    }, {
        key: '_setMapInteractionsActive',
        value: function _setMapInteractionsActive(active) {
            var map = this.state.map;
            if (map) {
                // deactivating all interactions may cause problems
                map.getInteractions().forEach(function (interaction) {
                    interaction.setActive(active);
                });
            }
        }
    }, {
        key: '_handleResolutionChange',
        value: function _handleResolutionChange(event) {
            console.log(event);
        }
    }, {
        key: '_updateFeatures',
        value: function _updateFeatures(newFeatures, isDataChange) {
            var source = this.geojsonLayer.getSource();

            if (isDataChange) {
                source.clear();
                source.addFeatures(newFeatures);
            } else {
                var currentFeatures = source.getFeatures();
                var newIds = newFeatures.map(function (feature) {
                    return feature.get('id');
                });
                var matchingIds = [];
                currentFeatures.forEach(function (feature) {
                    var fid = feature.get('id');
                    if (!newIds.includes(fid)) {
                        source.removeFeature(feature);
                    } else {
                        matchingIds.push(fid);
                    }
                });

                var featuresToAdd = newFeatures.filter(function (feature) {
                    return !matchingIds.includes(feature.get('id'));
                });
                if (featuresToAdd.length) {
                    source.addFeatures(featuresToAdd);
                }
            }
        }
    }, {
        key: '_clearFeatures',
        value: function _clearFeatures() {
            var source = this.geojsonLayer.getSource();
            source.clear();
        }
    }, {
        key: 'render',
        value: function render() {
            var _this2 = this;

            var windowHeight = 286;
            var windowWidth = 500;

            if (typeof window !== 'undefined') {
                windowHeight = window.innerHeight;
                windowWidth = window.innerWidth;
            }

            return external__react__default.a.createElement(
                'div',
                {
                    className: 'jsx-2195996067' + ' ' + 'map-wrap'
                },
                external__react__default.a.createElement(components_FullscreenFeatureCharts, {
                    active: this.state.fullscreenFeatureCharts,
                    feature: this.state.selectedFeature,
                    property: this.props.primaryProperty,
                    timeSettings: Object.assign(this.props.currentValues, { timeZone: this.props.timeZone }),
                    onClose: this._closeOverlay.bind(this) }),
                external__react__default.a.createElement(
                    'div',
                    { id: 'popup', style: { display: 'none' }, className: 'jsx-2195996067' + ' ' + 'popup ol-popup'
                    },
                    external__react__default.a.createElement('a', { href: '#', onClick: this._closeOverlay.bind(this), className: 'jsx-2195996067' + ' ' + 'popup-closer'
                    }),
                    external__react__default.a.createElement(components_FeatureCharts, {
                        feature: this.state.selectedFeature,
                        property: this.props.primaryProperty,
                        timeSettings: Object.assign(this.props.currentValues, { timeZone: this.props.timeZone }) })
                ),
                external__react__default.a.createElement(
                    external__semantic_ui_react_["Dimmer"],
                    { active: this.props.loading, inverted: true },
                    external__react__default.a.createElement(
                        external__semantic_ui_react_["Loader"],
                        null,
                        'Loading data...'
                    )
                ),
                external__react__default.a.createElement(
                    'div',
                    { ref: function ref(d) {
                            return _this2.mapElement = d;
                        }, className: 'jsx-2195996067' + ' ' + 'map'
                    },
                    ' '
                ),
                !this.props.loading && !this.props.isDataValid && external__react__default.a.createElement(
                    'div',
                    {
                        className: 'jsx-2195996067' + ' ' + 'warning-wrap'
                    },
                    external__react__default.a.createElement(
                        'div',
                        {
                            className: 'jsx-2195996067'
                        },
                        'No data to display'
                    )
                ),
                external__react__default.a.createElement(style__default.a, {
                    styleId: '477076293',
                    css: ['.map-wrap.jsx-2195996067,.map.jsx-2195996067{height:100%;width:100%;}', '@media (max-width:600px){.map-wrap.jsx-2195996067{height:100%;}}', '.popup.jsx-2195996067{background-color:white;color:#000;padding:15px;}', '.ol-popup.jsx-2195996067{position:absolute;-webkit-filter:drop-shadow(0 1px 4px rgba(0,0,0,0.2));-webkit-filter:drop-shadow(0 1px 4px rgba(0,0,0,0.2));filter:drop-shadow(0 1px 4px rgba(0,0,0,0.2));border-radius:10px;border:1px solid #cccccc;bottom:12px;left:-50px;min-width:280px;}', '.ol-popup.jsx-2195996067:after,.ol-popup.jsx-2195996067:before{top:100%;border:solid transparent;content:" ";height:0;width:0;position:absolute;pointer-events:none;}', '.ol-popup.jsx-2195996067:after{border-top-color:white;border-width:10px;left:48px;margin-left:-10px;}', '.ol-popup.jsx-2195996067:before{border-top-color:#cccccc;border-width:11px;left:48px;margin-left:-11px;}', '.popup-closer.jsx-2195996067{-webkit-text-decoration:none;text-decoration:none;position:absolute;top:2px;right:8px;}', '.popup-closer.jsx-2195996067:after{content:"\u2716";}', '.warning-wrap.jsx-2195996067{background-color:rgba(255,255,255,0.8);border:solid 3px rgba(0,0,0,0.2);border-radius:10px;color:rgba(0,0,0,0.6);font-weight:bolder;text-transform:uppercase;padding:10px;text-align:center;height:46px;width:30%;position:absolute;top:0;bottom:0;left:0;right:0;margin:auto;}', '.warning-wrap.jsx-2195996067>*.jsx-2195996067{vertical-align:middle;}']
                }),
                external__react__default.a.createElement(style__default.a, {
                    styleId: '2267574383',
                    css: ['.map-wrap .ui.blue.buttons.zoom .button:focus{background-color:#2185d0;}']
                })
            );
        }
    }]);

    return Map;
}(external__react__default.a.Component);

/* harmony default export */ var components_Map = (Map_Map);
// EXTERNAL MODULE: external "lodash/range"
var range_ = __webpack_require__(109);
var range__default = /*#__PURE__*/__webpack_require__.n(range_);

// EXTERNAL MODULE: external "react-datepicker"
var external__react_datepicker_ = __webpack_require__(110);
var external__react_datepicker__default = /*#__PURE__*/__webpack_require__.n(external__react_datepicker_);

// CONCATENATED MODULE: ./components/DateRangeSelector.js
var DateRangeSelector__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



function DateRangeSelector__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function DateRangeSelector__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function DateRangeSelector__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var formStyle = {
    margin: '8px',
    maxWidth: '245px'
};

var presetButtonStyle = {
    display: 'block'
};

var years = range__default()(2010, external__moment__default()().year() + 1, 1);
var months = external__moment__default.a.months();

var DateRangeSelector_DateRangeSelector = function (_React$Component) {
    DateRangeSelector__inherits(DateRangeSelector, _React$Component);

    function DateRangeSelector(props) {
        DateRangeSelector__classCallCheck(this, DateRangeSelector);

        var _this = DateRangeSelector__possibleConstructorReturn(this, (DateRangeSelector.__proto__ || Object.getPrototypeOf(DateRangeSelector)).call(this, props));

        _this.state = {
            fromDate: props.from,
            toDate: props.to,
            _nextDisabled: false
        };

        _this.handleFromChange = _this.handleFromChange.bind(_this);
        _this.handleToChange = _this.handleToChange.bind(_this);
        return _this;
    }

    DateRangeSelector__createClass(DateRangeSelector, [{
        key: 'handleFromChange',
        value: function handleFromChange(date) {
            date.utcOffset(this.props.timeZone);

            console.log('DateRangeSelector handleFromChange - fromDate): ', date.clone().unix());
            this.setState({
                fromDate: date
            });

            var to = this.state.toDate;
            if (this.props.callback && this._isRangeValid(date, to)) {
                this.props.callback(date, this.state.toDate);
            }

            if (!this._isRangeValid(date, to)) {
                this._notifyRangeFix();
                this.setState({
                    toDate: date
                });

                if (this.props.callback) {
                    this.props.callback(date, date);
                }
            }
        }
    }, {
        key: 'handleToChange',
        value: function handleToChange(date) {
            date.utcOffset(this.props.timeZone);

            this.setState({
                toDate: date
            });

            if (this.props.callback) {
                this.props.callback(this.state.fromDate, date);
            }
        }
    }, {
        key: '_isRangeValid',
        value: function _isRangeValid(from, to) {
            return from.isSameOrBefore(to);
        }
    }, {
        key: '_notifyRangeFix',
        value: function _notifyRangeFix() {
            console.log('To date can\'t be before from date.');
            this.props.notifyUser({
                text: '\'To date\' can\'t be before \'from date\'.',
                color: 'orange'
            });
        }

        /****************************** preset options *************************************/

    }, {
        key: '_getShiftedRange',
        value: function _getShiftedRange(state, shiftFn) {
            var diff = void 0;
            var from = void 0;
            var to = void 0;
            var fromMonthStart = state.fromDate.clone().startOf('month');
            var toMonthEnd = state.fromDate.clone().startOf('day').endOf('month');

            if (this._isSameDate(state.fromDate, fromMonthStart) && this._isSameDate(state.toDate, toMonthEnd)) {
                diff = state.toDate.diff(state.fromDate, 'month') + 1;
                from = shiftFn.call(state.fromDate, diff, 'month').startOf('month');
                to = shiftFn.call(state.toDate, diff, 'month').endOf('month');
                if (external__moment__default()().isBefore(to)) {
                    to = external__moment__default()();
                }
            } else {
                diff = state.toDate.diff(state.fromDate, 'days') + 1;
                from = shiftFn.call(state.fromDate, diff, 'days');
                to = shiftFn.call(state.toDate, diff, 'days');
            }
            return {
                from: from,
                to: to
            };
        }
    }, {
        key: '_setPrevious',
        value: function _setPrevious() {
            var _this2 = this;

            this.setState(function (prevState, props) {
                var _getShiftedRange2 = _this2._getShiftedRange(prevState, external__moment__default.a.prototype.subtract),
                    from = _getShiftedRange2.from,
                    to = _getShiftedRange2.to;

                if (_this2.props.callback) {
                    _this2.props.callback(from, to);
                }

                return {
                    fromDate: from,
                    toDate: to
                };
            });
        }
    }, {
        key: '_setNext',
        value: function _setNext() {
            var _this3 = this;

            this.setState(function (prevState, props) {
                var _getShiftedRange3 = _this3._getShiftedRange(prevState, external__moment__default.a.prototype.add),
                    from = _getShiftedRange3.from,
                    to = _getShiftedRange3.to;

                var nextDisabled = false;
                if (external__moment__default()().isBefore(to)) {
                    to = external__moment__default()();
                    nextDisabled = true;
                }

                if (_this3.props.callback) {
                    _this3.props.callback(from, to);
                }

                return {
                    fromDate: from,
                    toDate: to,
                    _nextDisabled: nextDisabled
                };
            });
        }
    }, {
        key: '_setThisWeek',
        value: function _setThisWeek() {
            var today = external__moment__default()();
            var from = today.clone().startOf('week');
            var to = today;

            if (this.props.callback) {
                this.props.callback(from, to);
            }

            this.setState({
                fromDate: from,
                toDate: today,
                _nextDisabled: true
            });
        }
    }, {
        key: '_setLastWeek',
        value: function _setLastWeek() {
            var today = external__moment__default()();
            var from = today.clone().startOf('week').subtract(1, 'week');
            var to = today.clone().endOf('week').subtract(1, 'week');

            if (this.props.callback) {
                this.props.callback(from, to);
            }

            this.setState({
                fromDate: from,
                toDate: to,
                _nextDisabled: false
            });
        }
    }, {
        key: '_setThisMonth',
        value: function _setThisMonth() {
            var today = external__moment__default()();
            var from = today.clone().startOf('month');
            var to = today;

            if (this.props.callback) {
                this.props.callback(from, to);
            }

            this.setState({
                fromDate: from,
                toDate: today,
                _nextDisabled: true
            });
        }
    }, {
        key: '_setLastMonth',
        value: function _setLastMonth() {
            var today = external__moment__default()();
            var from = today.clone().startOf('month').subtract(1, 'month');
            var to = today.clone().endOf('month').subtract(1, 'month');

            if (this.props.callback) {
                this.props.callback(from, to);
            }

            this.setState({
                fromDate: from,
                toDate: to,
                _nextDisabled: false
            });
        }
        /****************************** preset options *************************************/

    }, {
        key: '_isSameDate',
        value: function _isSameDate(value, currentValue) {
            return value.isSame(currentValue, 'day');
        }
    }, {
        key: '_getCurrentValueString',
        value: function _getCurrentValueString(value, currentValue) {
            var result = void 0;
            if (currentValue && !value.isSame(currentValue, 'second')) {
                if (this._isSameDate(value, currentValue)) {
                    result = currentValue.format('LT');
                } else {
                    result = currentValue.format('L LT');
                }
            }

            return result;
        }
    }, {
        key: '_renderCalendarHeader',
        value: function _renderCalendarHeader(_ref) {
            var date = _ref.date,
                changeYear = _ref.changeYear,
                changeMonth = _ref.changeMonth,
                decreaseMonth = _ref.decreaseMonth,
                increaseMonth = _ref.increaseMonth,
                prevMonthButtonDisabled = _ref.prevMonthButtonDisabled,
                nextMonthButtonDisabled = _ref.nextMonthButtonDisabled;

            var prevMonthButtonClick = function prevMonthButtonClick(event) {
                decreaseMonth(event);
                event.target.blur();
            };

            var nextMonthButtonClick = function nextMonthButtonClick(event) {
                increaseMonth(event);
                event.target.blur();
            };

            var onMonthChange = function onMonthChange(_ref2) {
                var target = _ref2.target;

                var value = target.value;
                changeMonth(value);
                target.blur();
            };

            var onYearChange = function onYearChange(_ref3) {
                var target = _ref3.target;

                var value = target.value;
                changeYear(value);
                target.blur();
            };

            return external__react__default.a.createElement(
                'div',
                {
                    style: {
                        margin: '0 12px',
                        display: 'flex',
                        justifyContent: 'center'
                    }
                },
                external__react__default.a.createElement('button', {
                    className: 'react-datepicker__navigation react-datepicker__navigation--previous',
                    onClick: prevMonthButtonClick,
                    disabled: prevMonthButtonDisabled,
                    style: {
                        top: '14px'
                    } }),
                external__react__default.a.createElement(
                    'select',
                    {
                        value: months[date.month()],
                        onChange: onMonthChange,
                        style: {
                            fontWeight: 'bold',
                            width: '92px',
                            padding: '.5em .5em'
                        } },
                    months.map(function (option) {
                        return external__react__default.a.createElement(
                            'option',
                            { key: option, value: option },
                            option
                        );
                    })
                ),
                external__react__default.a.createElement(
                    'select',
                    {
                        value: date.year(),
                        onChange: onYearChange,
                        style: {
                            fontWeight: 'bold',
                            width: '60px',
                            padding: '.5em .5em'
                        } },
                    years.map(function (option) {
                        return external__react__default.a.createElement(
                            'option',
                            { key: option, value: option },
                            option
                        );
                    })
                ),
                external__react__default.a.createElement('button', {
                    className: 'react-datepicker__navigation react-datepicker__navigation--next',
                    onClick: nextMonthButtonClick,
                    disabled: nextMonthButtonDisabled,
                    style: {
                        top: '14px'
                    } })
            );
        }
    }, {
        key: 'render',
        value: function render() {
            var from = this._getCurrentValueString(this.state.fromDate, this.props.currentValues.from);

            var to = void 0;
            if (this.props.currentValues.to) {
                var lastPossibleMeasurement = this.state.toDate.clone().add(1, 'days').subtract(this.props.currentValues.frequency, 'seconds');
                var lastMeasurement = this.props.currentValues.to.clone().subtract(this.props.currentValues.frequency, 'seconds');
                to = this._getCurrentValueString(lastPossibleMeasurement, lastMeasurement);
            }

            return external__react__default.a.createElement(
                'div',
                { style: { position: "relative" }, className: 'jsx-1341475301' + ' ' + 'main'
                },
                external__react__default.a.createElement(
                    external__semantic_ui_react_["Divider"],
                    { horizontal: true, inverted: true, style: { marginTop: '18px' } },
                    'Select date'
                ),
                external__react__default.a.createElement(
                    external__semantic_ui_react_["Form"],
                    { className: 'date-picker-wrapper column left' },
                    external__react__default.a.createElement(
                        external__semantic_ui_react_["Form"].Field,
                        { className: 'date-picker-field from' },
                        external__react__default.a.createElement(
                            'div',
                            {
                                className: 'jsx-1341475301' + ' ' + 'date-picker-input-labels-wrapper'
                            },
                            external__react__default.a.createElement(
                                external__semantic_ui_react_["Label"],
                                { size: 'small', style: { marginTop: '2px' } },
                                'From date'
                            ),
                            from && external__react__default.a.createElement(
                                external__semantic_ui_react_["Label"],
                                { basic: true, color: 'red', pointing: 'left', size: 'small' },
                                from
                            )
                        ),
                        external__react__default.a.createElement(
                            'div',
                            {
                                className: 'jsx-1341475301' + ' ' + 'date-picker-input-wrapper'
                            },
                            external__react__default.a.createElement(external__react_datepicker__default.a, {
                                selectsStart: true,
                                selected: this.state.fromDate,
                                startDate: this.state.fromDate,
                                endDate: this.state.toDate,
                                maxDate: external__moment__default()(),
                                renderCustomHeader: this._renderCalendarHeader,
                                previousMonthButtonLabel: '',
                                nextMonthButtonLabel: '',
                                style: { width: '105px' },
                                onChange: this.handleFromChange })
                        )
                    ),
                    external__react__default.a.createElement(
                        external__semantic_ui_react_["Form"].Field,
                        { className: 'date-picker-field to' },
                        external__react__default.a.createElement(
                            'div',
                            {
                                className: 'jsx-1341475301' + ' ' + 'date-picker-input-labels-wrapper'
                            },
                            external__react__default.a.createElement(
                                external__semantic_ui_react_["Label"],
                                { size: 'small', style: { marginTop: '2px' } },
                                'To date'
                            ),
                            to && external__react__default.a.createElement(
                                external__semantic_ui_react_["Label"],
                                { basic: true, color: 'red', pointing: 'left', size: 'small' },
                                to
                            )
                        ),
                        external__react__default.a.createElement(
                            'div',
                            {
                                className: 'jsx-1341475301' + ' ' + 'date-picker-input-wrapper'
                            },
                            external__react__default.a.createElement(external__react_datepicker__default.a, {
                                selectsEnd: true,
                                selected: this.state.toDate,
                                startDate: this.state.fromDate,
                                endDate: this.state.toDate,
                                minDate: this.state.fromDate,
                                maxDate: external__moment__default()(),
                                renderCustomHeader: this._renderCalendarHeader,
                                previousMonthButtonLabel: '',
                                nextMonthButtonLabel: '',
                                style: { width: '105px' },
                                onChange: this.handleToChange })
                        )
                    )
                ),
                external__react__default.a.createElement(
                    'div',
                    {
                        className: 'jsx-1341475301' + ' ' + 'column right'
                    },
                    external__react__default.a.createElement(
                        external__semantic_ui_react_["Button"].Group,
                        null,
                        external__react__default.a.createElement(
                            external__semantic_ui_react_["Button"],
                            {
                                inverted: true,
                                icon: true,
                                color: 'blue',
                                onClick: this._setPrevious.bind(this) },
                            external__react__default.a.createElement(external__semantic_ui_react_["Icon"], { name: 'caret left' })
                        ),
                        external__react__default.a.createElement(
                            external__semantic_ui_react_["Button"],
                            {
                                inverted: true,
                                icon: true,
                                color: 'blue',
                                disabled: this.state._nextDisabled,
                                onClick: this._setNext.bind(this) },
                            external__react__default.a.createElement(external__semantic_ui_react_["Icon"], { name: 'caret right' })
                        )
                    )
                ),
                external__react__default.a.createElement(
                    external__semantic_ui_react_["Form"],
                    { style: formStyle },
                    external__react__default.a.createElement(
                        'div',
                        {
                            className: 'jsx-1341475301' + ' ' + 'button-wrapper'
                        },
                        external__react__default.a.createElement(
                            external__semantic_ui_react_["Button"],
                            {
                                className: 'preset-button',
                                inverted: true,
                                size: 'mini',
                                color: 'blue',
                                onClick: this._setThisWeek.bind(this),
                                style: presetButtonStyle },
                            'This Week'
                        ),
                        external__react__default.a.createElement(
                            external__semantic_ui_react_["Button"],
                            {
                                className: 'preset-button',
                                inverted: true,
                                size: 'mini',
                                color: 'blue',
                                onClick: this._setLastWeek.bind(this),
                                style: presetButtonStyle },
                            'Last Week'
                        )
                    ),
                    external__react__default.a.createElement(
                        'div',
                        {
                            className: 'jsx-1341475301' + ' ' + 'button-wrapper'
                        },
                        external__react__default.a.createElement(
                            external__semantic_ui_react_["Button"],
                            {
                                className: 'preset-button',
                                inverted: true,
                                size: 'mini',
                                color: 'blue',
                                onClick: this._setThisMonth.bind(this),
                                style: presetButtonStyle },
                            'This Month'
                        ),
                        external__react__default.a.createElement(
                            external__semantic_ui_react_["Button"],
                            {
                                inverted: true,
                                size: 'mini',
                                color: 'blue',
                                onClick: this._setLastMonth.bind(this),
                                style: presetButtonStyle },
                            'Last Month'
                        )
                    )
                ),
                external__react__default.a.createElement(external__semantic_ui_react_["Divider"], { horizontal: true, inverted: true, style: { marginTop: '8px' } }),
                external__react__default.a.createElement(style__default.a, {
                    styleId: '1341475301',
                    css: ['.button-wrapper.jsx-1341475301{display:inline-block;}']
                })
            );
        }
    }]);

    return DateRangeSelector;
}(external__react__default.a.Component);

;

/* harmony default export */ var components_DateRangeSelector = (DateRangeSelector_DateRangeSelector);
// CONCATENATED MODULE: ./components/TimeSlider.js
var TimeSlider__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



function TimeSlider__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function TimeSlider__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function TimeSlider__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





var TimeSlider_TimeSlider = function (_React$Component) {
    TimeSlider__inherits(TimeSlider, _React$Component);

    function TimeSlider(props) {
        TimeSlider__classCallCheck(this, TimeSlider);

        var _this = TimeSlider__possibleConstructorReturn(this, (TimeSlider.__proto__ || Object.getPrototypeOf(TimeSlider)).call(this, props));

        console.log('TimeSlider constructor - props.from: ', props.from);
        _this.state = {
            value: props.from || 0,
            isPlaying: false
        };

        _this.onChange = _this.onChange.bind(_this);

        _this.togglePlay = _this.togglePlay.bind(_this);
        _this.stopButtonClick = _this.stopButtonClick.bind(_this);

        _this.moveStepBack = _this.moveStepBack.bind(_this);
        _this.moveStepForward = _this.moveStepForward.bind(_this);

        _this.setValueToMin = _this.setValueToMin.bind(_this);
        _this.setValueToMax = _this.setValueToMax.bind(_this);
        return _this;
    }

    TimeSlider__createClass(TimeSlider, [{
        key: 'componentWillReceiveProps',
        value: function componentWillReceiveProps(nextProps) {
            if (nextProps.from !== this.props.from || nextProps.to !== this.props.to) {
                console.log('TimeSlider componentWillReceiveProps - from: ', nextProps.from);
                this.setState({
                    value: nextProps.from || 0
                });
            }
        }
    }, {
        key: 'onChange',
        value: function onChange(event) {
            var time = parseInt(event.target.value);
            this.setState({
                value: time
            });

            if (this.props.callback) {
                var timeDate = external__moment__default.a.unix(time).utcOffset(this.props.timeZone);
                this.props.callback(timeDate);
            }
        }
    }, {
        key: 'togglePlay',
        value: function togglePlay() {
            var _this2 = this;

            if (this.timerId) {
                this._clearTimer();
            } else {
                this.timerId = setInterval(function () {
                    return _this2.moveStepForward();
                }, 1000);
            }

            this.setState(function (prevState, props) {
                return {
                    isPlaying: !prevState.isPlaying
                };
            });
        }
    }, {
        key: 'stopButtonClick',
        value: function stopButtonClick() {
            if (this.timerId) {
                this._clearTimer();
            }

            if (this.props.callback) {
                var timeDate = external__moment__default.a.unix(this.props.from).utcOffset(this.props.timeZone);
                this.props.callback(timeDate);
            }

            this.setState({
                isPlaying: false,
                value: this.props.from
            });
        }
    }, {
        key: '_clearTimer',
        value: function _clearTimer() {
            clearInterval(this.timerId);
            this.timerId = null;
        }
    }, {
        key: 'moveStepBack',
        value: function moveStepBack() {
            var _this3 = this;

            this.setState(function (prevState, props) {
                var time = parseInt(prevState.value);
                var step = parseInt(props.frequency || 1);
                var newValue = time - step;

                if (newValue < props.from) {
                    newValue = props.from;
                }

                if (time !== newValue) {
                    if (props.callback) {
                        var timeDate = external__moment__default.a.unix(newValue).utcOffset(_this3.props.timeZone);
                        props.callback(timeDate);
                    }
                }

                return {
                    value: newValue
                };
            });
        }
    }, {
        key: 'moveStepForward',
        value: function moveStepForward() {
            var _this4 = this;

            this.setState(function (prevState, props) {
                var time = parseInt(prevState.value);
                var step = parseInt(props.frequency || 1);
                var newValue = time + step;

                if (newValue > props.to) {
                    newValue = props.to;
                }

                var stopPlaying = void 0;
                if (_this4.timerId && newValue === props.to) {
                    _this4._clearTimer();
                    stopPlaying = true;
                }

                if (time !== newValue) {
                    if (props.callback) {
                        var timeDate = external__moment__default.a.unix(newValue).utcOffset(_this4.props.timeZone);
                        props.callback(timeDate);
                    }
                }

                return {
                    isPlaying: stopPlaying ? false : prevState.isPlaying,
                    value: newValue
                };
            });
        }
    }, {
        key: 'setValueToMin',
        value: function setValueToMin() {
            if (this.props.callback) {
                var timeDate = external__moment__default.a.unix(this.props.from).utcOffset(this.props.timeZone);
                this.props.callback(timeDate);
            }

            this.setState({
                value: this.props.from
            });
        }
    }, {
        key: 'setValueToMax',
        value: function setValueToMax() {
            if (this.props.callback) {
                var timeDate = external__moment__default.a.unix(this.props.to).utcOffset(this.props.timeZone);
                this.props.callback(timeDate);
            }

            this.setState({
                value: this.props.to
            });
        }
    }, {
        key: '_isMin',
        value: function _isMin() {
            return this.state.value === this.props.from;
        }
    }, {
        key: '_isMax',
        value: function _isMax() {
            return this.state.value === this.props.to;
        }
    }, {
        key: 'render',
        value: function render() {
            var isPlaying = this.state.isPlaying;

            var playPauseIcon = isPlaying ? 'pause' : 'play';

            var _props = this.props,
                from = _props.from,
                to = _props.to,
                interval = _props.interval;

            console.log('TimeSlider render - from: ', from);

            var thumbWidth = interval && from && to ? interval / (to - from) * 100 : null;
            if (!thumbWidth) {
                thumbWidth = '14px';
            } else {
                if (thumbWidth < 1) {
                    thumbWidth = 1;
                }
                thumbWidth += '%';
            }

            return external__react__default.a.createElement(
                'div',
                {
                    className: 'jsx-3533235142' + ' ' + 'timeSlider'
                },
                this.props.from && this.props.to && external__react__default.a.createElement(
                    'div',
                    {
                        className: 'jsx-3533235142'
                    },
                    external__react__default.a.createElement(
                        'div',
                        {
                            className: 'jsx-3533235142' + ' ' + 'currentValue'
                        },
                        external__moment__default.a.unix(this.state.value).utcOffset(this.props.timeZone).format('L LT Z')
                    ),
                    external__react__default.a.createElement(
                        'div',
                        {
                            className: 'jsx-3533235142' + ' ' + 'currentValue'
                        },
                        'from: ' + this.props.from
                    )
                ),
                external__react__default.a.createElement(
                    'div',
                    {
                        className: 'jsx-3533235142' + ' ' + 'sliderContainer'
                    },
                    external__react__default.a.createElement('input', { type: 'range',

                        min: this.props.from || 0,
                        max: this.props.to || 100,
                        step: this.props.frequency,
                        value: this.state.value,
                        disabled: this.props.disabled,
                        onChange: this.onChange,
                        style: { '--slider-thumb-width': thumbWidth }, className: 'jsx-3533235142' + ' ' + 'slider'
                    })
                ),
                external__react__default.a.createElement(
                    'div',
                    {
                        className: 'jsx-3533235142' + ' ' + 'controlButtons'
                    },
                    external__react__default.a.createElement(external__semantic_ui_react_["Button"], { icon: playPauseIcon,
                        color: 'teal',
                        circular: true,
                        inverted: true,
                        onClick: this.togglePlay,
                        disabled: this.props.disabled || this._isMax() }),
                    external__react__default.a.createElement(external__semantic_ui_react_["Button"], { icon: 'fast backward',
                        color: 'teal',
                        circular: true,
                        inverted: true,
                        onClick: this.setValueToMin,
                        disabled: this.props.disabled || this._isMin() }),
                    external__react__default.a.createElement(external__semantic_ui_react_["Button"], { icon: 'step backward',
                        color: 'teal',
                        circular: true,
                        inverted: true,
                        onClick: this.moveStepBack,
                        disabled: this.props.disabled || this._isMin() }),
                    external__react__default.a.createElement(external__semantic_ui_react_["Button"], { icon: 'step forward',
                        color: 'teal',
                        circular: true,
                        inverted: true,
                        onClick: this.moveStepForward,
                        disabled: this.props.disabled || this._isMax() }),
                    external__react__default.a.createElement(external__semantic_ui_react_["Button"], { icon: 'fast forward',
                        color: 'teal',
                        circular: true,
                        inverted: true,
                        onClick: this.setValueToMax,
                        disabled: this.props.disabled || this._isMax() }),
                    external__react__default.a.createElement(external__semantic_ui_react_["Button"], { icon: 'stop',
                        color: 'teal',
                        circular: true,
                        inverted: true,
                        onClick: this.stopButtonClick,
                        disabled: this.props.disabled || !this.state.isPlaying })
                ),
                external__react__default.a.createElement(style__default.a, {
                    styleId: '3533235142',
                    css: ['.timeSlider.jsx-3533235142{padding:8px 0;}', '.currentValue.jsx-3533235142{color:#54ffff;text-align:right;}', '.sliderContainer.jsx-3533235142{margin:8px 0 8px;}', '.slider.jsx-3533235142{-webkit-appearance:none;width:100%;height:8px;border-radius:5px;background:#ddd;outline:none;-webkit-transition:.2s;-webkit-transition:opacity .2s;transition:opacity .2s;}', '.slider.jsx-3533235142::-webkit-slider-thumb{-webkit-appearance:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;height:14px;width:var(--slider-thumb-width,14px);border-radius:50%;background:#54ffff;cursor:pointer;}', '.slider.jsx-3533235142::-moz-range-thumb{height:14px;width:var(--slider-thumb-width,14px);border-radius:50%;background:#4CAF50;cursor:pointer;}', '.controlButtons.jsx-3533235142{text-align:center;}']
                })
            );
        }
    }]);

    return TimeSlider;
}(external__react__default.a.Component);

/* harmony default export */ var components_TimeSlider = (TimeSlider_TimeSlider);
// CONCATENATED MODULE: ./components/TimeControl.js
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var TimeControl__createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function TimeControl__classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function TimeControl__possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : _typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function TimeControl__inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : _typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}






var controlPartStyle = {
    marginTop: '16px'
};

var TimeControl_TimeControl = function (_React$Component) {
    TimeControl__inherits(TimeControl, _React$Component);

    function TimeControl(props) {
        TimeControl__classCallCheck(this, TimeControl);

        var _this = TimeControl__possibleConstructorReturn(this, (TimeControl.__proto__ || Object.getPrototypeOf(TimeControl)).call(this, props));

        if (props.dateRange.from) {
            console.log('TimeControl constructor - dateRange.from: ', props.dateRange.from.unix());
        }

        _this.state = {
            from: props.dateRange ? props.dateRange.from : null,
            to: props.dateRange ? props.dateRange.to : null
        };

        _this.handleDateRangeChange = _this.handleDateRangeChange.bind(_this);
        return _this;
    }

    TimeControl__createClass(TimeControl, [{
        key: 'handleDateRangeChange',
        value: function handleDateRangeChange(from, to) {
            console.log('TimeControl handleDateRangeChange - from: ', from.clone().unix());
            if (this.props.handleDateRangeChange) {
                this.props.handleDateRangeChange(from, to);
            }

            this.setState({
                from: from,
                to: to
            });
        }
    }, {
        key: 'render',
        value: function render() {
            var currentTo = this.props.currentValues.to ? this.props.currentValues.to.clone().subtract(this.props.currentValues.frequency, 'seconds').unix() : null;

            if (this.props.currentValues.from) {
                console.log('TimeControl render - currentValues.from: ', this.props.currentValues.from.unix());
            }

            return external__react__default.a.createElement('div', null, external__react__default.a.createElement('div', { style: controlPartStyle }, external__react__default.a.createElement(components_TimeSlider, {
                from: this.props.currentValues.from ? this.props.currentValues.from.unix() : null,
                to: currentTo,
                interval: this.props.valueDuration,
                timeZone: this.props.timeZone,
                frequency: this.props.currentValues.frequency,
                disabled: this.props.currentValues.from == null || this.props.currentValues.to == null,
                callback: this.props.handleTimeValueChange })), external__react__default.a.createElement('div', { style: controlPartStyle }, external__react__default.a.createElement(components_DateRangeSelector, {
                from: this.state.from,
                to: this.state.to,
                timeZone: this.props.timeZone,
                currentValues: this.props.currentValues,
                callback: this.handleDateRangeChange,
                notifyUser: this.props.notifyUser,
                style: controlPartStyle })));
        }
    }]);

    return TimeControl;
}(external__react__default.a.Component);

;

/* harmony default export */ var components_TimeControl = (TimeControl_TimeControl);
// CONCATENATED MODULE: ./components/MapControls.js
var MapControls__typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var MapControls__createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function MapControls__classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function MapControls__possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && ((typeof call === "undefined" ? "undefined" : MapControls__typeof(call)) === "object" || typeof call === "function") ? call : self;
}

function MapControls__inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : MapControls__typeof(superClass)));
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}





/************************ styles ***************************************/
var partStyle = {
    margin: '8px 0'
};
/************************ styles ***************************************/

var processProperty = function processProperty(property) {
    return {
        value: property.name_id,
        text: property.name,
        description: property.unit
    };
};

var MapControls_MapControls = function (_React$Component) {
    MapControls__inherits(MapControls, _React$Component);

    function MapControls(props) {
        MapControls__classCallCheck(this, MapControls);

        return MapControls__possibleConstructorReturn(this, (MapControls.__proto__ || Object.getPrototypeOf(MapControls)).call(this, props));
    }

    MapControls__createClass(MapControls, [{
        key: 'render',
        value: function render() {
            return external__react__default.a.createElement('div', null, external__react__default.a.createElement(external__semantic_ui_react_["Dropdown"], {
                placeholder: 'Property',
                fluid: true,
                onChange: this.props.onPropertyChange,
                search: true,
                selection: true,
                options: this.props.properties.map(processProperty),
                value: this.props.selection.primaryPropertyId,
                style: partStyle }), external__react__default.a.createElement(components_TimeControl, {
                dateRange: { from: this.props.selection.from, to: this.props.selection.to },
                currentValues: this.props.currentValues,
                timeZone: this.props.timeZone,
                handleDateRangeChange: this.props.onDateRangeChange,
                handleTimeValueChange: this.props.onTimeValueChange,
                notifyUser: this.props.notifyUser,
                style: partStyle }));
        }
    }]);

    return MapControls;
}(external__react__default.a.Component);

;

/* harmony default export */ var components_MapControls = (MapControls_MapControls);
// CONCATENATED MODULE: ./components/NotificationPopup.js
var NotificationPopup__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function NotificationPopup__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function NotificationPopup__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function NotificationPopup__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }



var NotificationPopup_NotificationPopup = function (_React$Component) {
    NotificationPopup__inherits(NotificationPopup, _React$Component);

    function NotificationPopup() {
        NotificationPopup__classCallCheck(this, NotificationPopup);

        return NotificationPopup__possibleConstructorReturn(this, (NotificationPopup.__proto__ || Object.getPrototypeOf(NotificationPopup)).apply(this, arguments));
    }

    NotificationPopup__createClass(NotificationPopup, [{
        key: '_getBaseStyle',
        value: function _getBaseStyle(color) {
            return {
                backgroundColor: color || 'red',
                borderRadius: '4px',
                color: 'white',
                display: 'none',
                fontWeight: 'bold',
                lineHeight: '24px',
                position: 'absolute',
                padding: '8px',
                left: '10px',
                transition: 'bottom 10s ease 0s, height 10s ease-out 0s',
                zIndex: 1
            };
        }
    }, {
        key: '_getStyle',
        value: function _getStyle(open, color) {
            var style = this._getBaseStyle(color);

            if (open) {
                style.display = 'block';
                style.bottom = '10px';
                style.height = '40px';
            } else {
                style.bottom = 0;
                style.height = 0;
                style.display = 'none';
            }
            return style;
        }
    }, {
        key: 'render',
        value: function render() {
            return external__react__default.a.createElement(
                'div',
                { style: this._getStyle(this.props.open, this.props.color) },
                external__react__default.a.createElement(
                    'span',
                    null,
                    this.props.message
                )
            );
        }
    }]);

    return NotificationPopup;
}(external__react__default.a.Component);

;

/* harmony default export */ var components_NotificationPopup = (NotificationPopup_NotificationPopup);
// CONCATENATED MODULE: ./components/MapApp.js
var MapApp__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();



function MapApp__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function MapApp__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function MapApp__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }









/************************ styles ***************************************/
var narrowWidth = 700;

var sidebarContentStyle = {
    background: '#000',
    height: '100%',
    overflow: 'auto',
    padding: '16px'
};

var pusherStyle = {
    height: '100%',
    position: 'relative',
    width: '100%'
};

var sidebarToggleStyle = {
    background: '#000',
    color: '#fff',
    position: 'absolute',
    zIndex: 1
};

var getSidebarToggleStyle = function getSidebarToggleStyle(direction, visible) {
    var style = Object.assign({}, sidebarToggleStyle);

    if (direction === 'right') {
        Object.assign(style, {
            right: 0,
            top: '50%'
        });
    } else if (direction === 'bottom') {
        Object.assign(style, {
            bottom: 0,
            left: '50%'
        });
    }
    return style;
};

var getSidebarToggleIcon = function getSidebarToggleIcon(direction, visible) {
    if (direction === 'right') {
        return visible ? 'angle double right' : 'angle double left';
    } else if (direction === 'bottom') {
        return visible ? 'angle double down' : 'angle double up';
    }
};
/************************ styles ***************************************/

var defaultTopic_ = 'drought';

var propertiesRequestPath = '/api/v2/properties/';
var timeSeriesRequestPath = '/api/v2/timeseries/';

var MapApp_timeZone = '+01:00';

var MapApp_MapApp = function (_React$Component) {
    MapApp__inherits(MapApp, _React$Component);

    function MapApp(props) {
        MapApp__classCallCheck(this, MapApp);

        var _this = MapApp__possibleConstructorReturn(this, (MapApp.__proto__ || Object.getPrototypeOf(MapApp)).call(this, props));

        var now = external__moment__default()().utcOffset(MapApp_timeZone);

        var from = now.clone().startOf('day').subtract(1, 'months');
        var to = now.clone().startOf('day').subtract(1, 'days');

        _this.state = {
            isSmall: false,
            topic: props.topic || defaultTopic_,
            properties: [],
            selection: {
                primaryPropertyId: null,
                from: from,
                to: to,
                timeValueIndex: 0,
                bbox: null
            },
            currentValues: {
                from: from,
                to: to,
                frequency: 3600
            },
            geojsonData: null,
            loading: false,
            sidebarVisible: props.sidebarVisible,
            sidebarDirection: 'right',
            popupOpen: false,
            popupMessage: null
        };

        _this.handlePropertyChange = _this.handlePropertyChange.bind(_this);
        _this.handleDateRangeChange = _this.handleDateRangeChange.bind(_this);
        _this.handleTimeValueChange = _this.handleTimeValueChange.bind(_this);

        _this.notifyUser = _this.notifyUser.bind(_this);

        _this.handleSidebarToggleClick = _this.handleSidebarToggleClick.bind(_this);

        _this.mapRef = external__react__default.a.createRef();
        return _this;
    }

    MapApp__createClass(MapApp, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            var _this2 = this;

            external__moment__default.a.locale('en-gb');

            var propertiesRequestUrl = propertiesRequestPath + '?topic=' + this.state.topic + '&format=json';
            fetch(propertiesRequestUrl).then(function (results) {
                return results.json();
            }).then(function (data) {
                var primaryPropertyId = data.length ? data[0].name_id : null;

                _this2.setState(function (prevState, props) {
                    var selection = prevState.selection;
                    selection.primaryPropertyId = primaryPropertyId;

                    _this2.handleAppStateChange({
                        from: selection.from,
                        to: selection.to,
                        properties: data
                    });

                    return {
                        loading: true,
                        properties: data,
                        selection: selection
                    };
                });
            });

            this.resizeApp();
            window.addEventListener('resize', this.resizeApp.bind(this));
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            window.removeEventListener('resize', this.resizeApp.bind(this));
        }

        /**************************** sidebar handlers *********************************/

    }, {
        key: 'updateSidebarDirection',
        value: function updateSidebarDirection() {
            var _this3 = this;

            var direction = void 0;

            if (window.innerWidth <= narrowWidth) {
                direction = 'bottom';
            } else {
                direction = 'right';
            }

            this.setState({
                sidebarDirection: direction
            });

            setTimeout(function () {
                _this3.mapRef.current.updateMapSize();
            }, 100);
        }
    }, {
        key: 'handleSidebarToggleClick',
        value: function handleSidebarToggleClick() {
            var _this4 = this;

            this.setState({
                sidebarVisible: !this.state.sidebarVisible
            });

            setTimeout(function () {
                _this4.mapRef.current.updateMapSize();
            }, 100);
        }
    }, {
        key: 'getSidebarClass',
        value: function getSidebarClass() {
            var classes = '';

            if (this.state.sidebarVisible) {
                classes += 'sidebar-visible';
            } else {
                classes += 'sidebar-hidden';
            }

            classes += ' ' + this.state.sidebarDirection;
            return classes;
        }
        /**************************** sidebar handlers *********************************/

        /******************************** app handlers *********************************/

    }, {
        key: 'resizeApp',
        value: function resizeApp() {
            this.updateSidebarDirection();

            this.setState({
                isSmall: window.innerWidth <= narrowWidth ? true : false
            });
        }

        /**
         * @param params
         * @private
         */

    }, {
        key: '_sendTimeSeriesRequest',
        value: function _sendTimeSeriesRequest(params) {
            var paramParts = [];
            for (var key in params) {
                if (params[key] != null) {
                    paramParts.push(key + '=' + params[key]);
                }
            }

            var requestUrl = timeSeriesRequestPath + '?' + paramParts.join('&');
            return fetch(requestUrl);
        }

        /**
         * @param options
         * propertyId
         * from
         * to
         * bbox
         */

    }, {
        key: 'handleAppStateChange',
        value: function handleAppStateChange(options) {
            var _this5 = this;

            var requestParameters = {
                topic: this.state.topic,
                phenomenon_date_from: options.from.format('YYYY-MM-DD'),
                phenomenon_date_to: options.to.format('YYYY-MM-DD'),
                bbox: options.bbox
            };

            var properties = options.properties || this.state.properties;
            if (properties.length) {
                var nameIds = properties.map(function (property) {
                    return property.name_id;
                });
                requestParameters.properties = nameIds.join(',');
            }

            this._sendTimeSeriesRequest(requestParameters).then(function (response) {
                if (response.status !== 200) {
                    var message = 'Looks like there was a problem. Status Code: ' + response.status;
                    console.log(message);
                    _this5.notifyUser({
                        text: message,
                        color: 'red'
                    });

                    _this5.setState({
                        currentValues: {
                            from: null,
                            to: null,
                            frequency: null
                        },
                        geojsonData: null,
                        isDataValid: false,
                        loading: false
                    });
                    return;
                }

                response.json().then(function (data) {
                    var from = data.phenomenon_time_from ? external__moment__default()(data.phenomenon_time_from).utcOffset(MapApp_timeZone) : null;
                    var to = data.phenomenon_time_to ? external__moment__default()(data.phenomenon_time_to).utcOffset(MapApp_timeZone) : null;

                    _this5.setState({
                        currentValues: {
                            from: from,
                            to: to,
                            frequency: data.value_frequency,
                            valueDuration: data.value_duration
                        },
                        geojsonData: data,
                        isDataValid: from && to,
                        loading: false
                    });
                });
            }).catch(function (error) {
                return console.log(error);
            });
        }
    }, {
        key: 'handlePropertyChange',
        value: function handlePropertyChange(event, data) {
            var primaryPropertyId = data.value;

            this.setState(function (prevState, props) {
                var selection = prevState.selection;
                selection.primaryPropertyId = primaryPropertyId;

                return {
                    selection: selection
                };
            });
        }
    }, {
        key: 'handleDateRangeChange',
        value: function handleDateRangeChange(from, to) {
            var _this6 = this;

            console.log('MapApp handleDateRangeChange - from: ', from.clone().unix());
            this.setState(function (prevState, props) {
                var isPropertyChosen = prevState.selection.primaryPropertyId !== null;
                if (isPropertyChosen) {
                    _this6.handleAppStateChange({
                        from: from,
                        to: to
                    });
                }

                var selection = prevState.selection;
                selection.from = from;
                selection.to = to;

                return {
                    loading: isPropertyChosen,
                    selection: selection
                };
            });
        }
    }, {
        key: 'handleTimeValueChange',
        value: function handleTimeValueChange(time) {
            this.setState(function (prevState, props) {
                var from = prevState.currentValues.from.unix();
                var index = (time.unix() - from) / prevState.currentValues.frequency;

                var selection = prevState.selection;
                selection.timeValueIndex = index;

                return {
                    selection: selection
                };
            });
        }
    }, {
        key: 'notifyUser',
        value: function notifyUser(message) {
            this.setState({
                popupOpen: true,
                popupMessage: message.text,
                popupColor: message.color
            });

            setTimeout(function () {
                this.setState({
                    popupOpen: false
                });
            }.bind(this), 5000);
        }
        /******************************** app handlers *********************************/

    }, {
        key: 'getPropertyById',
        value: function getPropertyById(propertyId) {
            var property = this.state.properties.find(function (property) {
                return property.name_id === propertyId;
            });

            return property;
        }
    }, {
        key: 'render',
        value: function render() {
            var _state = this.state,
                sidebarVisible = _state.sidebarVisible,
                sidebarDirection = _state.sidebarDirection;


            return external__react__default.a.createElement(
                'div',
                {
                    className: 'jsx-2590784755' + ' ' + 'content'
                },
                external__react__default.a.createElement(
                    external__semantic_ui_react_["Sidebar"].Pushable,
                    { className: this.getSidebarClass() },
                    external__react__default.a.createElement(
                        external__semantic_ui_react_["Sidebar"],
                        {
                            as: 'div',
                            className: 'control-panel',
                            animation: 'overlay',
                            direction: sidebarDirection,
                            visible: sidebarVisible },
                        external__react__default.a.createElement(
                            'div',
                            { style: sidebarContentStyle, className: 'jsx-2590784755'
                            },
                            external__react__default.a.createElement(components_MapControls, {
                                properties: this.state.properties,
                                selection: this.state.selection,
                                currentValues: this.state.currentValues,
                                timeZone: MapApp_timeZone,
                                onPropertyChange: this.handlePropertyChange,
                                onDateRangeChange: this.handleDateRangeChange,
                                onTimeValueChange: this.handleTimeValueChange,
                                notifyUser: this.notifyUser
                            })
                        )
                    ),
                    external__react__default.a.createElement(
                        external__semantic_ui_react_["Sidebar"].Pusher,
                        { style: pusherStyle },
                        external__react__default.a.createElement(
                            'div',
                            {
                                className: 'jsx-2590784755' + ' ' + (this.getSidebarClass() + ' main-wrapper' || '')
                            },
                            external__react__default.a.createElement(components_Map, { className: 'map',
                                ref: this.mapRef,
                                topic: this.state.topic,
                                properties: this.state.properties,
                                primaryProperty: this.getPropertyById(this.state.selection.primaryPropertyId),
                                currentValues: this.state.currentValues,
                                timeZone: MapApp_timeZone,
                                data: this.state.geojsonData,
                                isSmall: this.state.isSmall,
                                isDataValid: this.state.isDataValid,
                                loading: this.state.loading,
                                index: this.state.selection.timeValueIndex }),
                            external__react__default.a.createElement(external__semantic_ui_react_["Button"], {
                                className: 'sidebar-toggle',
                                icon: getSidebarToggleIcon(sidebarDirection, sidebarVisible),
                                onClick: this.handleSidebarToggleClick,
                                style: getSidebarToggleStyle(sidebarDirection, sidebarVisible) })
                        )
                    )
                ),
                external__react__default.a.createElement(components_NotificationPopup, {
                    open: this.state.popupOpen,
                    message: this.state.popupMessage,
                    color: this.state.popupColor }),
                external__react__default.a.createElement(style__default.a, {
                    styleId: '2590784755',
                    css: ['.content.jsx-2590784755{height:calc(100vh - 40px);position:absolute;top:40px;width:100%;}']
                })
            );
        }
    }]);

    return MapApp;
}(external__react__default.a.Component);

/* harmony default export */ var components_MapApp = (MapApp_MapApp);
// EXTERNAL MODULE: external "isomorphic-unfetch"
var external__isomorphic_unfetch_ = __webpack_require__(45);
var external__isomorphic_unfetch__default = /*#__PURE__*/__webpack_require__.n(external__isomorphic_unfetch_);

// CONCATENATED MODULE: ./pages/map.js


var map__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function map__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function map__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function map__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







var map_MapPage = function (_React$Component) {
    map__inherits(MapPage, _React$Component);

    map__createClass(MapPage, null, [{
        key: 'getInitialProps',
        value: function () {
            var _ref = _asyncToGenerator( /*#__PURE__*/regenerator__default.a.mark(function _callee(ctx) {
                var topic, topics, req, baseUrl, res;
                return regenerator__default.a.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                topic = ctx.query.topic;
                                topics = ctx.query.topics;

                                if (topics) {
                                    _context.next = 11;
                                    break;
                                }

                                req = ctx.req;
                                baseUrl = req && req.protocol && req.headers && req.headers.host ? req.protocol + '://' + req.headers.host : '';
                                _context.next = 7;
                                return external__isomorphic_unfetch__default()(baseUrl + '/api/v2/topics?format=json');

                            case 7:
                                res = _context.sent;
                                _context.next = 10;
                                return res.json();

                            case 10:
                                topics = _context.sent;

                            case 11:
                                return _context.abrupt('return', {
                                    mode: 'map',
                                    topic: topic,
                                    topics: topics
                                });

                            case 12:
                            case 'end':
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function getInitialProps(_x) {
                return _ref.apply(this, arguments);
            }

            return getInitialProps;
        }()
    }]);

    function MapPage(props) {
        map__classCallCheck(this, MapPage);

        var _this = map__possibleConstructorReturn(this, (MapPage.__proto__ || Object.getPrototypeOf(MapPage)).call(this, props));

        _this.state = {
            mode: props.mode
        };

        _this.handleModeClick = function (e, _ref2) {
            var name = _ref2.name;
            return _this.setState({ mode: name });
        };
        return _this;
    }

    map__createClass(MapPage, [{
        key: 'render',
        value: function render() {
            return external__react__default.a.createElement(
                'div',
                { className: 'map ' + this.state.mode + '-mode' },
                external__react__default.a.createElement(
                    HeaderMenu["a" /* default */],
                    { topics: this.props.topics, activeItem: this.props.topic },
                    external__react__default.a.createElement(
                        external__semantic_ui_react_["Menu"].Item,
                        { name: 'map', position: 'right', active: this.state.mode === 'map', color: 'blue', onClick: this.handleModeClick },
                        external__react__default.a.createElement(external__semantic_ui_react_["Icon"], { name: 'map' })
                    ),
                    external__react__default.a.createElement(
                        external__semantic_ui_react_["Menu"].Item,
                        { name: 'settings', position: 'right', active: this.state.mode === 'settings', color: 'blue', onClick: this.handleModeClick },
                        external__react__default.a.createElement(external__semantic_ui_react_["Icon"], { name: 'cogs' })
                    )
                ),
                external__react__default.a.createElement(components_MapApp, { sidebarVisible: true, topic: this.props.topic, topics: this.props.topics })
            );
        }
    }]);

    return MapPage;
}(external__react__default.a.Component);

/* harmony default export */ var map = __webpack_exports__["default"] = (map_MapPage);

/***/ }),
/* 100 */
/***/ (function(module, exports) {

module.exports = require("@turf/helpers");

/***/ }),
/* 101 */
/***/ (function(module, exports) {

module.exports = require("@turf/buffer");

/***/ }),
/* 102 */
/***/ (function(module, exports) {

module.exports = require("@turf/projection");

/***/ }),
/* 103 */
/***/ (function(module, exports) {

module.exports = require("recharts");

/***/ }),
/* 104 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/ol/index.js
var ol = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ol/collection.js
var collection = __webpack_require__(50);

// EXTERNAL MODULE: ./node_modules/ol/collectioneventtype.js
var collectioneventtype = __webpack_require__(51);

// EXTERNAL MODULE: ./node_modules/ol/events/event.js
var events_event = __webpack_require__(18);

// CONCATENATED MODULE: ./node_modules/ol/mapevent.js



/**
 * @classdesc
 * Events emitted as map events are instances of this type.
 * See {@link ol.Map} for which events trigger a map event.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.MapEvent}
 * @param {string} type Event type.
 * @param {ol.PluggableMap} map Map.
 * @param {?olx.FrameState=} opt_frameState Frame state.
 */
var mapevent__ol_MapEvent_ = function _ol_MapEvent_(type, map, opt_frameState) {

  events_event["a" /* default */].call(this, type);

  /**
   * The map where the event occurred.
   * @type {ol.PluggableMap}
   * @api
   */
  this.map = map;

  /**
   * The frame state at the time of the event.
   * @type {?olx.FrameState}
   * @api
   */
  this.frameState = opt_frameState !== undefined ? opt_frameState : null;
};

ol["a" /* default */].inherits(mapevent__ol_MapEvent_, events_event["a" /* default */]);
/* harmony default export */ var mapevent = (mapevent__ol_MapEvent_);
// CONCATENATED MODULE: ./node_modules/ol/mapbrowserevent.js



/**
 * @classdesc
 * Events emitted as map browser events are instances of this type.
 * See {@link ol.Map} for which events trigger a map browser event.
 *
 * @constructor
 * @extends {ol.MapEvent}
 * @implements {oli.MapBrowserEvent}
 * @param {string} type Event type.
 * @param {ol.PluggableMap} map Map.
 * @param {Event} browserEvent Browser event.
 * @param {boolean=} opt_dragging Is the map currently being dragged?
 * @param {?olx.FrameState=} opt_frameState Frame state.
 */
var mapbrowserevent__ol_MapBrowserEvent_ = function _ol_MapBrowserEvent_(type, map, browserEvent, opt_dragging, opt_frameState) {

  mapevent.call(this, type, map, opt_frameState);

  /**
   * The original browser event.
   * @const
   * @type {Event}
   * @api
   */
  this.originalEvent = browserEvent;

  /**
   * The map pixel relative to the viewport corresponding to the original browser event.
   * @type {ol.Pixel}
   * @api
   */
  this.pixel = map.getEventPixel(browserEvent);

  /**
   * The coordinate in view projection corresponding to the original browser event.
   * @type {ol.Coordinate}
   * @api
   */
  this.coordinate = map.getCoordinateFromPixel(this.pixel);

  /**
   * Indicates if the map is currently being dragged. Only set for
   * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
   *
   * @type {boolean}
   * @api
   */
  this.dragging = opt_dragging !== undefined ? opt_dragging : false;
};

ol["a" /* default */].inherits(mapbrowserevent__ol_MapBrowserEvent_, mapevent);

/**
 * Prevents the default browser action.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault
 * @override
 * @api
 */
mapbrowserevent__ol_MapBrowserEvent_.prototype.preventDefault = function () {
  mapevent.prototype.preventDefault.call(this);
  this.originalEvent.preventDefault();
};

/**
 * Prevents further propagation of the current event.
 * @see https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation
 * @override
 * @api
 */
mapbrowserevent__ol_MapBrowserEvent_.prototype.stopPropagation = function () {
  mapevent.prototype.stopPropagation.call(this);
  this.originalEvent.stopPropagation();
};
/* harmony default export */ var mapbrowserevent = (mapbrowserevent__ol_MapBrowserEvent_);
// EXTERNAL MODULE: ./node_modules/ol/has.js
var has = __webpack_require__(19);

// EXTERNAL MODULE: ./node_modules/ol/mapbrowsereventtype.js
var mapbrowsereventtype = __webpack_require__(52);

// CONCATENATED MODULE: ./node_modules/ol/mapbrowserpointerevent.js



/**
 * @constructor
 * @extends {ol.MapBrowserEvent}
 * @param {string} type Event type.
 * @param {ol.PluggableMap} map Map.
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @param {boolean=} opt_dragging Is the map currently being dragged?
 * @param {?olx.FrameState=} opt_frameState Frame state.
 */
var mapbrowserpointerevent__ol_MapBrowserPointerEvent_ = function _ol_MapBrowserPointerEvent_(type, map, pointerEvent, opt_dragging, opt_frameState) {

  mapbrowserevent.call(this, type, map, pointerEvent.originalEvent, opt_dragging, opt_frameState);

  /**
   * @const
   * @type {ol.pointer.PointerEvent}
   */
  this.pointerEvent = pointerEvent;
};

ol["a" /* default */].inherits(mapbrowserpointerevent__ol_MapBrowserPointerEvent_, mapbrowserevent);
/* harmony default export */ var mapbrowserpointerevent = (mapbrowserpointerevent__ol_MapBrowserPointerEvent_);
// EXTERNAL MODULE: ./node_modules/ol/events.js
var ol_events = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/ol/events/eventtarget.js
var eventtarget = __webpack_require__(31);

// CONCATENATED MODULE: ./node_modules/ol/pointer/eventtype.js
/**
 * Constants for event names.
 * @enum {string}
 */
var _ol_pointer_EventType_ = {
  POINTERMOVE: 'pointermove',
  POINTERDOWN: 'pointerdown',
  POINTERUP: 'pointerup',
  POINTEROVER: 'pointerover',
  POINTEROUT: 'pointerout',
  POINTERENTER: 'pointerenter',
  POINTERLEAVE: 'pointerleave',
  POINTERCANCEL: 'pointercancel'
};

/* harmony default export */ var eventtype = (_ol_pointer_EventType_);
// CONCATENATED MODULE: ./node_modules/ol/pointer/eventsource.js
/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @param {!Object.<string, function(Event)>} mapping Event
 *     mapping.
 * @constructor
 */
var _ol_pointer_EventSource_ = function _ol_pointer_EventSource_(dispatcher, mapping) {
  /**
   * @type {ol.pointer.PointerEventHandler}
   */
  this.dispatcher = dispatcher;

  /**
   * @private
   * @const
   * @type {!Object.<string, function(Event)>}
   */
  this.mapping_ = mapping;
};

/**
 * List of events supported by this source.
 * @return {Array.<string>} Event names
 */
_ol_pointer_EventSource_.prototype.getEvents = function () {
  return Object.keys(this.mapping_);
};

/**
 * Returns the handler that should handle a given event type.
 * @param {string} eventType The event type.
 * @return {function(Event)} Handler
 */
_ol_pointer_EventSource_.prototype.getHandlerForEvent = function (eventType) {
  return this.mapping_[eventType];
};
/* harmony default export */ var eventsource = (_ol_pointer_EventSource_);
// CONCATENATED MODULE: ./node_modules/ol/pointer/mousesource.js
// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @constructor
 * @extends {ol.pointer.EventSource}
 */
var mousesource__ol_pointer_MouseSource_ = function _ol_pointer_MouseSource_(dispatcher) {
  var mapping = {
    'mousedown': this.mousedown,
    'mousemove': this.mousemove,
    'mouseup': this.mouseup,
    'mouseover': this.mouseover,
    'mouseout': this.mouseout
  };
  eventsource.call(this, dispatcher, mapping);

  /**
   * @const
   * @type {!Object.<string, Event|Object>}
   */
  this.pointerMap = dispatcher.pointerMap;

  /**
   * @const
   * @type {Array.<ol.Pixel>}
   */
  this.lastTouches = [];
};

ol["a" /* default */].inherits(mousesource__ol_pointer_MouseSource_, eventsource);

/**
 * @const
 * @type {number}
 */
mousesource__ol_pointer_MouseSource_.POINTER_ID = 1;

/**
 * @const
 * @type {string}
 */
mousesource__ol_pointer_MouseSource_.POINTER_TYPE = 'mouse';

/**
 * Radius around touchend that swallows mouse events.
 *
 * @const
 * @type {number}
 */
mousesource__ol_pointer_MouseSource_.DEDUP_DIST = 25;

/**
 * Detect if a mouse event was simulated from a touch by
 * checking if previously there was a touch event at the
 * same position.
 *
 * FIXME - Known problem with the native Android browser on
 * Samsung GT-I9100 (Android 4.1.2):
 * In case the page is scrolled, this function does not work
 * correctly when a canvas is used (WebGL or canvas renderer).
 * Mouse listeners on canvas elements (for this browser), create
 * two mouse events: One 'good' and one 'bad' one (on other browsers or
 * when a div is used, there is only one event). For the 'bad' one,
 * clientX/clientY and also pageX/pageY are wrong when the page
 * is scrolled. Because of that, this function can not detect if
 * the events were simulated from a touch event. As result, a
 * pointer event at a wrong position is dispatched, which confuses
 * the map interactions.
 * It is unclear, how one can get the correct position for the event
 * or detect that the positions are invalid.
 *
 * @private
 * @param {Event} inEvent The in event.
 * @return {boolean} True, if the event was generated by a touch.
 */
mousesource__ol_pointer_MouseSource_.prototype.isEventSimulatedFromTouch_ = function (inEvent) {
  var lts = this.lastTouches;
  var x = inEvent.clientX,
      y = inEvent.clientY;
  for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
    // simulated mouse events will be swallowed near a primary touchend
    var dx = Math.abs(x - t[0]),
        dy = Math.abs(y - t[1]);
    if (dx <= mousesource__ol_pointer_MouseSource_.DEDUP_DIST && dy <= mousesource__ol_pointer_MouseSource_.DEDUP_DIST) {
      return true;
    }
  }
  return false;
};

/**
 * Creates a copy of the original event that will be used
 * for the fake pointer event.
 *
 * @param {Event} inEvent The in event.
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @return {Object} The copied event.
 */
mousesource__ol_pointer_MouseSource_.prepareEvent = function (inEvent, dispatcher) {
  var e = dispatcher.cloneEvent(inEvent, inEvent);

  // forward mouse preventDefault
  var pd = e.preventDefault;
  e.preventDefault = function () {
    inEvent.preventDefault();
    pd();
  };

  e.pointerId = mousesource__ol_pointer_MouseSource_.POINTER_ID;
  e.isPrimary = true;
  e.pointerType = mousesource__ol_pointer_MouseSource_.POINTER_TYPE;

  return e;
};

/**
 * Handler for `mousedown`.
 *
 * @param {Event} inEvent The in event.
 */
mousesource__ol_pointer_MouseSource_.prototype.mousedown = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    // TODO(dfreedman) workaround for some elements not sending mouseup
    // http://crbug/149091
    if (mousesource__ol_pointer_MouseSource_.POINTER_ID.toString() in this.pointerMap) {
      this.cancel(inEvent);
    }
    var e = mousesource__ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);
    this.pointerMap[mousesource__ol_pointer_MouseSource_.POINTER_ID.toString()] = inEvent;
    this.dispatcher.down(e, inEvent);
  }
};

/**
 * Handler for `mousemove`.
 *
 * @param {Event} inEvent The in event.
 */
mousesource__ol_pointer_MouseSource_.prototype.mousemove = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = mousesource__ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.move(e, inEvent);
  }
};

/**
 * Handler for `mouseup`.
 *
 * @param {Event} inEvent The in event.
 */
mousesource__ol_pointer_MouseSource_.prototype.mouseup = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var p = this.pointerMap[mousesource__ol_pointer_MouseSource_.POINTER_ID.toString()];

    if (p && p.button === inEvent.button) {
      var e = mousesource__ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);
      this.dispatcher.up(e, inEvent);
      this.cleanupMouse();
    }
  }
};

/**
 * Handler for `mouseover`.
 *
 * @param {Event} inEvent The in event.
 */
mousesource__ol_pointer_MouseSource_.prototype.mouseover = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = mousesource__ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.enterOver(e, inEvent);
  }
};

/**
 * Handler for `mouseout`.
 *
 * @param {Event} inEvent The in event.
 */
mousesource__ol_pointer_MouseSource_.prototype.mouseout = function (inEvent) {
  if (!this.isEventSimulatedFromTouch_(inEvent)) {
    var e = mousesource__ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);
    this.dispatcher.leaveOut(e, inEvent);
  }
};

/**
 * Dispatches a `pointercancel` event.
 *
 * @param {Event} inEvent The in event.
 */
mousesource__ol_pointer_MouseSource_.prototype.cancel = function (inEvent) {
  var e = mousesource__ol_pointer_MouseSource_.prepareEvent(inEvent, this.dispatcher);
  this.dispatcher.cancel(e, inEvent);
  this.cleanupMouse();
};

/**
 * Remove the mouse from the list of active pointers.
 */
mousesource__ol_pointer_MouseSource_.prototype.cleanupMouse = function () {
  delete this.pointerMap[mousesource__ol_pointer_MouseSource_.POINTER_ID.toString()];
};
/* harmony default export */ var mousesource = (mousesource__ol_pointer_MouseSource_);
// CONCATENATED MODULE: ./node_modules/ol/pointer/mssource.js
// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @constructor
 * @extends {ol.pointer.EventSource}
 */
var mssource__ol_pointer_MsSource_ = function _ol_pointer_MsSource_(dispatcher) {
  var mapping = {
    'MSPointerDown': this.msPointerDown,
    'MSPointerMove': this.msPointerMove,
    'MSPointerUp': this.msPointerUp,
    'MSPointerOut': this.msPointerOut,
    'MSPointerOver': this.msPointerOver,
    'MSPointerCancel': this.msPointerCancel,
    'MSGotPointerCapture': this.msGotPointerCapture,
    'MSLostPointerCapture': this.msLostPointerCapture
  };
  eventsource.call(this, dispatcher, mapping);

  /**
   * @const
   * @type {!Object.<string, Event|Object>}
   */
  this.pointerMap = dispatcher.pointerMap;

  /**
   * @const
   * @type {Array.<string>}
   */
  this.POINTER_TYPES = ['', 'unavailable', 'touch', 'pen', 'mouse'];
};

ol["a" /* default */].inherits(mssource__ol_pointer_MsSource_, eventsource);

/**
 * Creates a copy of the original event that will be used
 * for the fake pointer event.
 *
 * @private
 * @param {Event} inEvent The in event.
 * @return {Object} The copied event.
 */
mssource__ol_pointer_MsSource_.prototype.prepareEvent_ = function (inEvent) {
  var e = inEvent;
  if (typeof inEvent.pointerType === 'number') {
    e = this.dispatcher.cloneEvent(inEvent, inEvent);
    e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
  }

  return e;
};

/**
 * Remove this pointer from the list of active pointers.
 * @param {number} pointerId Pointer identifier.
 */
mssource__ol_pointer_MsSource_.prototype.cleanup = function (pointerId) {
  delete this.pointerMap[pointerId.toString()];
};

/**
 * Handler for `msPointerDown`.
 *
 * @param {Event} inEvent The in event.
 */
mssource__ol_pointer_MsSource_.prototype.msPointerDown = function (inEvent) {
  this.pointerMap[inEvent.pointerId.toString()] = inEvent;
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.down(e, inEvent);
};

/**
 * Handler for `msPointerMove`.
 *
 * @param {Event} inEvent The in event.
 */
mssource__ol_pointer_MsSource_.prototype.msPointerMove = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.move(e, inEvent);
};

/**
 * Handler for `msPointerUp`.
 *
 * @param {Event} inEvent The in event.
 */
mssource__ol_pointer_MsSource_.prototype.msPointerUp = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.up(e, inEvent);
  this.cleanup(inEvent.pointerId);
};

/**
 * Handler for `msPointerOut`.
 *
 * @param {Event} inEvent The in event.
 */
mssource__ol_pointer_MsSource_.prototype.msPointerOut = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.leaveOut(e, inEvent);
};

/**
 * Handler for `msPointerOver`.
 *
 * @param {Event} inEvent The in event.
 */
mssource__ol_pointer_MsSource_.prototype.msPointerOver = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.enterOver(e, inEvent);
};

/**
 * Handler for `msPointerCancel`.
 *
 * @param {Event} inEvent The in event.
 */
mssource__ol_pointer_MsSource_.prototype.msPointerCancel = function (inEvent) {
  var e = this.prepareEvent_(inEvent);
  this.dispatcher.cancel(e, inEvent);
  this.cleanup(inEvent.pointerId);
};

/**
 * Handler for `msLostPointerCapture`.
 *
 * @param {Event} inEvent The in event.
 */
mssource__ol_pointer_MsSource_.prototype.msLostPointerCapture = function (inEvent) {
  var e = this.dispatcher.makeEvent('lostpointercapture', inEvent, inEvent);
  this.dispatcher.dispatchEvent(e);
};

/**
 * Handler for `msGotPointerCapture`.
 *
 * @param {Event} inEvent The in event.
 */
mssource__ol_pointer_MsSource_.prototype.msGotPointerCapture = function (inEvent) {
  var e = this.dispatcher.makeEvent('gotpointercapture', inEvent, inEvent);
  this.dispatcher.dispatchEvent(e);
};
/* harmony default export */ var mssource = (mssource__ol_pointer_MsSource_);
// CONCATENATED MODULE: ./node_modules/ol/pointer/nativesource.js
// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




/**
 * @param {ol.pointer.PointerEventHandler} dispatcher Event handler.
 * @constructor
 * @extends {ol.pointer.EventSource}
 */
var nativesource__ol_pointer_NativeSource_ = function _ol_pointer_NativeSource_(dispatcher) {
  var mapping = {
    'pointerdown': this.pointerDown,
    'pointermove': this.pointerMove,
    'pointerup': this.pointerUp,
    'pointerout': this.pointerOut,
    'pointerover': this.pointerOver,
    'pointercancel': this.pointerCancel,
    'gotpointercapture': this.gotPointerCapture,
    'lostpointercapture': this.lostPointerCapture
  };
  eventsource.call(this, dispatcher, mapping);
};

ol["a" /* default */].inherits(nativesource__ol_pointer_NativeSource_, eventsource);

/**
 * Handler for `pointerdown`.
 *
 * @param {Event} inEvent The in event.
 */
nativesource__ol_pointer_NativeSource_.prototype.pointerDown = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};

/**
 * Handler for `pointermove`.
 *
 * @param {Event} inEvent The in event.
 */
nativesource__ol_pointer_NativeSource_.prototype.pointerMove = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};

/**
 * Handler for `pointerup`.
 *
 * @param {Event} inEvent The in event.
 */
nativesource__ol_pointer_NativeSource_.prototype.pointerUp = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};

/**
 * Handler for `pointerout`.
 *
 * @param {Event} inEvent The in event.
 */
nativesource__ol_pointer_NativeSource_.prototype.pointerOut = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};

/**
 * Handler for `pointerover`.
 *
 * @param {Event} inEvent The in event.
 */
nativesource__ol_pointer_NativeSource_.prototype.pointerOver = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};

/**
 * Handler for `pointercancel`.
 *
 * @param {Event} inEvent The in event.
 */
nativesource__ol_pointer_NativeSource_.prototype.pointerCancel = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};

/**
 * Handler for `lostpointercapture`.
 *
 * @param {Event} inEvent The in event.
 */
nativesource__ol_pointer_NativeSource_.prototype.lostPointerCapture = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};

/**
 * Handler for `gotpointercapture`.
 *
 * @param {Event} inEvent The in event.
 */
nativesource__ol_pointer_NativeSource_.prototype.gotPointerCapture = function (inEvent) {
  this.dispatcher.fireNativeEvent(inEvent);
};
/* harmony default export */ var nativesource = (nativesource__ol_pointer_NativeSource_);
// CONCATENATED MODULE: ./node_modules/ol/pointer/pointerevent.js
// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.




/**
 * A class for pointer events.
 *
 * This class is used as an abstraction for mouse events,
 * touch events and even native pointer events.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @param {string} type The type of the event to create.
 * @param {Event} originalEvent The event.
 * @param {Object.<string, ?>=} opt_eventDict An optional dictionary of
 *    initial event properties.
 */
var pointerevent__ol_pointer_PointerEvent_ = function _ol_pointer_PointerEvent_(type, originalEvent, opt_eventDict) {
  events_event["a" /* default */].call(this, type);

  /**
   * @const
   * @type {Event}
   */
  this.originalEvent = originalEvent;

  var eventDict = opt_eventDict ? opt_eventDict : {};

  /**
   * @type {number}
   */
  this.buttons = this.getButtons_(eventDict);

  /**
   * @type {number}
   */
  this.pressure = this.getPressure_(eventDict, this.buttons);

  // MouseEvent related properties

  /**
   * @type {boolean}
   */
  this.bubbles = 'bubbles' in eventDict ? eventDict['bubbles'] : false;

  /**
   * @type {boolean}
   */
  this.cancelable = 'cancelable' in eventDict ? eventDict['cancelable'] : false;

  /**
   * @type {Object}
   */
  this.view = 'view' in eventDict ? eventDict['view'] : null;

  /**
   * @type {number}
   */
  this.detail = 'detail' in eventDict ? eventDict['detail'] : null;

  /**
   * @type {number}
   */
  this.screenX = 'screenX' in eventDict ? eventDict['screenX'] : 0;

  /**
   * @type {number}
   */
  this.screenY = 'screenY' in eventDict ? eventDict['screenY'] : 0;

  /**
   * @type {number}
   */
  this.clientX = 'clientX' in eventDict ? eventDict['clientX'] : 0;

  /**
   * @type {number}
   */
  this.clientY = 'clientY' in eventDict ? eventDict['clientY'] : 0;

  /**
   * @type {boolean}
   */
  this.ctrlKey = 'ctrlKey' in eventDict ? eventDict['ctrlKey'] : false;

  /**
   * @type {boolean}
   */
  this.altKey = 'altKey' in eventDict ? eventDict['altKey'] : false;

  /**
   * @type {boolean}
   */
  this.shiftKey = 'shiftKey' in eventDict ? eventDict['shiftKey'] : false;

  /**
   * @type {boolean}
   */
  this.metaKey = 'metaKey' in eventDict ? eventDict['metaKey'] : false;

  /**
   * @type {number}
   */
  this.button = 'button' in eventDict ? eventDict['button'] : 0;

  /**
   * @type {Node}
   */
  this.relatedTarget = 'relatedTarget' in eventDict ? eventDict['relatedTarget'] : null;

  // PointerEvent related properties

  /**
   * @const
   * @type {number}
   */
  this.pointerId = 'pointerId' in eventDict ? eventDict['pointerId'] : 0;

  /**
   * @type {number}
   */
  this.width = 'width' in eventDict ? eventDict['width'] : 0;

  /**
   * @type {number}
   */
  this.height = 'height' in eventDict ? eventDict['height'] : 0;

  /**
   * @type {number}
   */
  this.tiltX = 'tiltX' in eventDict ? eventDict['tiltX'] : 0;

  /**
   * @type {number}
   */
  this.tiltY = 'tiltY' in eventDict ? eventDict['tiltY'] : 0;

  /**
   * @type {string}
   */
  this.pointerType = 'pointerType' in eventDict ? eventDict['pointerType'] : '';

  /**
   * @type {number}
   */
  this.hwTimestamp = 'hwTimestamp' in eventDict ? eventDict['hwTimestamp'] : 0;

  /**
   * @type {boolean}
   */
  this.isPrimary = 'isPrimary' in eventDict ? eventDict['isPrimary'] : false;

  // keep the semantics of preventDefault
  if (originalEvent.preventDefault) {
    this.preventDefault = function () {
      originalEvent.preventDefault();
    };
  }
};

ol["a" /* default */].inherits(pointerevent__ol_pointer_PointerEvent_, events_event["a" /* default */]);

/**
 * @private
 * @param {Object.<string, ?>} eventDict The event dictionary.
 * @return {number} Button indicator.
 */
pointerevent__ol_pointer_PointerEvent_.prototype.getButtons_ = function (eventDict) {
  // According to the w3c spec,
  // http://www.w3.org/TR/DOM-Level-3-Events/#events-MouseEvent-button
  // MouseEvent.button == 0 can mean either no mouse button depressed, or the
  // left mouse button depressed.
  //
  // As of now, the only way to distinguish between the two states of
  // MouseEvent.button is by using the deprecated MouseEvent.which property, as
  // this maps mouse buttons to positive integers > 0, and uses 0 to mean that
  // no mouse button is held.
  //
  // MouseEvent.which is derived from MouseEvent.button at MouseEvent creation,
  // but initMouseEvent does not expose an argument with which to set
  // MouseEvent.which. Calling initMouseEvent with a buttonArg of 0 will set
  // MouseEvent.button == 0 and MouseEvent.which == 1, breaking the expectations
  // of app developers.
  //
  // The only way to propagate the correct state of MouseEvent.which and
  // MouseEvent.button to a new MouseEvent.button == 0 and MouseEvent.which == 0
  // is to call initMouseEvent with a buttonArg value of -1.
  //
  // This is fixed with DOM Level 4's use of buttons
  var buttons;
  if (eventDict.buttons || pointerevent__ol_pointer_PointerEvent_.HAS_BUTTONS) {
    buttons = eventDict.buttons;
  } else {
    switch (eventDict.which) {
      case 1:
        buttons = 1;break;
      case 2:
        buttons = 4;break;
      case 3:
        buttons = 2;break;
      default:
        buttons = 0;
    }
  }
  return buttons;
};

/**
 * @private
 * @param {Object.<string, ?>} eventDict The event dictionary.
 * @param {number} buttons Button indicator.
 * @return {number} The pressure.
 */
pointerevent__ol_pointer_PointerEvent_.prototype.getPressure_ = function (eventDict, buttons) {
  // Spec requires that pointers without pressure specified use 0.5 for down
  // state and 0 for up state.
  var pressure = 0;
  if (eventDict.pressure) {
    pressure = eventDict.pressure;
  } else {
    pressure = buttons ? 0.5 : 0;
  }
  return pressure;
};

/**
 * Is the `buttons` property supported?
 * @type {boolean}
 */
pointerevent__ol_pointer_PointerEvent_.HAS_BUTTONS = false;

/**
 * Checks if the `buttons` property is supported.
 */
(function () {
  try {
    var ev = new MouseEvent('click', { buttons: 1 });
    pointerevent__ol_pointer_PointerEvent_.HAS_BUTTONS = ev.buttons === 1;
  } catch (e) {
    // pass
  }
})();
/* harmony default export */ var pointerevent = (pointerevent__ol_pointer_PointerEvent_);
// EXTERNAL MODULE: ./node_modules/ol/array.js
var array = __webpack_require__(5);

// CONCATENATED MODULE: ./node_modules/ol/pointer/touchsource.js
// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.






/**
 * @constructor
 * @param {ol.pointer.PointerEventHandler} dispatcher The event handler.
 * @param {ol.pointer.MouseSource} mouseSource Mouse source.
 * @extends {ol.pointer.EventSource}
 */
var touchsource__ol_pointer_TouchSource_ = function _ol_pointer_TouchSource_(dispatcher, mouseSource) {
  var mapping = {
    'touchstart': this.touchstart,
    'touchmove': this.touchmove,
    'touchend': this.touchend,
    'touchcancel': this.touchcancel
  };
  eventsource.call(this, dispatcher, mapping);

  /**
   * @const
   * @type {!Object.<string, Event|Object>}
   */
  this.pointerMap = dispatcher.pointerMap;

  /**
   * @const
   * @type {ol.pointer.MouseSource}
   */
  this.mouseSource = mouseSource;

  /**
   * @private
   * @type {number|undefined}
   */
  this.firstTouchId_ = undefined;

  /**
   * @private
   * @type {number}
   */
  this.clickCount_ = 0;

  /**
   * @private
   * @type {number|undefined}
   */
  this.resetId_ = undefined;
};

ol["a" /* default */].inherits(touchsource__ol_pointer_TouchSource_, eventsource);

/**
 * Mouse event timeout: This should be long enough to
 * ignore compat mouse events made by touch.
 * @const
 * @type {number}
 */
touchsource__ol_pointer_TouchSource_.DEDUP_TIMEOUT = 2500;

/**
 * @const
 * @type {number}
 */
touchsource__ol_pointer_TouchSource_.CLICK_COUNT_TIMEOUT = 200;

/**
 * @const
 * @type {string}
 */
touchsource__ol_pointer_TouchSource_.POINTER_TYPE = 'touch';

/**
 * @private
 * @param {Touch} inTouch The in touch.
 * @return {boolean} True, if this is the primary touch.
 */
touchsource__ol_pointer_TouchSource_.prototype.isPrimaryTouch_ = function (inTouch) {
  return this.firstTouchId_ === inTouch.identifier;
};

/**
 * Set primary touch if there are no pointers, or the only pointer is the mouse.
 * @param {Touch} inTouch The in touch.
 * @private
 */
touchsource__ol_pointer_TouchSource_.prototype.setPrimaryTouch_ = function (inTouch) {
  var count = Object.keys(this.pointerMap).length;
  if (count === 0 || count === 1 && mousesource.POINTER_ID.toString() in this.pointerMap) {
    this.firstTouchId_ = inTouch.identifier;
    this.cancelResetClickCount_();
  }
};

/**
 * @private
 * @param {Object} inPointer The in pointer object.
 */
touchsource__ol_pointer_TouchSource_.prototype.removePrimaryPointer_ = function (inPointer) {
  if (inPointer.isPrimary) {
    this.firstTouchId_ = undefined;
    this.resetClickCount_();
  }
};

/**
 * @private
 */
touchsource__ol_pointer_TouchSource_.prototype.resetClickCount_ = function () {
  this.resetId_ = setTimeout(this.resetClickCountHandler_.bind(this), touchsource__ol_pointer_TouchSource_.CLICK_COUNT_TIMEOUT);
};

/**
 * @private
 */
touchsource__ol_pointer_TouchSource_.prototype.resetClickCountHandler_ = function () {
  this.clickCount_ = 0;
  this.resetId_ = undefined;
};

/**
 * @private
 */
touchsource__ol_pointer_TouchSource_.prototype.cancelResetClickCount_ = function () {
  if (this.resetId_ !== undefined) {
    clearTimeout(this.resetId_);
  }
};

/**
 * @private
 * @param {Event} browserEvent Browser event
 * @param {Touch} inTouch Touch event
 * @return {Object} A pointer object.
 */
touchsource__ol_pointer_TouchSource_.prototype.touchToPointer_ = function (browserEvent, inTouch) {
  var e = this.dispatcher.cloneEvent(browserEvent, inTouch);
  // Spec specifies that pointerId 1 is reserved for Mouse.
  // Touch identifiers can start at 0.
  // Add 2 to the touch identifier for compatibility.
  e.pointerId = inTouch.identifier + 2;
  // TODO: check if this is necessary?
  //e.target = findTarget(e);
  e.bubbles = true;
  e.cancelable = true;
  e.detail = this.clickCount_;
  e.button = 0;
  e.buttons = 1;
  e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;
  e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;
  e.pressure = inTouch.webkitForce || inTouch.force || 0.5;
  e.isPrimary = this.isPrimaryTouch_(inTouch);
  e.pointerType = touchsource__ol_pointer_TouchSource_.POINTER_TYPE;

  // make sure that the properties that are different for
  // each `Touch` object are not copied from the BrowserEvent object
  e.clientX = inTouch.clientX;
  e.clientY = inTouch.clientY;
  e.screenX = inTouch.screenX;
  e.screenY = inTouch.screenY;

  return e;
};

/**
 * @private
 * @param {Event} inEvent Touch event
 * @param {function(Event, Object)} inFunction In function.
 */
touchsource__ol_pointer_TouchSource_.prototype.processTouches_ = function (inEvent, inFunction) {
  var touches = Array.prototype.slice.call(inEvent.changedTouches);
  var count = touches.length;
  function preventDefault() {
    inEvent.preventDefault();
  }
  var i, pointer;
  for (i = 0; i < count; ++i) {
    pointer = this.touchToPointer_(inEvent, touches[i]);
    // forward touch preventDefaults
    pointer.preventDefault = preventDefault;
    inFunction.call(this, inEvent, pointer);
  }
};

/**
 * @private
 * @param {TouchList} touchList The touch list.
 * @param {number} searchId Search identifier.
 * @return {boolean} True, if the `Touch` with the given id is in the list.
 */
touchsource__ol_pointer_TouchSource_.prototype.findTouch_ = function (touchList, searchId) {
  var l = touchList.length;
  var touch;
  for (var i = 0; i < l; i++) {
    touch = touchList[i];
    if (touch.identifier === searchId) {
      return true;
    }
  }
  return false;
};

/**
 * In some instances, a touchstart can happen without a touchend. This
 * leaves the pointermap in a broken state.
 * Therefore, on every touchstart, we remove the touches that did not fire a
 * touchend event.
 * To keep state globally consistent, we fire a pointercancel for
 * this "abandoned" touch
 *
 * @private
 * @param {Event} inEvent The in event.
 */
touchsource__ol_pointer_TouchSource_.prototype.vacuumTouches_ = function (inEvent) {
  var touchList = inEvent.touches;
  // pointerMap.getCount() should be < touchList.length here,
  // as the touchstart has not been processed yet.
  var keys = Object.keys(this.pointerMap);
  var count = keys.length;
  if (count >= touchList.length) {
    var d = [];
    var i, key, value;
    for (i = 0; i < count; ++i) {
      key = keys[i];
      value = this.pointerMap[key];
      // Never remove pointerId == 1, which is mouse.
      // Touch identifiers are 2 smaller than their pointerId, which is the
      // index in pointermap.
      if (key != mousesource.POINTER_ID && !this.findTouch_(touchList, key - 2)) {
        d.push(value.out);
      }
    }
    for (i = 0; i < d.length; ++i) {
      this.cancelOut_(inEvent, d[i]);
    }
  }
};

/**
 * Handler for `touchstart`, triggers `pointerover`,
 * `pointerenter` and `pointerdown` events.
 *
 * @param {Event} inEvent The in event.
 */
touchsource__ol_pointer_TouchSource_.prototype.touchstart = function (inEvent) {
  this.vacuumTouches_(inEvent);
  this.setPrimaryTouch_(inEvent.changedTouches[0]);
  this.dedupSynthMouse_(inEvent);
  this.clickCount_++;
  this.processTouches_(inEvent, this.overDown_);
};

/**
 * @private
 * @param {Event} browserEvent The event.
 * @param {Object} inPointer The in pointer object.
 */
touchsource__ol_pointer_TouchSource_.prototype.overDown_ = function (browserEvent, inPointer) {
  this.pointerMap[inPointer.pointerId] = {
    target: inPointer.target,
    out: inPointer,
    outTarget: inPointer.target
  };
  this.dispatcher.over(inPointer, browserEvent);
  this.dispatcher.enter(inPointer, browserEvent);
  this.dispatcher.down(inPointer, browserEvent);
};

/**
 * Handler for `touchmove`.
 *
 * @param {Event} inEvent The in event.
 */
touchsource__ol_pointer_TouchSource_.prototype.touchmove = function (inEvent) {
  inEvent.preventDefault();
  this.processTouches_(inEvent, this.moveOverOut_);
};

/**
 * @private
 * @param {Event} browserEvent The event.
 * @param {Object} inPointer The in pointer.
 */
touchsource__ol_pointer_TouchSource_.prototype.moveOverOut_ = function (browserEvent, inPointer) {
  var event = inPointer;
  var pointer = this.pointerMap[event.pointerId];
  // a finger drifted off the screen, ignore it
  if (!pointer) {
    return;
  }
  var outEvent = pointer.out;
  var outTarget = pointer.outTarget;
  this.dispatcher.move(event, browserEvent);
  if (outEvent && outTarget !== event.target) {
    outEvent.relatedTarget = event.target;
    event.relatedTarget = outTarget;
    // recover from retargeting by shadow
    outEvent.target = outTarget;
    if (event.target) {
      this.dispatcher.leaveOut(outEvent, browserEvent);
      this.dispatcher.enterOver(event, browserEvent);
    } else {
      // clean up case when finger leaves the screen
      event.target = outTarget;
      event.relatedTarget = null;
      this.cancelOut_(browserEvent, event);
    }
  }
  pointer.out = event;
  pointer.outTarget = event.target;
};

/**
 * Handler for `touchend`, triggers `pointerup`,
 * `pointerout` and `pointerleave` events.
 *
 * @param {Event} inEvent The event.
 */
touchsource__ol_pointer_TouchSource_.prototype.touchend = function (inEvent) {
  this.dedupSynthMouse_(inEvent);
  this.processTouches_(inEvent, this.upOut_);
};

/**
 * @private
 * @param {Event} browserEvent An event.
 * @param {Object} inPointer The inPointer object.
 */
touchsource__ol_pointer_TouchSource_.prototype.upOut_ = function (browserEvent, inPointer) {
  this.dispatcher.up(inPointer, browserEvent);
  this.dispatcher.out(inPointer, browserEvent);
  this.dispatcher.leave(inPointer, browserEvent);
  this.cleanUpPointer_(inPointer);
};

/**
 * Handler for `touchcancel`, triggers `pointercancel`,
 * `pointerout` and `pointerleave` events.
 *
 * @param {Event} inEvent The in event.
 */
touchsource__ol_pointer_TouchSource_.prototype.touchcancel = function (inEvent) {
  this.processTouches_(inEvent, this.cancelOut_);
};

/**
 * @private
 * @param {Event} browserEvent The event.
 * @param {Object} inPointer The in pointer.
 */
touchsource__ol_pointer_TouchSource_.prototype.cancelOut_ = function (browserEvent, inPointer) {
  this.dispatcher.cancel(inPointer, browserEvent);
  this.dispatcher.out(inPointer, browserEvent);
  this.dispatcher.leave(inPointer, browserEvent);
  this.cleanUpPointer_(inPointer);
};

/**
 * @private
 * @param {Object} inPointer The inPointer object.
 */
touchsource__ol_pointer_TouchSource_.prototype.cleanUpPointer_ = function (inPointer) {
  delete this.pointerMap[inPointer.pointerId];
  this.removePrimaryPointer_(inPointer);
};

/**
 * Prevent synth mouse events from creating pointer events.
 *
 * @private
 * @param {Event} inEvent The in event.
 */
touchsource__ol_pointer_TouchSource_.prototype.dedupSynthMouse_ = function (inEvent) {
  var lts = this.mouseSource.lastTouches;
  var t = inEvent.changedTouches[0];
  // only the primary finger will synth mouse events
  if (this.isPrimaryTouch_(t)) {
    // remember x/y of last touch
    var lt = [t.clientX, t.clientY];
    lts.push(lt);

    setTimeout(function () {
      // remove touch after timeout
      array["a" /* default */].remove(lts, lt);
    }, touchsource__ol_pointer_TouchSource_.DEDUP_TIMEOUT);
  }
};
/* harmony default export */ var touchsource = (touchsource__ol_pointer_TouchSource_);
// CONCATENATED MODULE: ./node_modules/ol/pointer/pointereventhandler.js
// Based on https://github.com/Polymer/PointerEvents

// Copyright (c) 2013 The Polymer Authors. All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
// * Redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer.
// * Redistributions in binary form must reproduce the above
// copyright notice, this list of conditions and the following disclaimer
// in the documentation and/or other materials provided with the
// distribution.
// * Neither the name of Google Inc. nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.












/**
 * @constructor
 * @extends {ol.events.EventTarget}
 * @param {Element|HTMLDocument} element Viewport element.
 */
var pointereventhandler__ol_pointer_PointerEventHandler_ = function _ol_pointer_PointerEventHandler_(element) {
  eventtarget["a" /* default */].call(this);

  /**
   * @const
   * @private
   * @type {Element|HTMLDocument}
   */
  this.element_ = element;

  /**
   * @const
   * @type {!Object.<string, Event|Object>}
   */
  this.pointerMap = {};

  /**
   * @type {Object.<string, function(Event)>}
   * @private
   */
  this.eventMap_ = {};

  /**
   * @type {Array.<ol.pointer.EventSource>}
   * @private
   */
  this.eventSourceList_ = [];

  this.registerSources();
};

ol["a" /* default */].inherits(pointereventhandler__ol_pointer_PointerEventHandler_, eventtarget["a" /* default */]);

/**
 * Set up the event sources (mouse, touch and native pointers)
 * that generate pointer events.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.registerSources = function () {
  if (has["a" /* default */].POINTER) {
    this.registerSource('native', new nativesource(this));
  } else if (has["a" /* default */].MSPOINTER) {
    this.registerSource('ms', new mssource(this));
  } else {
    var mouseSource = new mousesource(this);
    this.registerSource('mouse', mouseSource);

    if (has["a" /* default */].TOUCH) {
      this.registerSource('touch', new touchsource(this, mouseSource));
    }
  }

  // register events on the viewport element
  this.register_();
};

/**
 * Add a new event source that will generate pointer events.
 *
 * @param {string} name A name for the event source
 * @param {ol.pointer.EventSource} source The source event.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.registerSource = function (name, source) {
  var s = source;
  var newEvents = s.getEvents();

  if (newEvents) {
    newEvents.forEach(function (e) {
      var handler = s.getHandlerForEvent(e);

      if (handler) {
        this.eventMap_[e] = handler.bind(s);
      }
    }, this);
    this.eventSourceList_.push(s);
  }
};

/**
 * Set up the events for all registered event sources.
 * @private
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.register_ = function () {
  var l = this.eventSourceList_.length;
  var eventSource;
  for (var i = 0; i < l; i++) {
    eventSource = this.eventSourceList_[i];
    this.addEvents_(eventSource.getEvents());
  }
};

/**
 * Remove all registered events.
 * @private
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.unregister_ = function () {
  var l = this.eventSourceList_.length;
  var eventSource;
  for (var i = 0; i < l; i++) {
    eventSource = this.eventSourceList_[i];
    this.removeEvents_(eventSource.getEvents());
  }
};

/**
 * Calls the right handler for a new event.
 * @private
 * @param {Event} inEvent Browser event.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.eventHandler_ = function (inEvent) {
  var type = inEvent.type;
  var handler = this.eventMap_[type];
  if (handler) {
    handler(inEvent);
  }
};

/**
 * Setup listeners for the given events.
 * @private
 * @param {Array.<string>} events List of events.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.addEvents_ = function (events) {
  events.forEach(function (eventName) {
    ol_events["a" /* default */].listen(this.element_, eventName, this.eventHandler_, this);
  }, this);
};

/**
 * Unregister listeners for the given events.
 * @private
 * @param {Array.<string>} events List of events.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.removeEvents_ = function (events) {
  events.forEach(function (e) {
    ol_events["a" /* default */].unlisten(this.element_, e, this.eventHandler_, this);
  }, this);
};

/**
 * Returns a snapshot of inEvent, with writable properties.
 *
 * @param {Event} event Browser event.
 * @param {Event|Touch} inEvent An event that contains
 *    properties to copy.
 * @return {Object} An object containing shallow copies of
 *    `inEvent`'s properties.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.cloneEvent = function (event, inEvent) {
  var eventCopy = {},
      p;
  for (var i = 0, ii = pointereventhandler__ol_pointer_PointerEventHandler_.CLONE_PROPS.length; i < ii; i++) {
    p = pointereventhandler__ol_pointer_PointerEventHandler_.CLONE_PROPS[i][0];
    eventCopy[p] = event[p] || inEvent[p] || pointereventhandler__ol_pointer_PointerEventHandler_.CLONE_PROPS[i][1];
  }

  return eventCopy;
};

// EVENTS


/**
 * Triggers a 'pointerdown' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.down = function (data, event) {
  this.fireEvent(eventtype.POINTERDOWN, data, event);
};

/**
 * Triggers a 'pointermove' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.move = function (data, event) {
  this.fireEvent(eventtype.POINTERMOVE, data, event);
};

/**
 * Triggers a 'pointerup' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.up = function (data, event) {
  this.fireEvent(eventtype.POINTERUP, data, event);
};

/**
 * Triggers a 'pointerenter' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.enter = function (data, event) {
  data.bubbles = false;
  this.fireEvent(eventtype.POINTERENTER, data, event);
};

/**
 * Triggers a 'pointerleave' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.leave = function (data, event) {
  data.bubbles = false;
  this.fireEvent(eventtype.POINTERLEAVE, data, event);
};

/**
 * Triggers a 'pointerover' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.over = function (data, event) {
  data.bubbles = true;
  this.fireEvent(eventtype.POINTEROVER, data, event);
};

/**
 * Triggers a 'pointerout' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.out = function (data, event) {
  data.bubbles = true;
  this.fireEvent(eventtype.POINTEROUT, data, event);
};

/**
 * Triggers a 'pointercancel' event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.cancel = function (data, event) {
  this.fireEvent(eventtype.POINTERCANCEL, data, event);
};

/**
 * Triggers a combination of 'pointerout' and 'pointerleave' events.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.leaveOut = function (data, event) {
  this.out(data, event);
  if (!this.contains_(data.target, data.relatedTarget)) {
    this.leave(data, event);
  }
};

/**
 * Triggers a combination of 'pointerover' and 'pointerevents' events.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.enterOver = function (data, event) {
  this.over(data, event);
  if (!this.contains_(data.target, data.relatedTarget)) {
    this.enter(data, event);
  }
};

/**
 * @private
 * @param {Element} container The container element.
 * @param {Element} contained The contained element.
 * @return {boolean} Returns true if the container element
 *   contains the other element.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.contains_ = function (container, contained) {
  if (!container || !contained) {
    return false;
  }
  return container.contains(contained);
};

// EVENT CREATION AND TRACKING
/**
 * Creates a new Event of type `inType`, based on the information in
 * `data`.
 *
 * @param {string} inType A string representing the type of event to create.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 * @return {ol.pointer.PointerEvent} A PointerEvent of type `inType`.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.makeEvent = function (inType, data, event) {
  return new pointerevent(inType, event, data);
};

/**
 * Make and dispatch an event in one call.
 * @param {string} inType A string representing the type of event.
 * @param {Object} data Pointer event data.
 * @param {Event} event The event.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.fireEvent = function (inType, data, event) {
  var e = this.makeEvent(inType, data, event);
  this.dispatchEvent(e);
};

/**
 * Creates a pointer event from a native pointer event
 * and dispatches this event.
 * @param {Event} event A platform event with a target.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.fireNativeEvent = function (event) {
  var e = this.makeEvent(event.type, event, event);
  this.dispatchEvent(e);
};

/**
 * Wrap a native mouse event into a pointer event.
 * This proxy method is required for the legacy IE support.
 * @param {string} eventType The pointer event type.
 * @param {Event} event The event.
 * @return {ol.pointer.PointerEvent} The wrapped event.
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.wrapMouseEvent = function (eventType, event) {
  var pointerEvent = this.makeEvent(eventType, mousesource.prepareEvent(event, this), event);
  return pointerEvent;
};

/**
 * @inheritDoc
 */
pointereventhandler__ol_pointer_PointerEventHandler_.prototype.disposeInternal = function () {
  this.unregister_();
  eventtarget["a" /* default */].prototype.disposeInternal.call(this);
};

/**
 * Properties to copy when cloning an event, with default values.
 * @type {Array.<Array>}
 */
pointereventhandler__ol_pointer_PointerEventHandler_.CLONE_PROPS = [
// MouseEvent
['bubbles', false], ['cancelable', false], ['view', null], ['detail', null], ['screenX', 0], ['screenY', 0], ['clientX', 0], ['clientY', 0], ['ctrlKey', false], ['altKey', false], ['shiftKey', false], ['metaKey', false], ['button', 0], ['relatedTarget', null],
// DOM Level 3
['buttons', 0],
// PointerEvent
['pointerId', 0], ['width', 0], ['height', 0], ['pressure', 0], ['tiltX', 0], ['tiltY', 0], ['pointerType', ''], ['hwTimestamp', 0], ['isPrimary', false],
// event instance
['type', ''], ['target', null], ['currentTarget', null], ['which', 0]];
/* harmony default export */ var pointereventhandler = (pointereventhandler__ol_pointer_PointerEventHandler_);
// CONCATENATED MODULE: ./node_modules/ol/mapbrowsereventhandler.js









/**
 * @param {ol.PluggableMap} map The map with the viewport to listen to events on.
 * @param {number|undefined} moveTolerance The minimal distance the pointer must travel to trigger a move.
 * @constructor
 * @extends {ol.events.EventTarget}
 */
var mapbrowsereventhandler__ol_MapBrowserEventHandler_ = function _ol_MapBrowserEventHandler_(map, moveTolerance) {

  eventtarget["a" /* default */].call(this);

  /**
   * This is the element that we will listen to the real events on.
   * @type {ol.PluggableMap}
   * @private
   */
  this.map_ = map;

  /**
   * @type {number}
   * @private
   */
  this.clickTimeoutId_ = 0;

  /**
   * @type {boolean}
   * @private
   */
  this.dragging_ = false;

  /**
   * @type {!Array.<ol.EventsKey>}
   * @private
   */
  this.dragListenerKeys_ = [];

  /**
   * @type {number}
   * @private
   */
  this.moveTolerance_ = moveTolerance ? moveTolerance * has["a" /* default */].DEVICE_PIXEL_RATIO : has["a" /* default */].DEVICE_PIXEL_RATIO;

  /**
   * The most recent "down" type event (or null if none have occurred).
   * Set on pointerdown.
   * @type {ol.pointer.PointerEvent}
   * @private
   */
  this.down_ = null;

  var element = this.map_.getViewport();

  /**
   * @type {number}
   * @private
   */
  this.activePointers_ = 0;

  /**
   * @type {!Object.<number, boolean>}
   * @private
   */
  this.trackedTouches_ = {};

  /**
   * Event handler which generates pointer events for
   * the viewport element.
   *
   * @type {ol.pointer.PointerEventHandler}
   * @private
   */
  this.pointerEventHandler_ = new pointereventhandler(element);

  /**
   * Event handler which generates pointer events for
   * the document (used when dragging).
   *
   * @type {ol.pointer.PointerEventHandler}
   * @private
   */
  this.documentPointerEventHandler_ = null;

  /**
   * @type {?ol.EventsKey}
   * @private
   */
  this.pointerdownListenerKey_ = ol_events["a" /* default */].listen(this.pointerEventHandler_, eventtype.POINTERDOWN, this.handlePointerDown_, this);

  /**
   * @type {?ol.EventsKey}
   * @private
   */
  this.relayedListenerKey_ = ol_events["a" /* default */].listen(this.pointerEventHandler_, eventtype.POINTERMOVE, this.relayEvent_, this);
};

ol["a" /* default */].inherits(mapbrowsereventhandler__ol_MapBrowserEventHandler_, eventtarget["a" /* default */]);

/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */
mapbrowsereventhandler__ol_MapBrowserEventHandler_.prototype.emulateClick_ = function (pointerEvent) {
  var newEvent = new mapbrowserpointerevent(mapbrowsereventtype["a" /* default */].CLICK, this.map_, pointerEvent);
  this.dispatchEvent(newEvent);
  if (this.clickTimeoutId_ !== 0) {
    // double-click
    clearTimeout(this.clickTimeoutId_);
    this.clickTimeoutId_ = 0;
    newEvent = new mapbrowserpointerevent(mapbrowsereventtype["a" /* default */].DBLCLICK, this.map_, pointerEvent);
    this.dispatchEvent(newEvent);
  } else {
    // click
    this.clickTimeoutId_ = setTimeout(function () {
      this.clickTimeoutId_ = 0;
      var newEvent = new mapbrowserpointerevent(mapbrowsereventtype["a" /* default */].SINGLECLICK, this.map_, pointerEvent);
      this.dispatchEvent(newEvent);
    }.bind(this), 250);
  }
};

/**
 * Keeps track on how many pointers are currently active.
 *
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */
mapbrowsereventhandler__ol_MapBrowserEventHandler_.prototype.updateActivePointers_ = function (pointerEvent) {
  var event = pointerEvent;

  if (event.type == mapbrowsereventtype["a" /* default */].POINTERUP || event.type == mapbrowsereventtype["a" /* default */].POINTERCANCEL) {
    delete this.trackedTouches_[event.pointerId];
  } else if (event.type == mapbrowsereventtype["a" /* default */].POINTERDOWN) {
    this.trackedTouches_[event.pointerId] = true;
  }
  this.activePointers_ = Object.keys(this.trackedTouches_).length;
};

/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */
mapbrowsereventhandler__ol_MapBrowserEventHandler_.prototype.handlePointerUp_ = function (pointerEvent) {
  this.updateActivePointers_(pointerEvent);
  var newEvent = new mapbrowserpointerevent(mapbrowsereventtype["a" /* default */].POINTERUP, this.map_, pointerEvent);
  this.dispatchEvent(newEvent);

  // We emulate click events on left mouse button click, touch contact, and pen
  // contact. isMouseActionButton returns true in these cases (evt.button is set
  // to 0).
  // See http://www.w3.org/TR/pointerevents/#button-states
  // We only fire click, singleclick, and doubleclick if nobody has called
  // event.stopPropagation() or event.preventDefault().
  if (!newEvent.propagationStopped && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
    this.emulateClick_(this.down_);
  }

  if (this.activePointers_ === 0) {
    this.dragListenerKeys_.forEach(ol_events["a" /* default */].unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.dragging_ = false;
    this.down_ = null;
    this.documentPointerEventHandler_.dispose();
    this.documentPointerEventHandler_ = null;
  }
};

/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @return {boolean} If the left mouse button was pressed.
 * @private
 */
mapbrowsereventhandler__ol_MapBrowserEventHandler_.prototype.isMouseActionButton_ = function (pointerEvent) {
  return pointerEvent.button === 0;
};

/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */
mapbrowsereventhandler__ol_MapBrowserEventHandler_.prototype.handlePointerDown_ = function (pointerEvent) {
  this.updateActivePointers_(pointerEvent);
  var newEvent = new mapbrowserpointerevent(mapbrowsereventtype["a" /* default */].POINTERDOWN, this.map_, pointerEvent);
  this.dispatchEvent(newEvent);

  this.down_ = pointerEvent;

  if (this.dragListenerKeys_.length === 0) {
    /* Set up a pointer event handler on the `document`,
     * which is required when the pointer is moved outside
     * the viewport when dragging.
     */
    this.documentPointerEventHandler_ = new pointereventhandler(document);

    this.dragListenerKeys_.push(ol_events["a" /* default */].listen(this.documentPointerEventHandler_, mapbrowsereventtype["a" /* default */].POINTERMOVE, this.handlePointerMove_, this), ol_events["a" /* default */].listen(this.documentPointerEventHandler_, mapbrowsereventtype["a" /* default */].POINTERUP, this.handlePointerUp_, this),
    /* Note that the listener for `pointercancel is set up on
    * `pointerEventHandler_` and not `documentPointerEventHandler_` like
    * the `pointerup` and `pointermove` listeners.
    *
    * The reason for this is the following: `TouchSource.vacuumTouches_()`
    * issues `pointercancel` events, when there was no `touchend` for a
    * `touchstart`. Now, let's say a first `touchstart` is registered on
    * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
    * But `documentPointerEventHandler_` doesn't know about the first
    * `touchstart`. If there is no `touchend` for the `touchstart`, we can
    * only receive a `touchcancel` from `pointerEventHandler_`, because it is
    * only registered there.
    */
    ol_events["a" /* default */].listen(this.pointerEventHandler_, mapbrowsereventtype["a" /* default */].POINTERCANCEL, this.handlePointerUp_, this));
  }
};

/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */
mapbrowsereventhandler__ol_MapBrowserEventHandler_.prototype.handlePointerMove_ = function (pointerEvent) {
  // Between pointerdown and pointerup, pointermove events are triggered.
  // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
  // moved a significant distance.
  if (this.isMoving_(pointerEvent)) {
    this.dragging_ = true;
    var newEvent = new mapbrowserpointerevent(mapbrowsereventtype["a" /* default */].POINTERDRAG, this.map_, pointerEvent, this.dragging_);
    this.dispatchEvent(newEvent);
  }

  // Some native android browser triggers mousemove events during small period
  // of time. See: https://code.google.com/p/android/issues/detail?id=5491 or
  // https://code.google.com/p/android/issues/detail?id=19827
  // ex: Galaxy Tab P3110 + Android 4.1.1
  pointerEvent.preventDefault();
};

/**
 * Wrap and relay a pointer event.  Note that this requires that the type
 * string for the MapBrowserPointerEvent matches the PointerEvent type.
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @private
 */
mapbrowsereventhandler__ol_MapBrowserEventHandler_.prototype.relayEvent_ = function (pointerEvent) {
  var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
  this.dispatchEvent(new mapbrowserpointerevent(pointerEvent.type, this.map_, pointerEvent, dragging));
};

/**
 * @param {ol.pointer.PointerEvent} pointerEvent Pointer event.
 * @return {boolean} Is moving.
 * @private
 */
mapbrowsereventhandler__ol_MapBrowserEventHandler_.prototype.isMoving_ = function (pointerEvent) {
  return Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
};

/**
 * @inheritDoc
 */
mapbrowsereventhandler__ol_MapBrowserEventHandler_.prototype.disposeInternal = function () {
  if (this.relayedListenerKey_) {
    ol_events["a" /* default */].unlistenByKey(this.relayedListenerKey_);
    this.relayedListenerKey_ = null;
  }
  if (this.pointerdownListenerKey_) {
    ol_events["a" /* default */].unlistenByKey(this.pointerdownListenerKey_);
    this.pointerdownListenerKey_ = null;
  }

  this.dragListenerKeys_.forEach(ol_events["a" /* default */].unlistenByKey);
  this.dragListenerKeys_.length = 0;

  if (this.documentPointerEventHandler_) {
    this.documentPointerEventHandler_.dispose();
    this.documentPointerEventHandler_ = null;
  }
  if (this.pointerEventHandler_) {
    this.pointerEventHandler_.dispose();
    this.pointerEventHandler_ = null;
  }
  eventtarget["a" /* default */].prototype.disposeInternal.call(this);
};
/* harmony default export */ var mapbrowsereventhandler = (mapbrowsereventhandler__ol_MapBrowserEventHandler_);
// EXTERNAL MODULE: ./node_modules/ol/mapeventtype.js
var mapeventtype = __webpack_require__(68);

// CONCATENATED MODULE: ./node_modules/ol/mapproperty.js
/**
 * @enum {string}
 */
var _ol_MapProperty_ = {
  LAYERGROUP: 'layergroup',
  SIZE: 'size',
  TARGET: 'target',
  VIEW: 'view'
};

/* harmony default export */ var mapproperty = (_ol_MapProperty_);
// EXTERNAL MODULE: ./node_modules/ol/object.js
var object = __webpack_require__(15);

// EXTERNAL MODULE: ./node_modules/ol/objecteventtype.js
var objecteventtype = __webpack_require__(54);

// EXTERNAL MODULE: ./node_modules/ol/tilestate.js
var tilestate = __webpack_require__(20);

// EXTERNAL MODULE: ./node_modules/ol/events/eventtype.js
var events_eventtype = __webpack_require__(4);

// EXTERNAL MODULE: ./node_modules/ol/asserts.js
var asserts = __webpack_require__(9);

// EXTERNAL MODULE: ./node_modules/ol/obj.js
var obj = __webpack_require__(2);

// CONCATENATED MODULE: ./node_modules/ol/structs/priorityqueue.js



/**
 * Priority queue.
 *
 * The implementation is inspired from the Closure Library's Heap class and
 * Python's heapq module.
 *
 * @see http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html
 * @see http://hg.python.org/cpython/file/2.7/Lib/heapq.py
 *
 * @constructor
 * @param {function(T): number} priorityFunction Priority function.
 * @param {function(T): string} keyFunction Key function.
 * @struct
 * @template T
 */
var _ol_structs_PriorityQueue_ = function _ol_structs_PriorityQueue_(priorityFunction, keyFunction) {

  /**
   * @type {function(T): number}
   * @private
   */
  this.priorityFunction_ = priorityFunction;

  /**
   * @type {function(T): string}
   * @private
   */
  this.keyFunction_ = keyFunction;

  /**
   * @type {Array.<T>}
   * @private
   */
  this.elements_ = [];

  /**
   * @type {Array.<number>}
   * @private
   */
  this.priorities_ = [];

  /**
   * @type {Object.<string, boolean>}
   * @private
   */
  this.queuedElements_ = {};
};

/**
 * @const
 * @type {number}
 */
_ol_structs_PriorityQueue_.DROP = Infinity;

/**
 * FIXME empty description for jsdoc
 */
_ol_structs_PriorityQueue_.prototype.clear = function () {
  this.elements_.length = 0;
  this.priorities_.length = 0;
  obj["a" /* default */].clear(this.queuedElements_);
};

/**
 * Remove and return the highest-priority element. O(log N).
 * @return {T} Element.
 */
_ol_structs_PriorityQueue_.prototype.dequeue = function () {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[0];
  if (elements.length == 1) {
    elements.length = 0;
    priorities.length = 0;
  } else {
    elements[0] = elements.pop();
    priorities[0] = priorities.pop();
    this.siftUp_(0);
  }
  var elementKey = this.keyFunction_(element);
  delete this.queuedElements_[elementKey];
  return element;
};

/**
 * Enqueue an element. O(log N).
 * @param {T} element Element.
 * @return {boolean} The element was added to the queue.
 */
_ol_structs_PriorityQueue_.prototype.enqueue = function (element) {
  asserts["a" /* default */].assert(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue
  var priority = this.priorityFunction_(element);
  if (priority != _ol_structs_PriorityQueue_.DROP) {
    this.elements_.push(element);
    this.priorities_.push(priority);
    this.queuedElements_[this.keyFunction_(element)] = true;
    this.siftDown_(0, this.elements_.length - 1);
    return true;
  }
  return false;
};

/**
 * @return {number} Count.
 */
_ol_structs_PriorityQueue_.prototype.getCount = function () {
  return this.elements_.length;
};

/**
 * Gets the index of the left child of the node at the given index.
 * @param {number} index The index of the node to get the left child for.
 * @return {number} The index of the left child.
 * @private
 */
_ol_structs_PriorityQueue_.prototype.getLeftChildIndex_ = function (index) {
  return index * 2 + 1;
};

/**
 * Gets the index of the right child of the node at the given index.
 * @param {number} index The index of the node to get the right child for.
 * @return {number} The index of the right child.
 * @private
 */
_ol_structs_PriorityQueue_.prototype.getRightChildIndex_ = function (index) {
  return index * 2 + 2;
};

/**
 * Gets the index of the parent of the node at the given index.
 * @param {number} index The index of the node to get the parent for.
 * @return {number} The index of the parent.
 * @private
 */
_ol_structs_PriorityQueue_.prototype.getParentIndex_ = function (index) {
  return index - 1 >> 1;
};

/**
 * Make this a heap. O(N).
 * @private
 */
_ol_structs_PriorityQueue_.prototype.heapify_ = function () {
  var i;
  for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
    this.siftUp_(i);
  }
};

/**
 * @return {boolean} Is empty.
 */
_ol_structs_PriorityQueue_.prototype.isEmpty = function () {
  return this.elements_.length === 0;
};

/**
 * @param {string} key Key.
 * @return {boolean} Is key queued.
 */
_ol_structs_PriorityQueue_.prototype.isKeyQueued = function (key) {
  return key in this.queuedElements_;
};

/**
 * @param {T} element Element.
 * @return {boolean} Is queued.
 */
_ol_structs_PriorityQueue_.prototype.isQueued = function (element) {
  return this.isKeyQueued(this.keyFunction_(element));
};

/**
 * @param {number} index The index of the node to move down.
 * @private
 */
_ol_structs_PriorityQueue_.prototype.siftUp_ = function (index) {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var count = elements.length;
  var element = elements[index];
  var priority = priorities[index];
  var startIndex = index;

  while (index < count >> 1) {
    var lIndex = this.getLeftChildIndex_(index);
    var rIndex = this.getRightChildIndex_(index);

    var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;

    elements[index] = elements[smallerChildIndex];
    priorities[index] = priorities[smallerChildIndex];
    index = smallerChildIndex;
  }

  elements[index] = element;
  priorities[index] = priority;
  this.siftDown_(startIndex, index);
};

/**
 * @param {number} startIndex The index of the root.
 * @param {number} index The index of the node to move up.
 * @private
 */
_ol_structs_PriorityQueue_.prototype.siftDown_ = function (startIndex, index) {
  var elements = this.elements_;
  var priorities = this.priorities_;
  var element = elements[index];
  var priority = priorities[index];

  while (index > startIndex) {
    var parentIndex = this.getParentIndex_(index);
    if (priorities[parentIndex] > priority) {
      elements[index] = elements[parentIndex];
      priorities[index] = priorities[parentIndex];
      index = parentIndex;
    } else {
      break;
    }
  }
  elements[index] = element;
  priorities[index] = priority;
};

/**
 * FIXME empty description for jsdoc
 */
_ol_structs_PriorityQueue_.prototype.reprioritize = function () {
  var priorityFunction = this.priorityFunction_;
  var elements = this.elements_;
  var priorities = this.priorities_;
  var index = 0;
  var n = elements.length;
  var element, i, priority;
  for (i = 0; i < n; ++i) {
    element = elements[i];
    priority = priorityFunction(element);
    if (priority == _ol_structs_PriorityQueue_.DROP) {
      delete this.queuedElements_[this.keyFunction_(element)];
    } else {
      priorities[index] = priority;
      elements[index++] = element;
    }
  }
  elements.length = index;
  priorities.length = index;
  this.heapify_();
};
/* harmony default export */ var priorityqueue = (_ol_structs_PriorityQueue_);
// CONCATENATED MODULE: ./node_modules/ol/tilequeue.js






/**
 * @constructor
 * @extends {ol.structs.PriorityQueue.<Array>}
 * @param {ol.TilePriorityFunction} tilePriorityFunction
 *     Tile priority function.
 * @param {function(): ?} tileChangeCallback
 *     Function called on each tile change event.
 * @struct
 */
var tilequeue__ol_TileQueue_ = function _ol_TileQueue_(tilePriorityFunction, tileChangeCallback) {

  priorityqueue.call(this,
  /**
   * @param {Array} element Element.
   * @return {number} Priority.
   */
  function (element) {
    return tilePriorityFunction.apply(null, element);
  },
  /**
   * @param {Array} element Element.
   * @return {string} Key.
   */
  function (element) {
    return (/** @type {ol.Tile} */element[0].getKey()
    );
  });

  /**
   * @private
   * @type {function(): ?}
   */
  this.tileChangeCallback_ = tileChangeCallback;

  /**
   * @private
   * @type {number}
   */
  this.tilesLoading_ = 0;

  /**
   * @private
   * @type {!Object.<string,boolean>}
   */
  this.tilesLoadingKeys_ = {};
};

ol["a" /* default */].inherits(tilequeue__ol_TileQueue_, priorityqueue);

/**
 * @inheritDoc
 */
tilequeue__ol_TileQueue_.prototype.enqueue = function (element) {
  var added = priorityqueue.prototype.enqueue.call(this, element);
  if (added) {
    var tile = element[0];
    ol_events["a" /* default */].listen(tile, events_eventtype["a" /* default */].CHANGE, this.handleTileChange, this);
  }
  return added;
};

/**
 * @return {number} Number of tiles loading.
 */
tilequeue__ol_TileQueue_.prototype.getTilesLoading = function () {
  return this.tilesLoading_;
};

/**
 * @param {ol.events.Event} event Event.
 * @protected
 */
tilequeue__ol_TileQueue_.prototype.handleTileChange = function (event) {
  var tile = /** @type {ol.Tile} */event.target;
  var state = tile.getState();
  if (state === tilestate["a" /* default */].LOADED || state === tilestate["a" /* default */].ERROR || state === tilestate["a" /* default */].EMPTY || state === tilestate["a" /* default */].ABORT) {
    ol_events["a" /* default */].unlisten(tile, events_eventtype["a" /* default */].CHANGE, this.handleTileChange, this);
    var tileKey = tile.getKey();
    if (tileKey in this.tilesLoadingKeys_) {
      delete this.tilesLoadingKeys_[tileKey];
      --this.tilesLoading_;
    }
    this.tileChangeCallback_();
  }
};

/**
 * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
 * @param {number} maxNewLoads Maximum number of new tiles to load.
 */
tilequeue__ol_TileQueue_.prototype.loadMoreTiles = function (maxTotalLoading, maxNewLoads) {
  var newLoads = 0;
  var abortedTiles = false;
  var state, tile, tileKey;
  while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
    tile = /** @type {ol.Tile} */this.dequeue()[0];
    tileKey = tile.getKey();
    state = tile.getState();
    if (state === tilestate["a" /* default */].ABORT) {
      abortedTiles = true;
    } else if (state === tilestate["a" /* default */].IDLE && !(tileKey in this.tilesLoadingKeys_)) {
      this.tilesLoadingKeys_[tileKey] = true;
      ++this.tilesLoading_;
      ++newLoads;
      tile.load();
    }
  }
  if (newLoads === 0 && abortedTiles) {
    // Do not stop the render loop when all wanted tiles were aborted due to
    // a small, saturated tile cache.
    this.tileChangeCallback_();
  }
};
/* harmony default export */ var tilequeue = (tilequeue__ol_TileQueue_);
// EXTERNAL MODULE: ./node_modules/ol/view.js + 3 modules
var ol_view = __webpack_require__(83);

// EXTERNAL MODULE: ./node_modules/ol/viewhint.js
var viewhint = __webpack_require__(17);

// EXTERNAL MODULE: ./node_modules/ol/dom.js
var dom = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__(1);

// EXTERNAL MODULE: ./node_modules/ol/functions.js
var functions = __webpack_require__(13);

// EXTERNAL MODULE: ./node_modules/ol/layer/base.js
var base = __webpack_require__(84);

// EXTERNAL MODULE: ./node_modules/ol/source/state.js
var source_state = __webpack_require__(35);

// CONCATENATED MODULE: ./node_modules/ol/layer/group.js













/**
 * @classdesc
 * A {@link ol.Collection} of layers that are handled together.
 *
 * A generic `change` event is triggered when the group/Collection changes.
 *
 * @constructor
 * @extends {ol.layer.Base}
 * @param {olx.layer.GroupOptions=} opt_options Layer options.
 * @api
 */
var group__ol_layer_Group_ = function _ol_layer_Group_(opt_options) {

  var options = opt_options || {};
  var baseOptions = /** @type {olx.layer.GroupOptions} */
  obj["a" /* default */].assign({}, options);
  delete baseOptions.layers;

  var layers = options.layers;

  base["a" /* default */].call(this, baseOptions);

  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */
  this.layersListenerKeys_ = [];

  /**
   * @private
   * @type {Object.<string, Array.<ol.EventsKey>>}
   */
  this.listenerKeys_ = {};

  ol_events["a" /* default */].listen(this, object["a" /* default */].getChangeEventType(_ol_layer_Group_.Property_.LAYERS), this.handleLayersChanged_, this);

  if (layers) {
    if (Array.isArray(layers)) {
      layers = new collection["a" /* default */](layers.slice(), { unique: true });
    } else {
      asserts["a" /* default */].assert(layers instanceof collection["a" /* default */], 43); // Expected `layers` to be an array or an `ol.Collection`
      layers = layers;
    }
  } else {
    layers = new collection["a" /* default */](undefined, { unique: true });
  }

  this.setLayers(layers);
};

ol["a" /* default */].inherits(group__ol_layer_Group_, base["a" /* default */]);

/**
 * @private
 */
group__ol_layer_Group_.prototype.handleLayerChange_ = function () {
  this.changed();
};

/**
 * @param {ol.events.Event} event Event.
 * @private
 */
group__ol_layer_Group_.prototype.handleLayersChanged_ = function (event) {
  this.layersListenerKeys_.forEach(ol_events["a" /* default */].unlistenByKey);
  this.layersListenerKeys_.length = 0;

  var layers = this.getLayers();
  this.layersListenerKeys_.push(ol_events["a" /* default */].listen(layers, collectioneventtype["a" /* default */].ADD, this.handleLayersAdd_, this), ol_events["a" /* default */].listen(layers, collectioneventtype["a" /* default */].REMOVE, this.handleLayersRemove_, this));

  for (var id in this.listenerKeys_) {
    this.listenerKeys_[id].forEach(ol_events["a" /* default */].unlistenByKey);
  }
  obj["a" /* default */].clear(this.listenerKeys_);

  var layersArray = layers.getArray();
  var i, ii, layer;
  for (i = 0, ii = layersArray.length; i < ii; i++) {
    layer = layersArray[i];
    this.listenerKeys_[ol["a" /* default */].getUid(layer).toString()] = [ol_events["a" /* default */].listen(layer, objecteventtype["a" /* default */].PROPERTYCHANGE, this.handleLayerChange_, this), ol_events["a" /* default */].listen(layer, events_eventtype["a" /* default */].CHANGE, this.handleLayerChange_, this)];
  }

  this.changed();
};

/**
 * @param {ol.Collection.Event} collectionEvent Collection event.
 * @private
 */
group__ol_layer_Group_.prototype.handleLayersAdd_ = function (collectionEvent) {
  var layer = /** @type {ol.layer.Base} */collectionEvent.element;
  var key = ol["a" /* default */].getUid(layer).toString();
  this.listenerKeys_[key] = [ol_events["a" /* default */].listen(layer, objecteventtype["a" /* default */].PROPERTYCHANGE, this.handleLayerChange_, this), ol_events["a" /* default */].listen(layer, events_eventtype["a" /* default */].CHANGE, this.handleLayerChange_, this)];
  this.changed();
};

/**
 * @param {ol.Collection.Event} collectionEvent Collection event.
 * @private
 */
group__ol_layer_Group_.prototype.handleLayersRemove_ = function (collectionEvent) {
  var layer = /** @type {ol.layer.Base} */collectionEvent.element;
  var key = ol["a" /* default */].getUid(layer).toString();
  this.listenerKeys_[key].forEach(ol_events["a" /* default */].unlistenByKey);
  delete this.listenerKeys_[key];
  this.changed();
};

/**
 * Returns the {@link ol.Collection collection} of {@link ol.layer.Layer layers}
 * in this group.
 * @return {!ol.Collection.<ol.layer.Base>} Collection of
 *   {@link ol.layer.Base layers} that are part of this group.
 * @observable
 * @api
 */
group__ol_layer_Group_.prototype.getLayers = function () {
  return (
    /** @type {!ol.Collection.<ol.layer.Base>} */this.get(group__ol_layer_Group_.Property_.LAYERS)
  );
};

/**
 * Set the {@link ol.Collection collection} of {@link ol.layer.Layer layers}
 * in this group.
 * @param {!ol.Collection.<ol.layer.Base>} layers Collection of
 *   {@link ol.layer.Base layers} that are part of this group.
 * @observable
 * @api
 */
group__ol_layer_Group_.prototype.setLayers = function (layers) {
  this.set(group__ol_layer_Group_.Property_.LAYERS, layers);
};

/**
 * @inheritDoc
 */
group__ol_layer_Group_.prototype.getLayersArray = function (opt_array) {
  var array = opt_array !== undefined ? opt_array : [];
  this.getLayers().forEach(function (layer) {
    layer.getLayersArray(array);
  });
  return array;
};

/**
 * @inheritDoc
 */
group__ol_layer_Group_.prototype.getLayerStatesArray = function (opt_states) {
  var states = opt_states !== undefined ? opt_states : [];

  var pos = states.length;

  this.getLayers().forEach(function (layer) {
    layer.getLayerStatesArray(states);
  });

  var ownLayerState = this.getLayerState();
  var i, ii, layerState;
  for (i = pos, ii = states.length; i < ii; i++) {
    layerState = states[i];
    layerState.opacity *= ownLayerState.opacity;
    layerState.visible = layerState.visible && ownLayerState.visible;
    layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
    layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
    if (ownLayerState.extent !== undefined) {
      if (layerState.extent !== undefined) {
        layerState.extent = ol_extent["a" /* default */].getIntersection(layerState.extent, ownLayerState.extent);
      } else {
        layerState.extent = ownLayerState.extent;
      }
    }
  }

  return states;
};

/**
 * @inheritDoc
 */
group__ol_layer_Group_.prototype.getSourceState = function () {
  return source_state["a" /* default */].READY;
};

/**
 * @enum {string}
 * @private
 */
group__ol_layer_Group_.Property_ = {
  LAYERS: 'layers'
};
/* harmony default export */ var layer_group = (group__ol_layer_Group_);
// CONCATENATED MODULE: ./node_modules/ol/plugintype.js
/**
 * A plugin type used when registering a plugin.  The supported plugin types are
 * 'MAP_RENDERER', and 'LAYER_RENDERER'.
 * @enum {string}
 */
var _ol_PluginType_ = {
  MAP_RENDERER: 'MAP_RENDERER',
  LAYER_RENDERER: 'LAYER_RENDERER'
};

/* harmony default export */ var plugintype = (_ol_PluginType_);
// CONCATENATED MODULE: ./node_modules/ol/plugins.js

var _ol_plugins_ = {};

/**
 * The registry of map renderer plugins.
 * @type {Array<olx.MapRendererPlugin>}
 * @private
 */
_ol_plugins_.mapRendererPlugins_ = [];

/**
 * Get all registered map renderer plugins.
 * @return {Array<olx.MapRendererPlugin>} The registered map renderer plugins.
 */
_ol_plugins_.getMapRendererPlugins = function () {
  return _ol_plugins_.mapRendererPlugins_;
};

/**
 * The registry of layer renderer plugins.
 * @type {Array<olx.LayerRendererPlugin>}
 * @private
 */
_ol_plugins_.layerRendererPlugins_ = [];

/**
 * Get all registered layer renderer plugins.
 * @return {Array<olx.LayerRendererPlugin>} The registered layer renderer plugins.
 */
_ol_plugins_.getLayerRendererPlugins = function () {
  return _ol_plugins_.layerRendererPlugins_;
};

/**
 * Register a plugin.
 * @param {ol.PluginType} type The plugin type.
 * @param {*} plugin The plugin.
 */
_ol_plugins_.register = function (type, plugin) {
  var plugins;
  switch (type) {
    case plugintype.MAP_RENDERER:
      {
        plugins = _ol_plugins_.mapRendererPlugins_;
        plugins.push( /** @type {olx.MapRendererPlugin} */plugin);
        break;
      }
    case plugintype.LAYER_RENDERER:
      {
        plugins = _ol_plugins_.layerRendererPlugins_;
        plugins.push( /** @type {olx.LayerRendererPlugin} */plugin);
        break;
      }
    default:
      {
        throw new Error('Unsupported plugin type: ' + type);
      }
  }
};

/**
 * Register multiple plugins.
 * @param {ol.PluginType} type The plugin type.
 * @param {Array} plugins The plugins.
 */
_ol_plugins_.registerMultiple = function (type, plugins) {
  for (var i = 0, ii = plugins.length; i < ii; ++i) {
    _ol_plugins_.register(type, plugins[i]);
  }
};
/* harmony default export */ var ol_plugins = (_ol_plugins_);
// CONCATENATED MODULE: ./node_modules/ol/renderer/type.js
/**
 * Available renderers: `'canvas'` or `'webgl'`.
 * @enum {string}
 */
var _ol_renderer_Type_ = {
  CANVAS: 'canvas',
  WEBGL: 'webgl'
};

/* harmony default export */ var renderer_type = (_ol_renderer_Type_);
// EXTERNAL MODULE: ./node_modules/ol/size.js
var ol_size = __webpack_require__(53);

// EXTERNAL MODULE: ./node_modules/ol/transform.js
var ol_transform = __webpack_require__(11);

// CONCATENATED MODULE: ./node_modules/ol/pluggablemap.js






























/**
 * @constructor
 * @extends {ol.Object}
 * @param {olx.MapOptions} options Map options.
 * @fires ol.MapBrowserEvent
 * @fires ol.MapEvent
 * @fires ol.render.Event#postcompose
 * @fires ol.render.Event#precompose
 * @api
 */
var pluggablemap__ol_PluggableMap_ = function _ol_PluggableMap_(options) {

  object["a" /* default */].call(this);

  var optionsInternal = _ol_PluggableMap_.createOptionsInternal(options);

  /**
   * @type {boolean}
   * @private
   */
  this.loadTilesWhileAnimating_ = options.loadTilesWhileAnimating !== undefined ? options.loadTilesWhileAnimating : false;

  /**
   * @type {boolean}
   * @private
   */
  this.loadTilesWhileInteracting_ = options.loadTilesWhileInteracting !== undefined ? options.loadTilesWhileInteracting : false;

  /**
   * @private
   * @type {number}
   */
  this.pixelRatio_ = options.pixelRatio !== undefined ? options.pixelRatio : has["a" /* default */].DEVICE_PIXEL_RATIO;

  /**
   * @private
   * @type {Object.<string, string>}
   */
  this.logos_ = optionsInternal.logos;

  /**
   * @private
   * @type {number|undefined}
   */
  this.animationDelayKey_;

  /**
   * @private
   */
  this.animationDelay_ = function () {
    this.animationDelayKey_ = undefined;
    this.renderFrame_.call(this, Date.now());
  }.bind(this);

  /**
   * @private
   * @type {ol.Transform}
   */
  this.coordinateToPixelTransform_ = ol_transform["a" /* default */].create();

  /**
   * @private
   * @type {ol.Transform}
   */
  this.pixelToCoordinateTransform_ = ol_transform["a" /* default */].create();

  /**
   * @private
   * @type {number}
   */
  this.frameIndex_ = 0;

  /**
   * @private
   * @type {?olx.FrameState}
   */
  this.frameState_ = null;

  /**
   * The extent at the previous 'moveend' event.
   * @private
   * @type {ol.Extent}
   */
  this.previousExtent_ = null;

  /**
   * @private
   * @type {?ol.EventsKey}
   */
  this.viewPropertyListenerKey_ = null;

  /**
   * @private
   * @type {?ol.EventsKey}
   */
  this.viewChangeListenerKey_ = null;

  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */
  this.layerGroupPropertyListenerKeys_ = null;

  /**
   * @private
   * @type {Element}
   */
  this.viewport_ = document.createElement('DIV');
  this.viewport_.className = 'ol-viewport' + (has["a" /* default */].TOUCH ? ' ol-touch' : '');
  this.viewport_.style.position = 'relative';
  this.viewport_.style.overflow = 'hidden';
  this.viewport_.style.width = '100%';
  this.viewport_.style.height = '100%';
  // prevent page zoom on IE >= 10 browsers
  this.viewport_.style.msTouchAction = 'none';
  this.viewport_.style.touchAction = 'none';

  /**
   * @private
   * @type {!Element}
   */
  this.overlayContainer_ = document.createElement('DIV');
  this.overlayContainer_.className = 'ol-overlaycontainer';
  this.viewport_.appendChild(this.overlayContainer_);

  /**
   * @private
   * @type {!Element}
   */
  this.overlayContainerStopEvent_ = document.createElement('DIV');
  this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
  var overlayEvents = [events_eventtype["a" /* default */].CLICK, events_eventtype["a" /* default */].DBLCLICK, events_eventtype["a" /* default */].MOUSEDOWN, events_eventtype["a" /* default */].TOUCHSTART, events_eventtype["a" /* default */].MSPOINTERDOWN, mapbrowsereventtype["a" /* default */].POINTERDOWN, events_eventtype["a" /* default */].MOUSEWHEEL, events_eventtype["a" /* default */].WHEEL];
  for (var i = 0, ii = overlayEvents.length; i < ii; ++i) {
    ol_events["a" /* default */].listen(this.overlayContainerStopEvent_, overlayEvents[i], events_event["a" /* default */].stopPropagation);
  }
  this.viewport_.appendChild(this.overlayContainerStopEvent_);

  /**
   * @private
   * @type {ol.MapBrowserEventHandler}
   */
  this.mapBrowserEventHandler_ = new mapbrowsereventhandler(this, options.moveTolerance);
  for (var key in mapbrowsereventtype["a" /* default */]) {
    ol_events["a" /* default */].listen(this.mapBrowserEventHandler_, mapbrowsereventtype["a" /* default */][key], this.handleMapBrowserEvent, this);
  }

  /**
   * @private
   * @type {Element|Document}
   */
  this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;

  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */
  this.keyHandlerKeys_ = null;

  ol_events["a" /* default */].listen(this.viewport_, events_eventtype["a" /* default */].WHEEL, this.handleBrowserEvent, this);
  ol_events["a" /* default */].listen(this.viewport_, events_eventtype["a" /* default */].MOUSEWHEEL, this.handleBrowserEvent, this);

  /**
   * @type {ol.Collection.<ol.control.Control>}
   * @protected
   */
  this.controls = optionsInternal.controls || new collection["a" /* default */]();

  /**
   * @type {ol.Collection.<ol.interaction.Interaction>}
   * @protected
   */
  this.interactions = optionsInternal.interactions || new collection["a" /* default */]();

  /**
   * @type {ol.Collection.<ol.Overlay>}
   * @private
   */
  this.overlays_ = optionsInternal.overlays;

  /**
   * A lookup of overlays by id.
   * @private
   * @type {Object.<string, ol.Overlay>}
   */
  this.overlayIdIndex_ = {};

  /**
   * @type {ol.renderer.Map}
   * @private
   */
  this.renderer_ = optionsInternal.mapRendererPlugin['create'](this.viewport_, this);

  /**
   * @type {function(Event)|undefined}
   * @private
   */
  this.handleResize_;

  /**
   * @private
   * @type {ol.Coordinate}
   */
  this.focus_ = null;

  /**
   * @private
   * @type {Array.<ol.PostRenderFunction>}
   */
  this.postRenderFunctions_ = [];

  /**
   * @private
   * @type {ol.TileQueue}
   */
  this.tileQueue_ = new tilequeue(this.getTilePriority.bind(this), this.handleTileChange_.bind(this));

  /**
   * Uids of features to skip at rendering time.
   * @type {Object.<string, boolean>}
   * @private
   */
  this.skippedFeatureUids_ = {};

  ol_events["a" /* default */].listen(this, object["a" /* default */].getChangeEventType(mapproperty.LAYERGROUP), this.handleLayerGroupChanged_, this);
  ol_events["a" /* default */].listen(this, object["a" /* default */].getChangeEventType(mapproperty.VIEW), this.handleViewChanged_, this);
  ol_events["a" /* default */].listen(this, object["a" /* default */].getChangeEventType(mapproperty.SIZE), this.handleSizeChanged_, this);
  ol_events["a" /* default */].listen(this, object["a" /* default */].getChangeEventType(mapproperty.TARGET), this.handleTargetChanged_, this);

  // setProperties will trigger the rendering of the map if the map
  // is "defined" already.
  this.setProperties(optionsInternal.values);

  this.controls.forEach(
  /**
   * @param {ol.control.Control} control Control.
   * @this {ol.PluggableMap}
   */
  function (control) {
    control.setMap(this);
  }, this);

  ol_events["a" /* default */].listen(this.controls, collectioneventtype["a" /* default */].ADD,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    event.element.setMap(this);
  }, this);

  ol_events["a" /* default */].listen(this.controls, collectioneventtype["a" /* default */].REMOVE,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    event.element.setMap(null);
  }, this);

  this.interactions.forEach(
  /**
   * @param {ol.interaction.Interaction} interaction Interaction.
   * @this {ol.PluggableMap}
   */
  function (interaction) {
    interaction.setMap(this);
  }, this);

  ol_events["a" /* default */].listen(this.interactions, collectioneventtype["a" /* default */].ADD,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    event.element.setMap(this);
  }, this);

  ol_events["a" /* default */].listen(this.interactions, collectioneventtype["a" /* default */].REMOVE,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    event.element.setMap(null);
  }, this);

  this.overlays_.forEach(this.addOverlayInternal_, this);

  ol_events["a" /* default */].listen(this.overlays_, collectioneventtype["a" /* default */].ADD,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    this.addOverlayInternal_( /** @type {ol.Overlay} */event.element);
  }, this);

  ol_events["a" /* default */].listen(this.overlays_, collectioneventtype["a" /* default */].REMOVE,
  /**
   * @param {ol.Collection.Event} event Collection event.
   */
  function (event) {
    var overlay = /** @type {ol.Overlay} */event.element;
    var id = overlay.getId();
    if (id !== undefined) {
      delete this.overlayIdIndex_[id.toString()];
    }
    event.element.setMap(null);
  }, this);
};

ol["a" /* default */].inherits(pluggablemap__ol_PluggableMap_, object["a" /* default */]);

/**
 * Add the given control to the map.
 * @param {ol.control.Control} control Control.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.addControl = function (control) {
  this.getControls().push(control);
};

/**
 * Add the given interaction to the map.
 * @param {ol.interaction.Interaction} interaction Interaction to add.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.addInteraction = function (interaction) {
  this.getInteractions().push(interaction);
};

/**
 * Adds the given layer to the top of this map. If you want to add a layer
 * elsewhere in the stack, use `getLayers()` and the methods available on
 * {@link ol.Collection}.
 * @param {ol.layer.Base} layer Layer.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.addLayer = function (layer) {
  var layers = this.getLayerGroup().getLayers();
  layers.push(layer);
};

/**
 * Add the given overlay to the map.
 * @param {ol.Overlay} overlay Overlay.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.addOverlay = function (overlay) {
  this.getOverlays().push(overlay);
};

/**
 * This deals with map's overlay collection changes.
 * @param {ol.Overlay} overlay Overlay.
 * @private
 */
pluggablemap__ol_PluggableMap_.prototype.addOverlayInternal_ = function (overlay) {
  var id = overlay.getId();
  if (id !== undefined) {
    this.overlayIdIndex_[id.toString()] = overlay;
  }
  overlay.setMap(this);
};

/**
 *
 * @inheritDoc
 */
pluggablemap__ol_PluggableMap_.prototype.disposeInternal = function () {
  this.mapBrowserEventHandler_.dispose();
  ol_events["a" /* default */].unlisten(this.viewport_, events_eventtype["a" /* default */].WHEEL, this.handleBrowserEvent, this);
  ol_events["a" /* default */].unlisten(this.viewport_, events_eventtype["a" /* default */].MOUSEWHEEL, this.handleBrowserEvent, this);
  if (this.handleResize_ !== undefined) {
    window.removeEventListener(events_eventtype["a" /* default */].RESIZE, this.handleResize_, false);
    this.handleResize_ = undefined;
  }
  if (this.animationDelayKey_) {
    cancelAnimationFrame(this.animationDelayKey_);
    this.animationDelayKey_ = undefined;
  }
  this.setTarget(null);
  object["a" /* default */].prototype.disposeInternal.call(this);
};

/**
 * Detect features that intersect a pixel on the viewport, and execute a
 * callback with each intersecting feature. Layers included in the detection can
 * be configured through the `layerFilter` option in `opt_options`.
 * @param {ol.Pixel} pixel Pixel.
 * @param {function(this: S, (ol.Feature|ol.render.Feature),
 *     ol.layer.Layer): T} callback Feature callback. The callback will be
 *     called with two arguments. The first argument is one
 *     {@link ol.Feature feature} or
 *     {@link ol.render.Feature render feature} at the pixel, the second is
 *     the {@link ol.layer.Layer layer} of the feature and will be null for
 *     unmanaged layers. To stop detection, callback functions can return a
 *     truthy value.
 * @param {olx.AtPixelOptions=} opt_options Optional options.
 * @return {T|undefined} Callback result, i.e. the return value of last
 * callback execution, or the first truthy callback return value.
 * @template S,T
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {
  if (!this.frameState_) {
    return;
  }
  var coordinate = this.getCoordinateFromPixel(pixel);
  opt_options = opt_options !== undefined ? opt_options : {};
  var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
  var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : functions["a" /* default */].TRUE;
  return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, callback, null, layerFilter, null);
};

/**
 * Get all features that intersect a pixel on the viewport.
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.AtPixelOptions=} opt_options Optional options.
 * @return {Array.<ol.Feature|ol.render.Feature>} The detected features or
 * `null` if none were found.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.getFeaturesAtPixel = function (pixel, opt_options) {
  var features = null;
  this.forEachFeatureAtPixel(pixel, function (feature) {
    if (!features) {
      features = [];
    }
    features.push(feature);
  }, opt_options);
  return features;
};

/**
 * Detect layers that have a color value at a pixel on the viewport, and
 * execute a callback with each matching layer. Layers included in the
 * detection can be configured through `opt_layerFilter`.
 * @param {ol.Pixel} pixel Pixel.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback
 *     Layer callback. This callback will receive two arguments: first is the
 *     {@link ol.layer.Layer layer}, second argument is an array representing
 *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
 *     that do not currently support this argument. To stop detection, callback
 *     functions can return a truthy value.
 * @param {S=} opt_this Value to use as `this` when executing `callback`.
 * @param {(function(this: U, ol.layer.Layer): boolean)=} opt_layerFilter Layer
 *     filter function. The filter function will receive one argument, the
 *     {@link ol.layer.Layer layer-candidate} and it should return a boolean
 *     value. Only layers which are visible and for which this function returns
 *     `true` will be tested for features. By default, all visible layers will
 *     be tested.
 * @param {U=} opt_this2 Value to use as `this` when executing `layerFilter`.
 * @return {T|undefined} Callback result, i.e. the return value of last
 * callback execution, or the first truthy callback return value.
 * @template S,T,U
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.forEachLayerAtPixel = function (pixel, callback, opt_this, opt_layerFilter, opt_this2) {
  if (!this.frameState_) {
    return;
  }
  var thisArg = opt_this !== undefined ? opt_this : null;
  var layerFilter = opt_layerFilter !== undefined ? opt_layerFilter : functions["a" /* default */].TRUE;
  var thisArg2 = opt_this2 !== undefined ? opt_this2 : null;
  return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, callback, thisArg, layerFilter, thisArg2);
};

/**
 * Detect if features intersect a pixel on the viewport. Layers included in the
 * detection can be configured through `opt_layerFilter`.
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.AtPixelOptions=} opt_options Optional options.
 * @return {boolean} Is there a feature at the given pixel?
 * @template U
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.hasFeatureAtPixel = function (pixel, opt_options) {
  if (!this.frameState_) {
    return false;
  }
  var coordinate = this.getCoordinateFromPixel(pixel);
  opt_options = opt_options !== undefined ? opt_options : {};
  var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : functions["a" /* default */].TRUE;
  var hitTolerance = opt_options.hitTolerance !== undefined ? opt_options.hitTolerance * this.frameState_.pixelRatio : 0;
  return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, layerFilter, null);
};

/**
 * Returns the coordinate in view projection for a browser event.
 * @param {Event} event Event.
 * @return {ol.Coordinate} Coordinate.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.getEventCoordinate = function (event) {
  return this.getCoordinateFromPixel(this.getEventPixel(event));
};

/**
 * Returns the map pixel position for a browser event relative to the viewport.
 * @param {Event} event Event.
 * @return {ol.Pixel} Pixel.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.getEventPixel = function (event) {
  var viewportPosition = this.viewport_.getBoundingClientRect();
  var eventPosition = event.changedTouches ? event.changedTouches[0] : event;
  return [eventPosition.clientX - viewportPosition.left, eventPosition.clientY - viewportPosition.top];
};

/**
 * Get the target in which this map is rendered.
 * Note that this returns what is entered as an option or in setTarget:
 * if that was an element, it returns an element; if a string, it returns that.
 * @return {Element|string|undefined} The Element or id of the Element that the
 *     map is rendered in.
 * @observable
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.getTarget = function () {
  return (
    /** @type {Element|string|undefined} */this.get(mapproperty.TARGET)
  );
};

/**
 * Get the DOM element into which this map is rendered. In contrast to
 * `getTarget` this method always return an `Element`, or `null` if the
 * map has no target.
 * @return {Element} The element that the map is rendered in.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.getTargetElement = function () {
  var target = this.getTarget();
  if (target !== undefined) {
    return typeof target === 'string' ? document.getElementById(target) : target;
  } else {
    return null;
  }
};

/**
 * Get the coordinate for a given pixel.  This returns a coordinate in the
 * map view projection.
 * @param {ol.Pixel} pixel Pixel position in the map viewport.
 * @return {ol.Coordinate} The coordinate for the pixel position.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.getCoordinateFromPixel = function (pixel) {
  var frameState = this.frameState_;
  if (!frameState) {
    return null;
  } else {
    return ol_transform["a" /* default */].apply(frameState.pixelToCoordinateTransform, pixel.slice());
  }
};

/**
 * Get the map controls. Modifying this collection changes the controls
 * associated with the map.
 * @return {ol.Collection.<ol.control.Control>} Controls.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.getControls = function () {
  return this.controls;
};

/**
 * Get the map overlays. Modifying this collection changes the overlays
 * associated with the map.
 * @return {ol.Collection.<ol.Overlay>} Overlays.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.getOverlays = function () {
  return this.overlays_;
};

/**
 * Get an overlay by its identifier (the value returned by overlay.getId()).
 * Note that the index treats string and numeric identifiers as the same. So
 * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
 * @param {string|number} id Overlay identifier.
 * @return {ol.Overlay} Overlay.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.getOverlayById = function (id) {
  var overlay = this.overlayIdIndex_[id.toString()];
  return overlay !== undefined ? overlay : null;
};

/**
 * Get the map interactions. Modifying this collection changes the interactions
 * associated with the map.
 *
 * Interactions are used for e.g. pan, zoom and rotate.
 * @return {ol.Collection.<ol.interaction.Interaction>} Interactions.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.getInteractions = function () {
  return this.interactions;
};

/**
 * Get the layergroup associated with this map.
 * @return {ol.layer.Group} A layer group containing the layers in this map.
 * @observable
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.getLayerGroup = function () {
  return (
    /** @type {ol.layer.Group} */this.get(mapproperty.LAYERGROUP)
  );
};

/**
 * Get the collection of layers associated with this map.
 * @return {!ol.Collection.<ol.layer.Base>} Layers.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.getLayers = function () {
  var layers = this.getLayerGroup().getLayers();
  return layers;
};

/**
 * Get the pixel for a coordinate.  This takes a coordinate in the map view
 * projection and returns the corresponding pixel.
 * @param {ol.Coordinate} coordinate A map coordinate.
 * @return {ol.Pixel} A pixel position in the map viewport.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.getPixelFromCoordinate = function (coordinate) {
  var frameState = this.frameState_;
  if (!frameState) {
    return null;
  } else {
    return ol_transform["a" /* default */].apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
  }
};

/**
 * Get the map renderer.
 * @return {ol.renderer.Map} Renderer
 */
pluggablemap__ol_PluggableMap_.prototype.getRenderer = function () {
  return this.renderer_;
};

/**
 * Get the size of this map.
 * @return {ol.Size|undefined} The size in pixels of the map in the DOM.
 * @observable
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.getSize = function () {
  return (
    /** @type {ol.Size|undefined} */this.get(mapproperty.SIZE)
  );
};

/**
 * Get the view associated with this map. A view manages properties such as
 * center and resolution.
 * @return {ol.View} The view that controls this map.
 * @observable
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.getView = function () {
  return (
    /** @type {ol.View} */this.get(mapproperty.VIEW)
  );
};

/**
 * Get the element that serves as the map viewport.
 * @return {Element} Viewport.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.getViewport = function () {
  return this.viewport_;
};

/**
 * Get the element that serves as the container for overlays.  Elements added to
 * this container will let mousedown and touchstart events through to the map,
 * so clicks and gestures on an overlay will trigger {@link ol.MapBrowserEvent}
 * events.
 * @return {!Element} The map's overlay container.
 */
pluggablemap__ol_PluggableMap_.prototype.getOverlayContainer = function () {
  return this.overlayContainer_;
};

/**
 * Get the element that serves as a container for overlays that don't allow
 * event propagation. Elements added to this container won't let mousedown and
 * touchstart events through to the map, so clicks and gestures on an overlay
 * don't trigger any {@link ol.MapBrowserEvent}.
 * @return {!Element} The map's overlay container that stops events.
 */
pluggablemap__ol_PluggableMap_.prototype.getOverlayContainerStopEvent = function () {
  return this.overlayContainerStopEvent_;
};

/**
 * @param {ol.Tile} tile Tile.
 * @param {string} tileSourceKey Tile source key.
 * @param {ol.Coordinate} tileCenter Tile center.
 * @param {number} tileResolution Tile resolution.
 * @return {number} Tile priority.
 */
pluggablemap__ol_PluggableMap_.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {
  // Filter out tiles at higher zoom levels than the current zoom level, or that
  // are outside the visible extent.
  var frameState = this.frameState_;
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return priorityqueue.DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
    return priorityqueue.DROP;
  }
  // Prioritize the highest zoom level tiles closest to the focus.
  // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
  // Within a zoom level, tiles are prioritized by the distance in pixels
  // between the center of the tile and the focus.  The factor of 65536 means
  // that the prioritization should behave as desired for tiles up to
  // 65536 * Math.log(2) = 45426 pixels from the focus.
  var deltaX = tileCenter[0] - frameState.focus[0];
  var deltaY = tileCenter[1] - frameState.focus[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
};

/**
 * @param {Event} browserEvent Browser event.
 * @param {string=} opt_type Type.
 */
pluggablemap__ol_PluggableMap_.prototype.handleBrowserEvent = function (browserEvent, opt_type) {
  var type = opt_type || browserEvent.type;
  var mapBrowserEvent = new mapbrowserevent(type, this, browserEvent);
  this.handleMapBrowserEvent(mapBrowserEvent);
};

/**
 * @param {ol.MapBrowserEvent} mapBrowserEvent The event to handle.
 */
pluggablemap__ol_PluggableMap_.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {
  if (!this.frameState_) {
    // With no view defined, we cannot translate pixels into geographical
    // coordinates so interactions cannot be used.
    return;
  }
  this.focus_ = mapBrowserEvent.coordinate;
  mapBrowserEvent.frameState = this.frameState_;
  var interactionsArray = this.getInteractions().getArray();
  var i;
  if (this.dispatchEvent(mapBrowserEvent) !== false) {
    for (i = interactionsArray.length - 1; i >= 0; i--) {
      var interaction = interactionsArray[i];
      if (!interaction.getActive()) {
        continue;
      }
      var cont = interaction.handleEvent(mapBrowserEvent);
      if (!cont) {
        break;
      }
    }
  }
};

/**
 * @protected
 */
pluggablemap__ol_PluggableMap_.prototype.handlePostRender = function () {

  var frameState = this.frameState_;

  // Manage the tile queue
  // Image loads are expensive and a limited resource, so try to use them
  // efficiently:
  // * When the view is static we allow a large number of parallel tile loads
  //   to complete the frame as quickly as possible.
  // * When animating or interacting, image loads can cause janks, so we reduce
  //   the maximum number of loads per frame and limit the number of parallel
  //   tile loads to remain reactive to view changes and to reduce the chance of
  //   loading tiles that will quickly disappear from view.
  var tileQueue = this.tileQueue_;
  if (!tileQueue.isEmpty()) {
    var maxTotalLoading = 16;
    var maxNewLoads = maxTotalLoading;
    if (frameState) {
      var hints = frameState.viewHints;
      if (hints[viewhint["a" /* default */].ANIMATING]) {
        maxTotalLoading = this.loadTilesWhileAnimating_ ? 8 : 0;
        maxNewLoads = 2;
      }
      if (hints[viewhint["a" /* default */].INTERACTING]) {
        maxTotalLoading = this.loadTilesWhileInteracting_ ? 8 : 0;
        maxNewLoads = 2;
      }
    }
    if (tileQueue.getTilesLoading() < maxTotalLoading) {
      tileQueue.reprioritize(); // FIXME only call if view has changed
      tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
    }
  }

  var postRenderFunctions = this.postRenderFunctions_;
  var i, ii;
  for (i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
    postRenderFunctions[i](this, frameState);
  }
  postRenderFunctions.length = 0;
};

/**
 * @private
 */
pluggablemap__ol_PluggableMap_.prototype.handleSizeChanged_ = function () {
  this.render();
};

/**
 * @private
 */
pluggablemap__ol_PluggableMap_.prototype.handleTargetChanged_ = function () {
  // target may be undefined, null, a string or an Element.
  // If it's a string we convert it to an Element before proceeding.
  // If it's not now an Element we remove the viewport from the DOM.
  // If it's an Element we append the viewport element to it.

  var targetElement;
  if (this.getTarget()) {
    targetElement = this.getTargetElement();
  }

  if (this.keyHandlerKeys_) {
    for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {
      ol_events["a" /* default */].unlistenByKey(this.keyHandlerKeys_[i]);
    }
    this.keyHandlerKeys_ = null;
  }

  if (!targetElement) {
    this.renderer_.removeLayerRenderers();
    dom["a" /* default */].removeNode(this.viewport_);
    if (this.handleResize_ !== undefined) {
      window.removeEventListener(events_eventtype["a" /* default */].RESIZE, this.handleResize_, false);
      this.handleResize_ = undefined;
    }
  } else {
    targetElement.appendChild(this.viewport_);

    var keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
    this.keyHandlerKeys_ = [ol_events["a" /* default */].listen(keyboardEventTarget, events_eventtype["a" /* default */].KEYDOWN, this.handleBrowserEvent, this), ol_events["a" /* default */].listen(keyboardEventTarget, events_eventtype["a" /* default */].KEYPRESS, this.handleBrowserEvent, this)];

    if (!this.handleResize_) {
      this.handleResize_ = this.updateSize.bind(this);
      window.addEventListener(events_eventtype["a" /* default */].RESIZE, this.handleResize_, false);
    }
  }

  this.updateSize();
  // updateSize calls setSize, so no need to call this.render
  // ourselves here.
};

/**
 * @private
 */
pluggablemap__ol_PluggableMap_.prototype.handleTileChange_ = function () {
  this.render();
};

/**
 * @private
 */
pluggablemap__ol_PluggableMap_.prototype.handleViewPropertyChanged_ = function () {
  this.render();
};

/**
 * @private
 */
pluggablemap__ol_PluggableMap_.prototype.handleViewChanged_ = function () {
  if (this.viewPropertyListenerKey_) {
    ol_events["a" /* default */].unlistenByKey(this.viewPropertyListenerKey_);
    this.viewPropertyListenerKey_ = null;
  }
  if (this.viewChangeListenerKey_) {
    ol_events["a" /* default */].unlistenByKey(this.viewChangeListenerKey_);
    this.viewChangeListenerKey_ = null;
  }
  var view = this.getView();
  if (view) {
    this.viewport_.setAttribute('data-view', ol["a" /* default */].getUid(view));
    this.viewPropertyListenerKey_ = ol_events["a" /* default */].listen(view, objecteventtype["a" /* default */].PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
    this.viewChangeListenerKey_ = ol_events["a" /* default */].listen(view, events_eventtype["a" /* default */].CHANGE, this.handleViewPropertyChanged_, this);
  }
  this.render();
};

/**
 * @private
 */
pluggablemap__ol_PluggableMap_.prototype.handleLayerGroupChanged_ = function () {
  if (this.layerGroupPropertyListenerKeys_) {
    this.layerGroupPropertyListenerKeys_.forEach(ol_events["a" /* default */].unlistenByKey);
    this.layerGroupPropertyListenerKeys_ = null;
  }
  var layerGroup = this.getLayerGroup();
  if (layerGroup) {
    this.layerGroupPropertyListenerKeys_ = [ol_events["a" /* default */].listen(layerGroup, objecteventtype["a" /* default */].PROPERTYCHANGE, this.render, this), ol_events["a" /* default */].listen(layerGroup, events_eventtype["a" /* default */].CHANGE, this.render, this)];
  }
  this.render();
};

/**
 * @return {boolean} Is rendered.
 */
pluggablemap__ol_PluggableMap_.prototype.isRendered = function () {
  return !!this.frameState_;
};

/**
 * Requests an immediate render in a synchronous manner.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.renderSync = function () {
  if (this.animationDelayKey_) {
    cancelAnimationFrame(this.animationDelayKey_);
  }
  this.animationDelay_();
};

/**
 * Request a map rendering (at the next animation frame).
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.render = function () {
  if (this.animationDelayKey_ === undefined) {
    this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
  }
};

/**
 * Remove the given control from the map.
 * @param {ol.control.Control} control Control.
 * @return {ol.control.Control|undefined} The removed control (or undefined
 *     if the control was not found).
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.removeControl = function (control) {
  return this.getControls().remove(control);
};

/**
 * Remove the given interaction from the map.
 * @param {ol.interaction.Interaction} interaction Interaction to remove.
 * @return {ol.interaction.Interaction|undefined} The removed interaction (or
 *     undefined if the interaction was not found).
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.removeInteraction = function (interaction) {
  return this.getInteractions().remove(interaction);
};

/**
 * Removes the given layer from the map.
 * @param {ol.layer.Base} layer Layer.
 * @return {ol.layer.Base|undefined} The removed layer (or undefined if the
 *     layer was not found).
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.removeLayer = function (layer) {
  var layers = this.getLayerGroup().getLayers();
  return layers.remove(layer);
};

/**
 * Remove the given overlay from the map.
 * @param {ol.Overlay} overlay Overlay.
 * @return {ol.Overlay|undefined} The removed overlay (or undefined
 *     if the overlay was not found).
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.removeOverlay = function (overlay) {
  return this.getOverlays().remove(overlay);
};

/**
 * @param {number} time Time.
 * @private
 */
pluggablemap__ol_PluggableMap_.prototype.renderFrame_ = function (time) {
  var i, ii, viewState;

  var size = this.getSize();
  var view = this.getView();
  var extent = ol_extent["a" /* default */].createEmpty();
  var previousFrameState = this.frameState_;
  /** @type {?olx.FrameState} */
  var frameState = null;
  if (size !== undefined && ol_size["a" /* default */].hasArea(size) && view && view.isDef()) {
    var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
    var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    var layerStates = {};
    for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      layerStates[ol["a" /* default */].getUid(layerStatesArray[i].layer)] = layerStatesArray[i];
    }
    viewState = view.getState();
    var center = viewState.center;
    var pixelResolution = viewState.resolution / this.pixelRatio_;
    center[0] = Math.round(center[0] / pixelResolution) * pixelResolution;
    center[1] = Math.round(center[1] / pixelResolution) * pixelResolution;
    frameState = /** @type {olx.FrameState} */{
      animate: false,
      coordinateToPixelTransform: this.coordinateToPixelTransform_,
      extent: extent,
      focus: !this.focus_ ? center : this.focus_,
      index: this.frameIndex_++,
      layerStates: layerStates,
      layerStatesArray: layerStatesArray,
      logos: obj["a" /* default */].assign({}, this.logos_),
      pixelRatio: this.pixelRatio_,
      pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
      postRenderFunctions: [],
      size: size,
      skippedFeatureUids: this.skippedFeatureUids_,
      tileQueue: this.tileQueue_,
      time: time,
      usedTiles: {},
      viewState: viewState,
      viewHints: viewHints,
      wantedTiles: {}
    };
  }

  if (frameState) {
    frameState.extent = ol_extent["a" /* default */].getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, frameState.size, extent);
  }

  this.frameState_ = frameState;
  this.renderer_.renderFrame(frameState);

  if (frameState) {
    if (frameState.animate) {
      this.render();
    }
    Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);

    if (previousFrameState) {
      var moveStart = !this.previousExtent_ || !ol_extent["a" /* default */].isEmpty(this.previousExtent_) && !ol_extent["a" /* default */].equals(frameState.extent, this.previousExtent_);
      if (moveStart) {
        this.dispatchEvent(new mapevent(mapeventtype["a" /* default */].MOVESTART, this, previousFrameState));
        this.previousExtent_ = ol_extent["a" /* default */].createOrUpdateEmpty(this.previousExtent_);
      }
    }

    var idle = this.previousExtent_ && !frameState.viewHints[viewhint["a" /* default */].ANIMATING] && !frameState.viewHints[viewhint["a" /* default */].INTERACTING] && !ol_extent["a" /* default */].equals(frameState.extent, this.previousExtent_);

    if (idle) {
      this.dispatchEvent(new mapevent(mapeventtype["a" /* default */].MOVEEND, this, frameState));
      ol_extent["a" /* default */].clone(frameState.extent, this.previousExtent_);
    }
  }

  this.dispatchEvent(new mapevent(mapeventtype["a" /* default */].POSTRENDER, this, frameState));

  setTimeout(this.handlePostRender.bind(this), 0);
};

/**
 * Sets the layergroup of this map.
 * @param {ol.layer.Group} layerGroup A layer group containing the layers in
 *     this map.
 * @observable
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.setLayerGroup = function (layerGroup) {
  this.set(mapproperty.LAYERGROUP, layerGroup);
};

/**
 * Set the size of this map.
 * @param {ol.Size|undefined} size The size in pixels of the map in the DOM.
 * @observable
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.setSize = function (size) {
  this.set(mapproperty.SIZE, size);
};

/**
 * Set the target element to render this map into.
 * @param {Element|string|undefined} target The Element or id of the Element
 *     that the map is rendered in.
 * @observable
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.setTarget = function (target) {
  this.set(mapproperty.TARGET, target);
};

/**
 * Set the view for this map.
 * @param {ol.View} view The view that controls this map.
 * @observable
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.setView = function (view) {
  this.set(mapproperty.VIEW, view);
};

/**
 * @param {ol.Feature} feature Feature.
 */
pluggablemap__ol_PluggableMap_.prototype.skipFeature = function (feature) {
  var featureUid = ol["a" /* default */].getUid(feature).toString();
  this.skippedFeatureUids_[featureUid] = true;
  this.render();
};

/**
 * Force a recalculation of the map viewport size.  This should be called when
 * third-party code changes the size of the map viewport.
 * @api
 */
pluggablemap__ol_PluggableMap_.prototype.updateSize = function () {
  var targetElement = this.getTargetElement();

  if (!targetElement) {
    this.setSize(undefined);
  } else {
    var computedStyle = getComputedStyle(targetElement);
    this.setSize([targetElement.offsetWidth - parseFloat(computedStyle['borderLeftWidth']) - parseFloat(computedStyle['paddingLeft']) - parseFloat(computedStyle['paddingRight']) - parseFloat(computedStyle['borderRightWidth']), targetElement.offsetHeight - parseFloat(computedStyle['borderTopWidth']) - parseFloat(computedStyle['paddingTop']) - parseFloat(computedStyle['paddingBottom']) - parseFloat(computedStyle['borderBottomWidth'])]);
  }
};

/**
 * @param {ol.Feature} feature Feature.
 */
pluggablemap__ol_PluggableMap_.prototype.unskipFeature = function (feature) {
  var featureUid = ol["a" /* default */].getUid(feature).toString();
  delete this.skippedFeatureUids_[featureUid];
  this.render();
};

/**
 * @type {Array.<ol.renderer.Type>}
 * @const
 */
pluggablemap__ol_PluggableMap_.DEFAULT_RENDERER_TYPES = [renderer_type.CANVAS, renderer_type.WEBGL];

/**
 * @const
 * @type {string}
 */
pluggablemap__ol_PluggableMap_.LOGO_URL = 'data:image/png;base64,' + 'iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAAAA3NCSVQICAjb4U/gAAAACXBI' + 'WXMAAAHGAAABxgEXwfpGAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAA' + 'AhNQTFRF////AP//AICAgP//AFVVQECA////K1VVSbbbYL/fJ05idsTYJFtbbcjbJllmZszW' + 'WMTOIFhoHlNiZszTa9DdUcHNHlNlV8XRIVdiasrUHlZjIVZjaMnVH1RlIFRkH1RkH1ZlasvY' + 'asvXVsPQH1VkacnVa8vWIVZjIFRjVMPQa8rXIVVkXsXRsNveIFVkIFZlIVVj3eDeh6GmbMvX' + 'H1ZkIFRka8rWbMvXIFVkIFVjIFVkbMvWH1VjbMvWIFVlbcvWIFVla8vVIFVkbMvWbMvVH1Vk' + 'bMvWIFVlbcvWIFVkbcvVbMvWjNPbIFVkU8LPwMzNIFVkbczWIFVkbsvWbMvXIFVkRnB8bcvW' + '2+TkW8XRIFVkIlZlJVloJlpoKlxrLl9tMmJwOWd0Omh1RXF8TneCT3iDUHiDU8LPVMLPVcLP' + 'VcPQVsPPVsPQV8PQWMTQWsTQW8TQXMXSXsXRX4SNX8bSYMfTYcfTYsfTY8jUZcfSZsnUaIqT' + 'acrVasrVa8jTa8rWbI2VbMvWbcvWdJObdcvUdszUd8vVeJaee87Yfc3WgJyjhqGnitDYjaar' + 'ldPZnrK2oNbborW5o9bbo9fbpLa6q9ndrL3ArtndscDDutzfu8fJwN7gwt7gxc/QyuHhy+Hi' + 'zeHi0NfX0+Pj19zb1+Tj2uXk29/e3uLg3+Lh3+bl4uXj4ufl4+fl5Ofl5ufl5ujm5+jmySDn' + 'BAAAAFp0Uk5TAAECAgMEBAYHCA0NDg4UGRogIiMmKSssLzU7PkJJT1JTVFliY2hrdHZ3foSF' + 'hYeJjY2QkpugqbG1tre5w8zQ09XY3uXn6+zx8vT09vf4+Pj5+fr6/P39/f3+gz7SsAAAAVVJ' + 'REFUOMtjYKA7EBDnwCPLrObS1BRiLoJLnte6CQy8FLHLCzs2QUG4FjZ5GbcmBDDjxJBXDWxC' + 'Brb8aM4zbkIDzpLYnAcE9VXlJSWlZRU13koIeW57mGx5XjoMZEUqwxWYQaQbSzLSkYGfKFSe' + '0QMsX5WbjgY0YS4MBplemI4BdGBW+DQ11eZiymfqQuXZIjqwyadPNoSZ4L+0FVM6e+oGI6g8' + 'a9iKNT3o8kVzNkzRg5lgl7p4wyRUL9Yt2jAxVh6mQCogae6GmflI8p0r13VFWTHBQ0rWPW7a' + 'hgWVcPm+9cuLoyy4kCJDzCm6d8PSFoh0zvQNC5OjDJhQopPPJqph1doJBUD5tnkbZiUEqaCn' + 'B3bTqLTFG1bPn71kw4b+GFdpLElKIzRxxgYgWNYc5SCENVHKeUaltHdXx0dZ8uBI1hJ2UUDg' + 'q82CM2MwKeibqAvSO7MCABq0wXEPiqWEAAAAAElFTkSuQmCC';

/**
 * @param {olx.MapOptions} options Map options.
 * @return {ol.MapOptionsInternal} Internal map options.
 */
pluggablemap__ol_PluggableMap_.createOptionsInternal = function (options) {

  /**
   * @type {Element|Document}
   */
  var keyboardEventTarget = null;
  if (options.keyboardEventTarget !== undefined) {
    keyboardEventTarget = typeof options.keyboardEventTarget === 'string' ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }

  /**
   * @type {Object.<string, *>}
   */
  var values = {};

  var logos = {};
  if (options.logo === undefined || typeof options.logo === 'boolean' && options.logo) {
    logos[pluggablemap__ol_PluggableMap_.LOGO_URL] = 'https://openlayers.org/';
  } else {
    var logo = options.logo;
    if (typeof logo === 'string') {
      logos[logo] = '';
    } else if (logo instanceof HTMLElement) {
      logos[ol["a" /* default */].getUid(logo).toString()] = logo;
    } else if (logo) {
      asserts["a" /* default */].assert(typeof logo.href == 'string', 44); // `logo.href` should be a string.
      asserts["a" /* default */].assert(typeof logo.src == 'string', 45); // `logo.src` should be a string.
      logos[logo.src] = logo.href;
    }
  }

  var layerGroup = options.layers instanceof layer_group ? options.layers : new layer_group({ layers: options.layers });
  values[mapproperty.LAYERGROUP] = layerGroup;

  values[mapproperty.TARGET] = options.target;

  values[mapproperty.VIEW] = options.view !== undefined ? options.view : new ol_view["default"]();

  /**
   * @type {Array.<ol.renderer.Type>}
   */
  var rendererTypes;

  if (options.renderer !== undefined) {
    if (Array.isArray(options.renderer)) {
      rendererTypes = options.renderer;
    } else if (typeof options.renderer === 'string') {
      rendererTypes = [options.renderer];
    } else {
      asserts["a" /* default */].assert(false, 46); // Incorrect format for `renderer` option
    }
    if (rendererTypes.indexOf( /** @type {ol.renderer.Type} */'dom') >= 0) {
      rendererTypes = rendererTypes.concat(pluggablemap__ol_PluggableMap_.DEFAULT_RENDERER_TYPES);
    }
  } else {
    rendererTypes = pluggablemap__ol_PluggableMap_.DEFAULT_RENDERER_TYPES;
  }

  /**
   * @type {olx.MapRendererPlugin}
   */
  var mapRendererPlugin;

  var mapRendererPlugins = ol_plugins.getMapRendererPlugins();
  outer: for (var i = 0, ii = rendererTypes.length; i < ii; ++i) {
    var rendererType = rendererTypes[i];
    for (var j = 0, jj = mapRendererPlugins.length; j < jj; ++j) {
      var candidate = mapRendererPlugins[j];
      if (candidate['handles'](rendererType)) {
        mapRendererPlugin = candidate;
        break outer;
      }
    }
  }

  if (!mapRendererPlugin) {
    throw new Error('Unable to create a map renderer for types: ' + rendererTypes.join(', '));
  }

  var controls;
  if (options.controls !== undefined) {
    if (Array.isArray(options.controls)) {
      controls = new collection["a" /* default */](options.controls.slice());
    } else {
      asserts["a" /* default */].assert(options.controls instanceof collection["a" /* default */], 47); // Expected `controls` to be an array or an `ol.Collection`
      controls = options.controls;
    }
  }

  var interactions;
  if (options.interactions !== undefined) {
    if (Array.isArray(options.interactions)) {
      interactions = new collection["a" /* default */](options.interactions.slice());
    } else {
      asserts["a" /* default */].assert(options.interactions instanceof collection["a" /* default */], 48); // Expected `interactions` to be an array or an `ol.Collection`
      interactions = options.interactions;
    }
  }

  var overlays;
  if (options.overlays !== undefined) {
    if (Array.isArray(options.overlays)) {
      overlays = new collection["a" /* default */](options.overlays.slice());
    } else {
      asserts["a" /* default */].assert(options.overlays instanceof collection["a" /* default */], 49); // Expected `overlays` to be an array or an `ol.Collection`
      overlays = options.overlays;
    }
  } else {
    overlays = new collection["a" /* default */]();
  }

  return {
    controls: controls,
    interactions: interactions,
    keyboardEventTarget: keyboardEventTarget,
    logos: logos,
    overlays: overlays,
    mapRendererPlugin: mapRendererPlugin,
    values: values
  };
};
/* harmony default export */ var pluggablemap = (pluggablemap__ol_PluggableMap_);
// CONCATENATED MODULE: ./node_modules/ol/control/control.js






/**
 * @classdesc
 * A control is a visible widget with a DOM element in a fixed position on the
 * screen. They can involve user input (buttons), or be informational only;
 * the position is determined using CSS. By default these are placed in the
 * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
 * any outside DOM element.
 *
 * This is the base class for controls. You can use it for simple custom
 * controls by creating the element with listeners, creating an instance:
 * ```js
 * var myControl = new ol.control.Control({element: myElement});
 * ```
 * and then adding this to the map.
 *
 * The main advantage of having this as a control rather than a simple separate
 * DOM element is that preventing propagation is handled for you. Controls
 * will also be `ol.Object`s in a `ol.Collection`, so you can use their
 * methods.
 *
 * You can also extend this base for your own control class. See
 * examples/custom-controls for an example of how to do this.
 *
 * @constructor
 * @extends {ol.Object}
 * @implements {oli.control.Control}
 * @param {olx.control.ControlOptions} options Control options.
 * @api
 */
var control__ol_control_Control_ = function _ol_control_Control_(options) {

  object["a" /* default */].call(this);

  /**
   * @protected
   * @type {Element}
   */
  this.element = options.element ? options.element : null;

  /**
   * @private
   * @type {Element}
   */
  this.target_ = null;

  /**
   * @private
   * @type {ol.PluggableMap}
   */
  this.map_ = null;

  /**
   * @protected
   * @type {!Array.<ol.EventsKey>}
   */
  this.listenerKeys = [];

  /**
   * @type {function(ol.MapEvent)}
   */
  this.render = options.render ? options.render : ol["a" /* default */].nullFunction;

  if (options.target) {
    this.setTarget(options.target);
  }
};

ol["a" /* default */].inherits(control__ol_control_Control_, object["a" /* default */]);

/**
 * @inheritDoc
 */
control__ol_control_Control_.prototype.disposeInternal = function () {
  dom["a" /* default */].removeNode(this.element);
  object["a" /* default */].prototype.disposeInternal.call(this);
};

/**
 * Get the map associated with this control.
 * @return {ol.PluggableMap} Map.
 * @api
 */
control__ol_control_Control_.prototype.getMap = function () {
  return this.map_;
};

/**
 * Remove the control from its current map and attach it to the new map.
 * Subclasses may set up event handlers to get notified about changes to
 * the map here.
 * @param {ol.PluggableMap} map Map.
 * @override
 * @api
 */
control__ol_control_Control_.prototype.setMap = function (map) {
  if (this.map_) {
    dom["a" /* default */].removeNode(this.element);
  }
  for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
    ol_events["a" /* default */].unlistenByKey(this.listenerKeys[i]);
  }
  this.listenerKeys.length = 0;
  this.map_ = map;
  if (this.map_) {
    var target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
    target.appendChild(this.element);
    if (this.render !== ol["a" /* default */].nullFunction) {
      this.listenerKeys.push(ol_events["a" /* default */].listen(map, mapeventtype["a" /* default */].POSTRENDER, this.render, this));
    }
    map.render();
  }
};

/**
 * This function is used to set a target element for the control. It has no
 * effect if it is called after the control has been added to the map (i.e.
 * after `setMap` is called on the control). If no `target` is set in the
 * options passed to the control constructor and if `setTarget` is not called
 * then the control is added to the map's overlay container.
 * @param {Element|string} target Target.
 * @api
 */
control__ol_control_Control_.prototype.setTarget = function (target) {
  this.target_ = typeof target === 'string' ? document.getElementById(target) : target;
};
/* harmony default export */ var control = (control__ol_control_Control_);
// EXTERNAL MODULE: ./node_modules/ol/css.js
var css = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/ol/layer/layer.js
var layer_layer = __webpack_require__(42);

// CONCATENATED MODULE: ./node_modules/ol/control/attribution.js
// FIXME handle date line wrap











/**
 * @classdesc
 * Control to show all the attributions associated with the layer sources
 * in the map. This control is one of the default controls included in maps.
 * By default it will show in the bottom right portion of the map, but this can
 * be changed by using a css selector for `.ol-attribution`.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.AttributionOptions=} opt_options Attribution options.
 * @api
 */
var attribution__ol_control_Attribution_ = function _ol_control_Attribution_(opt_options) {

  var options = opt_options ? opt_options : {};

  /**
   * @private
   * @type {Element}
   */
  this.ulElement_ = document.createElement('UL');

  /**
   * @private
   * @type {Element}
   */
  this.logoLi_ = document.createElement('LI');

  this.ulElement_.appendChild(this.logoLi_);
  this.logoLi_.style.display = 'none';

  /**
   * @private
   * @type {boolean}
   */
  this.collapsed_ = options.collapsed !== undefined ? options.collapsed : true;

  /**
   * @private
   * @type {boolean}
   */
  this.collapsible_ = options.collapsible !== undefined ? options.collapsible : true;

  if (!this.collapsible_) {
    this.collapsed_ = false;
  }

  var className = options.className !== undefined ? options.className : 'ol-attribution';

  var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';

  var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\xBB';

  if (typeof collapseLabel === 'string') {
    /**
     * @private
     * @type {Node}
     */
    this.collapseLabel_ = document.createElement('span');
    this.collapseLabel_.textContent = collapseLabel;
  } else {
    this.collapseLabel_ = collapseLabel;
  }

  var label = options.label !== undefined ? options.label : 'i';

  if (typeof label === 'string') {
    /**
     * @private
     * @type {Node}
     */
    this.label_ = document.createElement('span');
    this.label_.textContent = label;
  } else {
    this.label_ = label;
  }

  var activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
  var button = document.createElement('button');
  button.setAttribute('type', 'button');
  button.title = tipLabel;
  button.appendChild(activeLabel);

  ol_events["a" /* default */].listen(button, events_eventtype["a" /* default */].CLICK, this.handleClick_, this);

  var cssClasses = className + ' ' + css["a" /* default */].CLASS_UNSELECTABLE + ' ' + css["a" /* default */].CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? ' ol-collapsed' : '') + (this.collapsible_ ? '' : ' ol-uncollapsible');
  var element = document.createElement('div');
  element.className = cssClasses;
  element.appendChild(this.ulElement_);
  element.appendChild(button);

  var render = options.render ? options.render : _ol_control_Attribution_.render;

  control.call(this, {
    element: element,
    render: render,
    target: options.target
  });

  /**
   * A list of currently rendered resolutions.
   * @type {Array.<string>}
   * @private
   */
  this.renderedAttributions_ = [];

  /**
   * @private
   * @type {boolean}
   */
  this.renderedVisible_ = true;

  /**
   * @private
   * @type {Object.<string, Element>}
   */
  this.logoElements_ = {};
};

ol["a" /* default */].inherits(attribution__ol_control_Attribution_, control);

/**
 * Get a list of visible attributions.
 * @param {olx.FrameState} frameState Frame state.
 * @return {Array.<string>} Attributions.
 * @private
 */
attribution__ol_control_Attribution_.prototype.getSourceAttributions_ = function (frameState) {
  /**
   * Used to determine if an attribution already exists.
   * @type {Object.<string, boolean>}
   */
  var lookup = {};

  /**
   * A list of visible attributions.
   * @type {Array.<string>}
   */
  var visibleAttributions = [];

  var layerStatesArray = frameState.layerStatesArray;
  var resolution = frameState.viewState.resolution;
  for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
    var layerState = layerStatesArray[i];
    if (!layer_layer["a" /* default */].visibleAtResolution(layerState, resolution)) {
      continue;
    }

    var source = layerState.layer.getSource();
    if (!source) {
      continue;
    }

    var attributionGetter = source.getAttributions2();
    if (!attributionGetter) {
      continue;
    }

    var attributions = attributionGetter(frameState);
    if (!attributions) {
      continue;
    }

    if (Array.isArray(attributions)) {
      for (var j = 0, jj = attributions.length; j < jj; ++j) {
        if (!(attributions[j] in lookup)) {
          visibleAttributions.push(attributions[j]);
          lookup[attributions[j]] = true;
        }
      }
    } else {
      if (!(attributions in lookup)) {
        visibleAttributions.push(attributions);
        lookup[attributions] = true;
      }
    }
  }
  return visibleAttributions;
};

/**
 * Update the attribution element.
 * @param {ol.MapEvent} mapEvent Map event.
 * @this {ol.control.Attribution}
 * @api
 */
attribution__ol_control_Attribution_.render = function (mapEvent) {
  this.updateElement_(mapEvent.frameState);
};

/**
 * @private
 * @param {?olx.FrameState} frameState Frame state.
 */
attribution__ol_control_Attribution_.prototype.updateElement_ = function (frameState) {
  if (!frameState) {
    if (this.renderedVisible_) {
      this.element.style.display = 'none';
      this.renderedVisible_ = false;
    }
    return;
  }

  var attributions = this.getSourceAttributions_(frameState);
  if (array["a" /* default */].equals(attributions, this.renderedAttributions_)) {
    return;
  }

  // remove everything but the logo
  while (this.ulElement_.lastChild !== this.logoLi_) {
    this.ulElement_.removeChild(this.ulElement_.lastChild);
  }

  // append the attributions
  for (var i = 0, ii = attributions.length; i < ii; ++i) {
    var element = document.createElement('LI');
    element.innerHTML = attributions[i];
    this.ulElement_.appendChild(element);
  }

  if (attributions.length === 0 && this.renderedAttributions_.length > 0) {
    this.element.classList.add('ol-logo-only');
  } else if (this.renderedAttributions_.length === 0 && attributions.length > 0) {
    this.element.classList.remove('ol-logo-only');
  }

  var visible = attributions.length > 0 || !obj["a" /* default */].isEmpty(frameState.logos);
  if (this.renderedVisible_ != visible) {
    this.element.style.display = visible ? '' : 'none';
    this.renderedVisible_ = visible;
  }

  this.renderedAttributions_ = attributions;
  this.insertLogos_(frameState);
};

/**
 * @param {?olx.FrameState} frameState Frame state.
 * @private
 */
attribution__ol_control_Attribution_.prototype.insertLogos_ = function (frameState) {

  var logo;
  var logos = frameState.logos;
  var logoElements = this.logoElements_;

  for (logo in logoElements) {
    if (!(logo in logos)) {
      dom["a" /* default */].removeNode(logoElements[logo]);
      delete logoElements[logo];
    }
  }

  var image, logoElement, logoKey;
  for (logoKey in logos) {
    var logoValue = logos[logoKey];
    if (logoValue instanceof HTMLElement) {
      this.logoLi_.appendChild(logoValue);
      logoElements[logoKey] = logoValue;
    }
    if (!(logoKey in logoElements)) {
      image = new Image();
      image.src = logoKey;
      if (logoValue === '') {
        logoElement = image;
      } else {
        logoElement = document.createElement('a');
        logoElement.href = logoValue;
        logoElement.appendChild(image);
      }
      this.logoLi_.appendChild(logoElement);
      logoElements[logoKey] = logoElement;
    }
  }

  this.logoLi_.style.display = !obj["a" /* default */].isEmpty(logos) ? '' : 'none';
};

/**
 * @param {Event} event The event to handle
 * @private
 */
attribution__ol_control_Attribution_.prototype.handleClick_ = function (event) {
  event.preventDefault();
  this.handleToggle_();
};

/**
 * @private
 */
attribution__ol_control_Attribution_.prototype.handleToggle_ = function () {
  this.element.classList.toggle('ol-collapsed');
  if (this.collapsed_) {
    dom["a" /* default */].replaceNode(this.collapseLabel_, this.label_);
  } else {
    dom["a" /* default */].replaceNode(this.label_, this.collapseLabel_);
  }
  this.collapsed_ = !this.collapsed_;
};

/**
 * Return `true` if the attribution is collapsible, `false` otherwise.
 * @return {boolean} True if the widget is collapsible.
 * @api
 */
attribution__ol_control_Attribution_.prototype.getCollapsible = function () {
  return this.collapsible_;
};

/**
 * Set whether the attribution should be collapsible.
 * @param {boolean} collapsible True if the widget is collapsible.
 * @api
 */
attribution__ol_control_Attribution_.prototype.setCollapsible = function (collapsible) {
  if (this.collapsible_ === collapsible) {
    return;
  }
  this.collapsible_ = collapsible;
  this.element.classList.toggle('ol-uncollapsible');
  if (!collapsible && this.collapsed_) {
    this.handleToggle_();
  }
};

/**
 * Collapse or expand the attribution according to the passed parameter. Will
 * not do anything if the attribution isn't collapsible or if the current
 * collapsed state is already the one requested.
 * @param {boolean} collapsed True if the widget is collapsed.
 * @api
 */
attribution__ol_control_Attribution_.prototype.setCollapsed = function (collapsed) {
  if (!this.collapsible_ || this.collapsed_ === collapsed) {
    return;
  }
  this.handleToggle_();
};

/**
 * Return `true` when the attribution is currently collapsed or `false`
 * otherwise.
 * @return {boolean} True if the widget is collapsed.
 * @api
 */
attribution__ol_control_Attribution_.prototype.getCollapsed = function () {
  return this.collapsed_;
};
/* harmony default export */ var attribution = (attribution__ol_control_Attribution_);
// EXTERNAL MODULE: ./node_modules/ol/easing.js
var easing = __webpack_require__(29);

// CONCATENATED MODULE: ./node_modules/ol/control/rotate.js







/**
 * @classdesc
 * A button control to reset rotation to 0.
 * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
 * selector is added to the button when the rotation is 0.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.RotateOptions=} opt_options Rotate options.
 * @api
 */
var rotate__ol_control_Rotate_ = function _ol_control_Rotate_(opt_options) {

  var options = opt_options ? opt_options : {};

  var className = options.className !== undefined ? options.className : 'ol-rotate';

  var label = options.label !== undefined ? options.label : '\u21E7';

  /**
   * @type {Element}
   * @private
   */
  this.label_ = null;

  if (typeof label === 'string') {
    this.label_ = document.createElement('span');
    this.label_.className = 'ol-compass';
    this.label_.textContent = label;
  } else {
    this.label_ = label;
    this.label_.classList.add('ol-compass');
  }

  var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';

  var button = document.createElement('button');
  button.className = className + '-reset';
  button.setAttribute('type', 'button');
  button.title = tipLabel;
  button.appendChild(this.label_);

  ol_events["a" /* default */].listen(button, events_eventtype["a" /* default */].CLICK, _ol_control_Rotate_.prototype.handleClick_, this);

  var cssClasses = className + ' ' + css["a" /* default */].CLASS_UNSELECTABLE + ' ' + css["a" /* default */].CLASS_CONTROL;
  var element = document.createElement('div');
  element.className = cssClasses;
  element.appendChild(button);

  var render = options.render ? options.render : _ol_control_Rotate_.render;

  this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;

  control.call(this, {
    element: element,
    render: render,
    target: options.target
  });

  /**
   * @type {number}
   * @private
   */
  this.duration_ = options.duration !== undefined ? options.duration : 250;

  /**
   * @type {boolean}
   * @private
   */
  this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;

  /**
   * @private
   * @type {number|undefined}
   */
  this.rotation_ = undefined;

  if (this.autoHide_) {
    this.element.classList.add(css["a" /* default */].CLASS_HIDDEN);
  }
};

ol["a" /* default */].inherits(rotate__ol_control_Rotate_, control);

/**
 * @param {Event} event The event to handle
 * @private
 */
rotate__ol_control_Rotate_.prototype.handleClick_ = function (event) {
  event.preventDefault();
  if (this.callResetNorth_ !== undefined) {
    this.callResetNorth_();
  } else {
    this.resetNorth_();
  }
};

/**
 * @private
 */
rotate__ol_control_Rotate_.prototype.resetNorth_ = function () {
  var map = this.getMap();
  var view = map.getView();
  if (!view) {
    // the map does not have a view, so we can't act
    // upon it
    return;
  }
  if (view.getRotation() !== undefined) {
    if (this.duration_ > 0) {
      view.animate({
        rotation: 0,
        duration: this.duration_,
        easing: easing["a" /* default */].easeOut
      });
    } else {
      view.setRotation(0);
    }
  }
};

/**
 * Update the rotate control element.
 * @param {ol.MapEvent} mapEvent Map event.
 * @this {ol.control.Rotate}
 * @api
 */
rotate__ol_control_Rotate_.render = function (mapEvent) {
  var frameState = mapEvent.frameState;
  if (!frameState) {
    return;
  }
  var rotation = frameState.viewState.rotation;
  if (rotation != this.rotation_) {
    var transform = 'rotate(' + rotation + 'rad)';
    if (this.autoHide_) {
      var contains = this.element.classList.contains(css["a" /* default */].CLASS_HIDDEN);
      if (!contains && rotation === 0) {
        this.element.classList.add(css["a" /* default */].CLASS_HIDDEN);
      } else if (contains && rotation !== 0) {
        this.element.classList.remove(css["a" /* default */].CLASS_HIDDEN);
      }
    }
    this.label_.style.msTransform = transform;
    this.label_.style.webkitTransform = transform;
    this.label_.style.transform = transform;
  }
  this.rotation_ = rotation;
};
/* harmony default export */ var rotate = (rotate__ol_control_Rotate_);
// CONCATENATED MODULE: ./node_modules/ol/control/zoom.js







/**
 * @classdesc
 * A control with 2 buttons, one for zoom in and one for zoom out.
 * This control is one of the default controls of a map. To style this control
 * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
 *
 * @constructor
 * @extends {ol.control.Control}
 * @param {olx.control.ZoomOptions=} opt_options Zoom options.
 * @api
 */
var zoom__ol_control_Zoom_ = function _ol_control_Zoom_(opt_options) {

  var options = opt_options ? opt_options : {};

  var className = options.className !== undefined ? options.className : 'ol-zoom';

  var delta = options.delta !== undefined ? options.delta : 1;

  var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
  var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2212';

  var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
  var zoomOutTipLabel = options.zoomOutTipLabel !== undefined ? options.zoomOutTipLabel : 'Zoom out';

  var inElement = document.createElement('button');
  inElement.className = className + '-in';
  inElement.setAttribute('type', 'button');
  inElement.title = zoomInTipLabel;
  inElement.appendChild(typeof zoomInLabel === 'string' ? document.createTextNode(zoomInLabel) : zoomInLabel);

  ol_events["a" /* default */].listen(inElement, events_eventtype["a" /* default */].CLICK, _ol_control_Zoom_.prototype.handleClick_.bind(this, delta));

  var outElement = document.createElement('button');
  outElement.className = className + '-out';
  outElement.setAttribute('type', 'button');
  outElement.title = zoomOutTipLabel;
  outElement.appendChild(typeof zoomOutLabel === 'string' ? document.createTextNode(zoomOutLabel) : zoomOutLabel);

  ol_events["a" /* default */].listen(outElement, events_eventtype["a" /* default */].CLICK, _ol_control_Zoom_.prototype.handleClick_.bind(this, -delta));

  var cssClasses = className + ' ' + css["a" /* default */].CLASS_UNSELECTABLE + ' ' + css["a" /* default */].CLASS_CONTROL;
  var element = document.createElement('div');
  element.className = cssClasses;
  element.appendChild(inElement);
  element.appendChild(outElement);

  control.call(this, {
    element: element,
    target: options.target
  });

  /**
   * @type {number}
   * @private
   */
  this.duration_ = options.duration !== undefined ? options.duration : 250;
};

ol["a" /* default */].inherits(zoom__ol_control_Zoom_, control);

/**
 * @param {number} delta Zoom delta.
 * @param {Event} event The event to handle
 * @private
 */
zoom__ol_control_Zoom_.prototype.handleClick_ = function (delta, event) {
  event.preventDefault();
  this.zoomByDelta_(delta);
};

/**
 * @param {number} delta Zoom delta.
 * @private
 */
zoom__ol_control_Zoom_.prototype.zoomByDelta_ = function (delta) {
  var map = this.getMap();
  var view = map.getView();
  if (!view) {
    // the map does not have a view, so we can't act
    // upon it
    return;
  }
  var currentResolution = view.getResolution();
  if (currentResolution) {
    var newResolution = view.constrainResolution(currentResolution, delta);
    if (this.duration_ > 0) {
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      view.animate({
        resolution: newResolution,
        duration: this.duration_,
        easing: easing["a" /* default */].easeOut
      });
    } else {
      view.setResolution(newResolution);
    }
  }
};
/* harmony default export */ var zoom = (zoom__ol_control_Zoom_);
// CONCATENATED MODULE: ./node_modules/ol/control.js




var _ol_control_ = {};

/**
 * Set of controls included in maps by default. Unless configured otherwise,
 * this returns a collection containing an instance of each of the following
 * controls:
 * * {@link ol.control.Zoom}
 * * {@link ol.control.Rotate}
 * * {@link ol.control.Attribution}
 *
 * @param {olx.control.DefaultsOptions=} opt_options Defaults options.
 * @return {ol.Collection.<ol.control.Control>} Controls.
 * @api
 */
_ol_control_.defaults = function (opt_options) {

  var options = opt_options ? opt_options : {};

  var controls = new collection["a" /* default */]();

  var zoomControl = options.zoom !== undefined ? options.zoom : true;
  if (zoomControl) {
    controls.push(new zoom(options.zoomOptions));
  }

  var rotateControl = options.rotate !== undefined ? options.rotate : true;
  if (rotateControl) {
    controls.push(new rotate(options.rotateOptions));
  }

  var attributionControl = options.attribution !== undefined ? options.attribution : true;
  if (attributionControl) {
    controls.push(new attribution(options.attributionOptions));
  }

  return controls;
};
/* harmony default export */ var ol_control = (_ol_control_);
// CONCATENATED MODULE: ./node_modules/ol/kinetic.js
/**
 * @classdesc
 * Implementation of inertial deceleration for map movement.
 *
 * @constructor
 * @param {number} decay Rate of decay (must be negative).
 * @param {number} minVelocity Minimum velocity (pixels/millisecond).
 * @param {number} delay Delay to consider to calculate the kinetic
 *     initial values (milliseconds).
 * @struct
 * @api
 */
var _ol_Kinetic_ = function _ol_Kinetic_(decay, minVelocity, delay) {

  /**
   * @private
   * @type {number}
   */
  this.decay_ = decay;

  /**
   * @private
   * @type {number}
   */
  this.minVelocity_ = minVelocity;

  /**
   * @private
   * @type {number}
   */
  this.delay_ = delay;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.points_ = [];

  /**
   * @private
   * @type {number}
   */
  this.angle_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.initialVelocity_ = 0;
};

/**
 * FIXME empty description for jsdoc
 */
_ol_Kinetic_.prototype.begin = function () {
  this.points_.length = 0;
  this.angle_ = 0;
  this.initialVelocity_ = 0;
};

/**
 * @param {number} x X.
 * @param {number} y Y.
 */
_ol_Kinetic_.prototype.update = function (x, y) {
  this.points_.push(x, y, Date.now());
};

/**
 * @return {boolean} Whether we should do kinetic animation.
 */
_ol_Kinetic_.prototype.end = function () {
  if (this.points_.length < 6) {
    // at least 2 points are required (i.e. there must be at least 6 elements
    // in the array)
    return false;
  }
  var delay = Date.now() - this.delay_;
  var lastIndex = this.points_.length - 3;
  if (this.points_[lastIndex + 2] < delay) {
    // the last tracked point is too old, which means that the user stopped
    // panning before releasing the map
    return false;
  }

  // get the first point which still falls into the delay time
  var firstIndex = lastIndex - 3;
  while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
    firstIndex -= 3;
  }

  var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
  // we don't want a duration of 0 (divide by zero)
  // we also make sure the user panned for a duration of at least one frame
  // (1/60s) to compute sane displacement values
  if (duration < 1000 / 60) {
    return false;
  }

  var dx = this.points_[lastIndex] - this.points_[firstIndex];
  var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
  this.angle_ = Math.atan2(dy, dx);
  this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
  return this.initialVelocity_ > this.minVelocity_;
};

/**
 * @return {number} Total distance travelled (pixels).
 */
_ol_Kinetic_.prototype.getDistance = function () {
  return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
};

/**
 * @return {number} Angle of the kinetic panning animation (radians).
 */
_ol_Kinetic_.prototype.getAngle = function () {
  return this.angle_;
};
/* harmony default export */ var ol_kinetic = (_ol_Kinetic_);
// EXTERNAL MODULE: ./node_modules/ol/interaction/interaction.js + 1 modules
var interaction = __webpack_require__(23);

// CONCATENATED MODULE: ./node_modules/ol/interaction/doubleclickzoom.js




/**
 * @classdesc
 * Allows the user to zoom by double-clicking on the map.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {olx.interaction.DoubleClickZoomOptions=} opt_options Options.
 * @api
 */
var doubleclickzoom__ol_interaction_DoubleClickZoom_ = function _ol_interaction_DoubleClickZoom_(opt_options) {

  var options = opt_options ? opt_options : {};

  /**
   * @private
   * @type {number}
   */
  this.delta_ = options.delta ? options.delta : 1;

  interaction["a" /* default */].call(this, {
    handleEvent: _ol_interaction_DoubleClickZoom_.handleEvent
  });

  /**
   * @private
   * @type {number}
   */
  this.duration_ = options.duration !== undefined ? options.duration : 250;
};

ol["a" /* default */].inherits(doubleclickzoom__ol_interaction_DoubleClickZoom_, interaction["a" /* default */]);

/**
 * Handles the {@link ol.MapBrowserEvent map browser event} (if it was a
 * doubleclick) and eventually zooms the map.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.DoubleClickZoom}
 * @api
 */
doubleclickzoom__ol_interaction_DoubleClickZoom_.handleEvent = function (mapBrowserEvent) {
  var stopEvent = false;
  var browserEvent = mapBrowserEvent.originalEvent;
  if (mapBrowserEvent.type == mapbrowsereventtype["a" /* default */].DBLCLICK) {
    var map = mapBrowserEvent.map;
    var anchor = mapBrowserEvent.coordinate;
    var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
    var view = map.getView();
    interaction["a" /* default */].zoomByDelta(view, delta, anchor, this.duration_);
    mapBrowserEvent.preventDefault();
    stopEvent = true;
  }
  return !stopEvent;
};
/* harmony default export */ var doubleclickzoom = (doubleclickzoom__ol_interaction_DoubleClickZoom_);
// EXTERNAL MODULE: ./node_modules/ol/coordinate.js + 1 modules
var ol_coordinate = __webpack_require__(62);

// EXTERNAL MODULE: ./node_modules/ol/events/condition.js
var events_condition = __webpack_require__(36);

// CONCATENATED MODULE: ./node_modules/ol/interaction/pointer.js







/**
 * @classdesc
 * Base class that calls user-defined functions on `down`, `move` and `up`
 * events. This class also manages "drag sequences".
 *
 * When the `handleDownEvent` user function returns `true` a drag sequence is
 * started. During a drag sequence the `handleDragEvent` user function is
 * called on `move` events. The drag sequence ends when the `handleUpEvent`
 * user function is called and returns `false`.
 *
 * @constructor
 * @param {olx.interaction.PointerOptions=} opt_options Options.
 * @extends {ol.interaction.Interaction}
 * @api
 */
var pointer__ol_interaction_Pointer_ = function _ol_interaction_Pointer_(opt_options) {

  var options = opt_options ? opt_options : {};

  var handleEvent = options.handleEvent ? options.handleEvent : _ol_interaction_Pointer_.handleEvent;

  interaction["a" /* default */].call(this, {
    handleEvent: handleEvent
  });

  /**
   * @type {function(ol.MapBrowserPointerEvent):boolean}
   * @private
   */
  this.handleDownEvent_ = options.handleDownEvent ? options.handleDownEvent : _ol_interaction_Pointer_.handleDownEvent;

  /**
   * @type {function(ol.MapBrowserPointerEvent)}
   * @private
   */
  this.handleDragEvent_ = options.handleDragEvent ? options.handleDragEvent : _ol_interaction_Pointer_.handleDragEvent;

  /**
   * @type {function(ol.MapBrowserPointerEvent)}
   * @private
   */
  this.handleMoveEvent_ = options.handleMoveEvent ? options.handleMoveEvent : _ol_interaction_Pointer_.handleMoveEvent;

  /**
   * @type {function(ol.MapBrowserPointerEvent):boolean}
   * @private
   */
  this.handleUpEvent_ = options.handleUpEvent ? options.handleUpEvent : _ol_interaction_Pointer_.handleUpEvent;

  /**
   * @type {boolean}
   * @protected
   */
  this.handlingDownUpSequence = false;

  /**
   * @type {Object.<string, ol.pointer.PointerEvent>}
   * @private
   */
  this.trackedPointers_ = {};

  /**
   * @type {Array.<ol.pointer.PointerEvent>}
   * @protected
   */
  this.targetPointers = [];
};

ol["a" /* default */].inherits(pointer__ol_interaction_Pointer_, interaction["a" /* default */]);

/**
 * @param {Array.<ol.pointer.PointerEvent>} pointerEvents List of events.
 * @return {ol.Pixel} Centroid pixel.
 */
pointer__ol_interaction_Pointer_.centroid = function (pointerEvents) {
  var length = pointerEvents.length;
  var clientX = 0;
  var clientY = 0;
  for (var i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }
  return [clientX / length, clientY / length];
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Whether the event is a pointerdown, pointerdrag
 *     or pointerup event.
 * @private
 */
pointer__ol_interaction_Pointer_.prototype.isPointerDraggingEvent_ = function (mapBrowserEvent) {
  var type = mapBrowserEvent.type;
  return type === mapbrowsereventtype["a" /* default */].POINTERDOWN || type === mapbrowsereventtype["a" /* default */].POINTERDRAG || type === mapbrowsereventtype["a" /* default */].POINTERUP;
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @private
 */
pointer__ol_interaction_Pointer_.prototype.updateTrackedPointers_ = function (mapBrowserEvent) {
  if (this.isPointerDraggingEvent_(mapBrowserEvent)) {
    var event = mapBrowserEvent.pointerEvent;

    var id = event.pointerId.toString();
    if (mapBrowserEvent.type == mapbrowsereventtype["a" /* default */].POINTERUP) {
      delete this.trackedPointers_[id];
    } else if (mapBrowserEvent.type == mapbrowsereventtype["a" /* default */].POINTERDOWN) {
      this.trackedPointers_[id] = event;
    } else if (id in this.trackedPointers_) {
      // update only when there was a pointerdown event for this pointer
      this.trackedPointers_[id] = event;
    }
    this.targetPointers = obj["a" /* default */].getValues(this.trackedPointers_);
  }
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.Pointer}
 */
pointer__ol_interaction_Pointer_.handleDragEvent = ol["a" /* default */].nullFunction;

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Capture dragging.
 * @this {ol.interaction.Pointer}
 */
pointer__ol_interaction_Pointer_.handleUpEvent = functions["a" /* default */].FALSE;

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Capture dragging.
 * @this {ol.interaction.Pointer}
 */
pointer__ol_interaction_Pointer_.handleDownEvent = functions["a" /* default */].FALSE;

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.Pointer}
 */
pointer__ol_interaction_Pointer_.handleMoveEvent = ol["a" /* default */].nullFunction;

/**
 * Handles the {@link ol.MapBrowserEvent map browser event} and may call into
 * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
 * detected.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.Pointer}
 * @api
 */
pointer__ol_interaction_Pointer_.handleEvent = function (mapBrowserEvent) {
  if (!(mapBrowserEvent instanceof mapbrowserpointerevent)) {
    return true;
  }

  var stopEvent = false;
  this.updateTrackedPointers_(mapBrowserEvent);
  if (this.handlingDownUpSequence) {
    if (mapBrowserEvent.type == mapbrowsereventtype["a" /* default */].POINTERDRAG) {
      this.handleDragEvent_(mapBrowserEvent);
    } else if (mapBrowserEvent.type == mapbrowsereventtype["a" /* default */].POINTERUP) {
      var handledUp = this.handleUpEvent_(mapBrowserEvent);
      this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
    }
  } else {
    if (mapBrowserEvent.type == mapbrowsereventtype["a" /* default */].POINTERDOWN) {
      var handled = this.handleDownEvent_(mapBrowserEvent);
      this.handlingDownUpSequence = handled;
      stopEvent = this.shouldStopEvent(handled);
    } else if (mapBrowserEvent.type == mapbrowsereventtype["a" /* default */].POINTERMOVE) {
      this.handleMoveEvent_(mapBrowserEvent);
    }
  }
  return !stopEvent;
};

/**
 * This method is used to determine if "down" events should be propagated to
 * other interactions or should be stopped.
 *
 * The method receives the return code of the "handleDownEvent" function.
 *
 * By default this function is the "identity" function. It's overidden in
 * child classes.
 *
 * @param {boolean} handled Was the event handled by the interaction?
 * @return {boolean} Should the event be stopped?
 * @protected
 */
pointer__ol_interaction_Pointer_.prototype.shouldStopEvent = function (handled) {
  return handled;
};
/* harmony default export */ var pointer = (pointer__ol_interaction_Pointer_);
// CONCATENATED MODULE: ./node_modules/ol/interaction/dragpan.js








/**
 * @classdesc
 * Allows the user to pan the map by dragging the map.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.DragPanOptions=} opt_options Options.
 * @api
 */
var dragpan__ol_interaction_DragPan_ = function _ol_interaction_DragPan_(opt_options) {

  pointer.call(this, {
    handleDownEvent: _ol_interaction_DragPan_.handleDownEvent_,
    handleDragEvent: _ol_interaction_DragPan_.handleDragEvent_,
    handleUpEvent: _ol_interaction_DragPan_.handleUpEvent_
  });

  var options = opt_options ? opt_options : {};

  /**
   * @private
   * @type {ol.Kinetic|undefined}
   */
  this.kinetic_ = options.kinetic;

  /**
   * @type {ol.Pixel}
   */
  this.lastCentroid = null;

  /**
   * @type {number}
   */
  this.lastPointersCount_;

  /**
   * @private
   * @type {ol.EventsConditionType}
   */
  this.condition_ = options.condition ? options.condition : events_condition["a" /* default */].noModifierKeys;

  /**
   * @private
   * @type {boolean}
   */
  this.noKinetic_ = false;
};

ol["a" /* default */].inherits(dragpan__ol_interaction_DragPan_, pointer);

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragPan}
 * @private
 */
dragpan__ol_interaction_DragPan_.handleDragEvent_ = function (mapBrowserEvent) {
  var targetPointers = this.targetPointers;
  var centroid = pointer.centroid(targetPointers);
  if (targetPointers.length == this.lastPointersCount_) {
    if (this.kinetic_) {
      this.kinetic_.update(centroid[0], centroid[1]);
    }
    if (this.lastCentroid) {
      var deltaX = this.lastCentroid[0] - centroid[0];
      var deltaY = centroid[1] - this.lastCentroid[1];
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var viewState = view.getState();
      var center = [deltaX, deltaY];
      ol_coordinate["a" /* default */].scale(center, viewState.resolution);
      ol_coordinate["a" /* default */].rotate(center, viewState.rotation);
      ol_coordinate["a" /* default */].add(center, viewState.center);
      center = view.constrainCenter(center);
      view.setCenter(center);
    }
  } else if (this.kinetic_) {
    // reset so we don't overestimate the kinetic energy after
    // after one finger down, tiny drag, second finger down
    this.kinetic_.begin();
  }
  this.lastCentroid = centroid;
  this.lastPointersCount_ = targetPointers.length;
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragPan}
 * @private
 */
dragpan__ol_interaction_DragPan_.handleUpEvent_ = function (mapBrowserEvent) {
  var map = mapBrowserEvent.map;
  var view = map.getView();
  if (this.targetPointers.length === 0) {
    if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
      var distance = this.kinetic_.getDistance();
      var angle = this.kinetic_.getAngle();
      var center = /** @type {!ol.Coordinate} */view.getCenter();
      var centerpx = map.getPixelFromCoordinate(center);
      var dest = map.getCoordinateFromPixel([centerpx[0] - distance * Math.cos(angle), centerpx[1] - distance * Math.sin(angle)]);
      view.animate({
        center: view.constrainCenter(dest),
        duration: 500,
        easing: easing["a" /* default */].easeOut
      });
    }
    view.setHint(viewhint["a" /* default */].INTERACTING, -1);
    return false;
  } else {
    if (this.kinetic_) {
      // reset so we don't overestimate the kinetic energy after
      // after one finger up, tiny drag, second finger up
      this.kinetic_.begin();
    }
    this.lastCentroid = null;
    return true;
  }
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.DragPan}
 * @private
 */
dragpan__ol_interaction_DragPan_.handleDownEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    this.lastCentroid = null;
    if (!this.handlingDownUpSequence) {
      view.setHint(viewhint["a" /* default */].INTERACTING, 1);
    }
    // stop any current animation
    if (view.getAnimating()) {
      view.setCenter(mapBrowserEvent.frameState.viewState.center);
    }
    if (this.kinetic_) {
      this.kinetic_.begin();
    }
    // No kinetic as soon as more than one pointer on the screen is
    // detected. This is to prevent nasty pans after pinch.
    this.noKinetic_ = this.targetPointers.length > 1;
    return true;
  } else {
    return false;
  }
};

/**
 * @inheritDoc
 */
dragpan__ol_interaction_DragPan_.prototype.shouldStopEvent = functions["a" /* default */].FALSE;
/* harmony default export */ var dragpan = (dragpan__ol_interaction_DragPan_);
// EXTERNAL MODULE: ./node_modules/ol/rotationconstraint.js
var rotationconstraint = __webpack_require__(69);

// CONCATENATED MODULE: ./node_modules/ol/interaction/dragrotate.js








/**
 * @classdesc
 * Allows the user to rotate the map by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when the alt and shift keys are held down.
 *
 * This interaction is only supported for mouse devices.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.DragRotateOptions=} opt_options Options.
 * @api
 */
var dragrotate__ol_interaction_DragRotate_ = function _ol_interaction_DragRotate_(opt_options) {

  var options = opt_options ? opt_options : {};

  pointer.call(this, {
    handleDownEvent: _ol_interaction_DragRotate_.handleDownEvent_,
    handleDragEvent: _ol_interaction_DragRotate_.handleDragEvent_,
    handleUpEvent: _ol_interaction_DragRotate_.handleUpEvent_
  });

  /**
   * @private
   * @type {ol.EventsConditionType}
   */
  this.condition_ = options.condition ? options.condition : events_condition["a" /* default */].altShiftKeysOnly;

  /**
   * @private
   * @type {number|undefined}
   */
  this.lastAngle_ = undefined;

  /**
   * @private
   * @type {number}
   */
  this.duration_ = options.duration !== undefined ? options.duration : 250;
};

ol["a" /* default */].inherits(dragrotate__ol_interaction_DragRotate_, pointer);

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragRotate}
 * @private
 */
dragrotate__ol_interaction_DragRotate_.handleDragEvent_ = function (mapBrowserEvent) {
  if (!events_condition["a" /* default */].mouseOnly(mapBrowserEvent)) {
    return;
  }

  var map = mapBrowserEvent.map;
  var view = map.getView();
  if (view.getConstraints().rotation === rotationconstraint["a" /* default */].disable) {
    return;
  }
  var size = map.getSize();
  var offset = mapBrowserEvent.pixel;
  var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
  if (this.lastAngle_ !== undefined) {
    var delta = theta - this.lastAngle_;
    var rotation = view.getRotation();
    interaction["a" /* default */].rotateWithoutConstraints(view, rotation - delta);
  }
  this.lastAngle_ = theta;
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragRotate}
 * @private
 */
dragrotate__ol_interaction_DragRotate_.handleUpEvent_ = function (mapBrowserEvent) {
  if (!events_condition["a" /* default */].mouseOnly(mapBrowserEvent)) {
    return true;
  }

  var map = mapBrowserEvent.map;
  var view = map.getView();
  view.setHint(viewhint["a" /* default */].INTERACTING, -1);
  var rotation = view.getRotation();
  interaction["a" /* default */].rotate(view, rotation, undefined, this.duration_);
  return false;
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.DragRotate}
 * @private
 */
dragrotate__ol_interaction_DragRotate_.handleDownEvent_ = function (mapBrowserEvent) {
  if (!events_condition["a" /* default */].mouseOnly(mapBrowserEvent)) {
    return false;
  }

  if (events_condition["a" /* default */].mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
    var map = mapBrowserEvent.map;
    map.getView().setHint(viewhint["a" /* default */].INTERACTING, 1);
    this.lastAngle_ = undefined;
    return true;
  } else {
    return false;
  }
};

/**
 * @inheritDoc
 */
dragrotate__ol_interaction_DragRotate_.prototype.shouldStopEvent = functions["a" /* default */].FALSE;
/* harmony default export */ var dragrotate = (dragrotate__ol_interaction_DragRotate_);
// EXTERNAL MODULE: ./node_modules/ol/disposable.js
var disposable = __webpack_require__(55);

// EXTERNAL MODULE: ./node_modules/ol/geom/polygon.js + 1 modules
var polygon = __webpack_require__(59);

// CONCATENATED MODULE: ./node_modules/ol/render/box.js
// FIXME add rotation





/**
 * @constructor
 * @extends {ol.Disposable}
 * @param {string} className CSS class name.
 */
var _ol_render_Box_ = function _ol_render_Box_(className) {

  /**
   * @type {ol.geom.Polygon}
   * @private
   */
  this.geometry_ = null;

  /**
   * @type {HTMLDivElement}
   * @private
   */
  this.element_ = /** @type {HTMLDivElement} */document.createElement('div');
  this.element_.style.position = 'absolute';
  this.element_.className = 'ol-box ' + className;

  /**
   * @private
   * @type {ol.PluggableMap}
   */
  this.map_ = null;

  /**
   * @private
   * @type {ol.Pixel}
   */
  this.startPixel_ = null;

  /**
   * @private
   * @type {ol.Pixel}
   */
  this.endPixel_ = null;
};

ol["a" /* default */].inherits(_ol_render_Box_, disposable["a" /* default */]);

/**
 * @inheritDoc
 */
_ol_render_Box_.prototype.disposeInternal = function () {
  this.setMap(null);
};

/**
 * @private
 */
_ol_render_Box_.prototype.render_ = function () {
  var startPixel = this.startPixel_;
  var endPixel = this.endPixel_;
  var px = 'px';
  var style = this.element_.style;
  style.left = Math.min(startPixel[0], endPixel[0]) + px;
  style.top = Math.min(startPixel[1], endPixel[1]) + px;
  style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
  style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
};

/**
 * @param {ol.PluggableMap} map Map.
 */
_ol_render_Box_.prototype.setMap = function (map) {
  if (this.map_) {
    this.map_.getOverlayContainer().removeChild(this.element_);
    var style = this.element_.style;
    style.left = style.top = style.width = style.height = 'inherit';
  }
  this.map_ = map;
  if (this.map_) {
    this.map_.getOverlayContainer().appendChild(this.element_);
  }
};

/**
 * @param {ol.Pixel} startPixel Start pixel.
 * @param {ol.Pixel} endPixel End pixel.
 */
_ol_render_Box_.prototype.setPixels = function (startPixel, endPixel) {
  this.startPixel_ = startPixel;
  this.endPixel_ = endPixel;
  this.createOrUpdateGeometry();
  this.render_();
};

/**
 * Creates or updates the cached geometry.
 */
_ol_render_Box_.prototype.createOrUpdateGeometry = function () {
  var startPixel = this.startPixel_;
  var endPixel = this.endPixel_;
  var pixels = [startPixel, [startPixel[0], endPixel[1]], endPixel, [endPixel[0], startPixel[1]]];
  var coordinates = pixels.map(this.map_.getCoordinateFromPixel, this.map_);
  // close the polygon
  coordinates[4] = coordinates[0].slice();
  if (!this.geometry_) {
    this.geometry_ = new polygon["a" /* default */]([coordinates]);
  } else {
    this.geometry_.setCoordinates([coordinates]);
  }
};

/**
 * @return {ol.geom.Polygon} Geometry.
 */
_ol_render_Box_.prototype.getGeometry = function () {
  return this.geometry_;
};
/* harmony default export */ var render_box = (_ol_render_Box_);
// CONCATENATED MODULE: ./node_modules/ol/interaction/dragbox.js
// FIXME draw drag box






/**
 * @classdesc
 * Allows the user to draw a vector box by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when the shift or other key is held down. This is used, for example,
 * for zooming to a specific area of the map
 * (see {@link ol.interaction.DragZoom} and
 * {@link ol.interaction.DragRotateAndZoom}).
 *
 * This interaction is only supported for mouse devices.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @fires ol.interaction.DragBox.Event
 * @param {olx.interaction.DragBoxOptions=} opt_options Options.
 * @api
 */
var dragbox__ol_interaction_DragBox_ = function _ol_interaction_DragBox_(opt_options) {

  pointer.call(this, {
    handleDownEvent: _ol_interaction_DragBox_.handleDownEvent_,
    handleDragEvent: _ol_interaction_DragBox_.handleDragEvent_,
    handleUpEvent: _ol_interaction_DragBox_.handleUpEvent_
  });

  var options = opt_options ? opt_options : {};

  /**
   * @type {ol.render.Box}
   * @private
   */
  this.box_ = new render_box(options.className || 'ol-dragbox');

  /**
   * @type {number}
   * @private
   */
  this.minArea_ = options.minArea !== undefined ? options.minArea : 64;

  /**
   * @type {ol.Pixel}
   * @private
   */
  this.startPixel_ = null;

  /**
   * @private
   * @type {ol.EventsConditionType}
   */
  this.condition_ = options.condition ? options.condition : events_condition["a" /* default */].always;

  /**
   * @private
   * @type {ol.DragBoxEndConditionType}
   */
  this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : _ol_interaction_DragBox_.defaultBoxEndCondition;
};

ol["a" /* default */].inherits(dragbox__ol_interaction_DragBox_, pointer);

/**
 * The default condition for determining whether the boxend event
 * should fire.
 * @param {ol.MapBrowserEvent} mapBrowserEvent The originating MapBrowserEvent
 *     leading to the box end.
 * @param {ol.Pixel} startPixel The starting pixel of the box.
 * @param {ol.Pixel} endPixel The end pixel of the box.
 * @return {boolean} Whether or not the boxend condition should be fired.
 * @this {ol.interaction.DragBox}
 */
dragbox__ol_interaction_DragBox_.defaultBoxEndCondition = function (mapBrowserEvent, startPixel, endPixel) {
  var width = endPixel[0] - startPixel[0];
  var height = endPixel[1] - startPixel[1];
  return width * width + height * height >= this.minArea_;
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.DragBox}
 * @private
 */
dragbox__ol_interaction_DragBox_.handleDragEvent_ = function (mapBrowserEvent) {
  if (!events_condition["a" /* default */].mouseOnly(mapBrowserEvent)) {
    return;
  }

  this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);

  this.dispatchEvent(new dragbox__ol_interaction_DragBox_.Event(dragbox__ol_interaction_DragBox_.EventType_.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
};

/**
 * Returns geometry of last drawn box.
 * @return {ol.geom.Polygon} Geometry.
 * @api
 */
dragbox__ol_interaction_DragBox_.prototype.getGeometry = function () {
  return this.box_.getGeometry();
};

/**
 * To be overridden by child classes.
 * FIXME: use constructor option instead of relying on overriding.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @protected
 */
dragbox__ol_interaction_DragBox_.prototype.onBoxEnd = ol["a" /* default */].nullFunction;

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.DragBox}
 * @private
 */
dragbox__ol_interaction_DragBox_.handleUpEvent_ = function (mapBrowserEvent) {
  if (!events_condition["a" /* default */].mouseOnly(mapBrowserEvent)) {
    return true;
  }

  this.box_.setMap(null);

  if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {
    this.onBoxEnd(mapBrowserEvent);
    this.dispatchEvent(new dragbox__ol_interaction_DragBox_.Event(dragbox__ol_interaction_DragBox_.EventType_.BOXEND, mapBrowserEvent.coordinate, mapBrowserEvent));
  }
  return false;
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.DragBox}
 * @private
 */
dragbox__ol_interaction_DragBox_.handleDownEvent_ = function (mapBrowserEvent) {
  if (!events_condition["a" /* default */].mouseOnly(mapBrowserEvent)) {
    return false;
  }

  if (events_condition["a" /* default */].mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
    this.startPixel_ = mapBrowserEvent.pixel;
    this.box_.setMap(mapBrowserEvent.map);
    this.box_.setPixels(this.startPixel_, this.startPixel_);
    this.dispatchEvent(new dragbox__ol_interaction_DragBox_.Event(dragbox__ol_interaction_DragBox_.EventType_.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
    return true;
  } else {
    return false;
  }
};

/**
 * @enum {string}
 * @private
 */
dragbox__ol_interaction_DragBox_.EventType_ = {
  /**
   * Triggered upon drag box start.
   * @event ol.interaction.DragBox.Event#boxstart
   * @api
   */
  BOXSTART: 'boxstart',

  /**
   * Triggered on drag when box is active.
   * @event ol.interaction.DragBox.Event#boxdrag
   * @api
   */
  BOXDRAG: 'boxdrag',

  /**
   * Triggered upon drag box end.
   * @event ol.interaction.DragBox.Event#boxend
   * @api
   */
  BOXEND: 'boxend'
};

/**
 * @classdesc
 * Events emitted by {@link ol.interaction.DragBox} instances are instances of
 * this type.
 *
 * @param {string} type The event type.
 * @param {ol.Coordinate} coordinate The event coordinate.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Originating event.
 * @extends {ol.events.Event}
 * @constructor
 * @implements {oli.DragBoxEvent}
 */
dragbox__ol_interaction_DragBox_.Event = function (type, coordinate, mapBrowserEvent) {
  events_event["a" /* default */].call(this, type);

  /**
   * The coordinate of the drag event.
   * @const
   * @type {ol.Coordinate}
   * @api
   */
  this.coordinate = coordinate;

  /**
   * @const
   * @type {ol.MapBrowserEvent}
   * @api
   */
  this.mapBrowserEvent = mapBrowserEvent;
};
ol["a" /* default */].inherits(dragbox__ol_interaction_DragBox_.Event, events_event["a" /* default */]);
/* harmony default export */ var dragbox = (dragbox__ol_interaction_DragBox_);
// CONCATENATED MODULE: ./node_modules/ol/interaction/dragzoom.js






/**
 * @classdesc
 * Allows the user to zoom the map by clicking and dragging on the map,
 * normally combined with an {@link ol.events.condition} that limits
 * it to when a key, shift by default, is held down.
 *
 * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
 * your custom one configured with `className`.
 *
 * @constructor
 * @extends {ol.interaction.DragBox}
 * @param {olx.interaction.DragZoomOptions=} opt_options Options.
 * @api
 */
var dragzoom__ol_interaction_DragZoom_ = function _ol_interaction_DragZoom_(opt_options) {
  var options = opt_options ? opt_options : {};

  var condition = options.condition ? options.condition : events_condition["a" /* default */].shiftKeyOnly;

  /**
   * @private
   * @type {number}
   */
  this.duration_ = options.duration !== undefined ? options.duration : 200;

  /**
   * @private
   * @type {boolean}
   */
  this.out_ = options.out !== undefined ? options.out : false;

  dragbox.call(this, {
    condition: condition,
    className: options.className || 'ol-dragzoom'
  });
};

ol["a" /* default */].inherits(dragzoom__ol_interaction_DragZoom_, dragbox);

/**
 * @inheritDoc
 */
dragzoom__ol_interaction_DragZoom_.prototype.onBoxEnd = function () {
  var map = this.getMap();

  var view = /** @type {!ol.View} */map.getView();

  var size = /** @type {!ol.Size} */map.getSize();

  var extent = this.getGeometry().getExtent();

  if (this.out_) {
    var mapExtent = view.calculateExtent(size);
    var boxPixelExtent = ol_extent["a" /* default */].createOrUpdateFromCoordinates([map.getPixelFromCoordinate(ol_extent["a" /* default */].getBottomLeft(extent)), map.getPixelFromCoordinate(ol_extent["a" /* default */].getTopRight(extent))]);
    var factor = view.getResolutionForExtent(boxPixelExtent, size);

    ol_extent["a" /* default */].scaleFromCenter(mapExtent, 1 / factor);
    extent = mapExtent;
  }

  var resolution = view.constrainResolution(view.getResolutionForExtent(extent, size));

  var center = ol_extent["a" /* default */].getCenter(extent);
  center = view.constrainCenter(center);

  view.animate({
    resolution: resolution,
    center: center,
    duration: this.duration_,
    easing: easing["a" /* default */].easeOut
  });
};
/* harmony default export */ var dragzoom = (dragzoom__ol_interaction_DragZoom_);
// CONCATENATED MODULE: ./node_modules/ol/events/keycode.js
/**
 * @enum {number}
 * @const
 */
var _ol_events_KeyCode_ = {
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
};

/* harmony default export */ var keycode = (_ol_events_KeyCode_);
// CONCATENATED MODULE: ./node_modules/ol/interaction/keyboardpan.js







/**
 * @classdesc
 * Allows the user to pan the map using keyboard arrows.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link ol.Map}. `document` never loses focus but, for any other element,
 * focus will have to be on, and returned to, this element if the keys are to
 * function.
 * See also {@link ol.interaction.KeyboardZoom}.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {olx.interaction.KeyboardPanOptions=} opt_options Options.
 * @api
 */
var keyboardpan__ol_interaction_KeyboardPan_ = function _ol_interaction_KeyboardPan_(opt_options) {

  interaction["a" /* default */].call(this, {
    handleEvent: _ol_interaction_KeyboardPan_.handleEvent
  });

  var options = opt_options || {};

  /**
   * @private
   * @param {ol.MapBrowserEvent} mapBrowserEvent Browser event.
   * @return {boolean} Combined condition result.
   */
  this.defaultCondition_ = function (mapBrowserEvent) {
    return events_condition["a" /* default */].noModifierKeys(mapBrowserEvent) && events_condition["a" /* default */].targetNotEditable(mapBrowserEvent);
  };

  /**
   * @private
   * @type {ol.EventsConditionType}
   */
  this.condition_ = options.condition !== undefined ? options.condition : this.defaultCondition_;

  /**
   * @private
   * @type {number}
   */
  this.duration_ = options.duration !== undefined ? options.duration : 100;

  /**
   * @private
   * @type {number}
   */
  this.pixelDelta_ = options.pixelDelta !== undefined ? options.pixelDelta : 128;
};

ol["a" /* default */].inherits(keyboardpan__ol_interaction_KeyboardPan_, interaction["a" /* default */]);

/**
 * Handles the {@link ol.MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides the direction to pan to (if an arrow key was
 * pressed).
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.KeyboardPan}
 * @api
 */
keyboardpan__ol_interaction_KeyboardPan_.handleEvent = function (mapBrowserEvent) {
  var stopEvent = false;
  if (mapBrowserEvent.type == events_eventtype["a" /* default */].KEYDOWN) {
    var keyEvent = mapBrowserEvent.originalEvent;
    var keyCode = keyEvent.keyCode;
    if (this.condition_(mapBrowserEvent) && (keyCode == keycode.DOWN || keyCode == keycode.LEFT || keyCode == keycode.RIGHT || keyCode == keycode.UP)) {
      var map = mapBrowserEvent.map;
      var view = map.getView();
      var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
      var deltaX = 0,
          deltaY = 0;
      if (keyCode == keycode.DOWN) {
        deltaY = -mapUnitsDelta;
      } else if (keyCode == keycode.LEFT) {
        deltaX = -mapUnitsDelta;
      } else if (keyCode == keycode.RIGHT) {
        deltaX = mapUnitsDelta;
      } else {
        deltaY = mapUnitsDelta;
      }
      var delta = [deltaX, deltaY];
      ol_coordinate["a" /* default */].rotate(delta, view.getRotation());
      interaction["a" /* default */].pan(view, delta, this.duration_);
      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }
  return !stopEvent;
};
/* harmony default export */ var keyboardpan = (keyboardpan__ol_interaction_KeyboardPan_);
// CONCATENATED MODULE: ./node_modules/ol/interaction/keyboardzoom.js





/**
 * @classdesc
 * Allows the user to zoom the map using keyboard + and -.
 * Note that, although this interaction is by default included in maps,
 * the keys can only be used when browser focus is on the element to which
 * the keyboard events are attached. By default, this is the map div,
 * though you can change this with the `keyboardEventTarget` in
 * {@link ol.Map}. `document` never loses focus but, for any other element,
 * focus will have to be on, and returned to, this element if the keys are to
 * function.
 * See also {@link ol.interaction.KeyboardPan}.
 *
 * @constructor
 * @param {olx.interaction.KeyboardZoomOptions=} opt_options Options.
 * @extends {ol.interaction.Interaction}
 * @api
 */
var keyboardzoom__ol_interaction_KeyboardZoom_ = function _ol_interaction_KeyboardZoom_(opt_options) {

  interaction["a" /* default */].call(this, {
    handleEvent: _ol_interaction_KeyboardZoom_.handleEvent
  });

  var options = opt_options ? opt_options : {};

  /**
   * @private
   * @type {ol.EventsConditionType}
   */
  this.condition_ = options.condition ? options.condition : events_condition["a" /* default */].targetNotEditable;

  /**
   * @private
   * @type {number}
   */
  this.delta_ = options.delta ? options.delta : 1;

  /**
   * @private
   * @type {number}
   */
  this.duration_ = options.duration !== undefined ? options.duration : 100;
};

ol["a" /* default */].inherits(keyboardzoom__ol_interaction_KeyboardZoom_, interaction["a" /* default */]);

/**
 * Handles the {@link ol.MapBrowserEvent map browser event} if it was a
 * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
 * key pressed was '+' or '-').
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.KeyboardZoom}
 * @api
 */
keyboardzoom__ol_interaction_KeyboardZoom_.handleEvent = function (mapBrowserEvent) {
  var stopEvent = false;
  if (mapBrowserEvent.type == events_eventtype["a" /* default */].KEYDOWN || mapBrowserEvent.type == events_eventtype["a" /* default */].KEYPRESS) {
    var keyEvent = mapBrowserEvent.originalEvent;
    var charCode = keyEvent.charCode;
    if (this.condition_(mapBrowserEvent) && (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
      var map = mapBrowserEvent.map;
      var delta = charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;
      var view = map.getView();
      interaction["a" /* default */].zoomByDelta(view, delta, undefined, this.duration_);
      mapBrowserEvent.preventDefault();
      stopEvent = true;
    }
  }
  return !stopEvent;
};
/* harmony default export */ var keyboardzoom = (keyboardzoom__ol_interaction_KeyboardZoom_);
// EXTERNAL MODULE: ./node_modules/ol/math.js
var math = __webpack_require__(6);

// CONCATENATED MODULE: ./node_modules/ol/interaction/mousewheelzoom.js








/**
 * @classdesc
 * Allows the user to zoom the map by scrolling the mouse wheel.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {olx.interaction.MouseWheelZoomOptions=} opt_options Options.
 * @api
 */
var mousewheelzoom__ol_interaction_MouseWheelZoom_ = function _ol_interaction_MouseWheelZoom_(opt_options) {

  interaction["a" /* default */].call(this, {
    handleEvent: _ol_interaction_MouseWheelZoom_.handleEvent
  });

  var options = opt_options || {};

  /**
   * @private
   * @type {number}
   */
  this.delta_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.duration_ = options.duration !== undefined ? options.duration : 250;

  /**
   * @private
   * @type {number}
   */
  this.timeout_ = options.timeout !== undefined ? options.timeout : 80;

  /**
   * @private
   * @type {boolean}
   */
  this.useAnchor_ = options.useAnchor !== undefined ? options.useAnchor : true;

  /**
   * @private
   * @type {boolean}
   */
  this.constrainResolution_ = options.constrainResolution || false;

  /**
   * @private
   * @type {?ol.Coordinate}
   */
  this.lastAnchor_ = null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.startTime_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.timeoutId_ = undefined;

  /**
   * @private
   * @type {ol.interaction.MouseWheelZoom.Mode_|undefined}
   */
  this.mode_ = undefined;

  /**
   * Trackpad events separated by this delay will be considered separate
   * interactions.
   * @type {number}
   */
  this.trackpadEventGap_ = 400;

  /**
   * @type {number|undefined}
   */
  this.trackpadTimeoutId_ = undefined;

  /**
   * The number of delta values per zoom level
   * @private
   * @type {number}
   */
  this.trackpadDeltaPerZoom_ = 300;

  /**
   * The zoom factor by which scroll zooming is allowed to exceed the limits.
   * @private
   * @type {number}
   */
  this.trackpadZoomBuffer_ = 1.5;
};

ol["a" /* default */].inherits(mousewheelzoom__ol_interaction_MouseWheelZoom_, interaction["a" /* default */]);

/**
 * Handles the {@link ol.MapBrowserEvent map browser event} (if it was a
 * mousewheel-event) and eventually zooms the map.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} Allow event propagation.
 * @this {ol.interaction.MouseWheelZoom}
 * @api
 */
mousewheelzoom__ol_interaction_MouseWheelZoom_.handleEvent = function (mapBrowserEvent) {
  var type = mapBrowserEvent.type;
  if (type !== events_eventtype["a" /* default */].WHEEL && type !== events_eventtype["a" /* default */].MOUSEWHEEL) {
    return true;
  }

  mapBrowserEvent.preventDefault();

  var map = mapBrowserEvent.map;
  var wheelEvent = /** @type {WheelEvent} */mapBrowserEvent.originalEvent;

  if (this.useAnchor_) {
    this.lastAnchor_ = mapBrowserEvent.coordinate;
  }

  // Delta normalisation inspired by
  // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
  var delta;
  if (mapBrowserEvent.type == events_eventtype["a" /* default */].WHEEL) {
    delta = wheelEvent.deltaY;
    if (has["a" /* default */].FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
      delta /= has["a" /* default */].DEVICE_PIXEL_RATIO;
    }
    if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
      delta *= 40;
    }
  } else if (mapBrowserEvent.type == events_eventtype["a" /* default */].MOUSEWHEEL) {
    delta = -wheelEvent.wheelDeltaY;
    if (has["a" /* default */].SAFARI) {
      delta /= 3;
    }
  }

  if (delta === 0) {
    return false;
  }

  var now = Date.now();

  if (this.startTime_ === undefined) {
    this.startTime_ = now;
  }

  if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
    this.mode_ = Math.abs(delta) < 4 ? mousewheelzoom__ol_interaction_MouseWheelZoom_.Mode_.TRACKPAD : mousewheelzoom__ol_interaction_MouseWheelZoom_.Mode_.WHEEL;
  }

  if (this.mode_ === mousewheelzoom__ol_interaction_MouseWheelZoom_.Mode_.TRACKPAD) {
    var view = map.getView();
    if (this.trackpadTimeoutId_) {
      clearTimeout(this.trackpadTimeoutId_);
    } else {
      view.setHint(viewhint["a" /* default */].INTERACTING, 1);
    }
    this.trackpadTimeoutId_ = setTimeout(this.decrementInteractingHint_.bind(this), this.trackpadEventGap_);
    var resolution = view.getResolution() * Math.pow(2, delta / this.trackpadDeltaPerZoom_);
    var minResolution = view.getMinResolution();
    var maxResolution = view.getMaxResolution();
    var rebound = 0;
    if (resolution < minResolution) {
      resolution = Math.max(resolution, minResolution / this.trackpadZoomBuffer_);
      rebound = 1;
    } else if (resolution > maxResolution) {
      resolution = Math.min(resolution, maxResolution * this.trackpadZoomBuffer_);
      rebound = -1;
    }
    if (this.lastAnchor_) {
      var center = view.calculateCenterZoom(resolution, this.lastAnchor_);
      view.setCenter(view.constrainCenter(center));
    }
    view.setResolution(resolution);

    if (rebound === 0 && this.constrainResolution_) {
      view.animate({
        resolution: view.constrainResolution(resolution, delta > 0 ? -1 : 1),
        easing: easing["a" /* default */].easeOut,
        anchor: this.lastAnchor_,
        duration: this.duration_
      });
    }

    if (rebound > 0) {
      view.animate({
        resolution: minResolution,
        easing: easing["a" /* default */].easeOut,
        anchor: this.lastAnchor_,
        duration: 500
      });
    } else if (rebound < 0) {
      view.animate({
        resolution: maxResolution,
        easing: easing["a" /* default */].easeOut,
        anchor: this.lastAnchor_,
        duration: 500
      });
    }
    this.startTime_ = now;
    return false;
  }

  this.delta_ += delta;

  var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);

  clearTimeout(this.timeoutId_);
  this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);

  return false;
};

/**
 * @private
 */
mousewheelzoom__ol_interaction_MouseWheelZoom_.prototype.decrementInteractingHint_ = function () {
  this.trackpadTimeoutId_ = undefined;
  var view = this.getMap().getView();
  view.setHint(viewhint["a" /* default */].INTERACTING, -1);
};

/**
 * @private
 * @param {ol.PluggableMap} map Map.
 */
mousewheelzoom__ol_interaction_MouseWheelZoom_.prototype.handleWheelZoom_ = function (map) {
  var view = map.getView();
  if (view.getAnimating()) {
    view.cancelAnimations();
  }
  var maxDelta = ol["a" /* default */].MOUSEWHEELZOOM_MAXDELTA;
  var delta = math["a" /* default */].clamp(this.delta_, -maxDelta, maxDelta);
  interaction["a" /* default */].zoomByDelta(view, -delta, this.lastAnchor_, this.duration_);
  this.mode_ = undefined;
  this.delta_ = 0;
  this.lastAnchor_ = null;
  this.startTime_ = undefined;
  this.timeoutId_ = undefined;
};

/**
 * Enable or disable using the mouse's location as an anchor when zooming
 * @param {boolean} useAnchor true to zoom to the mouse's location, false
 * to zoom to the center of the map
 * @api
 */
mousewheelzoom__ol_interaction_MouseWheelZoom_.prototype.setMouseAnchor = function (useAnchor) {
  this.useAnchor_ = useAnchor;
  if (!useAnchor) {
    this.lastAnchor_ = null;
  }
};

/**
 * @enum {string}
 * @private
 */
mousewheelzoom__ol_interaction_MouseWheelZoom_.Mode_ = {
  TRACKPAD: 'trackpad',
  WHEEL: 'wheel'
};
/* harmony default export */ var mousewheelzoom = (mousewheelzoom__ol_interaction_MouseWheelZoom_);
// CONCATENATED MODULE: ./node_modules/ol/interaction/pinchrotate.js







/**
 * @classdesc
 * Allows the user to rotate the map by twisting with two fingers
 * on a touch screen.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.PinchRotateOptions=} opt_options Options.
 * @api
 */
var pinchrotate__ol_interaction_PinchRotate_ = function _ol_interaction_PinchRotate_(opt_options) {

  pointer.call(this, {
    handleDownEvent: _ol_interaction_PinchRotate_.handleDownEvent_,
    handleDragEvent: _ol_interaction_PinchRotate_.handleDragEvent_,
    handleUpEvent: _ol_interaction_PinchRotate_.handleUpEvent_
  });

  var options = opt_options || {};

  /**
   * @private
   * @type {ol.Coordinate}
   */
  this.anchor_ = null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.lastAngle_ = undefined;

  /**
   * @private
   * @type {boolean}
   */
  this.rotating_ = false;

  /**
   * @private
   * @type {number}
   */
  this.rotationDelta_ = 0.0;

  /**
   * @private
   * @type {number}
   */
  this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;

  /**
   * @private
   * @type {number}
   */
  this.duration_ = options.duration !== undefined ? options.duration : 250;
};

ol["a" /* default */].inherits(pinchrotate__ol_interaction_PinchRotate_, pointer);

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.PinchRotate}
 * @private
 */
pinchrotate__ol_interaction_PinchRotate_.handleDragEvent_ = function (mapBrowserEvent) {
  var rotationDelta = 0.0;

  var touch0 = this.targetPointers[0];
  var touch1 = this.targetPointers[1];

  // angle between touches
  var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);

  if (this.lastAngle_ !== undefined) {
    var delta = angle - this.lastAngle_;
    this.rotationDelta_ += delta;
    if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
      this.rotating_ = true;
    }
    rotationDelta = delta;
  }
  this.lastAngle_ = angle;

  var map = mapBrowserEvent.map;
  var view = map.getView();
  if (view.getConstraints().rotation === rotationconstraint["a" /* default */].disable) {
    return;
  }

  // rotate anchor point.
  // FIXME: should be the intersection point between the lines:
  //     touch0,touch1 and previousTouch0,previousTouch1
  var viewportPosition = map.getViewport().getBoundingClientRect();
  var centroid = pointer.centroid(this.targetPointers);
  centroid[0] -= viewportPosition.left;
  centroid[1] -= viewportPosition.top;
  this.anchor_ = map.getCoordinateFromPixel(centroid);

  // rotate
  if (this.rotating_) {
    var rotation = view.getRotation();
    map.render();
    interaction["a" /* default */].rotateWithoutConstraints(view, rotation + rotationDelta, this.anchor_);
  }
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.PinchRotate}
 * @private
 */
pinchrotate__ol_interaction_PinchRotate_.handleUpEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length < 2) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.setHint(viewhint["a" /* default */].INTERACTING, -1);
    if (this.rotating_) {
      var rotation = view.getRotation();
      interaction["a" /* default */].rotate(view, rotation, this.anchor_, this.duration_);
    }
    return false;
  } else {
    return true;
  }
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.PinchRotate}
 * @private
 */
pinchrotate__ol_interaction_PinchRotate_.handleDownEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length >= 2) {
    var map = mapBrowserEvent.map;
    this.anchor_ = null;
    this.lastAngle_ = undefined;
    this.rotating_ = false;
    this.rotationDelta_ = 0.0;
    if (!this.handlingDownUpSequence) {
      map.getView().setHint(viewhint["a" /* default */].INTERACTING, 1);
    }
    return true;
  } else {
    return false;
  }
};

/**
 * @inheritDoc
 */
pinchrotate__ol_interaction_PinchRotate_.prototype.shouldStopEvent = functions["a" /* default */].FALSE;
/* harmony default export */ var pinchrotate = (pinchrotate__ol_interaction_PinchRotate_);
// CONCATENATED MODULE: ./node_modules/ol/interaction/pinchzoom.js






/**
 * @classdesc
 * Allows the user to zoom the map by pinching with two fingers
 * on a touch screen.
 *
 * @constructor
 * @extends {ol.interaction.Pointer}
 * @param {olx.interaction.PinchZoomOptions=} opt_options Options.
 * @api
 */
var pinchzoom__ol_interaction_PinchZoom_ = function _ol_interaction_PinchZoom_(opt_options) {

  pointer.call(this, {
    handleDownEvent: _ol_interaction_PinchZoom_.handleDownEvent_,
    handleDragEvent: _ol_interaction_PinchZoom_.handleDragEvent_,
    handleUpEvent: _ol_interaction_PinchZoom_.handleUpEvent_
  });

  var options = opt_options ? opt_options : {};

  /**
   * @private
   * @type {boolean}
   */
  this.constrainResolution_ = options.constrainResolution || false;

  /**
   * @private
   * @type {ol.Coordinate}
   */
  this.anchor_ = null;

  /**
   * @private
   * @type {number}
   */
  this.duration_ = options.duration !== undefined ? options.duration : 400;

  /**
   * @private
   * @type {number|undefined}
   */
  this.lastDistance_ = undefined;

  /**
   * @private
   * @type {number}
   */
  this.lastScaleDelta_ = 1;
};

ol["a" /* default */].inherits(pinchzoom__ol_interaction_PinchZoom_, pointer);

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @this {ol.interaction.PinchZoom}
 * @private
 */
pinchzoom__ol_interaction_PinchZoom_.handleDragEvent_ = function (mapBrowserEvent) {
  var scaleDelta = 1.0;

  var touch0 = this.targetPointers[0];
  var touch1 = this.targetPointers[1];
  var dx = touch0.clientX - touch1.clientX;
  var dy = touch0.clientY - touch1.clientY;

  // distance between touches
  var distance = Math.sqrt(dx * dx + dy * dy);

  if (this.lastDistance_ !== undefined) {
    scaleDelta = this.lastDistance_ / distance;
  }
  this.lastDistance_ = distance;

  var map = mapBrowserEvent.map;
  var view = map.getView();
  var resolution = view.getResolution();
  var maxResolution = view.getMaxResolution();
  var minResolution = view.getMinResolution();
  var newResolution = resolution * scaleDelta;
  if (newResolution > maxResolution) {
    scaleDelta = maxResolution / resolution;
    newResolution = maxResolution;
  } else if (newResolution < minResolution) {
    scaleDelta = minResolution / resolution;
    newResolution = minResolution;
  }

  if (scaleDelta != 1.0) {
    this.lastScaleDelta_ = scaleDelta;
  }

  // scale anchor point.
  var viewportPosition = map.getViewport().getBoundingClientRect();
  var centroid = pointer.centroid(this.targetPointers);
  centroid[0] -= viewportPosition.left;
  centroid[1] -= viewportPosition.top;
  this.anchor_ = map.getCoordinateFromPixel(centroid);

  // scale, bypass the resolution constraint
  map.render();
  interaction["a" /* default */].zoomWithoutConstraints(view, newResolution, this.anchor_);
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Stop drag sequence?
 * @this {ol.interaction.PinchZoom}
 * @private
 */
pinchzoom__ol_interaction_PinchZoom_.handleUpEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length < 2) {
    var map = mapBrowserEvent.map;
    var view = map.getView();
    view.setHint(viewhint["a" /* default */].INTERACTING, -1);
    var resolution = view.getResolution();
    if (this.constrainResolution_ || resolution < view.getMinResolution() || resolution > view.getMaxResolution()) {
      // Zoom to final resolution, with an animation, and provide a
      // direction not to zoom out/in if user was pinching in/out.
      // Direction is > 0 if pinching out, and < 0 if pinching in.
      var direction = this.lastScaleDelta_ - 1;
      interaction["a" /* default */].zoom(view, resolution, this.anchor_, this.duration_, direction);
    }
    return false;
  } else {
    return true;
  }
};

/**
 * @param {ol.MapBrowserPointerEvent} mapBrowserEvent Event.
 * @return {boolean} Start drag sequence?
 * @this {ol.interaction.PinchZoom}
 * @private
 */
pinchzoom__ol_interaction_PinchZoom_.handleDownEvent_ = function (mapBrowserEvent) {
  if (this.targetPointers.length >= 2) {
    var map = mapBrowserEvent.map;
    this.anchor_ = null;
    this.lastDistance_ = undefined;
    this.lastScaleDelta_ = 1;
    if (!this.handlingDownUpSequence) {
      map.getView().setHint(viewhint["a" /* default */].INTERACTING, 1);
    }
    return true;
  } else {
    return false;
  }
};

/**
 * @inheritDoc
 */
pinchzoom__ol_interaction_PinchZoom_.prototype.shouldStopEvent = functions["a" /* default */].FALSE;
/* harmony default export */ var pinchzoom = (pinchzoom__ol_interaction_PinchZoom_);
// CONCATENATED MODULE: ./node_modules/ol/interaction.js











var _ol_interaction_ = {};

/**
 * Set of interactions included in maps by default. Specific interactions can be
 * excluded by setting the appropriate option to false in the constructor
 * options, but the order of the interactions is fixed.  If you want to specify
 * a different order for interactions, you will need to create your own
 * {@link ol.interaction.Interaction} instances and insert them into a
 * {@link ol.Collection} in the order you want before creating your
 * {@link ol.Map} instance. The default set of interactions, in sequence, is:
 * * {@link ol.interaction.DragRotate}
 * * {@link ol.interaction.DoubleClickZoom}
 * * {@link ol.interaction.DragPan}
 * * {@link ol.interaction.PinchRotate}
 * * {@link ol.interaction.PinchZoom}
 * * {@link ol.interaction.KeyboardPan}
 * * {@link ol.interaction.KeyboardZoom}
 * * {@link ol.interaction.MouseWheelZoom}
 * * {@link ol.interaction.DragZoom}
 *
 * @param {olx.interaction.DefaultsOptions=} opt_options Defaults options.
 * @return {ol.Collection.<ol.interaction.Interaction>} A collection of
 * interactions to be used with the ol.Map constructor's interactions option.
 * @api
 */
_ol_interaction_.defaults = function (opt_options) {

  var options = opt_options ? opt_options : {};

  var interactions = new collection["a" /* default */]();

  var kinetic = new ol_kinetic(-0.005, 0.05, 100);

  var altShiftDragRotate = options.altShiftDragRotate !== undefined ? options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new dragrotate());
  }

  var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(new doubleclickzoom({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var dragPan = options.dragPan !== undefined ? options.dragPan : true;
  if (dragPan) {
    interactions.push(new dragpan({
      kinetic: kinetic
    }));
  }

  var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;
  if (pinchRotate) {
    interactions.push(new pinchrotate());
  }

  var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(new pinchzoom({
      constrainResolution: options.constrainResolution,
      duration: options.zoomDuration
    }));
  }

  var keyboard = options.keyboard !== undefined ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new keyboardpan());
    interactions.push(new keyboardzoom({
      delta: options.zoomDelta,
      duration: options.zoomDuration
    }));
  }

  var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(new mousewheelzoom({
      constrainResolution: options.constrainResolution,
      duration: options.zoomDuration
    }));
  }

  var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(new dragzoom({
      duration: options.zoomDuration
    }));
  }

  return interactions;
};
/* harmony default export */ var ol_interaction = (_ol_interaction_);
// CONCATENATED MODULE: ./node_modules/ol/imagebase.js




/**
 * @constructor
 * @abstract
 * @extends {ol.events.EventTarget}
 * @param {ol.Extent} extent Extent.
 * @param {number|undefined} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.ImageState} state State.
 */
var imagebase__ol_ImageBase_ = function _ol_ImageBase_(extent, resolution, pixelRatio, state) {

  eventtarget["a" /* default */].call(this);

  /**
   * @protected
   * @type {ol.Extent}
   */
  this.extent = extent;

  /**
   * @private
   * @type {number}
   */
  this.pixelRatio_ = pixelRatio;

  /**
   * @protected
   * @type {number|undefined}
   */
  this.resolution = resolution;

  /**
   * @protected
   * @type {ol.ImageState}
   */
  this.state = state;
};

ol["a" /* default */].inherits(imagebase__ol_ImageBase_, eventtarget["a" /* default */]);

/**
 * @protected
 */
imagebase__ol_ImageBase_.prototype.changed = function () {
  this.dispatchEvent(events_eventtype["a" /* default */].CHANGE);
};

/**
 * @return {ol.Extent} Extent.
 */
imagebase__ol_ImageBase_.prototype.getExtent = function () {
  return this.extent;
};

/**
 * @abstract
 * @return {HTMLCanvasElement|Image|HTMLVideoElement} Image.
 */
imagebase__ol_ImageBase_.prototype.getImage = function () {};

/**
 * @return {number} PixelRatio.
 */
imagebase__ol_ImageBase_.prototype.getPixelRatio = function () {
  return this.pixelRatio_;
};

/**
 * @return {number} Resolution.
 */
imagebase__ol_ImageBase_.prototype.getResolution = function () {
  return (/** @type {number} */this.resolution
  );
};

/**
 * @return {ol.ImageState} State.
 */
imagebase__ol_ImageBase_.prototype.getState = function () {
  return this.state;
};

/**
 * Load not yet loaded URI.
 * @abstract
 */
imagebase__ol_ImageBase_.prototype.load = function () {};
/* harmony default export */ var imagebase = (imagebase__ol_ImageBase_);
// EXTERNAL MODULE: ./node_modules/ol/imagestate.js
var imagestate = __webpack_require__(40);

// CONCATENATED MODULE: ./node_modules/ol/imagecanvas.js




/**
 * @constructor
 * @extends {ol.ImageBase}
 * @param {ol.Extent} extent Extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {ol.ImageCanvasLoader=} opt_loader Optional loader function to
 *     support asynchronous canvas drawing.
 */
var imagecanvas__ol_ImageCanvas_ = function _ol_ImageCanvas_(extent, resolution, pixelRatio, canvas, opt_loader) {

  /**
   * Optional canvas loader function.
   * @type {?ol.ImageCanvasLoader}
   * @private
   */
  this.loader_ = opt_loader !== undefined ? opt_loader : null;

  var state = opt_loader !== undefined ? imagestate["a" /* default */].IDLE : imagestate["a" /* default */].LOADED;

  imagebase.call(this, extent, resolution, pixelRatio, state);

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = canvas;

  /**
   * @private
   * @type {Error}
   */
  this.error_ = null;
};

ol["a" /* default */].inherits(imagecanvas__ol_ImageCanvas_, imagebase);

/**
 * Get any error associated with asynchronous rendering.
 * @return {Error} Any error that occurred during rendering.
 */
imagecanvas__ol_ImageCanvas_.prototype.getError = function () {
  return this.error_;
};

/**
 * Handle async drawing complete.
 * @param {Error} err Any error during drawing.
 * @private
 */
imagecanvas__ol_ImageCanvas_.prototype.handleLoad_ = function (err) {
  if (err) {
    this.error_ = err;
    this.state = imagestate["a" /* default */].ERROR;
  } else {
    this.state = imagestate["a" /* default */].LOADED;
  }
  this.changed();
};

/**
 * @inheritDoc
 */
imagecanvas__ol_ImageCanvas_.prototype.load = function () {
  if (this.state == imagestate["a" /* default */].IDLE) {
    this.state = imagestate["a" /* default */].LOADING;
    this.changed();
    this.loader_(this.handleLoad_.bind(this));
  }
};

/**
 * @inheritDoc
 */
imagecanvas__ol_ImageCanvas_.prototype.getImage = function () {
  return this.canvas_;
};
/* harmony default export */ var imagecanvas = (imagecanvas__ol_ImageCanvas_);
// EXTERNAL MODULE: ./node_modules/ol/layertype.js
var layertype = __webpack_require__(24);

// EXTERNAL MODULE: ./node_modules/ol/layer/vectorrendertype.js
var vectorrendertype = __webpack_require__(86);

// CONCATENATED MODULE: ./node_modules/ol/render/event.js



/**
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.render.Event}
 * @param {ol.render.EventType} type Type.
 * @param {ol.render.VectorContext=} opt_vectorContext Vector context.
 * @param {olx.FrameState=} opt_frameState Frame state.
 * @param {?CanvasRenderingContext2D=} opt_context Context.
 * @param {?ol.webgl.Context=} opt_glContext WebGL Context.
 */
var event__ol_render_Event_ = function _ol_render_Event_(type, opt_vectorContext, opt_frameState, opt_context, opt_glContext) {

  events_event["a" /* default */].call(this, type);

  /**
   * For canvas, this is an instance of {@link ol.render.canvas.Immediate}.
   * @type {ol.render.VectorContext|undefined}
   * @api
   */
  this.vectorContext = opt_vectorContext;

  /**
   * An object representing the current render frame state.
   * @type {olx.FrameState|undefined}
   * @api
   */
  this.frameState = opt_frameState;

  /**
   * Canvas context. Only available when a Canvas renderer is used, null
   * otherwise.
   * @type {CanvasRenderingContext2D|null|undefined}
   * @api
   */
  this.context = opt_context;

  /**
   * WebGL context. Only available when a WebGL renderer is used, null
   * otherwise.
   * @type {ol.webgl.Context|null|undefined}
   * @api
   */
  this.glContext = opt_glContext;
};

ol["a" /* default */].inherits(event__ol_render_Event_, events_event["a" /* default */]);
/* harmony default export */ var render_event = (event__ol_render_Event_);
// EXTERNAL MODULE: ./node_modules/ol/render/eventtype.js
var render_eventtype = __webpack_require__(43);

// EXTERNAL MODULE: ./node_modules/ol/render/canvas.js
var render_canvas = __webpack_require__(21);

// EXTERNAL MODULE: ./node_modules/ol/colorlike.js
var colorlike = __webpack_require__(46);

// EXTERNAL MODULE: ./node_modules/ol/geom/geometrytype.js
var geometrytype = __webpack_require__(10);

// EXTERNAL MODULE: ./node_modules/ol/geom/simplegeometry.js
var simplegeometry = __webpack_require__(22);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/transform.js
var flat_transform = __webpack_require__(25);

// CONCATENATED MODULE: ./node_modules/ol/render/vectorcontext.js
/**
 * Context for drawing geometries.  A vector context is available on render
 * events and does not need to be constructed directly.
 * @constructor
 * @abstract
 * @struct
 * @api
 */
var _ol_render_VectorContext_ = function _ol_render_VectorContext_() {};

/**
 * Render a geometry with a custom renderer.
 *
 * @param {ol.geom.SimpleGeometry} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {Function} renderer Renderer.
 */
_ol_render_VectorContext_.prototype.drawCustom = function (geometry, feature, renderer) {};

/**
 * Render a geometry.
 *
 * @param {ol.geom.Geometry} geometry The geometry to render.
 */
_ol_render_VectorContext_.prototype.drawGeometry = function (geometry) {};

/**
 * Set the rendering style.
 *
 * @param {ol.style.Style} style The rendering style.
 */
_ol_render_VectorContext_.prototype.setStyle = function (style) {};

/**
 * @param {ol.geom.Circle} circleGeometry Circle geometry.
 * @param {ol.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawCircle = function (circleGeometry, feature) {};

/**
 * @param {ol.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 */
_ol_render_VectorContext_.prototype.drawFeature = function (feature, style) {};

/**
 * @param {ol.geom.GeometryCollection} geometryCollectionGeometry Geometry
 *     collection.
 * @param {ol.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawGeometryCollection = function (geometryCollectionGeometry, feature) {};

/**
 * @param {ol.geom.LineString|ol.render.Feature} lineStringGeometry Line
 *     string geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawLineString = function (lineStringGeometry, feature) {};

/**
 * @param {ol.geom.MultiLineString|ol.render.Feature} multiLineStringGeometry
 *     MultiLineString geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {};

/**
 * @param {ol.geom.MultiPoint|ol.render.Feature} multiPointGeometry MultiPoint
 *     geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawMultiPoint = function (multiPointGeometry, feature) {};

/**
 * @param {ol.geom.MultiPolygon} multiPolygonGeometry MultiPolygon geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {};

/**
 * @param {ol.geom.Point|ol.render.Feature} pointGeometry Point geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawPoint = function (pointGeometry, feature) {};

/**
 * @param {ol.geom.Polygon|ol.render.Feature} polygonGeometry Polygon
 *     geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawPolygon = function (polygonGeometry, feature) {};

/**
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
_ol_render_VectorContext_.prototype.drawText = function (geometry, feature) {};

/**
 * @param {ol.style.Fill} fillStyle Fill style.
 * @param {ol.style.Stroke} strokeStyle Stroke style.
 */
_ol_render_VectorContext_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {};

/**
 * @param {ol.style.Image} imageStyle Image style.
 * @param {ol.DeclutterGroup=} opt_declutterGroup Declutter.
 */
_ol_render_VectorContext_.prototype.setImageStyle = function (imageStyle, opt_declutterGroup) {};

/**
 * @param {ol.style.Text} textStyle Text style.
 * @param {ol.DeclutterGroup=} opt_declutterGroup Declutter.
 */
_ol_render_VectorContext_.prototype.setTextStyle = function (textStyle, opt_declutterGroup) {};
/* harmony default export */ var vectorcontext = (_ol_render_VectorContext_);
// CONCATENATED MODULE: ./node_modules/ol/render/canvas/immediate.js
// FIXME test, especially polygons with holes and multipolygons
// FIXME need to handle large thick features (where pixel size matters)
// FIXME add offset and end to ol.geom.flat.transform.transform2D?













/**
 * @classdesc
 * A concrete subclass of {@link ol.render.VectorContext} that implements
 * direct rendering of features and geometries to an HTML5 Canvas context.
 * Instances of this class are created internally by the library and
 * provided to application code as vectorContext member of the
 * {@link ol.render.Event} object associated with postcompose, precompose and
 * render events emitted by layers and maps.
 *
 * @constructor
 * @extends {ol.render.VectorContext}
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Extent} extent Extent.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @struct
 */
var immediate__ol_render_canvas_Immediate_ = function _ol_render_canvas_Immediate_(context, pixelRatio, extent, transform, viewRotation) {
  vectorcontext.call(this);

  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */
  this.context_ = context;

  /**
   * @private
   * @type {number}
   */
  this.pixelRatio_ = pixelRatio;

  /**
   * @private
   * @type {ol.Extent}
   */
  this.extent_ = extent;

  /**
   * @private
   * @type {ol.Transform}
   */
  this.transform_ = transform;

  /**
   * @private
   * @type {number}
   */
  this.viewRotation_ = viewRotation;

  /**
   * @private
   * @type {?ol.CanvasFillState}
   */
  this.contextFillState_ = null;

  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */
  this.contextStrokeState_ = null;

  /**
   * @private
   * @type {?ol.CanvasTextState}
   */
  this.contextTextState_ = null;

  /**
   * @private
   * @type {?ol.CanvasFillState}
   */
  this.fillState_ = null;

  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */
  this.strokeState_ = null;

  /**
   * @private
   * @type {HTMLCanvasElement|HTMLVideoElement|Image}
   */
  this.image_ = null;

  /**
   * @private
   * @type {number}
   */
  this.imageAnchorX_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.imageAnchorY_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.imageHeight_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.imageOpacity_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.imageOriginX_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.imageOriginY_ = 0;

  /**
   * @private
   * @type {boolean}
   */
  this.imageRotateWithView_ = false;

  /**
   * @private
   * @type {number}
   */
  this.imageRotation_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.imageScale_ = 0;

  /**
   * @private
   * @type {boolean}
   */
  this.imageSnapToPixel_ = false;

  /**
   * @private
   * @type {number}
   */
  this.imageWidth_ = 0;

  /**
   * @private
   * @type {string}
   */
  this.text_ = '';

  /**
   * @private
   * @type {number}
   */
  this.textOffsetX_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.textOffsetY_ = 0;

  /**
   * @private
   * @type {boolean}
   */
  this.textRotateWithView_ = false;

  /**
   * @private
   * @type {number}
   */
  this.textRotation_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.textScale_ = 0;

  /**
   * @private
   * @type {?ol.CanvasFillState}
   */
  this.textFillState_ = null;

  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */
  this.textStrokeState_ = null;

  /**
   * @private
   * @type {?ol.CanvasTextState}
   */
  this.textState_ = null;

  /**
   * @private
   * @type {Array.<number>}
   */
  this.pixelCoordinates_ = [];

  /**
   * @private
   * @type {ol.Transform}
   */
  this.tmpLocalTransform_ = ol_transform["a" /* default */].create();
};

ol["a" /* default */].inherits(immediate__ol_render_canvas_Immediate_, vectorcontext);

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 */
immediate__ol_render_canvas_Immediate_.prototype.drawImages_ = function (flatCoordinates, offset, end, stride) {
  if (!this.image_) {
    return;
  }
  var pixelCoordinates = flat_transform["a" /* default */].transform2D(flatCoordinates, offset, end, 2, this.transform_, this.pixelCoordinates_);
  var context = this.context_;
  var localTransform = this.tmpLocalTransform_;
  var alpha = context.globalAlpha;
  if (this.imageOpacity_ != 1) {
    context.globalAlpha = alpha * this.imageOpacity_;
  }
  var rotation = this.imageRotation_;
  if (this.imageRotateWithView_) {
    rotation += this.viewRotation_;
  }
  var i, ii;
  for (i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
    var x = pixelCoordinates[i] - this.imageAnchorX_;
    var y = pixelCoordinates[i + 1] - this.imageAnchorY_;
    if (this.imageSnapToPixel_) {
      x = Math.round(x);
      y = Math.round(y);
    }
    if (rotation !== 0 || this.imageScale_ != 1) {
      var centerX = x + this.imageAnchorX_;
      var centerY = y + this.imageAnchorY_;
      ol_transform["a" /* default */].compose(localTransform, centerX, centerY, this.imageScale_, this.imageScale_, rotation, -centerX, -centerY);
      context.setTransform.apply(context, localTransform);
    }
    context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
  }
  if (rotation !== 0 || this.imageScale_ != 1) {
    context.setTransform(1, 0, 0, 1, 0, 0);
  }
  if (this.imageOpacity_ != 1) {
    context.globalAlpha = alpha;
  }
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 */
immediate__ol_render_canvas_Immediate_.prototype.drawText_ = function (flatCoordinates, offset, end, stride) {
  if (!this.textState_ || this.text_ === '') {
    return;
  }
  if (this.textFillState_) {
    this.setContextFillState_(this.textFillState_);
  }
  if (this.textStrokeState_) {
    this.setContextStrokeState_(this.textStrokeState_);
  }
  this.setContextTextState_(this.textState_);
  var pixelCoordinates = flat_transform["a" /* default */].transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
  var context = this.context_;
  var rotation = this.textRotation_;
  if (this.textRotateWithView_) {
    rotation += this.viewRotation_;
  }
  for (; offset < end; offset += stride) {
    var x = pixelCoordinates[offset] + this.textOffsetX_;
    var y = pixelCoordinates[offset + 1] + this.textOffsetY_;
    if (rotation !== 0 || this.textScale_ != 1) {
      var localTransform = ol_transform["a" /* default */].compose(this.tmpLocalTransform_, x, y, this.textScale_, this.textScale_, rotation, -x, -y);
      context.setTransform.apply(context, localTransform);
    }
    if (this.textStrokeState_) {
      context.strokeText(this.text_, x, y);
    }
    if (this.textFillState_) {
      context.fillText(this.text_, x, y);
    }
  }
  if (rotation !== 0 || this.textScale_ != 1) {
    context.setTransform(1, 0, 0, 1, 0, 0);
  }
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {boolean} close Close.
 * @private
 * @return {number} end End.
 */
immediate__ol_render_canvas_Immediate_.prototype.moveToLineTo_ = function (flatCoordinates, offset, end, stride, close) {
  var context = this.context_;
  var pixelCoordinates = flat_transform["a" /* default */].transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
  context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
  var length = pixelCoordinates.length;
  if (close) {
    length -= 2;
  }
  for (var i = 2; i < length; i += 2) {
    context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
  }
  if (close) {
    context.closePath();
  }
  return end;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @private
 * @return {number} End.
 */
immediate__ol_render_canvas_Immediate_.prototype.drawRings_ = function (flatCoordinates, offset, ends, stride) {
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
  }
  return offset;
};

/**
 * Render a circle geometry into the canvas.  Rendering is immediate and uses
 * the current fill and stroke styles.
 *
 * @param {ol.geom.Circle} geometry Circle geometry.
 * @override
 * @api
 */
immediate__ol_render_canvas_Immediate_.prototype.drawCircle = function (geometry) {
  if (!ol_extent["a" /* default */].intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  if (this.fillState_ || this.strokeState_) {
    if (this.fillState_) {
      this.setContextFillState_(this.fillState_);
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
    }
    var pixelCoordinates = simplegeometry["a" /* default */].transform2D(geometry, this.transform_, this.pixelCoordinates_);
    var dx = pixelCoordinates[2] - pixelCoordinates[0];
    var dy = pixelCoordinates[3] - pixelCoordinates[1];
    var radius = Math.sqrt(dx * dx + dy * dy);
    var context = this.context_;
    context.beginPath();
    context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
    if (this.fillState_) {
      context.fill();
    }
    if (this.strokeState_) {
      context.stroke();
    }
  }
  if (this.text_ !== '') {
    this.drawText_(geometry.getCenter(), 0, 2, 2);
  }
};

/**
 * Set the rendering style.  Note that since this is an immediate rendering API,
 * any `zIndex` on the provided style will be ignored.
 *
 * @param {ol.style.Style} style The rendering style.
 * @override
 * @api
 */
immediate__ol_render_canvas_Immediate_.prototype.setStyle = function (style) {
  this.setFillStrokeStyle(style.getFill(), style.getStroke());
  this.setImageStyle(style.getImage());
  this.setTextStyle(style.getText());
};

/**
 * Render a geometry into the canvas.  Call
 * {@link ol.render.canvas.Immediate#setStyle} first to set the rendering style.
 *
 * @param {ol.geom.Geometry|ol.render.Feature} geometry The geometry to render.
 * @override
 * @api
 */
immediate__ol_render_canvas_Immediate_.prototype.drawGeometry = function (geometry) {
  var type = geometry.getType();
  switch (type) {
    case geometrytype["a" /* default */].POINT:
      this.drawPoint( /** @type {ol.geom.Point} */geometry);
      break;
    case geometrytype["a" /* default */].LINE_STRING:
      this.drawLineString( /** @type {ol.geom.LineString} */geometry);
      break;
    case geometrytype["a" /* default */].POLYGON:
      this.drawPolygon( /** @type {ol.geom.Polygon} */geometry);
      break;
    case geometrytype["a" /* default */].MULTI_POINT:
      this.drawMultiPoint( /** @type {ol.geom.MultiPoint} */geometry);
      break;
    case geometrytype["a" /* default */].MULTI_LINE_STRING:
      this.drawMultiLineString( /** @type {ol.geom.MultiLineString} */geometry);
      break;
    case geometrytype["a" /* default */].MULTI_POLYGON:
      this.drawMultiPolygon( /** @type {ol.geom.MultiPolygon} */geometry);
      break;
    case geometrytype["a" /* default */].GEOMETRY_COLLECTION:
      this.drawGeometryCollection( /** @type {ol.geom.GeometryCollection} */geometry);
      break;
    case geometrytype["a" /* default */].CIRCLE:
      this.drawCircle( /** @type {ol.geom.Circle} */geometry);
      break;
    default:
  }
};

/**
 * Render a feature into the canvas.  Note that any `zIndex` on the provided
 * style will be ignored - features are rendered immediately in the order that
 * this method is called.  If you need `zIndex` support, you should be using an
 * {@link ol.layer.Vector} instead.
 *
 * @param {ol.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 * @override
 * @api
 */
immediate__ol_render_canvas_Immediate_.prototype.drawFeature = function (feature, style) {
  var geometry = style.getGeometryFunction()(feature);
  if (!geometry || !ol_extent["a" /* default */].intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  this.setStyle(style);
  this.drawGeometry(geometry);
};

/**
 * Render a GeometryCollection to the canvas.  Rendering is immediate and
 * uses the current styles appropriate for each geometry in the collection.
 *
 * @param {ol.geom.GeometryCollection} geometry Geometry collection.
 * @override
 */
immediate__ol_render_canvas_Immediate_.prototype.drawGeometryCollection = function (geometry) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    this.drawGeometry(geometries[i]);
  }
};

/**
 * Render a Point geometry into the canvas.  Rendering is immediate and uses
 * the current style.
 *
 * @param {ol.geom.Point|ol.render.Feature} geometry Point geometry.
 * @override
 */
immediate__ol_render_canvas_Immediate_.prototype.drawPoint = function (geometry) {
  var flatCoordinates = geometry.getFlatCoordinates();
  var stride = geometry.getStride();
  if (this.image_) {
    this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
  if (this.text_ !== '') {
    this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
};

/**
 * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
 * uses the current style.
 *
 * @param {ol.geom.MultiPoint|ol.render.Feature} geometry MultiPoint geometry.
 * @override
 */
immediate__ol_render_canvas_Immediate_.prototype.drawMultiPoint = function (geometry) {
  var flatCoordinates = geometry.getFlatCoordinates();
  var stride = geometry.getStride();
  if (this.image_) {
    this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
  if (this.text_ !== '') {
    this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
};

/**
 * Render a LineString into the canvas.  Rendering is immediate and uses
 * the current style.
 *
 * @param {ol.geom.LineString|ol.render.Feature} geometry LineString geometry.
 * @override
 */
immediate__ol_render_canvas_Immediate_.prototype.drawLineString = function (geometry) {
  if (!ol_extent["a" /* default */].intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  if (this.strokeState_) {
    this.setContextStrokeState_(this.strokeState_);
    var context = this.context_;
    var flatCoordinates = geometry.getFlatCoordinates();
    context.beginPath();
    this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
    context.stroke();
  }
  if (this.text_ !== '') {
    var flatMidpoint = geometry.getFlatMidpoint();
    this.drawText_(flatMidpoint, 0, 2, 2);
  }
};

/**
 * Render a MultiLineString geometry into the canvas.  Rendering is immediate
 * and uses the current style.
 *
 * @param {ol.geom.MultiLineString|ol.render.Feature} geometry MultiLineString
 *     geometry.
 * @override
 */
immediate__ol_render_canvas_Immediate_.prototype.drawMultiLineString = function (geometry) {
  var geometryExtent = geometry.getExtent();
  if (!ol_extent["a" /* default */].intersects(this.extent_, geometryExtent)) {
    return;
  }
  if (this.strokeState_) {
    this.setContextStrokeState_(this.strokeState_);
    var context = this.context_;
    var flatCoordinates = geometry.getFlatCoordinates();
    var offset = 0;
    var ends = geometry.getEnds();
    var stride = geometry.getStride();
    context.beginPath();
    var i, ii;
    for (i = 0, ii = ends.length; i < ii; ++i) {
      offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
    }
    context.stroke();
  }
  if (this.text_ !== '') {
    var flatMidpoints = geometry.getFlatMidpoints();
    this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
  }
};

/**
 * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
 * the current style.
 *
 * @param {ol.geom.Polygon|ol.render.Feature} geometry Polygon geometry.
 * @override
 */
immediate__ol_render_canvas_Immediate_.prototype.drawPolygon = function (geometry) {
  if (!ol_extent["a" /* default */].intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  if (this.strokeState_ || this.fillState_) {
    if (this.fillState_) {
      this.setContextFillState_(this.fillState_);
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
    }
    var context = this.context_;
    context.beginPath();
    this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, geometry.getEnds(), geometry.getStride());
    if (this.fillState_) {
      context.fill();
    }
    if (this.strokeState_) {
      context.stroke();
    }
  }
  if (this.text_ !== '') {
    var flatInteriorPoint = geometry.getFlatInteriorPoint();
    this.drawText_(flatInteriorPoint, 0, 2, 2);
  }
};

/**
 * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
 * uses the current style.
 * @param {ol.geom.MultiPolygon} geometry MultiPolygon geometry.
 * @override
 */
immediate__ol_render_canvas_Immediate_.prototype.drawMultiPolygon = function (geometry) {
  if (!ol_extent["a" /* default */].intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  if (this.strokeState_ || this.fillState_) {
    if (this.fillState_) {
      this.setContextFillState_(this.fillState_);
    }
    if (this.strokeState_) {
      this.setContextStrokeState_(this.strokeState_);
    }
    var context = this.context_;
    var flatCoordinates = geometry.getOrientedFlatCoordinates();
    var offset = 0;
    var endss = geometry.getEndss();
    var stride = geometry.getStride();
    var i, ii;
    context.beginPath();
    for (i = 0, ii = endss.length; i < ii; ++i) {
      var ends = endss[i];
      offset = this.drawRings_(flatCoordinates, offset, ends, stride);
    }
    if (this.fillState_) {
      context.fill();
    }
    if (this.strokeState_) {
      context.stroke();
    }
  }
  if (this.text_ !== '') {
    var flatInteriorPoints = geometry.getFlatInteriorPoints();
    this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
  }
};

/**
 * @param {ol.CanvasFillState} fillState Fill state.
 * @private
 */
immediate__ol_render_canvas_Immediate_.prototype.setContextFillState_ = function (fillState) {
  var context = this.context_;
  var contextFillState = this.contextFillState_;
  if (!contextFillState) {
    context.fillStyle = fillState.fillStyle;
    this.contextFillState_ = {
      fillStyle: fillState.fillStyle
    };
  } else {
    if (contextFillState.fillStyle != fillState.fillStyle) {
      contextFillState.fillStyle = context.fillStyle = fillState.fillStyle;
    }
  }
};

/**
 * @param {ol.CanvasStrokeState} strokeState Stroke state.
 * @private
 */
immediate__ol_render_canvas_Immediate_.prototype.setContextStrokeState_ = function (strokeState) {
  var context = this.context_;
  var contextStrokeState = this.contextStrokeState_;
  if (!contextStrokeState) {
    context.lineCap = strokeState.lineCap;
    if (has["a" /* default */].CANVAS_LINE_DASH) {
      context.setLineDash(strokeState.lineDash);
      context.lineDashOffset = strokeState.lineDashOffset;
    }
    context.lineJoin = strokeState.lineJoin;
    context.lineWidth = strokeState.lineWidth;
    context.miterLimit = strokeState.miterLimit;
    context.strokeStyle = strokeState.strokeStyle;
    this.contextStrokeState_ = {
      lineCap: strokeState.lineCap,
      lineDash: strokeState.lineDash,
      lineDashOffset: strokeState.lineDashOffset,
      lineJoin: strokeState.lineJoin,
      lineWidth: strokeState.lineWidth,
      miterLimit: strokeState.miterLimit,
      strokeStyle: strokeState.strokeStyle
    };
  } else {
    if (contextStrokeState.lineCap != strokeState.lineCap) {
      contextStrokeState.lineCap = context.lineCap = strokeState.lineCap;
    }
    if (has["a" /* default */].CANVAS_LINE_DASH) {
      if (!array["a" /* default */].equals(contextStrokeState.lineDash, strokeState.lineDash)) {
        context.setLineDash(contextStrokeState.lineDash = strokeState.lineDash);
      }
      if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
        contextStrokeState.lineDashOffset = context.lineDashOffset = strokeState.lineDashOffset;
      }
    }
    if (contextStrokeState.lineJoin != strokeState.lineJoin) {
      contextStrokeState.lineJoin = context.lineJoin = strokeState.lineJoin;
    }
    if (contextStrokeState.lineWidth != strokeState.lineWidth) {
      contextStrokeState.lineWidth = context.lineWidth = strokeState.lineWidth;
    }
    if (contextStrokeState.miterLimit != strokeState.miterLimit) {
      contextStrokeState.miterLimit = context.miterLimit = strokeState.miterLimit;
    }
    if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
      contextStrokeState.strokeStyle = context.strokeStyle = strokeState.strokeStyle;
    }
  }
};

/**
 * @param {ol.CanvasTextState} textState Text state.
 * @private
 */
immediate__ol_render_canvas_Immediate_.prototype.setContextTextState_ = function (textState) {
  var context = this.context_;
  var contextTextState = this.contextTextState_;
  var textAlign = textState.textAlign ? textState.textAlign : render_canvas["a" /* default */].defaultTextAlign;
  if (!contextTextState) {
    context.font = textState.font;
    context.textAlign = textAlign;
    context.textBaseline = textState.textBaseline;
    this.contextTextState_ = {
      font: textState.font,
      textAlign: textAlign,
      textBaseline: textState.textBaseline
    };
  } else {
    if (contextTextState.font != textState.font) {
      contextTextState.font = context.font = textState.font;
    }
    if (contextTextState.textAlign != textAlign) {
      contextTextState.textAlign = textAlign;
    }
    if (contextTextState.textBaseline != textState.textBaseline) {
      contextTextState.textBaseline = context.textBaseline = textState.textBaseline;
    }
  }
};

/**
 * Set the fill and stroke style for subsequent draw operations.  To clear
 * either fill or stroke styles, pass null for the appropriate parameter.
 *
 * @param {ol.style.Fill} fillStyle Fill style.
 * @param {ol.style.Stroke} strokeStyle Stroke style.
 * @override
 */
immediate__ol_render_canvas_Immediate_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  if (!fillStyle) {
    this.fillState_ = null;
  } else {
    var fillStyleColor = fillStyle.getColor();
    this.fillState_ = {
      fillStyle: colorlike["a" /* default */].asColorLike(fillStyleColor ? fillStyleColor : render_canvas["a" /* default */].defaultFillStyle)
    };
  }
  if (!strokeStyle) {
    this.strokeState_ = null;
  } else {
    var strokeStyleColor = strokeStyle.getColor();
    var strokeStyleLineCap = strokeStyle.getLineCap();
    var strokeStyleLineDash = strokeStyle.getLineDash();
    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
    var strokeStyleLineJoin = strokeStyle.getLineJoin();
    var strokeStyleWidth = strokeStyle.getWidth();
    var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
    this.strokeState_ = {
      lineCap: strokeStyleLineCap !== undefined ? strokeStyleLineCap : render_canvas["a" /* default */].defaultLineCap,
      lineDash: strokeStyleLineDash ? strokeStyleLineDash : render_canvas["a" /* default */].defaultLineDash,
      lineDashOffset: strokeStyleLineDashOffset ? strokeStyleLineDashOffset : render_canvas["a" /* default */].defaultLineDashOffset,
      lineJoin: strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : render_canvas["a" /* default */].defaultLineJoin,
      lineWidth: this.pixelRatio_ * (strokeStyleWidth !== undefined ? strokeStyleWidth : render_canvas["a" /* default */].defaultLineWidth),
      miterLimit: strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : render_canvas["a" /* default */].defaultMiterLimit,
      strokeStyle: colorlike["a" /* default */].asColorLike(strokeStyleColor ? strokeStyleColor : render_canvas["a" /* default */].defaultStrokeStyle)
    };
  }
};

/**
 * Set the image style for subsequent draw operations.  Pass null to remove
 * the image style.
 *
 * @param {ol.style.Image} imageStyle Image style.
 * @override
 */
immediate__ol_render_canvas_Immediate_.prototype.setImageStyle = function (imageStyle) {
  if (!imageStyle) {
    this.image_ = null;
  } else {
    var imageAnchor = imageStyle.getAnchor();
    // FIXME pixel ratio
    var imageImage = imageStyle.getImage(1);
    var imageOrigin = imageStyle.getOrigin();
    var imageSize = imageStyle.getSize();
    this.imageAnchorX_ = imageAnchor[0];
    this.imageAnchorY_ = imageAnchor[1];
    this.imageHeight_ = imageSize[1];
    this.image_ = imageImage;
    this.imageOpacity_ = imageStyle.getOpacity();
    this.imageOriginX_ = imageOrigin[0];
    this.imageOriginY_ = imageOrigin[1];
    this.imageRotateWithView_ = imageStyle.getRotateWithView();
    this.imageRotation_ = imageStyle.getRotation();
    this.imageScale_ = imageStyle.getScale() * this.pixelRatio_;
    this.imageSnapToPixel_ = imageStyle.getSnapToPixel();
    this.imageWidth_ = imageSize[0];
  }
};

/**
 * Set the text style for subsequent draw operations.  Pass null to
 * remove the text style.
 *
 * @param {ol.style.Text} textStyle Text style.
 * @override
 */
immediate__ol_render_canvas_Immediate_.prototype.setTextStyle = function (textStyle) {
  if (!textStyle) {
    this.text_ = '';
  } else {
    var textFillStyle = textStyle.getFill();
    if (!textFillStyle) {
      this.textFillState_ = null;
    } else {
      var textFillStyleColor = textFillStyle.getColor();
      this.textFillState_ = {
        fillStyle: colorlike["a" /* default */].asColorLike(textFillStyleColor ? textFillStyleColor : render_canvas["a" /* default */].defaultFillStyle)
      };
    }
    var textStrokeStyle = textStyle.getStroke();
    if (!textStrokeStyle) {
      this.textStrokeState_ = null;
    } else {
      var textStrokeStyleColor = textStrokeStyle.getColor();
      var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
      var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
      var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
      var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
      var textStrokeStyleWidth = textStrokeStyle.getWidth();
      var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
      this.textStrokeState_ = {
        lineCap: textStrokeStyleLineCap !== undefined ? textStrokeStyleLineCap : render_canvas["a" /* default */].defaultLineCap,
        lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : render_canvas["a" /* default */].defaultLineDash,
        lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : render_canvas["a" /* default */].defaultLineDashOffset,
        lineJoin: textStrokeStyleLineJoin !== undefined ? textStrokeStyleLineJoin : render_canvas["a" /* default */].defaultLineJoin,
        lineWidth: textStrokeStyleWidth !== undefined ? textStrokeStyleWidth : render_canvas["a" /* default */].defaultLineWidth,
        miterLimit: textStrokeStyleMiterLimit !== undefined ? textStrokeStyleMiterLimit : render_canvas["a" /* default */].defaultMiterLimit,
        strokeStyle: colorlike["a" /* default */].asColorLike(textStrokeStyleColor ? textStrokeStyleColor : render_canvas["a" /* default */].defaultStrokeStyle)
      };
    }
    var textFont = textStyle.getFont();
    var textOffsetX = textStyle.getOffsetX();
    var textOffsetY = textStyle.getOffsetY();
    var textRotateWithView = textStyle.getRotateWithView();
    var textRotation = textStyle.getRotation();
    var textScale = textStyle.getScale();
    var textText = textStyle.getText();
    var textTextAlign = textStyle.getTextAlign();
    var textTextBaseline = textStyle.getTextBaseline();
    this.textState_ = {
      font: textFont !== undefined ? textFont : render_canvas["a" /* default */].defaultFont,
      textAlign: textTextAlign !== undefined ? textTextAlign : render_canvas["a" /* default */].defaultTextAlign,
      textBaseline: textTextBaseline !== undefined ? textTextBaseline : render_canvas["a" /* default */].defaultTextBaseline
    };
    this.text_ = textText !== undefined ? textText : '';
    this.textOffsetX_ = textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
    this.textOffsetY_ = textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
    this.textRotateWithView_ = textRotateWithView !== undefined ? textRotateWithView : false;
    this.textRotation_ = textRotation !== undefined ? textRotation : 0;
    this.textScale_ = this.pixelRatio_ * (textScale !== undefined ? textScale : 1);
  }
};
/* harmony default export */ var immediate = (immediate__ol_render_canvas_Immediate_);
// EXTERNAL MODULE: ./node_modules/ol/observable.js
var observable = __webpack_require__(73);

// CONCATENATED MODULE: ./node_modules/ol/renderer/layer.js










/**
 * @constructor
 * @extends {ol.Observable}
 * @param {ol.layer.Layer} layer Layer.
 * @struct
 */
var layer__ol_renderer_Layer_ = function _ol_renderer_Layer_(layer) {

  observable["a" /* default */].call(this);

  /**
   * @private
   * @type {ol.layer.Layer}
   */
  this.layer_ = layer;
};

ol["a" /* default */].inherits(layer__ol_renderer_Layer_, observable["a" /* default */]);

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState Frame state.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {function(this: S, (ol.Feature|ol.render.Feature), ol.layer.Layer): T}
 *     callback Feature callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @return {T|undefined} Callback result.
 * @template S,T
 */
layer__ol_renderer_Layer_.prototype.forEachFeatureAtCoordinate = ol["a" /* default */].nullFunction;

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState Frame state.
 * @return {boolean} Is there a feature at the given coordinate?
 */
layer__ol_renderer_Layer_.prototype.hasFeatureAtCoordinate = functions["a" /* default */].FALSE;

/**
 * Create a function that adds loaded tiles to the tile lookup.
 * @param {ol.source.Tile} source Tile source.
 * @param {ol.proj.Projection} projection Projection of the tiles.
 * @param {Object.<number, Object.<string, ol.Tile>>} tiles Lookup of loaded
 *     tiles by zoom level.
 * @return {function(number, ol.TileRange):boolean} A function that can be
 *     called with a zoom level and a tile range to add loaded tiles to the
 *     lookup.
 * @protected
 */
layer__ol_renderer_Layer_.prototype.createLoadedTileFinder = function (source, projection, tiles) {
  return (
    /**
     * @param {number} zoom Zoom level.
     * @param {ol.TileRange} tileRange Tile range.
     * @return {boolean} The tile range is fully loaded.
     */
    function (zoom, tileRange) {
      function callback(tile) {
        if (!tiles[zoom]) {
          tiles[zoom] = {};
        }
        tiles[zoom][tile.tileCoord.toString()] = tile;
      }
      return source.forEachLoadedTile(projection, zoom, tileRange, callback);
    }
  );
};

/**
 * @return {ol.layer.Layer} Layer.
 */
layer__ol_renderer_Layer_.prototype.getLayer = function () {
  return this.layer_;
};

/**
 * Handle changes in image state.
 * @param {ol.events.Event} event Image change event.
 * @private
 */
layer__ol_renderer_Layer_.prototype.handleImageChange_ = function (event) {
  var image = /** @type {ol.Image} */event.target;
  if (image.getState() === imagestate["a" /* default */].LOADED) {
    this.renderIfReadyAndVisible();
  }
};

/**
 * Load the image if not already loaded, and register the image change
 * listener if needed.
 * @param {ol.ImageBase} image Image.
 * @return {boolean} `true` if the image is already loaded, `false`
 *     otherwise.
 * @protected
 */
layer__ol_renderer_Layer_.prototype.loadImage = function (image) {
  var imageState = image.getState();
  if (imageState != imagestate["a" /* default */].LOADED && imageState != imagestate["a" /* default */].ERROR) {
    ol_events["a" /* default */].listen(image, events_eventtype["a" /* default */].CHANGE, this.handleImageChange_, this);
  }
  if (imageState == imagestate["a" /* default */].IDLE) {
    image.load();
    imageState = image.getState();
  }
  return imageState == imagestate["a" /* default */].LOADED;
};

/**
 * @protected
 */
layer__ol_renderer_Layer_.prototype.renderIfReadyAndVisible = function () {
  var layer = this.getLayer();
  if (layer.getVisible() && layer.getSourceState() == source_state["a" /* default */].READY) {
    this.changed();
  }
};

/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.source.Tile} tileSource Tile source.
 * @protected
 */
layer__ol_renderer_Layer_.prototype.scheduleExpireCache = function (frameState, tileSource) {
  if (tileSource.canExpireCache()) {
    /**
     * @param {ol.source.Tile} tileSource Tile source.
     * @param {ol.PluggableMap} map Map.
     * @param {olx.FrameState} frameState Frame state.
     */
    var postRenderFunction = function (tileSource, map, frameState) {
      var tileSourceKey = ol["a" /* default */].getUid(tileSource).toString();
      if (tileSourceKey in frameState.usedTiles) {
        tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
      }
    }.bind(null, tileSource);

    frameState.postRenderFunctions.push(
    /** @type {ol.PostRenderFunction} */postRenderFunction);
  }
};

/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.source.Source} source Source.
 * @protected
 */
layer__ol_renderer_Layer_.prototype.updateLogos = function (frameState, source) {
  var logo = source.getLogo();
  if (logo !== undefined) {
    if (typeof logo === 'string') {
      frameState.logos[logo] = '';
    } else if (logo) {
      asserts["a" /* default */].assert(typeof logo.href == 'string', 44); // `logo.href` should be a string.
      asserts["a" /* default */].assert(typeof logo.src == 'string', 45); // `logo.src` should be a string.
      frameState.logos[logo.src] = logo.href;
    }
  }
};

/**
 * @param {Object.<string, Object.<string, ol.TileRange>>} usedTiles Used tiles.
 * @param {ol.source.Tile} tileSource Tile source.
 * @param {number} z Z.
 * @param {ol.TileRange} tileRange Tile range.
 * @protected
 */
layer__ol_renderer_Layer_.prototype.updateUsedTiles = function (usedTiles, tileSource, z, tileRange) {
  // FIXME should we use tilesToDrawByZ instead?
  var tileSourceKey = ol["a" /* default */].getUid(tileSource).toString();
  var zKey = z.toString();
  if (tileSourceKey in usedTiles) {
    if (zKey in usedTiles[tileSourceKey]) {
      usedTiles[tileSourceKey][zKey].extend(tileRange);
    } else {
      usedTiles[tileSourceKey][zKey] = tileRange;
    }
  } else {
    usedTiles[tileSourceKey] = {};
    usedTiles[tileSourceKey][zKey] = tileRange;
  }
};

/**
 * Manage tile pyramid.
 * This function performs a number of functions related to the tiles at the
 * current zoom and lower zoom levels:
 * - registers idle tiles in frameState.wantedTiles so that they are not
 *   discarded by the tile queue
 * - enqueues missing tiles
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.source.Tile} tileSource Tile source.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @param {ol.Extent} extent Extent.
 * @param {number} currentZ Current Z.
 * @param {number} preload Load low resolution tiles up to 'preload' levels.
 * @param {function(this: T, ol.Tile)=} opt_tileCallback Tile callback.
 * @param {T=} opt_this Object to use as `this` in `opt_tileCallback`.
 * @protected
 * @template T
 */
layer__ol_renderer_Layer_.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback, opt_this) {
  var tileSourceKey = ol["a" /* default */].getUid(tileSource).toString();
  if (!(tileSourceKey in frameState.wantedTiles)) {
    frameState.wantedTiles[tileSourceKey] = {};
  }
  var wantedTiles = frameState.wantedTiles[tileSourceKey];
  var tileQueue = frameState.tileQueue;
  var minZoom = tileGrid.getMinZoom();
  var tile, tileRange, tileResolution, x, y, z;
  for (z = minZoom; z <= currentZ; ++z) {
    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
    tileResolution = tileGrid.getResolution(z);
    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
        if (currentZ - z <= preload) {
          tile = tileSource.getTile(z, x, y, pixelRatio, projection);
          if (tile.getState() == tilestate["a" /* default */].IDLE) {
            wantedTiles[tile.getKey()] = true;
            if (!tileQueue.isKeyQueued(tile.getKey())) {
              tileQueue.enqueue([tile, tileSourceKey, tileGrid.getTileCoordCenter(tile.tileCoord), tileResolution]);
            }
          }
          if (opt_tileCallback !== undefined) {
            opt_tileCallback.call(opt_this, tile);
          }
        } else {
          tileSource.useTile(z, x, y, projection);
        }
      }
    }
  }
};
/* harmony default export */ var renderer_layer = (layer__ol_renderer_Layer_);
// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/layer.js










/**
 * @constructor
 * @abstract
 * @extends {ol.renderer.Layer}
 * @param {ol.layer.Layer} layer Layer.
 */
var layer__ol_renderer_canvas_Layer_ = function _ol_renderer_canvas_Layer_(layer) {

  renderer_layer.call(this, layer);

  /**
   * @protected
   * @type {number}
   */
  this.renderedResolution;

  /**
   * @private
   * @type {ol.Transform}
   */
  this.transform_ = ol_transform["a" /* default */].create();
};

ol["a" /* default */].inherits(layer__ol_renderer_canvas_Layer_, renderer_layer);

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Extent} extent Clip extent.
 * @protected
 */
layer__ol_renderer_canvas_Layer_.prototype.clip = function (context, frameState, extent) {
  var pixelRatio = frameState.pixelRatio;
  var width = frameState.size[0] * pixelRatio;
  var height = frameState.size[1] * pixelRatio;
  var rotation = frameState.viewState.rotation;
  var topLeft = ol_extent["a" /* default */].getTopLeft( /** @type {ol.Extent} */extent);
  var topRight = ol_extent["a" /* default */].getTopRight( /** @type {ol.Extent} */extent);
  var bottomRight = ol_extent["a" /* default */].getBottomRight( /** @type {ol.Extent} */extent);
  var bottomLeft = ol_extent["a" /* default */].getBottomLeft( /** @type {ol.Extent} */extent);

  ol_transform["a" /* default */].apply(frameState.coordinateToPixelTransform, topLeft);
  ol_transform["a" /* default */].apply(frameState.coordinateToPixelTransform, topRight);
  ol_transform["a" /* default */].apply(frameState.coordinateToPixelTransform, bottomRight);
  ol_transform["a" /* default */].apply(frameState.coordinateToPixelTransform, bottomLeft);

  context.save();
  render_canvas["a" /* default */].rotateAtOffset(context, -rotation, width / 2, height / 2);
  context.beginPath();
  context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);
  context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);
  context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);
  context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);
  context.clip();
  render_canvas["a" /* default */].rotateAtOffset(context, rotation, width / 2, height / 2);
};

/**
 * @param {ol.render.EventType} type Event type.
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Transform=} opt_transform Transform.
 * @private
 */
layer__ol_renderer_canvas_Layer_.prototype.dispatchComposeEvent_ = function (type, context, frameState, opt_transform) {
  var layer = this.getLayer();
  if (layer.hasListener(type)) {
    var width = frameState.size[0] * frameState.pixelRatio;
    var height = frameState.size[1] * frameState.pixelRatio;
    var rotation = frameState.viewState.rotation;
    render_canvas["a" /* default */].rotateAtOffset(context, -rotation, width / 2, height / 2);
    var transform = opt_transform !== undefined ? opt_transform : this.getTransform(frameState, 0);
    var render = new immediate(context, frameState.pixelRatio, frameState.extent, transform, frameState.viewState.rotation);
    var composeEvent = new render_event(type, render, frameState, context, null);
    layer.dispatchEvent(composeEvent);
    render_canvas["a" /* default */].rotateAtOffset(context, rotation, width / 2, height / 2);
  }
};

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState FrameState.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
 *     callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */
layer__ol_renderer_canvas_Layer_.prototype.forEachLayerAtCoordinate = function (coordinate, frameState, callback, thisArg) {
  var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, 0, functions["a" /* default */].TRUE, this);

  if (hasFeature) {
    return callback.call(thisArg, this.getLayer(), null);
  } else {
    return undefined;
  }
};

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {ol.Transform=} opt_transform Transform.
 * @protected
 */
layer__ol_renderer_canvas_Layer_.prototype.postCompose = function (context, frameState, layerState, opt_transform) {
  this.dispatchComposeEvent_(render_eventtype["a" /* default */].POSTCOMPOSE, context, frameState, opt_transform);
};

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Transform=} opt_transform Transform.
 * @protected
 */
layer__ol_renderer_canvas_Layer_.prototype.preCompose = function (context, frameState, opt_transform) {
  this.dispatchComposeEvent_(render_eventtype["a" /* default */].PRECOMPOSE, context, frameState, opt_transform);
};

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.Transform=} opt_transform Transform.
 * @protected
 */
layer__ol_renderer_canvas_Layer_.prototype.dispatchRenderEvent = function (context, frameState, opt_transform) {
  this.dispatchComposeEvent_(render_eventtype["a" /* default */].RENDER, context, frameState, opt_transform);
};

/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {number} offsetX Offset on the x-axis in view coordinates.
 * @protected
 * @return {!ol.Transform} Transform.
 */
layer__ol_renderer_canvas_Layer_.prototype.getTransform = function (frameState, offsetX) {
  var viewState = frameState.viewState;
  var pixelRatio = frameState.pixelRatio;
  var dx1 = pixelRatio * frameState.size[0] / 2;
  var dy1 = pixelRatio * frameState.size[1] / 2;
  var sx = pixelRatio / viewState.resolution;
  var sy = -sx;
  var angle = -viewState.rotation;
  var dx2 = -viewState.center[0] + offsetX;
  var dy2 = -viewState.center[1];
  return ol_transform["a" /* default */].compose(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
};

/**
 * @abstract
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {CanvasRenderingContext2D} context Context.
 */
layer__ol_renderer_canvas_Layer_.prototype.composeFrame = function (frameState, layerState, context) {};

/**
 * @abstract
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @return {boolean} whether composeFrame should be called.
 */
layer__ol_renderer_canvas_Layer_.prototype.prepareFrame = function (frameState, layerState) {};
/* harmony default export */ var canvas_layer = (layer__ol_renderer_canvas_Layer_);
// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/intermediatecanvas.js







/**
 * @constructor
 * @abstract
 * @extends {ol.renderer.canvas.Layer}
 * @param {ol.layer.Layer} layer Layer.
 */
var intermediatecanvas__ol_renderer_canvas_IntermediateCanvas_ = function _ol_renderer_canvas_IntermediateCanvas_(layer) {

  canvas_layer.call(this, layer);

  /**
   * @protected
   * @type {ol.Transform}
   */
  this.coordinateToCanvasPixelTransform = ol_transform["a" /* default */].create();

  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */
  this.hitCanvasContext_ = null;
};

ol["a" /* default */].inherits(intermediatecanvas__ol_renderer_canvas_IntermediateCanvas_, canvas_layer);

/**
 * @inheritDoc
 */
intermediatecanvas__ol_renderer_canvas_IntermediateCanvas_.prototype.composeFrame = function (frameState, layerState, context) {

  this.preCompose(context, frameState);

  var image = this.getImage();
  if (image) {

    // clipped rendering if layer extent is set
    var extent = layerState.extent;
    var clipped = extent !== undefined && !ol_extent["a" /* default */].containsExtent(extent, frameState.extent) && ol_extent["a" /* default */].intersects(extent, frameState.extent);
    if (clipped) {
      this.clip(context, frameState, /** @type {ol.Extent} */extent);
    }

    var imageTransform = this.getImageTransform();
    // for performance reasons, context.save / context.restore is not used
    // to save and restore the transformation matrix and the opacity.
    // see http://jsperf.com/context-save-restore-versus-variable
    var alpha = context.globalAlpha;
    context.globalAlpha = layerState.opacity;

    // for performance reasons, context.setTransform is only used
    // when the view is rotated. see http://jsperf.com/canvas-transform
    var dx = imageTransform[4];
    var dy = imageTransform[5];
    var dw = image.width * imageTransform[0];
    var dh = image.height * imageTransform[3];
    context.drawImage(image, 0, 0, +image.width, +image.height, Math.round(dx), Math.round(dy), Math.round(dw), Math.round(dh));
    context.globalAlpha = alpha;

    if (clipped) {
      context.restore();
    }
  }

  this.postCompose(context, frameState, layerState);
};

/**
 * @abstract
 * @return {HTMLCanvasElement|HTMLVideoElement|Image} Canvas.
 */
intermediatecanvas__ol_renderer_canvas_IntermediateCanvas_.prototype.getImage = function () {};

/**
 * @abstract
 * @return {!ol.Transform} Image transform.
 */
intermediatecanvas__ol_renderer_canvas_IntermediateCanvas_.prototype.getImageTransform = function () {};

/**
 * @inheritDoc
 */
intermediatecanvas__ol_renderer_canvas_IntermediateCanvas_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  var layer = this.getLayer();
  var source = layer.getSource();
  var resolution = frameState.viewState.resolution;
  var rotation = frameState.viewState.rotation;
  var skippedFeatureUids = frameState.skippedFeatureUids;
  return source.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, skippedFeatureUids,
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {?} Callback result.
   */
  function (feature) {
    return callback.call(thisArg, feature, layer);
  });
};

/**
 * @inheritDoc
 */
intermediatecanvas__ol_renderer_canvas_IntermediateCanvas_.prototype.forEachLayerAtCoordinate = function (coordinate, frameState, callback, thisArg) {
  if (!this.getImage()) {
    return undefined;
  }

  if (this.getLayer().getSource().forEachFeatureAtCoordinate !== ol["a" /* default */].nullFunction) {
    // for ImageCanvas sources use the original hit-detection logic,
    // so that for example also transparent polygons are detected
    return canvas_layer.prototype.forEachLayerAtCoordinate.apply(this, arguments);
  } else {
    var pixel = ol_transform["a" /* default */].apply(this.coordinateToCanvasPixelTransform, coordinate.slice());
    ol_coordinate["a" /* default */].scale(pixel, frameState.viewState.resolution / this.renderedResolution);

    if (!this.hitCanvasContext_) {
      this.hitCanvasContext_ = dom["a" /* default */].createCanvasContext2D(1, 1);
    }

    this.hitCanvasContext_.clearRect(0, 0, 1, 1);
    this.hitCanvasContext_.drawImage(this.getImage(), pixel[0], pixel[1], 1, 1, 0, 0, 1, 1);

    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;
    if (imageData[3] > 0) {
      return callback.call(thisArg, this.getLayer(), imageData);
    } else {
      return undefined;
    }
  }
};
/* harmony default export */ var intermediatecanvas = (intermediatecanvas__ol_renderer_canvas_IntermediateCanvas_);
// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/imagelayer.js













/**
 * @constructor
 * @extends {ol.renderer.canvas.IntermediateCanvas}
 * @param {ol.layer.Image} imageLayer Single image layer.
 * @api
 */
var imagelayer__ol_renderer_canvas_ImageLayer_ = function _ol_renderer_canvas_ImageLayer_(imageLayer) {

  intermediatecanvas.call(this, imageLayer);

  /**
   * @private
   * @type {?ol.ImageBase}
   */
  this.image_ = null;

  /**
   * @private
   * @type {ol.Transform}
   */
  this.imageTransform_ = ol_transform["a" /* default */].create();

  /**
   * @type {!Array.<string>}
   */
  this.skippedFeatures_ = [];

  /**
   * @private
   * @type {ol.renderer.canvas.VectorLayer}
   */
  this.vectorRenderer_ = null;
};

ol["a" /* default */].inherits(imagelayer__ol_renderer_canvas_ImageLayer_, intermediatecanvas);

/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
imagelayer__ol_renderer_canvas_ImageLayer_['handles'] = function (type, layer) {
  return type === renderer_type.CANVAS && (layer.getType() === layertype["a" /* default */].IMAGE || layer.getType() === layertype["a" /* default */].VECTOR &&
  /** @type {ol.layer.Vector} */layer.getRenderMode() === vectorrendertype["a" /* default */].IMAGE);
};

/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.canvas.ImageLayer} The layer renderer.
 */
imagelayer__ol_renderer_canvas_ImageLayer_['create'] = function (mapRenderer, layer) {
  var renderer = new imagelayer__ol_renderer_canvas_ImageLayer_( /** @type {ol.layer.Image} */layer);
  if (layer.getType() === layertype["a" /* default */].VECTOR) {
    var candidates = ol_plugins.getLayerRendererPlugins();
    for (var i = 0, ii = candidates.length; i < ii; ++i) {
      var candidate = /** @type {Object.<string, Function>} */candidates[i];
      if (candidate !== imagelayer__ol_renderer_canvas_ImageLayer_ && candidate['handles'](renderer_type.CANVAS, layer)) {
        renderer.setVectorRenderer(candidate['create'](mapRenderer, layer));
      }
    }
  }
  return renderer;
};

/**
 * @inheritDoc
 */
imagelayer__ol_renderer_canvas_ImageLayer_.prototype.getImage = function () {
  return !this.image_ ? null : this.image_.getImage();
};

/**
 * @inheritDoc
 */
imagelayer__ol_renderer_canvas_ImageLayer_.prototype.getImageTransform = function () {
  return this.imageTransform_;
};

/**
 * @inheritDoc
 */
imagelayer__ol_renderer_canvas_ImageLayer_.prototype.prepareFrame = function (frameState, layerState) {

  var pixelRatio = frameState.pixelRatio;
  var size = frameState.size;
  var viewState = frameState.viewState;
  var viewCenter = viewState.center;
  var viewResolution = viewState.resolution;

  var image;
  var imageLayer = /** @type {ol.layer.Image} */this.getLayer();
  var imageSource = imageLayer.getSource();

  var hints = frameState.viewHints;

  var renderedExtent = frameState.extent;
  if (layerState.extent !== undefined) {
    renderedExtent = ol_extent["a" /* default */].getIntersection(renderedExtent, layerState.extent);
  }

  if (!hints[viewhint["a" /* default */].ANIMATING] && !hints[viewhint["a" /* default */].INTERACTING] && !ol_extent["a" /* default */].isEmpty(renderedExtent)) {
    var projection = viewState.projection;
    if (!ol["a" /* default */].ENABLE_RASTER_REPROJECTION) {
      var sourceProjection = imageSource.getProjection();
      if (sourceProjection) {
        projection = sourceProjection;
      }
    }
    var vectorRenderer = this.vectorRenderer_;
    if (vectorRenderer) {
      var context = vectorRenderer.context;
      var imageFrameState = /** @type {olx.FrameState} */obj["a" /* default */].assign({}, frameState, {
        size: [ol_extent["a" /* default */].getWidth(renderedExtent) / viewResolution, ol_extent["a" /* default */].getHeight(renderedExtent) / viewResolution],
        viewState: /** @type {olx.ViewState} */obj["a" /* default */].assign({}, frameState.viewState, {
          rotation: 0
        })
      });
      var skippedFeatures = Object.keys(imageFrameState.skippedFeatureUids).sort();
      if (vectorRenderer.prepareFrame(imageFrameState, layerState) && (vectorRenderer.replayGroupChanged || !array["a" /* default */].equals(skippedFeatures, this.skippedFeatures_))) {
        context.canvas.width = imageFrameState.size[0] * pixelRatio;
        context.canvas.height = imageFrameState.size[1] * pixelRatio;
        vectorRenderer.composeFrame(imageFrameState, layerState, context);
        this.image_ = new imagecanvas(renderedExtent, viewResolution, pixelRatio, context.canvas);
        this.skippedFeatures_ = skippedFeatures;
      }
    } else {
      image = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);
      if (image) {
        var loaded = this.loadImage(image);
        if (loaded) {
          this.image_ = image;
        }
      }
    }
  }

  if (this.image_) {
    image = this.image_;
    var imageExtent = image.getExtent();
    var imageResolution = image.getResolution();
    var imagePixelRatio = image.getPixelRatio();
    var scale = pixelRatio * imageResolution / (viewResolution * imagePixelRatio);
    var transform = ol_transform["a" /* default */].compose(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, imagePixelRatio * (imageExtent[0] - viewCenter[0]) / imageResolution, imagePixelRatio * (viewCenter[1] - imageExtent[3]) / imageResolution);
    ol_transform["a" /* default */].compose(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);

    this.updateLogos(frameState, imageSource);
    this.renderedResolution = imageResolution * pixelRatio / imagePixelRatio;
  }

  return !!this.image_;
};

/**
 * @inheritDoc
 */
imagelayer__ol_renderer_canvas_ImageLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  if (this.vectorRenderer_) {
    return this.vectorRenderer_.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);
  } else {
    return intermediatecanvas.prototype.forEachFeatureAtCoordinate.call(this, coordinate, frameState, hitTolerance, callback, thisArg);
  }
};

/**
 * @param {ol.renderer.canvas.VectorLayer} renderer Vector renderer.
 */
imagelayer__ol_renderer_canvas_ImageLayer_.prototype.setVectorRenderer = function (renderer) {
  this.vectorRenderer_ = renderer;
};
/* harmony default export */ var imagelayer = (imagelayer__ol_renderer_canvas_ImageLayer_);
// EXTERNAL MODULE: ./node_modules/ol/style.js + 1 modules
var ol_style = __webpack_require__(82);

// CONCATENATED MODULE: ./node_modules/ol/renderer/map.js











/**
 * @constructor
 * @abstract
 * @extends {ol.Disposable}
 * @param {Element} container Container.
 * @param {ol.PluggableMap} map Map.
 * @struct
 */
var map__ol_renderer_Map_ = function _ol_renderer_Map_(container, map) {

  disposable["a" /* default */].call(this);

  /**
   * @private
   * @type {ol.PluggableMap}
   */
  this.map_ = map;

  /**
   * @private
   * @type {Object.<string, ol.renderer.Layer>}
   */
  this.layerRenderers_ = {};

  /**
   * @private
   * @type {Object.<string, ol.EventsKey>}
   */
  this.layerRendererListeners_ = {};
};

ol["a" /* default */].inherits(map__ol_renderer_Map_, disposable["a" /* default */]);

/**
 * @param {olx.FrameState} frameState FrameState.
 * @protected
 */
map__ol_renderer_Map_.prototype.calculateMatrices2D = function (frameState) {
  var viewState = frameState.viewState;
  var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
  var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;

  ol_transform["a" /* default */].compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);

  ol_transform["a" /* default */].invert(ol_transform["a" /* default */].setFromArray(pixelToCoordinateTransform, coordinateToPixelTransform));
};

/**
 * Removes all layer renderers.
 */
map__ol_renderer_Map_.prototype.removeLayerRenderers = function () {
  for (var key in this.layerRenderers_) {
    this.removeLayerRendererByKey_(key).dispose();
  }
};

/**
 * @param {ol.PluggableMap} map Map.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */
map__ol_renderer_Map_.expireIconCache_ = function (map, frameState) {
  var cache = ol_style["a" /* default */].iconImageCache;
  cache.expire();
};

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState FrameState.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {function(this: S, (ol.Feature|ol.render.Feature),
 *     ol.layer.Layer): T} callback Feature callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter
 *     function, only layers which are visible and for which this function
 *     returns `true` will be tested for features.  By default, all visible
 *     layers will be tested.
 * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */
map__ol_renderer_Map_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
  var result;
  var viewState = frameState.viewState;
  var viewResolution = viewState.resolution;

  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @param {ol.layer.Layer} layer Layer.
   * @return {?} Callback result.
   */
  function forEachFeatureAtCoordinate(feature, layer) {
    var key = ol["a" /* default */].getUid(feature).toString();
    var managed = frameState.layerStates[ol["a" /* default */].getUid(layer)].managed;
    if (!(key in frameState.skippedFeatureUids && !managed)) {
      return callback.call(thisArg, feature, managed ? layer : null);
    }
  }

  var projection = viewState.projection;

  var translatedCoordinate = coordinate;
  if (projection.canWrapX()) {
    var projectionExtent = projection.getExtent();
    var worldWidth = ol_extent["a" /* default */].getWidth(projectionExtent);
    var x = coordinate[0];
    if (x < projectionExtent[0] || x > projectionExtent[2]) {
      var worldsAway = Math.ceil((projectionExtent[0] - x) / worldWidth);
      translatedCoordinate = [x + worldWidth * worldsAway, coordinate[1]];
    }
  }

  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;
  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;
    if (layer_layer["a" /* default */].visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
      var layerRenderer = this.getLayerRenderer(layer);
      if (layer.getSource()) {
        result = layerRenderer.forEachFeatureAtCoordinate(layer.getSource().getWrapX() ? translatedCoordinate : coordinate, frameState, hitTolerance, forEachFeatureAtCoordinate, thisArg);
      }
      if (result) {
        return result;
      }
    }
  }
  return undefined;
};

/**
 * @abstract
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.FrameState} frameState FrameState.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
 *     callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter
 *     function, only layers which are visible and for which this function
 *     returns `true` will be tested for features.  By default, all visible
 *     layers will be tested.
 * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */
map__ol_renderer_Map_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg, layerFilter, thisArg2) {};

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {olx.FrameState} frameState FrameState.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {function(this: U, ol.layer.Layer): boolean} layerFilter Layer filter
 *     function, only layers which are visible and for which this function
 *     returns `true` will be tested for features.  By default, all visible
 *     layers will be tested.
 * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
 * @return {boolean} Is there a feature at the given coordinate?
 * @template U
 */
map__ol_renderer_Map_.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, layerFilter, thisArg) {
  var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, functions["a" /* default */].TRUE, this, layerFilter, thisArg);

  return hasFeature !== undefined;
};

/**
 * @param {ol.layer.Layer} layer Layer.
 * @protected
 * @return {ol.renderer.Layer} Layer renderer.
 */
map__ol_renderer_Map_.prototype.getLayerRenderer = function (layer) {
  var layerKey = ol["a" /* default */].getUid(layer).toString();
  if (layerKey in this.layerRenderers_) {
    return this.layerRenderers_[layerKey];
  } else {
    var layerRendererPlugins = ol_plugins.getLayerRendererPlugins();
    var renderer;
    var type = this.getType();
    for (var i = 0, ii = layerRendererPlugins.length; i < ii; ++i) {
      var plugin = layerRendererPlugins[i];
      if (plugin['handles'](type, layer)) {
        renderer = plugin['create'](this, layer);
        break;
      }
    }
    if (renderer) {
      this.layerRenderers_[layerKey] = renderer;
      this.layerRendererListeners_[layerKey] = ol_events["a" /* default */].listen(renderer, events_eventtype["a" /* default */].CHANGE, this.handleLayerRendererChange_, this);
    } else {
      throw new Error('Unable to create renderer for layer: ' + layer.getType());
    }
    return renderer;
  }
};

/**
 * @param {string} layerKey Layer key.
 * @protected
 * @return {ol.renderer.Layer} Layer renderer.
 */
map__ol_renderer_Map_.prototype.getLayerRendererByKey = function (layerKey) {
  return this.layerRenderers_[layerKey];
};

/**
 * @protected
 * @return {Object.<string, ol.renderer.Layer>} Layer renderers.
 */
map__ol_renderer_Map_.prototype.getLayerRenderers = function () {
  return this.layerRenderers_;
};

/**
 * @return {ol.PluggableMap} Map.
 */
map__ol_renderer_Map_.prototype.getMap = function () {
  return this.map_;
};

/**
 * @abstract
 * @return {ol.renderer.Type} Type
 */
map__ol_renderer_Map_.prototype.getType = function () {};

/**
 * Handle changes in a layer renderer.
 * @private
 */
map__ol_renderer_Map_.prototype.handleLayerRendererChange_ = function () {
  this.map_.render();
};

/**
 * @param {string} layerKey Layer key.
 * @return {ol.renderer.Layer} Layer renderer.
 * @private
 */
map__ol_renderer_Map_.prototype.removeLayerRendererByKey_ = function (layerKey) {
  var layerRenderer = this.layerRenderers_[layerKey];
  delete this.layerRenderers_[layerKey];

  ol_events["a" /* default */].unlistenByKey(this.layerRendererListeners_[layerKey]);
  delete this.layerRendererListeners_[layerKey];

  return layerRenderer;
};

/**
 * Render.
 * @param {?olx.FrameState} frameState Frame state.
 */
map__ol_renderer_Map_.prototype.renderFrame = ol["a" /* default */].nullFunction;

/**
 * @param {ol.PluggableMap} map Map.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */
map__ol_renderer_Map_.prototype.removeUnusedLayerRenderers_ = function (map, frameState) {
  var layerKey;
  for (layerKey in this.layerRenderers_) {
    if (!frameState || !(layerKey in frameState.layerStates)) {
      this.removeLayerRendererByKey_(layerKey).dispose();
    }
  }
};

/**
 * @param {olx.FrameState} frameState Frame state.
 * @protected
 */
map__ol_renderer_Map_.prototype.scheduleExpireIconCache = function (frameState) {
  frameState.postRenderFunctions.push(
  /** @type {ol.PostRenderFunction} */map__ol_renderer_Map_.expireIconCache_);
};

/**
 * @param {!olx.FrameState} frameState Frame state.
 * @protected
 */
map__ol_renderer_Map_.prototype.scheduleRemoveUnusedLayerRenderers = function (frameState) {
  var layerKey;
  for (layerKey in this.layerRenderers_) {
    if (!(layerKey in frameState.layerStates)) {
      frameState.postRenderFunctions.push(
      /** @type {ol.PostRenderFunction} */this.removeUnusedLayerRenderers_.bind(this));
      return;
    }
  }
};

/**
 * @param {ol.LayerState} state1 First layer state.
 * @param {ol.LayerState} state2 Second layer state.
 * @return {number} The zIndex difference.
 */
map__ol_renderer_Map_.sortByZIndex = function (state1, state2) {
  return state1.zIndex - state2.zIndex;
};
/* harmony default export */ var renderer_map = (map__ol_renderer_Map_);
// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/map.js
// FIXME offset panning















/**
 * @constructor
 * @extends {ol.renderer.Map}
 * @param {Element} container Container.
 * @param {ol.PluggableMap} map Map.
 * @api
 */
var map__ol_renderer_canvas_Map_ = function _ol_renderer_canvas_Map_(container, map) {

  renderer_map.call(this, container, map);

  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */
  this.context_ = dom["a" /* default */].createCanvasContext2D();

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = this.context_.canvas;

  this.canvas_.style.width = '100%';
  this.canvas_.style.height = '100%';
  this.canvas_.style.display = 'block';
  this.canvas_.className = css["a" /* default */].CLASS_UNSELECTABLE;
  container.insertBefore(this.canvas_, container.childNodes[0] || null);

  /**
   * @private
   * @type {boolean}
   */
  this.renderedVisible_ = true;

  /**
   * @private
   * @type {ol.Transform}
   */
  this.transform_ = ol_transform["a" /* default */].create();
};

ol["a" /* default */].inherits(map__ol_renderer_canvas_Map_, renderer_map);

/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @return {boolean} The renderer can render the layer.
 */
map__ol_renderer_canvas_Map_['handles'] = function (type) {
  return type === renderer_type.CANVAS;
};

/**
 * Create the map renderer.
 * @param {Element} container Container.
 * @param {ol.PluggableMap} map Map.
 * @return {ol.renderer.canvas.Map} The map renderer.
 */
map__ol_renderer_canvas_Map_['create'] = function (container, map) {
  return new map__ol_renderer_canvas_Map_(container, map);
};

/**
 * @param {ol.render.EventType} type Event type.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */
map__ol_renderer_canvas_Map_.prototype.dispatchComposeEvent_ = function (type, frameState) {
  var map = this.getMap();
  var context = this.context_;
  if (map.hasListener(type)) {
    var extent = frameState.extent;
    var pixelRatio = frameState.pixelRatio;
    var viewState = frameState.viewState;
    var rotation = viewState.rotation;

    var transform = this.getTransform(frameState);

    var vectorContext = new immediate(context, pixelRatio, extent, transform, rotation);
    var composeEvent = new render_event(type, vectorContext, frameState, context, null);
    map.dispatchEvent(composeEvent);
  }
};

/**
 * @param {olx.FrameState} frameState Frame state.
 * @protected
 * @return {!ol.Transform} Transform.
 */
map__ol_renderer_canvas_Map_.prototype.getTransform = function (frameState) {
  var viewState = frameState.viewState;
  var dx1 = this.canvas_.width / 2;
  var dy1 = this.canvas_.height / 2;
  var sx = frameState.pixelRatio / viewState.resolution;
  var sy = -sx;
  var angle = -viewState.rotation;
  var dx2 = -viewState.center[0];
  var dy2 = -viewState.center[1];
  return ol_transform["a" /* default */].compose(this.transform_, dx1, dy1, sx, sy, angle, dx2, dy2);
};

/**
 * @inheritDoc
 */
map__ol_renderer_canvas_Map_.prototype.getType = function () {
  return renderer_type.CANVAS;
};

/**
 * @inheritDoc
 */
map__ol_renderer_canvas_Map_.prototype.renderFrame = function (frameState) {

  if (!frameState) {
    if (this.renderedVisible_) {
      this.canvas_.style.display = 'none';
      this.renderedVisible_ = false;
    }
    return;
  }

  var context = this.context_;
  var pixelRatio = frameState.pixelRatio;
  var width = Math.round(frameState.size[0] * pixelRatio);
  var height = Math.round(frameState.size[1] * pixelRatio);
  if (this.canvas_.width != width || this.canvas_.height != height) {
    this.canvas_.width = width;
    this.canvas_.height = height;
  } else {
    context.clearRect(0, 0, width, height);
  }

  var rotation = frameState.viewState.rotation;

  this.calculateMatrices2D(frameState);

  this.dispatchComposeEvent_(render_eventtype["a" /* default */].PRECOMPOSE, frameState);

  var layerStatesArray = frameState.layerStatesArray;
  array["a" /* default */].stableSort(layerStatesArray, renderer_map.sortByZIndex);

  if (rotation) {
    context.save();
    render_canvas["a" /* default */].rotateAtOffset(context, rotation, width / 2, height / 2);
  }

  var viewResolution = frameState.viewState.resolution;
  var i, ii, layer, layerRenderer, layerState;
  for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
    layerState = layerStatesArray[i];
    layer = layerState.layer;
    layerRenderer = /** @type {ol.renderer.canvas.Layer} */this.getLayerRenderer(layer);
    if (!layer_layer["a" /* default */].visibleAtResolution(layerState, viewResolution) || layerState.sourceState != source_state["a" /* default */].READY) {
      continue;
    }
    if (layerRenderer.prepareFrame(frameState, layerState)) {
      layerRenderer.composeFrame(frameState, layerState, context);
    }
  }

  if (rotation) {
    context.restore();
  }

  this.dispatchComposeEvent_(render_eventtype["a" /* default */].POSTCOMPOSE, frameState);

  if (!this.renderedVisible_) {
    this.canvas_.style.display = '';
    this.renderedVisible_ = true;
  }

  this.scheduleRemoveUnusedLayerRenderers(frameState);
  this.scheduleExpireIconCache(frameState);
};

/**
 * @inheritDoc
 */
map__ol_renderer_canvas_Map_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg, layerFilter, thisArg2) {
  var result;
  var viewState = frameState.viewState;
  var viewResolution = viewState.resolution;

  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;

  var coordinate = ol_transform["a" /* default */].apply(frameState.pixelToCoordinateTransform, pixel.slice());

  var i;
  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;
    if (layer_layer["a" /* default */].visibleAtResolution(layerState, viewResolution) && layerFilter.call(thisArg2, layer)) {
      var layerRenderer = /** @type {ol.renderer.canvas.Layer} */this.getLayerRenderer(layer);
      result = layerRenderer.forEachLayerAtCoordinate(coordinate, frameState, callback, thisArg);
      if (result) {
        return result;
      }
    }
  }
  return undefined;
};
/* harmony default export */ var canvas_map = (map__ol_renderer_canvas_Map_);
// EXTERNAL MODULE: ./node_modules/ol/tilerange.js
var tilerange = __webpack_require__(63);

// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/tilelayer.js











/**
 * @constructor
 * @extends {ol.renderer.canvas.IntermediateCanvas}
 * @param {ol.layer.Tile|ol.layer.VectorTile} tileLayer Tile layer.
 * @api
 */
var tilelayer__ol_renderer_canvas_TileLayer_ = function _ol_renderer_canvas_TileLayer_(tileLayer) {

  intermediatecanvas.call(this, tileLayer);

  /**
   * @protected
   * @type {CanvasRenderingContext2D}
   */
  this.context = this.context === null ? null : dom["a" /* default */].createCanvasContext2D();

  /**
   * @private
   * @type {number}
   */
  this.oversampling_;

  /**
   * @private
   * @type {ol.Extent}
   */
  this.renderedExtent_ = null;

  /**
   * @protected
   * @type {number}
   */
  this.renderedRevision;

  /**
   * @protected
   * @type {!Array.<ol.Tile>}
   */
  this.renderedTiles = [];

  /**
   * @protected
   * @type {ol.Extent}
   */
  this.tmpExtent = ol_extent["a" /* default */].createEmpty();

  /**
   * @private
   * @type {ol.TileRange}
   */
  this.tmpTileRange_ = new tilerange["a" /* default */](0, 0, 0, 0);

  /**
   * @private
   * @type {ol.Transform}
   */
  this.imageTransform_ = ol_transform["a" /* default */].create();

  /**
   * @protected
   * @type {number}
   */
  this.zDirection = 0;
};

ol["a" /* default */].inherits(tilelayer__ol_renderer_canvas_TileLayer_, intermediatecanvas);

/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
tilelayer__ol_renderer_canvas_TileLayer_['handles'] = function (type, layer) {
  return type === renderer_type.CANVAS && layer.getType() === layertype["a" /* default */].TILE;
};

/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.canvas.TileLayer} The layer renderer.
 */
tilelayer__ol_renderer_canvas_TileLayer_['create'] = function (mapRenderer, layer) {
  return new tilelayer__ol_renderer_canvas_TileLayer_( /** @type {ol.layer.Tile} */layer);
};

/**
 * @private
 * @param {ol.Tile} tile Tile.
 * @return {boolean} Tile is drawable.
 */
tilelayer__ol_renderer_canvas_TileLayer_.prototype.isDrawableTile_ = function (tile) {
  var tileState = tile.getState();
  var useInterimTilesOnError = this.getLayer().getUseInterimTilesOnError();
  return tileState == tilestate["a" /* default */].LOADED || tileState == tilestate["a" /* default */].EMPTY || tileState == tilestate["a" /* default */].ERROR && !useInterimTilesOnError;
};

/**
 * @inheritDoc
 */
tilelayer__ol_renderer_canvas_TileLayer_.prototype.prepareFrame = function (frameState, layerState) {

  var pixelRatio = frameState.pixelRatio;
  var size = frameState.size;
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var viewResolution = viewState.resolution;
  var viewCenter = viewState.center;

  var tileLayer = this.getLayer();
  var tileSource = /** @type {ol.source.Tile} */tileLayer.getSource();
  var sourceRevision = tileSource.getRevision();
  var tileGrid = tileSource.getTileGridForProjection(projection);
  var z = tileGrid.getZForResolution(viewResolution, this.zDirection);
  var tileResolution = tileGrid.getResolution(z);
  var oversampling = Math.round(viewResolution / tileResolution) || 1;
  var extent = frameState.extent;

  if (layerState.extent !== undefined) {
    extent = ol_extent["a" /* default */].getIntersection(extent, layerState.extent);
  }
  if (ol_extent["a" /* default */].isEmpty(extent)) {
    // Return false to prevent the rendering of the layer.
    return false;
  }

  var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
  var imageExtent = tileGrid.getTileRangeExtent(z, tileRange);

  var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);

  /**
   * @type {Object.<number, Object.<string, ol.Tile>>}
   */
  var tilesToDrawByZ = {};
  tilesToDrawByZ[z] = {};

  var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);

  var tmpExtent = this.tmpExtent;
  var tmpTileRange = this.tmpTileRange_;
  var newTiles = false;
  var tile, x, y;
  for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
    for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
      tile = tileSource.getTile(z, x, y, pixelRatio, projection);
      if (tile.getState() == tilestate["a" /* default */].ERROR) {
        if (!tileLayer.getUseInterimTilesOnError()) {
          // When useInterimTilesOnError is false, we consider the error tile as loaded.
          tile.setState(tilestate["a" /* default */].LOADED);
        } else if (tileLayer.getPreload() > 0) {
          // Preloaded tiles for lower resolutions might have finished loading.
          newTiles = true;
        }
      }
      if (!this.isDrawableTile_(tile)) {
        tile = tile.getInterimTile();
      }
      if (this.isDrawableTile_(tile)) {
        var uid = ol["a" /* default */].getUid(this);
        if (tile.getState() == tilestate["a" /* default */].LOADED) {
          tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
          var inTransition = tile.inTransition(uid);
          if (!newTiles && (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
            newTiles = true;
          }
        }
        if (tile.getAlpha(uid, frameState.time) === 1) {
          // don't look for alt tiles if alpha is 1
          continue;
        }
      }

      var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
      var covered = false;
      if (childTileRange) {
        covered = findLoadedTiles(z + 1, childTileRange);
      }
      if (!covered) {
        tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);
      }
    }
  }

  var renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
  var hints = frameState.viewHints;
  var animatingOrInteracting = hints[viewhint["a" /* default */].ANIMATING] || hints[viewhint["a" /* default */].INTERACTING];
  if (!(this.renderedResolution && Date.now() - frameState.time > 16 && animatingOrInteracting) && (newTiles || !(this.renderedExtent_ && ol_extent["a" /* default */].containsExtent(this.renderedExtent_, extent)) || this.renderedRevision != sourceRevision || oversampling != this.oversampling_ || !animatingOrInteracting && renderedResolution != this.renderedResolution)) {

    var context = this.context;
    if (context) {
      var tilePixelSize = tileSource.getTilePixelSize(z, pixelRatio, projection);
      var width = Math.round(tileRange.getWidth() * tilePixelSize[0] / oversampling);
      var height = Math.round(tileRange.getHeight() * tilePixelSize[1] / oversampling);
      var canvas = context.canvas;
      if (canvas.width != width || canvas.height != height) {
        this.oversampling_ = oversampling;
        canvas.width = width;
        canvas.height = height;
      } else {
        if (this.renderedExtent_ && !ol_extent["a" /* default */].equals(imageExtent, this.renderedExtent_)) {
          context.clearRect(0, 0, width, height);
        }
        oversampling = this.oversampling_;
      }
    }

    this.renderedTiles.length = 0;
    /** @type {Array.<number>} */
    var zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(function (a, b) {
      if (a === z) {
        return 1;
      } else if (b === z) {
        return -1;
      } else {
        return a > b ? 1 : a < b ? -1 : 0;
      }
    });
    var currentResolution, currentScale, currentTilePixelSize, currentZ, i, ii;
    var tileExtent, tileGutter, tilesToDraw, w, h;
    for (i = 0, ii = zs.length; i < ii; ++i) {
      currentZ = zs[i];
      currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
      currentResolution = tileGrid.getResolution(currentZ);
      currentScale = currentResolution / tileResolution;
      tileGutter = tilePixelRatio * tileSource.getGutter(projection);
      tilesToDraw = tilesToDrawByZ[currentZ];
      for (var tileCoordKey in tilesToDraw) {
        tile = tilesToDraw[tileCoordKey];
        tileExtent = tileGrid.getTileCoordExtent(tile.getTileCoord(), tmpExtent);
        x = (tileExtent[0] - imageExtent[0]) / tileResolution * tilePixelRatio / oversampling;
        y = (imageExtent[3] - tileExtent[3]) / tileResolution * tilePixelRatio / oversampling;
        w = currentTilePixelSize[0] * currentScale / oversampling;
        h = currentTilePixelSize[1] * currentScale / oversampling;
        this.drawTileImage(tile, frameState, layerState, x, y, w, h, tileGutter, z === currentZ);
        this.renderedTiles.push(tile);
      }
    }

    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution * pixelRatio / tilePixelRatio * oversampling;
    this.renderedExtent_ = imageExtent;
  }

  var scale = this.renderedResolution / viewResolution;
  var transform = ol_transform["a" /* default */].compose(this.imageTransform_, pixelRatio * size[0] / 2, pixelRatio * size[1] / 2, scale, scale, 0, (this.renderedExtent_[0] - viewCenter[0]) / this.renderedResolution * pixelRatio, (viewCenter[1] - this.renderedExtent_[3]) / this.renderedResolution * pixelRatio);
  ol_transform["a" /* default */].compose(this.coordinateToCanvasPixelTransform, pixelRatio * size[0] / 2 - transform[4], pixelRatio * size[1] / 2 - transform[5], pixelRatio / viewResolution, -pixelRatio / viewResolution, 0, -viewCenter[0], -viewCenter[1]);

  this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);
  this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
  this.scheduleExpireCache(frameState, tileSource);
  this.updateLogos(frameState, tileSource);

  return this.renderedTiles.length > 0;
};

/**
 * @param {ol.Tile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {number} x Left of the tile.
 * @param {number} y Top of the tile.
 * @param {number} w Width of the tile.
 * @param {number} h Height of the tile.
 * @param {number} gutter Tile gutter.
 * @param {boolean} transition Apply an alpha transition.
 */
tilelayer__ol_renderer_canvas_TileLayer_.prototype.drawTileImage = function (tile, frameState, layerState, x, y, w, h, gutter, transition) {
  var image = tile.getImage(this.getLayer());
  if (!image) {
    return;
  }
  var uid = ol["a" /* default */].getUid(this);
  var alpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
  if (alpha === 1 && !this.getLayer().getSource().getOpaque(frameState.viewState.projection)) {
    this.context.clearRect(x, y, w, h);
  }
  var alphaChanged = alpha !== this.context.globalAlpha;
  if (alphaChanged) {
    this.context.save();
    this.context.globalAlpha = alpha;
  }
  this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);

  if (alphaChanged) {
    this.context.restore();
  }
  if (alpha !== 1) {
    frameState.animate = true;
  } else if (transition) {
    tile.endTransition(uid);
  }
};

/**
 * @inheritDoc
 */
tilelayer__ol_renderer_canvas_TileLayer_.prototype.getImage = function () {
  var context = this.context;
  return context ? context.canvas : null;
};

/**
 * @function
 * @return {ol.layer.Tile|ol.layer.VectorTile}
 */
tilelayer__ol_renderer_canvas_TileLayer_.prototype.getLayer;

/**
 * @inheritDoc
 */
tilelayer__ol_renderer_canvas_TileLayer_.prototype.getImageTransform = function () {
  return this.imageTransform_;
};
/* harmony default export */ var tilelayer = (tilelayer__ol_renderer_canvas_TileLayer_);
// EXTERNAL MODULE: external "rbush"
var external__rbush_ = __webpack_require__(70);
var external__rbush__default = /*#__PURE__*/__webpack_require__.n(external__rbush_);

// CONCATENATED MODULE: ./node_modules/ol/render/replaygroup.js
/**
 * Base class for replay groups.
 * @constructor
 * @abstract
 */
var _ol_render_ReplayGroup_ = function _ol_render_ReplayGroup_() {};

/**
 * @abstract
 * @param {number|undefined} zIndex Z index.
 * @param {ol.render.ReplayType} replayType Replay type.
 * @return {ol.render.VectorContext} Replay.
 */
_ol_render_ReplayGroup_.prototype.getReplay = function (zIndex, replayType) {};

/**
 * @abstract
 * @return {boolean} Is empty.
 */
_ol_render_ReplayGroup_.prototype.isEmpty = function () {};
/* harmony default export */ var replaygroup = (_ol_render_ReplayGroup_);
// CONCATENATED MODULE: ./node_modules/ol/render/replaytype.js
/**
 * @enum {string}
 */
var _ol_render_ReplayType_ = {
  CIRCLE: 'Circle',
  DEFAULT: 'Default',
  IMAGE: 'Image',
  LINE_STRING: 'LineString',
  POLYGON: 'Polygon',
  TEXT: 'Text'
};

/* harmony default export */ var replaytype = (_ol_render_ReplayType_);
// EXTERNAL MODULE: ./node_modules/ol/extent/relationship.js
var relationship = __webpack_require__(75);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/inflate.js
var inflate = __webpack_require__(34);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/length.js
var flat_length = __webpack_require__(80);

// CONCATENATED MODULE: ./node_modules/ol/geom/flat/textpath.js

var _ol_geom_flat_textpath_ = {};

/**
 * @param {Array.<number>} flatCoordinates Path to put text on.
 * @param {number} offset Start offset of the `flatCoordinates`.
 * @param {number} end End offset of the `flatCoordinates`.
 * @param {number} stride Stride.
 * @param {string} text Text to place on the path.
 * @param {function(string):number} measure Measure function returning the
 * width of the character passed as 1st argument.
 * @param {number} startM m along the path where the text starts.
 * @param {number} maxAngle Max angle between adjacent chars in radians.
 * @return {Array.<Array.<*>>} The result array of null if `maxAngle` was
 * exceeded. Entries of the array are x, y, anchorX, angle, chunk.
 */
_ol_geom_flat_textpath_.lineString = function (flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {
  var result = [];

  // Keep text upright
  var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];

  var numChars = text.length;

  var x1 = flatCoordinates[offset];
  var y1 = flatCoordinates[offset + 1];
  offset += stride;
  var x2 = flatCoordinates[offset];
  var y2 = flatCoordinates[offset + 1];
  var segmentM = 0;
  var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));

  var chunk = '';
  var chunkLength = 0;
  var data, index, previousAngle;
  for (var i = 0; i < numChars; ++i) {
    index = reverse ? numChars - i - 1 : i;
    var char = text.charAt(index);
    chunk = reverse ? char + chunk : chunk + char;
    var charLength = measure(chunk) - chunkLength;
    chunkLength += charLength;
    var charM = startM + charLength / 2;
    while (offset < end - stride && segmentM + segmentLength < charM) {
      x1 = x2;
      y1 = y2;
      offset += stride;
      x2 = flatCoordinates[offset];
      y2 = flatCoordinates[offset + 1];
      segmentM += segmentLength;
      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    }
    var segmentPos = charM - segmentM;
    var angle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      angle += angle > 0 ? -Math.PI : Math.PI;
    }
    if (previousAngle !== undefined) {
      var delta = angle - previousAngle;
      delta += delta > Math.PI ? -2 * Math.PI : delta < -Math.PI ? 2 * Math.PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    var interpolate = segmentPos / segmentLength;
    var x = math["a" /* default */].lerp(x1, x2, interpolate);
    var y = math["a" /* default */].lerp(y1, y2, interpolate);
    if (previousAngle == angle) {
      if (reverse) {
        data[0] = x;
        data[1] = y;
        data[2] = charLength / 2;
      }
      data[4] = chunk;
    } else {
      chunk = char;
      chunkLength = charLength;
      data = [x, y, charLength / 2, angle, chunk];
      if (reverse) {
        result.unshift(data);
      } else {
        result.push(data);
      }
      previousAngle = angle;
    }
    startM += charLength;
  }
  return result;
};
/* harmony default export */ var textpath = (_ol_geom_flat_textpath_);
// CONCATENATED MODULE: ./node_modules/ol/render/canvas/instruction.js
/**
 * @enum {number}
 */
var _ol_render_canvas_Instruction_ = {
  BEGIN_GEOMETRY: 0,
  BEGIN_PATH: 1,
  CIRCLE: 2,
  CLOSE_PATH: 3,
  CUSTOM: 4,
  DRAW_CHARS: 5,
  DRAW_IMAGE: 6,
  END_GEOMETRY: 7,
  FILL: 8,
  MOVE_TO_LINE_TO: 9,
  SET_FILL_STYLE: 10,
  SET_STROKE_STYLE: 11,
  STROKE: 12
};

/* harmony default export */ var canvas_instruction = (_ol_render_canvas_Instruction_);
// CONCATENATED MODULE: ./node_modules/ol/render/replay.js

var _ol_render_replay_ = {};

/**
 * @const
 * @type {Array.<ol.render.ReplayType>}
 */
_ol_render_replay_.ORDER = [replaytype.POLYGON, replaytype.CIRCLE, replaytype.LINE_STRING, replaytype.IMAGE, replaytype.TEXT, replaytype.DEFAULT];

/**
 * @const
 * @enum {number}
 */
_ol_render_replay_.TEXT_ALIGN = {};
_ol_render_replay_.TEXT_ALIGN['left'] = 0;
_ol_render_replay_.TEXT_ALIGN['end'] = 0;
_ol_render_replay_.TEXT_ALIGN['center'] = 0.5;
_ol_render_replay_.TEXT_ALIGN['right'] = 1;
_ol_render_replay_.TEXT_ALIGN['start'] = 1;
_ol_render_replay_.TEXT_ALIGN['top'] = 0;
_ol_render_replay_.TEXT_ALIGN['middle'] = 0.5;
_ol_render_replay_.TEXT_ALIGN['hanging'] = 0.2;
_ol_render_replay_.TEXT_ALIGN['alphabetic'] = 0.8;
_ol_render_replay_.TEXT_ALIGN['ideographic'] = 0.8;
_ol_render_replay_.TEXT_ALIGN['bottom'] = 1;
/* harmony default export */ var render_replay = (_ol_render_replay_);
// CONCATENATED MODULE: ./node_modules/ol/render/canvas/replay.js


















/**
 * @constructor
 * @extends {ol.render.VectorContext}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @param {?} declutterTree Declutter tree.
 * @struct
 */
var replay__ol_render_canvas_Replay_ = function _ol_render_canvas_Replay_(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  vectorcontext.call(this);

  /**
   * @type {?}
   */
  this.declutterTree = declutterTree;

  /**
   * @private
   * @type {ol.Extent}
   */
  this.tmpExtent_ = ol_extent["a" /* default */].createEmpty();

  /**
   * @protected
   * @type {number}
   */
  this.tolerance = tolerance;

  /**
   * @protected
   * @const
   * @type {ol.Extent}
   */
  this.maxExtent = maxExtent;

  /**
   * @protected
   * @type {boolean}
   */
  this.overlaps = overlaps;

  /**
   * @protected
   * @type {number}
   */
  this.pixelRatio = pixelRatio;

  /**
   * @protected
   * @type {number}
   */
  this.maxLineWidth = 0;

  /**
   * @protected
   * @const
   * @type {number}
   */
  this.resolution = resolution;

  /**
   * @private
   * @type {ol.Coordinate}
   */
  this.fillOrigin_;

  /**
   * @private
   * @type {Array.<*>}
   */
  this.beginGeometryInstruction1_ = null;

  /**
   * @private
   * @type {Array.<*>}
   */
  this.beginGeometryInstruction2_ = null;

  /**
   * @private
   * @type {ol.Extent}
   */
  this.bufferedMaxExtent_ = null;

  /**
   * @protected
   * @type {Array.<*>}
   */
  this.instructions = [];

  /**
   * @protected
   * @type {Array.<number>}
   */
  this.coordinates = [];

  /**
   * @private
   * @type {Object.<number,ol.Coordinate|Array.<ol.Coordinate>|Array.<Array.<ol.Coordinate>>>}
   */
  this.coordinateCache_ = {};

  /**
   * @private
   * @type {!ol.Transform}
   */
  this.renderedTransform_ = ol_transform["a" /* default */].create();

  /**
   * @protected
   * @type {Array.<*>}
   */
  this.hitDetectionInstructions = [];

  /**
   * @private
   * @type {Array.<number>}
   */
  this.pixelCoordinates_ = null;

  /**
   * @protected
   * @type {ol.CanvasFillStrokeState}
   */
  this.state = /** @type {ol.CanvasFillStrokeState} */{};

  /**
   * @private
   * @type {number}
   */
  this.viewRotation_ = 0;

  /**
   * @private
   * @type {!ol.Transform}
   */
  this.tmpLocalTransform_ = ol_transform["a" /* default */].create();

  /**
   * @private
   * @type {!ol.Transform}
   */
  this.resetTransform_ = ol_transform["a" /* default */].create();
};

ol["a" /* default */].inherits(replay__ol_render_canvas_Replay_, vectorcontext);

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Coordinate} p1 1st point of the background box.
 * @param {ol.Coordinate} p2 2nd point of the background box.
 * @param {ol.Coordinate} p3 3rd point of the background box.
 * @param {ol.Coordinate} p4 4th point of the background box.
 * @param {Array.<*>} fillInstruction Fill instruction.
 * @param {Array.<*>} strokeInstruction Stroke instruction.
 */
replay__ol_render_canvas_Replay_.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction) {
  context.beginPath();
  context.moveTo.apply(context, p1);
  context.lineTo.apply(context, p2);
  context.lineTo.apply(context, p3);
  context.lineTo.apply(context, p4);
  context.lineTo.apply(context, p1);
  if (fillInstruction) {
    this.fillOrigin_ = /** @type {Array.<number>} */fillInstruction[2];
    this.fill_(context);
  }
  if (strokeInstruction) {
    this.setStrokeStyle_(context, /** @type {Array.<*>} */strokeInstruction);
    context.stroke();
  }
};

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} x X.
 * @param {number} y Y.
 * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image Image.
 * @param {number} anchorX Anchor X.
 * @param {number} anchorY Anchor Y.
 * @param {ol.DeclutterGroup} declutterGroup Declutter group.
 * @param {number} height Height.
 * @param {number} opacity Opacity.
 * @param {number} originX Origin X.
 * @param {number} originY Origin Y.
 * @param {number} rotation Rotation.
 * @param {number} scale Scale.
 * @param {boolean} snapToPixel Snap to pixel.
 * @param {number} width Width.
 * @param {Array.<number>} padding Padding.
 * @param {Array.<*>} fillInstruction Fill instruction.
 * @param {Array.<*>} strokeInstruction Stroke instruction.
 */
replay__ol_render_canvas_Replay_.prototype.replayImage_ = function (context, x, y, image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {
  var fillStroke = fillInstruction || strokeInstruction;
  var localTransform = this.tmpLocalTransform_;
  anchorX *= scale;
  anchorY *= scale;
  x -= anchorX;
  y -= anchorY;
  if (snapToPixel) {
    x = Math.round(x);
    y = Math.round(y);
  }

  var w = width + originX > image.width ? image.width - originX : width;
  var h = height + originY > image.height ? image.height - originY : height;
  var box = this.tmpExtent_;
  var boxW = padding[3] + w * scale + padding[1];
  var boxH = padding[0] + h * scale + padding[2];
  var boxX = x - padding[3];
  var boxY = y - padding[0];

  /** @type {ol.Coordinate} */
  var p1;
  /** @type {ol.Coordinate} */
  var p2;
  /** @type {ol.Coordinate} */
  var p3;
  /** @type {ol.Coordinate} */
  var p4;
  if (fillStroke || rotation !== 0) {
    p1 = [boxX, boxY];
    p2 = [boxX + boxW, boxY];
    p3 = [boxX + boxW, boxY + boxH];
    p4 = [boxX, boxY + boxH];
  }

  var transform = null;
  if (rotation !== 0) {
    var centerX = x + anchorX;
    var centerY = y + anchorY;
    transform = ol_transform["a" /* default */].compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);

    ol_extent["a" /* default */].createOrUpdateEmpty(box);
    ol_extent["a" /* default */].extendCoordinate(box, ol_transform["a" /* default */].apply(localTransform, p1));
    ol_extent["a" /* default */].extendCoordinate(box, ol_transform["a" /* default */].apply(localTransform, p2));
    ol_extent["a" /* default */].extendCoordinate(box, ol_transform["a" /* default */].apply(localTransform, p3));
    ol_extent["a" /* default */].extendCoordinate(box, ol_transform["a" /* default */].apply(localTransform, p4));
  } else {
    ol_extent["a" /* default */].createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, box);
  }
  var canvas = context.canvas;
  var intersects = box[0] <= canvas.width && box[2] >= 0 && box[1] <= canvas.height && box[3] >= 0;
  if (declutterGroup) {
    if (!intersects && declutterGroup[4] == 1) {
      return;
    }
    ol_extent["a" /* default */].extend(declutterGroup, box);
    var declutterArgs = intersects ? [context, transform ? transform.slice(0) : null, opacity, image, originX, originY, w, h, x, y, scale] : null;
    if (declutterArgs && fillStroke) {
      declutterArgs.push(fillInstruction, strokeInstruction, p1, p2, p3, p4);
    }
    declutterGroup.push(declutterArgs);
  } else if (intersects) {
    if (fillStroke) {
      this.replayTextBackground_(context, p1, p2, p3, p4,
      /** @type {Array.<*>} */fillInstruction,
      /** @type {Array.<*>} */strokeInstruction);
    }
    render_canvas["a" /* default */].drawImage(context, transform, opacity, image, originX, originY, w, h, x, y, scale);
  }
};

/**
 * @protected
 * @param {Array.<number>} dashArray Dash array.
 * @return {Array.<number>} Dash array with pixel ratio applied
 */
replay__ol_render_canvas_Replay_.prototype.applyPixelRatio = function (dashArray) {
  var pixelRatio = this.pixelRatio;
  return pixelRatio == 1 ? dashArray : dashArray.map(function (dash) {
    return dash * pixelRatio;
  });
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @param {boolean} closed Last input coordinate equals first.
 * @param {boolean} skipFirst Skip first coordinate.
 * @protected
 * @return {number} My end.
 */
replay__ol_render_canvas_Replay_.prototype.appendFlatCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {

  var myEnd = this.coordinates.length;
  var extent = this.getBufferedMaxExtent();
  if (skipFirst) {
    offset += stride;
  }
  var lastCoord = [flatCoordinates[offset], flatCoordinates[offset + 1]];
  var nextCoord = [NaN, NaN];
  var skipped = true;

  var i, lastRel, nextRel;
  for (i = offset + stride; i < end; i += stride) {
    nextCoord[0] = flatCoordinates[i];
    nextCoord[1] = flatCoordinates[i + 1];
    nextRel = ol_extent["a" /* default */].coordinateRelationship(extent, nextCoord);
    if (nextRel !== lastRel) {
      if (skipped) {
        this.coordinates[myEnd++] = lastCoord[0];
        this.coordinates[myEnd++] = lastCoord[1];
      }
      this.coordinates[myEnd++] = nextCoord[0];
      this.coordinates[myEnd++] = nextCoord[1];
      skipped = false;
    } else if (nextRel === relationship["a" /* default */].INTERSECTING) {
      this.coordinates[myEnd++] = nextCoord[0];
      this.coordinates[myEnd++] = nextCoord[1];
      skipped = false;
    } else {
      skipped = true;
    }
    lastCoord[0] = nextCoord[0];
    lastCoord[1] = nextCoord[1];
    lastRel = nextRel;
  }

  // Last coordinate equals first or only one point to append:
  if (closed && skipped || i === offset + stride) {
    this.coordinates[myEnd++] = lastCoord[0];
    this.coordinates[myEnd++] = lastCoord[1];
  }
  return myEnd;
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @param {Array.<number>} replayEnds Replay ends.
 * @return {number} Offset.
 */
replay__ol_render_canvas_Replay_.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, replayEnds) {
  for (var i = 0, ii = ends.length; i < ii; ++i) {
    var end = ends[i];
    var replayEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
    replayEnds.push(replayEnd);
    offset = end;
  }
  return offset;
};

/**
 * @inheritDoc.
 */
replay__ol_render_canvas_Replay_.prototype.drawCustom = function (geometry, feature, renderer) {
  this.beginGeometry(geometry, feature);
  var type = geometry.getType();
  var stride = geometry.getStride();
  var replayBegin = this.coordinates.length;
  var flatCoordinates, replayEnd, replayEnds, replayEndss;
  var offset;
  if (type == geometrytype["a" /* default */].MULTI_POLYGON) {
    geometry = /** @type {ol.geom.MultiPolygon} */geometry;
    flatCoordinates = geometry.getOrientedFlatCoordinates();
    replayEndss = [];
    var endss = geometry.getEndss();
    offset = 0;
    for (var i = 0, ii = endss.length; i < ii; ++i) {
      var myEnds = [];
      offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
      replayEndss.push(myEnds);
    }
    this.instructions.push([canvas_instruction.CUSTOM, replayBegin, replayEndss, geometry, renderer, inflate["a" /* default */].coordinatesss]);
  } else if (type == geometrytype["a" /* default */].POLYGON || type == geometrytype["a" /* default */].MULTI_LINE_STRING) {
    replayEnds = [];
    flatCoordinates = type == geometrytype["a" /* default */].POLYGON ?
    /** @type {ol.geom.Polygon} */geometry.getOrientedFlatCoordinates() : geometry.getFlatCoordinates();
    offset = this.drawCustomCoordinates_(flatCoordinates, 0,
    /** @type {ol.geom.Polygon|ol.geom.MultiLineString} */geometry.getEnds(), stride, replayEnds);
    this.instructions.push([canvas_instruction.CUSTOM, replayBegin, replayEnds, geometry, renderer, inflate["a" /* default */].coordinatess]);
  } else if (type == geometrytype["a" /* default */].LINE_STRING || type == geometrytype["a" /* default */].MULTI_POINT) {
    flatCoordinates = geometry.getFlatCoordinates();
    replayEnd = this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
    this.instructions.push([canvas_instruction.CUSTOM, replayBegin, replayEnd, geometry, renderer, inflate["a" /* default */].coordinates]);
  } else if (type == geometrytype["a" /* default */].POINT) {
    flatCoordinates = geometry.getFlatCoordinates();
    this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
    replayEnd = this.coordinates.length;
    this.instructions.push([canvas_instruction.CUSTOM, replayBegin, replayEnd, geometry, renderer]);
  }
  this.endGeometry(geometry, feature);
};

/**
 * @protected
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
replay__ol_render_canvas_Replay_.prototype.beginGeometry = function (geometry, feature) {
  this.beginGeometryInstruction1_ = [canvas_instruction.BEGIN_GEOMETRY, feature, 0];
  this.instructions.push(this.beginGeometryInstruction1_);
  this.beginGeometryInstruction2_ = [canvas_instruction.BEGIN_GEOMETRY, feature, 0];
  this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
};

/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 */
replay__ol_render_canvas_Replay_.prototype.fill_ = function (context) {
  if (this.fillOrigin_) {
    var origin = ol_transform["a" /* default */].apply(this.renderedTransform_, this.fillOrigin_.slice());
    context.translate(origin[0], origin[1]);
    context.rotate(this.viewRotation_);
  }
  context.fill();
  if (this.fillOrigin_) {
    context.setTransform.apply(context, render_canvas["a" /* default */].resetTransform_);
  }
};

/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 * @param {Array.<*>} instruction Instruction.
 */
replay__ol_render_canvas_Replay_.prototype.setStrokeStyle_ = function (context, instruction) {
  context.strokeStyle = /** @type {ol.ColorLike} */instruction[1];
  context.lineWidth = /** @type {number} */instruction[2];
  context.lineCap = /** @type {string} */instruction[3];
  context.lineJoin = /** @type {string} */instruction[4];
  context.miterLimit = /** @type {number} */instruction[5];
  if (has["a" /* default */].CANVAS_LINE_DASH) {
    context.lineDashOffset = /** @type {number} */instruction[7];
    context.setLineDash( /** @type {Array.<number>} */instruction[6]);
  }
};

/**
 * @param {ol.DeclutterGroup} declutterGroup Declutter group.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
replay__ol_render_canvas_Replay_.prototype.renderDeclutter_ = function (declutterGroup, feature) {
  if (declutterGroup && declutterGroup.length > 5) {
    var groupCount = declutterGroup[4];
    if (groupCount == 1 || groupCount == declutterGroup.length - 5) {
      /** @type {ol.RBushEntry} */
      var box = {
        minX: /** @type {number} */declutterGroup[0],
        minY: /** @type {number} */declutterGroup[1],
        maxX: /** @type {number} */declutterGroup[2],
        maxY: /** @type {number} */declutterGroup[3],
        value: feature
      };
      if (!this.declutterTree.collides(box)) {
        this.declutterTree.insert(box);
        var drawImage = render_canvas["a" /* default */].drawImage;
        for (var j = 5, jj = declutterGroup.length; j < jj; ++j) {
          var declutterData = /** @type {Array} */declutterGroup[j];
          if (declutterData) {
            if (declutterData.length > 11) {
              this.replayTextBackground_(declutterData[0], declutterData[13], declutterData[14], declutterData[15], declutterData[16], declutterData[11], declutterData[12]);
            }
            drawImage.apply(undefined, declutterData);
          }
        }
      }
      declutterGroup.length = 5;
      ol_extent["a" /* default */].createOrUpdateEmpty(declutterGroup);
    }
  }
};

/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {Array.<*>} instructions Instructions array.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined}
 *     featureCallback Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @return {T|undefined} Callback result.
 * @template T
 */
replay__ol_render_canvas_Replay_.prototype.replay_ = function (context, transform, skippedFeaturesHash, instructions, featureCallback, opt_hitExtent) {
  /** @type {Array.<number>} */
  var pixelCoordinates;
  if (this.pixelCoordinates_ && array["a" /* default */].equals(transform, this.renderedTransform_)) {
    pixelCoordinates = this.pixelCoordinates_;
  } else {
    if (!this.pixelCoordinates_) {
      this.pixelCoordinates_ = [];
    }
    pixelCoordinates = flat_transform["a" /* default */].transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
    ol_transform["a" /* default */].setFromArray(this.renderedTransform_, transform);
  }
  var skipFeatures = !obj["a" /* default */].isEmpty(skippedFeaturesHash);
  var i = 0; // instruction index
  var ii = instructions.length; // end of instructions
  var d = 0; // data index
  var dd; // end of per-instruction data
  var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, image;
  var pendingFill = 0;
  var pendingStroke = 0;
  var lastFillInstruction = null;
  var lastStrokeInstruction = null;
  var coordinateCache = this.coordinateCache_;
  var viewRotation = this.viewRotation_;

  var state = /** @type {olx.render.State} */{
    context: context,
    pixelRatio: this.pixelRatio,
    resolution: this.resolution,
    rotation: viewRotation
  };

  // When the batch size gets too big, performance decreases. 200 is a good
  // balance between batch size and number of fill/stroke instructions.
  var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
  while (i < ii) {
    var instruction = instructions[i];
    var type = /** @type {ol.render.canvas.Instruction} */instruction[0];
    var /** @type {ol.Feature|ol.render.Feature} */feature, x, y;
    switch (type) {
      case canvas_instruction.BEGIN_GEOMETRY:
        feature = /** @type {ol.Feature|ol.render.Feature} */instruction[1];
        if (skipFeatures && skippedFeaturesHash[ol["a" /* default */].getUid(feature).toString()] || !feature.getGeometry()) {
          i = /** @type {number} */instruction[2];
        } else if (opt_hitExtent !== undefined && !ol_extent["a" /* default */].intersects(opt_hitExtent, feature.getGeometry().getExtent())) {
          i = /** @type {number} */instruction[2] + 1;
        } else {
          ++i;
        }
        break;
      case canvas_instruction.BEGIN_PATH:
        if (pendingFill > batchSize) {
          this.fill_(context);
          pendingFill = 0;
        }
        if (pendingStroke > batchSize) {
          context.stroke();
          pendingStroke = 0;
        }
        if (!pendingFill && !pendingStroke) {
          context.beginPath();
          prevX = prevY = NaN;
        }
        ++i;
        break;
      case canvas_instruction.CIRCLE:
        d = /** @type {number} */instruction[1];
        var x1 = pixelCoordinates[d];
        var y1 = pixelCoordinates[d + 1];
        var x2 = pixelCoordinates[d + 2];
        var y2 = pixelCoordinates[d + 3];
        var dx = x2 - x1;
        var dy = y2 - y1;
        var r = Math.sqrt(dx * dx + dy * dy);
        context.moveTo(x1 + r, y1);
        context.arc(x1, y1, r, 0, 2 * Math.PI, true);
        ++i;
        break;
      case canvas_instruction.CLOSE_PATH:
        context.closePath();
        ++i;
        break;
      case canvas_instruction.CUSTOM:
        d = /** @type {number} */instruction[1];
        dd = instruction[2];
        var geometry = /** @type {ol.geom.SimpleGeometry} */instruction[3];
        var renderer = instruction[4];
        var fn = instruction.length == 6 ? instruction[5] : undefined;
        state.geometry = geometry;
        state.feature = feature;
        if (!(i in coordinateCache)) {
          coordinateCache[i] = [];
        }
        var coords = coordinateCache[i];
        if (fn) {
          fn(pixelCoordinates, d, dd, 2, coords);
        } else {
          coords[0] = pixelCoordinates[d];
          coords[1] = pixelCoordinates[d + 1];
          coords.length = 2;
        }
        renderer(coords, state);
        ++i;
        break;
      case canvas_instruction.DRAW_IMAGE:
        d = /** @type {number} */instruction[1];
        dd = /** @type {number} */instruction[2];
        image = /** @type {HTMLCanvasElement|HTMLVideoElement|Image} */
        instruction[3];
        // Remaining arguments in DRAW_IMAGE are in alphabetical order
        anchorX = /** @type {number} */instruction[4];
        anchorY = /** @type {number} */instruction[5];
        declutterGroup = featureCallback ? null : /** @type {ol.DeclutterGroup} */instruction[6];
        var height = /** @type {number} */instruction[7];
        var opacity = /** @type {number} */instruction[8];
        var originX = /** @type {number} */instruction[9];
        var originY = /** @type {number} */instruction[10];
        var rotateWithView = /** @type {boolean} */instruction[11];
        var rotation = /** @type {number} */instruction[12];
        var scale = /** @type {number} */instruction[13];
        var snapToPixel = /** @type {boolean} */instruction[14];
        var width = /** @type {number} */instruction[15];

        var padding, backgroundFill, backgroundStroke;
        if (instruction.length > 16) {
          padding = /** @type {Array.<number>} */instruction[16];
          backgroundFill = /** @type {boolean} */instruction[17];
          backgroundStroke = /** @type {boolean} */instruction[18];
        } else {
          padding = render_canvas["a" /* default */].defaultPadding;
          backgroundFill = backgroundStroke = false;
        }

        if (rotateWithView) {
          rotation += viewRotation;
        }
        for (; d < dd; d += 2) {
          this.replayImage_(context, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill ? /** @type {Array.<*>} */lastFillInstruction : null, backgroundStroke ? /** @type {Array.<*>} */lastStrokeInstruction : null);
        }
        this.renderDeclutter_(declutterGroup, feature);
        ++i;
        break;
      case canvas_instruction.DRAW_CHARS:
        var begin = /** @type {number} */instruction[1];
        var end = /** @type {number} */instruction[2];
        var baseline = /** @type {number} */instruction[3];
        declutterGroup = featureCallback ? null : /** @type {ol.DeclutterGroup} */instruction[4];
        var overflow = /** @type {number} */instruction[5];
        var fillKey = /** @type {string} */instruction[6];
        var maxAngle = /** @type {number} */instruction[7];
        var measure = /** @type {function(string):number} */instruction[8];
        var offsetY = /** @type {number} */instruction[9];
        var strokeKey = /** @type {string} */instruction[10];
        var strokeWidth = /** @type {number} */instruction[11];
        var text = /** @type {string} */instruction[12];
        var textKey = /** @type {string} */instruction[13];
        var textScale = /** @type {number} */instruction[14];

        var pathLength = flat_length["a" /* default */].lineString(pixelCoordinates, begin, end, 2);
        var textLength = measure(text);
        if (overflow || textLength <= pathLength) {
          var textAlign = /** @type {ol.render.canvas.TextReplay} */this.textStates[textKey].textAlign;
          var startM = (pathLength - textLength) * render_replay.TEXT_ALIGN[textAlign];
          var parts = textpath.lineString(pixelCoordinates, begin, end, 2, text, measure, startM, maxAngle);
          if (parts) {
            var c, cc, chars, label, part;
            if (strokeKey) {
              for (c = 0, cc = parts.length; c < cc; ++c) {
                part = parts[c]; // x, y, anchorX, rotation, chunk
                chars = /** @type {string} */part[4];
                label = /** @type {ol.render.canvas.TextReplay} */this.getImage(chars, textKey, '', strokeKey);
                anchorX = /** @type {number} */part[2] + strokeWidth;
                anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth - offsetY;
                this.replayImage_(context,
                /** @type {number} */part[0], /** @type {number} */part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,
                /** @type {number} */part[3], textScale, false, label.width, render_canvas["a" /* default */].defaultPadding, null, null);
              }
            }
            if (fillKey) {
              for (c = 0, cc = parts.length; c < cc; ++c) {
                part = parts[c]; // x, y, anchorX, rotation, chunk
                chars = /** @type {string} */part[4];
                label = /** @type {ol.render.canvas.TextReplay} */this.getImage(chars, textKey, fillKey, '');
                anchorX = /** @type {number} */part[2];
                anchorY = baseline * label.height - offsetY;
                this.replayImage_(context,
                /** @type {number} */part[0], /** @type {number} */part[1], label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0,
                /** @type {number} */part[3], textScale, false, label.width, render_canvas["a" /* default */].defaultPadding, null, null);
              }
            }
          }
        }
        this.renderDeclutter_(declutterGroup, feature);
        ++i;
        break;
      case canvas_instruction.END_GEOMETRY:
        if (featureCallback !== undefined) {
          feature = /** @type {ol.Feature|ol.render.Feature} */instruction[1];
          var result = featureCallback(feature);
          if (result) {
            return result;
          }
        }
        ++i;
        break;
      case canvas_instruction.FILL:
        if (batchSize) {
          pendingFill++;
        } else {
          this.fill_(context);
        }
        ++i;
        break;
      case canvas_instruction.MOVE_TO_LINE_TO:
        d = /** @type {number} */instruction[1];
        dd = /** @type {number} */instruction[2];
        x = pixelCoordinates[d];
        y = pixelCoordinates[d + 1];
        roundX = x + 0.5 | 0;
        roundY = y + 0.5 | 0;
        if (roundX !== prevX || roundY !== prevY) {
          context.moveTo(x, y);
          prevX = roundX;
          prevY = roundY;
        }
        for (d += 2; d < dd; d += 2) {
          x = pixelCoordinates[d];
          y = pixelCoordinates[d + 1];
          roundX = x + 0.5 | 0;
          roundY = y + 0.5 | 0;
          if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
            context.lineTo(x, y);
            prevX = roundX;
            prevY = roundY;
          }
        }
        ++i;
        break;
      case canvas_instruction.SET_FILL_STYLE:
        lastFillInstruction = instruction;
        this.fillOrigin_ = instruction[2];

        if (pendingFill) {
          this.fill_(context);
          pendingFill = 0;
          if (pendingStroke) {
            context.stroke();
            pendingStroke = 0;
          }
        }

        context.fillStyle = /** @type {ol.ColorLike} */instruction[1];
        ++i;
        break;
      case canvas_instruction.SET_STROKE_STYLE:
        lastStrokeInstruction = instruction;
        if (pendingStroke) {
          context.stroke();
          pendingStroke = 0;
        }
        this.setStrokeStyle_(context, /** @type {Array.<*>} */instruction);
        ++i;
        break;
      case canvas_instruction.STROKE:
        if (batchSize) {
          pendingStroke++;
        } else {
          context.stroke();
        }
        ++i;
        break;
      default:
        ++i; // consume the instruction anyway, to avoid an infinite loop
        break;
    }
  }
  if (pendingFill) {
    this.fill_(context);
  }
  if (pendingStroke) {
    context.stroke();
  }
  return undefined;
};

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 */
replay__ol_render_canvas_Replay_.prototype.replay = function (context, transform, viewRotation, skippedFeaturesHash) {
  this.viewRotation_ = viewRotation;
  this.replay_(context, transform, skippedFeaturesHash, this.instructions, undefined, undefined);
};

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T=} opt_featureCallback
 *     Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @return {T|undefined} Callback result.
 * @template T
 */
replay__ol_render_canvas_Replay_.prototype.replayHitDetection = function (context, transform, viewRotation, skippedFeaturesHash, opt_featureCallback, opt_hitExtent) {
  this.viewRotation_ = viewRotation;
  return this.replay_(context, transform, skippedFeaturesHash, this.hitDetectionInstructions, opt_featureCallback, opt_hitExtent);
};

/**
 * Reverse the hit detection instructions.
 */
replay__ol_render_canvas_Replay_.prototype.reverseHitDetectionInstructions = function () {
  var hitDetectionInstructions = this.hitDetectionInstructions;
  // step 1 - reverse array
  hitDetectionInstructions.reverse();
  // step 2 - reverse instructions within geometry blocks
  var i;
  var n = hitDetectionInstructions.length;
  var instruction;
  var type;
  var begin = -1;
  for (i = 0; i < n; ++i) {
    instruction = hitDetectionInstructions[i];
    type = /** @type {ol.render.canvas.Instruction} */instruction[0];
    if (type == canvas_instruction.END_GEOMETRY) {
      begin = i;
    } else if (type == canvas_instruction.BEGIN_GEOMETRY) {
      instruction[2] = i;
      array["a" /* default */].reverseSubArray(this.hitDetectionInstructions, begin, i);
      begin = -1;
    }
  }
};

/**
 * @inheritDoc
 */
replay__ol_render_canvas_Replay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  var state = this.state;
  if (fillStyle) {
    var fillStyleColor = fillStyle.getColor();
    state.fillStyle = colorlike["a" /* default */].asColorLike(fillStyleColor ? fillStyleColor : render_canvas["a" /* default */].defaultFillStyle);
  } else {
    state.fillStyle = undefined;
  }
  if (strokeStyle) {
    var strokeStyleColor = strokeStyle.getColor();
    state.strokeStyle = colorlike["a" /* default */].asColorLike(strokeStyleColor ? strokeStyleColor : render_canvas["a" /* default */].defaultStrokeStyle);
    var strokeStyleLineCap = strokeStyle.getLineCap();
    state.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : render_canvas["a" /* default */].defaultLineCap;
    var strokeStyleLineDash = strokeStyle.getLineDash();
    state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : render_canvas["a" /* default */].defaultLineDash;
    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
    state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : render_canvas["a" /* default */].defaultLineDashOffset;
    var strokeStyleLineJoin = strokeStyle.getLineJoin();
    state.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : render_canvas["a" /* default */].defaultLineJoin;
    var strokeStyleWidth = strokeStyle.getWidth();
    state.lineWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : render_canvas["a" /* default */].defaultLineWidth;
    var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
    state.miterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : render_canvas["a" /* default */].defaultMiterLimit;

    if (state.lineWidth > this.maxLineWidth) {
      this.maxLineWidth = state.lineWidth;
      // invalidate the buffered max extent cache
      this.bufferedMaxExtent_ = null;
    }
  } else {
    state.strokeStyle = undefined;
    state.lineCap = undefined;
    state.lineDash = null;
    state.lineDashOffset = undefined;
    state.lineJoin = undefined;
    state.lineWidth = undefined;
    state.miterLimit = undefined;
  }
};

/**
 * @param {ol.CanvasFillStrokeState} state State.
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 */
replay__ol_render_canvas_Replay_.prototype.applyFill = function (state, geometry) {
  var fillStyle = state.fillStyle;
  var fillInstruction = [canvas_instruction.SET_FILL_STYLE, fillStyle];
  if (typeof fillStyle !== 'string') {
    var fillExtent = geometry.getExtent();
    fillInstruction.push([fillExtent[0], fillExtent[3]]);
  }
  this.instructions.push(fillInstruction);
};

/**
 * @param {ol.CanvasFillStrokeState} state State.
 */
replay__ol_render_canvas_Replay_.prototype.applyStroke = function (state) {
  this.instructions.push([canvas_instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth * this.pixelRatio, state.lineCap, state.lineJoin, state.miterLimit, this.applyPixelRatio(state.lineDash), state.lineDashOffset * this.pixelRatio]);
};

/**
 * @param {ol.CanvasFillStrokeState} state State.
 * @param {function(this:ol.render.canvas.Replay, ol.CanvasFillStrokeState, (ol.geom.Geometry|ol.render.Feature))} applyFill Apply fill.
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 */
replay__ol_render_canvas_Replay_.prototype.updateFillStyle = function (state, applyFill, geometry) {
  var fillStyle = state.fillStyle;
  if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
    applyFill.call(this, state, geometry);
    state.currentFillStyle = fillStyle;
  }
};

/**
 * @param {ol.CanvasFillStrokeState} state State.
 * @param {function(this:ol.render.canvas.Replay, ol.CanvasFillStrokeState)} applyStroke Apply stroke.
 */
replay__ol_render_canvas_Replay_.prototype.updateStrokeStyle = function (state, applyStroke) {
  var strokeStyle = state.strokeStyle;
  var lineCap = state.lineCap;
  var lineDash = state.lineDash;
  var lineDashOffset = state.lineDashOffset;
  var lineJoin = state.lineJoin;
  var lineWidth = state.lineWidth;
  var miterLimit = state.miterLimit;
  if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !array["a" /* default */].equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
    applyStroke.call(this, state);
    state.currentStrokeStyle = strokeStyle;
    state.currentLineCap = lineCap;
    state.currentLineDash = lineDash;
    state.currentLineDashOffset = lineDashOffset;
    state.currentLineJoin = lineJoin;
    state.currentLineWidth = lineWidth;
    state.currentMiterLimit = miterLimit;
  }
};

/**
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 */
replay__ol_render_canvas_Replay_.prototype.endGeometry = function (geometry, feature) {
  this.beginGeometryInstruction1_[2] = this.instructions.length;
  this.beginGeometryInstruction1_ = null;
  this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
  this.beginGeometryInstruction2_ = null;
  var endGeometryInstruction = [canvas_instruction.END_GEOMETRY, feature];
  this.instructions.push(endGeometryInstruction);
  this.hitDetectionInstructions.push(endGeometryInstruction);
};

/**
 * FIXME empty description for jsdoc
 */
replay__ol_render_canvas_Replay_.prototype.finish = ol["a" /* default */].nullFunction;

/**
 * Get the buffered rendering extent.  Rendering will be clipped to the extent
 * provided to the constructor.  To account for symbolizers that may intersect
 * this extent, we calculate a buffered extent (e.g. based on stroke width).
 * @return {ol.Extent} The buffered rendering extent.
 * @protected
 */
replay__ol_render_canvas_Replay_.prototype.getBufferedMaxExtent = function () {
  if (!this.bufferedMaxExtent_) {
    this.bufferedMaxExtent_ = ol_extent["a" /* default */].clone(this.maxExtent);
    if (this.maxLineWidth > 0) {
      var width = this.resolution * (this.maxLineWidth + 1) / 2;
      ol_extent["a" /* default */].buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
    }
  }
  return this.bufferedMaxExtent_;
};
/* harmony default export */ var canvas_replay = (replay__ol_render_canvas_Replay_);
// CONCATENATED MODULE: ./node_modules/ol/render/canvas/imagereplay.js




/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @param {?} declutterTree Declutter tree.
 * @struct
 */
var imagereplay__ol_render_canvas_ImageReplay_ = function _ol_render_canvas_ImageReplay_(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  canvas_replay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);

  /**
   * @private
   * @type {ol.DeclutterGroup}
   */
  this.declutterGroup_ = null;

  /**
   * @private
   * @type {HTMLCanvasElement|HTMLVideoElement|Image}
   */
  this.hitDetectionImage_ = null;

  /**
   * @private
   * @type {HTMLCanvasElement|HTMLVideoElement|Image}
   */
  this.image_ = null;

  /**
   * @private
   * @type {number|undefined}
   */
  this.anchorX_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.anchorY_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.height_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.opacity_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.originX_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.originY_ = undefined;

  /**
   * @private
   * @type {boolean|undefined}
   */
  this.rotateWithView_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.rotation_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.scale_ = undefined;

  /**
   * @private
   * @type {boolean|undefined}
   */
  this.snapToPixel_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.width_ = undefined;
};

ol["a" /* default */].inherits(imagereplay__ol_render_canvas_ImageReplay_, canvas_replay);

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 * @return {number} My end.
 */
imagereplay__ol_render_canvas_ImageReplay_.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {
  return this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
};

/**
 * @inheritDoc
 */
imagereplay__ol_render_canvas_ImageReplay_.prototype.drawPoint = function (pointGeometry, feature) {
  if (!this.image_) {
    return;
  }
  this.beginGeometry(pointGeometry, feature);
  var flatCoordinates = pointGeometry.getFlatCoordinates();
  var stride = pointGeometry.getStride();
  var myBegin = this.coordinates.length;
  var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  this.instructions.push([canvas_instruction.DRAW_IMAGE, myBegin, myEnd, this.image_,
  // Remaining arguments to DRAW_IMAGE are in alphabetical order
  this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_]);
  this.hitDetectionInstructions.push([canvas_instruction.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_,
  // Remaining arguments to DRAW_IMAGE are in alphabetical order
  this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.snapToPixel_, this.width_]);
  this.endGeometry(pointGeometry, feature);
};

/**
 * @inheritDoc
 */
imagereplay__ol_render_canvas_ImageReplay_.prototype.drawMultiPoint = function (multiPointGeometry, feature) {
  if (!this.image_) {
    return;
  }
  this.beginGeometry(multiPointGeometry, feature);
  var flatCoordinates = multiPointGeometry.getFlatCoordinates();
  var stride = multiPointGeometry.getStride();
  var myBegin = this.coordinates.length;
  var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  this.instructions.push([canvas_instruction.DRAW_IMAGE, myBegin, myEnd, this.image_,
  // Remaining arguments to DRAW_IMAGE are in alphabetical order
  this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_ * this.pixelRatio, this.snapToPixel_, this.width_]);
  this.hitDetectionInstructions.push([canvas_instruction.DRAW_IMAGE, myBegin, myEnd, this.hitDetectionImage_,
  // Remaining arguments to DRAW_IMAGE are in alphabetical order
  this.anchorX_, this.anchorY_, this.declutterGroup_, this.height_, this.opacity_, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.snapToPixel_, this.width_]);
  this.endGeometry(multiPointGeometry, feature);
};

/**
 * @inheritDoc
 */
imagereplay__ol_render_canvas_ImageReplay_.prototype.finish = function () {
  this.reverseHitDetectionInstructions();
  // FIXME this doesn't really protect us against further calls to draw*Geometry
  this.anchorX_ = undefined;
  this.anchorY_ = undefined;
  this.hitDetectionImage_ = null;
  this.image_ = null;
  this.height_ = undefined;
  this.scale_ = undefined;
  this.opacity_ = undefined;
  this.originX_ = undefined;
  this.originY_ = undefined;
  this.rotateWithView_ = undefined;
  this.rotation_ = undefined;
  this.snapToPixel_ = undefined;
  this.width_ = undefined;
};

/**
 * @inheritDoc
 */
imagereplay__ol_render_canvas_ImageReplay_.prototype.setImageStyle = function (imageStyle, declutterGroup) {
  var anchor = imageStyle.getAnchor();
  var size = imageStyle.getSize();
  var hitDetectionImage = imageStyle.getHitDetectionImage(1);
  var image = imageStyle.getImage(1);
  var origin = imageStyle.getOrigin();
  this.anchorX_ = anchor[0];
  this.anchorY_ = anchor[1];
  this.declutterGroup_ = /** @type {ol.DeclutterGroup} */declutterGroup;
  this.hitDetectionImage_ = hitDetectionImage;
  this.image_ = image;
  this.height_ = size[1];
  this.opacity_ = imageStyle.getOpacity();
  this.originX_ = origin[0];
  this.originY_ = origin[1];
  this.rotateWithView_ = imageStyle.getRotateWithView();
  this.rotation_ = imageStyle.getRotation();
  this.scale_ = imageStyle.getScale();
  this.snapToPixel_ = imageStyle.getSnapToPixel();
  this.width_ = size[0];
};
/* harmony default export */ var imagereplay = (imagereplay__ol_render_canvas_ImageReplay_);
// CONCATENATED MODULE: ./node_modules/ol/render/canvas/linestringreplay.js




/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @param {?} declutterTree Declutter tree.
 * @struct
 */
var linestringreplay__ol_render_canvas_LineStringReplay_ = function _ol_render_canvas_LineStringReplay_(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  canvas_replay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
};

ol["a" /* default */].inherits(linestringreplay__ol_render_canvas_LineStringReplay_, canvas_replay);

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @private
 * @return {number} end.
 */
linestringreplay__ol_render_canvas_LineStringReplay_.prototype.drawFlatCoordinates_ = function (flatCoordinates, offset, end, stride) {
  var myBegin = this.coordinates.length;
  var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
  var moveToLineToInstruction = [canvas_instruction.MOVE_TO_LINE_TO, myBegin, myEnd];
  this.instructions.push(moveToLineToInstruction);
  this.hitDetectionInstructions.push(moveToLineToInstruction);
  return end;
};

/**
 * @inheritDoc
 */
linestringreplay__ol_render_canvas_LineStringReplay_.prototype.drawLineString = function (lineStringGeometry, feature) {
  var state = this.state;
  var strokeStyle = state.strokeStyle;
  var lineWidth = state.lineWidth;
  if (strokeStyle === undefined || lineWidth === undefined) {
    return;
  }
  this.updateStrokeStyle(state, this.applyStroke);
  this.beginGeometry(lineStringGeometry, feature);
  this.hitDetectionInstructions.push([canvas_instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], [canvas_instruction.BEGIN_PATH]);
  var flatCoordinates = lineStringGeometry.getFlatCoordinates();
  var stride = lineStringGeometry.getStride();
  this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  this.hitDetectionInstructions.push([canvas_instruction.STROKE]);
  this.endGeometry(lineStringGeometry, feature);
};

/**
 * @inheritDoc
 */
linestringreplay__ol_render_canvas_LineStringReplay_.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {
  var state = this.state;
  var strokeStyle = state.strokeStyle;
  var lineWidth = state.lineWidth;
  if (strokeStyle === undefined || lineWidth === undefined) {
    return;
  }
  this.updateStrokeStyle(state, this.applyStroke);
  this.beginGeometry(multiLineStringGeometry, feature);
  this.hitDetectionInstructions.push([canvas_instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset], [canvas_instruction.BEGIN_PATH]);
  var ends = multiLineStringGeometry.getEnds();
  var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
  var stride = multiLineStringGeometry.getStride();
  var offset = 0;
  var i, ii;
  for (i = 0, ii = ends.length; i < ii; ++i) {
    offset = this.drawFlatCoordinates_(flatCoordinates, offset, ends[i], stride);
  }
  this.hitDetectionInstructions.push([canvas_instruction.STROKE]);
  this.endGeometry(multiLineStringGeometry, feature);
};

/**
 * @inheritDoc
 */
linestringreplay__ol_render_canvas_LineStringReplay_.prototype.finish = function () {
  var state = this.state;
  if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
    this.instructions.push([canvas_instruction.STROKE]);
  }
  this.reverseHitDetectionInstructions();
  this.state = null;
};

/**
 * @inheritDoc.
 */
linestringreplay__ol_render_canvas_LineStringReplay_.prototype.applyStroke = function (state) {
  if (state.lastStroke != undefined && state.lastStroke != this.coordinates.length) {
    this.instructions.push([canvas_instruction.STROKE]);
    state.lastStroke = this.coordinates.length;
  }
  state.lastStroke = 0;
  canvas_replay.prototype.applyStroke.call(this, state);
  this.instructions.push([canvas_instruction.BEGIN_PATH]);
};
/* harmony default export */ var linestringreplay = (linestringreplay__ol_render_canvas_LineStringReplay_);
// EXTERNAL MODULE: ./node_modules/ol/color.js
var color = __webpack_require__(27);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/simplify.js
var simplify = __webpack_require__(41);

// CONCATENATED MODULE: ./node_modules/ol/render/canvas/polygonreplay.js







/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @param {?} declutterTree Declutter tree.
 * @struct
 */
var polygonreplay__ol_render_canvas_PolygonReplay_ = function _ol_render_canvas_PolygonReplay_(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  canvas_replay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);
};

ol["a" /* default */].inherits(polygonreplay__ol_render_canvas_PolygonReplay_, canvas_replay);

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {Array.<number>} ends Ends.
 * @param {number} stride Stride.
 * @private
 * @return {number} End.
 */
polygonreplay__ol_render_canvas_PolygonReplay_.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {
  var state = this.state;
  var fill = state.fillStyle !== undefined;
  var stroke = state.strokeStyle != undefined;
  var numEnds = ends.length;
  var beginPathInstruction = [canvas_instruction.BEGIN_PATH];
  this.instructions.push(beginPathInstruction);
  this.hitDetectionInstructions.push(beginPathInstruction);
  for (var i = 0; i < numEnds; ++i) {
    var end = ends[i];
    var myBegin = this.coordinates.length;
    var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
    var moveToLineToInstruction = [canvas_instruction.MOVE_TO_LINE_TO, myBegin, myEnd];
    this.instructions.push(moveToLineToInstruction);
    this.hitDetectionInstructions.push(moveToLineToInstruction);
    if (stroke) {
      // Performance optimization: only call closePath() when we have a stroke.
      // Otherwise the ring is closed already (see appendFlatCoordinates above).
      var closePathInstruction = [canvas_instruction.CLOSE_PATH];
      this.instructions.push(closePathInstruction);
      this.hitDetectionInstructions.push(closePathInstruction);
    }
    offset = end;
  }
  var fillInstruction = [canvas_instruction.FILL];
  this.hitDetectionInstructions.push(fillInstruction);
  if (fill) {
    this.instructions.push(fillInstruction);
  }
  if (stroke) {
    var strokeInstruction = [canvas_instruction.STROKE];
    this.instructions.push(strokeInstruction);
    this.hitDetectionInstructions.push(strokeInstruction);
  }
  return offset;
};

/**
 * @inheritDoc
 */
polygonreplay__ol_render_canvas_PolygonReplay_.prototype.drawCircle = function (circleGeometry, feature) {
  var state = this.state;
  var fillStyle = state.fillStyle;
  var strokeStyle = state.strokeStyle;
  if (fillStyle === undefined && strokeStyle === undefined) {
    return;
  }
  this.setFillStrokeStyles_(circleGeometry);
  this.beginGeometry(circleGeometry, feature);
  // always fill the circle for hit detection
  this.hitDetectionInstructions.push([canvas_instruction.SET_FILL_STYLE, color["a" /* default */].asString(render_canvas["a" /* default */].defaultFillStyle)]);
  if (state.strokeStyle !== undefined) {
    this.hitDetectionInstructions.push([canvas_instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
  }
  var flatCoordinates = circleGeometry.getFlatCoordinates();
  var stride = circleGeometry.getStride();
  var myBegin = this.coordinates.length;
  this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
  var beginPathInstruction = [canvas_instruction.BEGIN_PATH];
  var circleInstruction = [canvas_instruction.CIRCLE, myBegin];
  this.instructions.push(beginPathInstruction, circleInstruction);
  this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
  var fillInstruction = [canvas_instruction.FILL];
  this.hitDetectionInstructions.push(fillInstruction);
  if (state.fillStyle !== undefined) {
    this.instructions.push(fillInstruction);
  }
  if (state.strokeStyle !== undefined) {
    var strokeInstruction = [canvas_instruction.STROKE];
    this.instructions.push(strokeInstruction);
    this.hitDetectionInstructions.push(strokeInstruction);
  }
  this.endGeometry(circleGeometry, feature);
};

/**
 * @inheritDoc
 */
polygonreplay__ol_render_canvas_PolygonReplay_.prototype.drawPolygon = function (polygonGeometry, feature) {
  var state = this.state;
  this.setFillStrokeStyles_(polygonGeometry);
  this.beginGeometry(polygonGeometry, feature);
  // always fill the polygon for hit detection
  this.hitDetectionInstructions.push([canvas_instruction.SET_FILL_STYLE, color["a" /* default */].asString(render_canvas["a" /* default */].defaultFillStyle)]);
  if (state.strokeStyle !== undefined) {
    this.hitDetectionInstructions.push([canvas_instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
  }
  var ends = polygonGeometry.getEnds();
  var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
  var stride = polygonGeometry.getStride();
  this.drawFlatCoordinatess_(flatCoordinates, 0, ends, stride);
  this.endGeometry(polygonGeometry, feature);
};

/**
 * @inheritDoc
 */
polygonreplay__ol_render_canvas_PolygonReplay_.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {
  var state = this.state;
  var fillStyle = state.fillStyle;
  var strokeStyle = state.strokeStyle;
  if (fillStyle === undefined && strokeStyle === undefined) {
    return;
  }
  this.setFillStrokeStyles_(multiPolygonGeometry);
  this.beginGeometry(multiPolygonGeometry, feature);
  // always fill the multi-polygon for hit detection
  this.hitDetectionInstructions.push([canvas_instruction.SET_FILL_STYLE, color["a" /* default */].asString(render_canvas["a" /* default */].defaultFillStyle)]);
  if (state.strokeStyle !== undefined) {
    this.hitDetectionInstructions.push([canvas_instruction.SET_STROKE_STYLE, state.strokeStyle, state.lineWidth, state.lineCap, state.lineJoin, state.miterLimit, state.lineDash, state.lineDashOffset]);
  }
  var endss = multiPolygonGeometry.getEndss();
  var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
  var stride = multiPolygonGeometry.getStride();
  var offset = 0;
  var i, ii;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
  }
  this.endGeometry(multiPolygonGeometry, feature);
};

/**
 * @inheritDoc
 */
polygonreplay__ol_render_canvas_PolygonReplay_.prototype.finish = function () {
  this.reverseHitDetectionInstructions();
  this.state = null;
  // We want to preserve topology when drawing polygons.  Polygons are
  // simplified using quantization and point elimination. However, we might
  // have received a mix of quantized and non-quantized geometries, so ensure
  // that all are quantized by quantizing all coordinates in the batch.
  var tolerance = this.tolerance;
  if (tolerance !== 0) {
    var coordinates = this.coordinates;
    var i, ii;
    for (i = 0, ii = coordinates.length; i < ii; ++i) {
      coordinates[i] = simplify["a" /* default */].snap(coordinates[i], tolerance);
    }
  }
};

/**
 * @private
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 */
polygonreplay__ol_render_canvas_PolygonReplay_.prototype.setFillStrokeStyles_ = function (geometry) {
  var state = this.state;
  var fillStyle = state.fillStyle;
  if (fillStyle !== undefined) {
    this.updateFillStyle(state, this.applyFill, geometry);
  }
  if (state.strokeStyle !== undefined) {
    this.updateStrokeStyle(state, this.applyStroke);
  }
};
/* harmony default export */ var polygonreplay = (polygonreplay__ol_render_canvas_PolygonReplay_);
// CONCATENATED MODULE: ./node_modules/ol/geom/flat/straightchunk.js
var _ol_geom_flat_straightchunk_ = {};

/**
 * @param {number} maxAngle Maximum acceptable angle delta between segments.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {Array.<number>} Start and end of the first suitable chunk of the
 * given `flatCoordinates`.
 */
_ol_geom_flat_straightchunk_.lineString = function (maxAngle, flatCoordinates, offset, end, stride) {
  var chunkStart = offset;
  var chunkEnd = offset;
  var chunkM = 0;
  var m = 0;
  var start = offset;
  var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i = offset; i < end; i += stride) {
    var x2 = flatCoordinates[i];
    var y2 = flatCoordinates[i + 1];
    if (x1 !== undefined) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== undefined) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }
          m = 0;
          start = i - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x2;
    y1 = y2;
  }
  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
};
/* harmony default export */ var straightchunk = (_ol_geom_flat_straightchunk_);
// CONCATENATED MODULE: ./node_modules/ol/style/textplacement.js
/**
 * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that
 * `'line'` requires the underlying geometry to be a {@link ol.geom.LineString},
 * {@link ol.geom.Polygon}, {@link ol.geom.MultiLineString} or
 * {@link ol.geom.MultiPolygon}.
 * @enum {string}
 */
var _ol_style_TextPlacement_ = {
  POINT: 'point',
  LINE: 'line'
};

/* harmony default export */ var textplacement = (_ol_style_TextPlacement_);
// CONCATENATED MODULE: ./node_modules/ol/render/canvas/textreplay.js













/**
 * @constructor
 * @extends {ol.render.canvas.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Maximum extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay can have overlapping geometries.
 * @param {?} declutterTree Declutter tree.
 * @struct
 */
var textreplay__ol_render_canvas_TextReplay_ = function _ol_render_canvas_TextReplay_(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree) {
  canvas_replay.call(this, tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree);

  /**
   * @private
   * @type {ol.DeclutterGroup}
   */
  this.declutterGroup_;

  /**
   * @private
   * @type {Array.<HTMLCanvasElement>}
   */
  this.labels_ = null;

  /**
   * @private
   * @type {string}
   */
  this.text_ = '';

  /**
   * @private
   * @type {number}
   */
  this.textOffsetX_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.textOffsetY_ = 0;

  /**
   * @private
   * @type {boolean|undefined}
   */
  this.textRotateWithView_ = undefined;

  /**
   * @private
   * @type {number}
   */
  this.textRotation_ = 0;

  /**
   * @private
   * @type {?ol.CanvasFillState}
   */
  this.textFillState_ = null;

  /**
   * @type {Object.<string, ol.CanvasFillState>}
   */
  this.fillStates = {};

  /**
   * @private
   * @type {?ol.CanvasStrokeState}
   */
  this.textStrokeState_ = null;

  /**
   * @type {Object.<string, ol.CanvasStrokeState>}
   */
  this.strokeStates = {};

  /**
   * @private
   * @type {ol.CanvasTextState}
   */
  this.textState_ = /** @type {ol.CanvasTextState} */{};

  /**
   * @type {Object.<string, ol.CanvasTextState>}
   */
  this.textStates = {};

  /**
   * @private
   * @type {string}
   */
  this.textKey_ = '';

  /**
   * @private
   * @type {string}
   */
  this.fillKey_ = '';

  /**
   * @private
   * @type {string}
   */
  this.strokeKey_ = '';

  /**
   * @private
   * @type {Object.<string, Object.<string, number>>}
   */
  this.widths_ = {};

  var labelCache = render_canvas["a" /* default */].labelCache;
  labelCache.prune();
};

ol["a" /* default */].inherits(textreplay__ol_render_canvas_TextReplay_, canvas_replay);

/**
 * @param {string} font Font to use for measuring.
 * @param {Array.<string>} lines Lines to measure.
 * @param {Array.<number>} widths Array will be populated with the widths of
 * each line.
 * @return {number} Width of the whole text.
 */
textreplay__ol_render_canvas_TextReplay_.measureTextWidths = function (font, lines, widths) {
  var numLines = lines.length;
  var width = 0;
  var currentWidth, i;
  for (i = 0; i < numLines; ++i) {
    currentWidth = render_canvas["a" /* default */].measureTextWidth(font, lines[i]);
    width = Math.max(width, currentWidth);
    widths.push(currentWidth);
  }
  return width;
};

/**
 * @inheritDoc
 */
textreplay__ol_render_canvas_TextReplay_.prototype.drawText = function (geometry, feature) {
  var fillState = this.textFillState_;
  var strokeState = this.textStrokeState_;
  var textState = this.textState_;
  if (this.text_ === '' || !textState || !fillState && !strokeState) {
    return;
  }

  var begin = this.coordinates.length;

  var geometryType = geometry.getType();
  var flatCoordinates = null;
  var end = 2;
  var stride = 2;
  var i, ii;

  if (textState.placement === textplacement.LINE) {
    if (!ol_extent["a" /* default */].intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
      return;
    }
    var ends;
    flatCoordinates = geometry.getFlatCoordinates();
    stride = geometry.getStride();
    if (geometryType == geometrytype["a" /* default */].LINE_STRING) {
      ends = [flatCoordinates.length];
    } else if (geometryType == geometrytype["a" /* default */].MULTI_LINE_STRING) {
      ends = geometry.getEnds();
    } else if (geometryType == geometrytype["a" /* default */].POLYGON) {
      ends = geometry.getEnds().slice(0, 1);
    } else if (geometryType == geometrytype["a" /* default */].MULTI_POLYGON) {
      var endss = geometry.getEndss();
      ends = [];
      for (i = 0, ii = endss.length; i < ii; ++i) {
        ends.push(endss[i][0]);
      }
    }
    this.beginGeometry(geometry, feature);
    var textAlign = textState.textAlign;
    var flatOffset = 0;
    var flatEnd;
    for (var o = 0, oo = ends.length; o < oo; ++o) {
      if (textAlign == undefined) {
        var range = straightchunk.lineString(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
        flatOffset = range[0];
        flatEnd = range[1];
      } else {
        flatEnd = ends[o];
      }
      for (i = flatOffset; i < flatEnd; i += stride) {
        this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
      }
      end = this.coordinates.length;
      flatOffset = ends[o];
      this.drawChars_(begin, end, this.declutterGroup_);
      begin = end;
    }
    this.endGeometry(geometry, feature);
  } else {
    var label = this.getImage(this.text_, this.textKey_, this.fillKey_, this.strokeKey_);
    var width = label.width / this.pixelRatio;
    switch (geometryType) {
      case geometrytype["a" /* default */].POINT:
      case geometrytype["a" /* default */].MULTI_POINT:
        flatCoordinates = geometry.getFlatCoordinates();
        end = flatCoordinates.length;
        break;
      case geometrytype["a" /* default */].LINE_STRING:
        flatCoordinates = /** @type {ol.geom.LineString} */geometry.getFlatMidpoint();
        break;
      case geometrytype["a" /* default */].CIRCLE:
        flatCoordinates = /** @type {ol.geom.Circle} */geometry.getCenter();
        break;
      case geometrytype["a" /* default */].MULTI_LINE_STRING:
        flatCoordinates = /** @type {ol.geom.MultiLineString} */geometry.getFlatMidpoints();
        end = flatCoordinates.length;
        break;
      case geometrytype["a" /* default */].POLYGON:
        flatCoordinates = /** @type {ol.geom.Polygon} */geometry.getFlatInteriorPoint();
        if (!textState.overflow && flatCoordinates[2] / this.resolution < width) {
          return;
        }
        stride = 3;
        break;
      case geometrytype["a" /* default */].MULTI_POLYGON:
        var interiorPoints = /** @type {ol.geom.MultiPolygon} */geometry.getFlatInteriorPoints();
        flatCoordinates = [];
        for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {
          if (textState.overflow || interiorPoints[i + 2] / this.resolution >= width) {
            flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
          }
        }
        end = flatCoordinates.length;
        if (end == 0) {
          return;
        }
        break;
      default:
    }
    end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);
    this.beginGeometry(geometry, feature);
    if (textState.backgroundFill || textState.backgroundStroke) {
      this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
      this.updateFillStyle(this.state, this.applyFill, geometry);
      this.updateStrokeStyle(this.state, this.applyStroke);
    }
    this.drawTextImage_(label, begin, end);
    this.endGeometry(geometry, feature);
  }
};

/**
 * @param {string} text Text.
 * @param {string} textKey Text style key.
 * @param {string} fillKey Fill style key.
 * @param {string} strokeKey Stroke style key.
 * @return {HTMLCanvasElement} Image.
 */
textreplay__ol_render_canvas_TextReplay_.prototype.getImage = function (text, textKey, fillKey, strokeKey) {
  var label;
  var key = strokeKey + textKey + text + fillKey + this.pixelRatio;

  var labelCache = render_canvas["a" /* default */].labelCache;
  if (!labelCache.containsKey(key)) {
    var strokeState = strokeKey ? this.strokeStates[strokeKey] || this.textStrokeState_ : null;
    var fillState = fillKey ? this.fillStates[fillKey] || this.textFillState_ : null;
    var textState = this.textStates[textKey] || this.textState_;
    var pixelRatio = this.pixelRatio;
    var scale = textState.scale * pixelRatio;
    var align = render_replay.TEXT_ALIGN[textState.textAlign || render_canvas["a" /* default */].defaultTextAlign];
    var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;

    var lines = text.split('\n');
    var numLines = lines.length;
    var widths = [];
    var width = textreplay__ol_render_canvas_TextReplay_.measureTextWidths(textState.font, lines, widths);
    var lineHeight = render_canvas["a" /* default */].measureTextHeight(textState.font);
    var height = lineHeight * numLines;
    var renderWidth = width + strokeWidth;
    var context = dom["a" /* default */].createCanvasContext2D(Math.ceil(renderWidth * scale), Math.ceil((height + strokeWidth) * scale));
    label = context.canvas;
    labelCache.set(key, label);
    if (scale != 1) {
      context.scale(scale, scale);
    }
    context.font = textState.font;
    if (strokeKey) {
      context.strokeStyle = strokeState.strokeStyle;
      context.lineWidth = strokeWidth * (has["a" /* default */].SAFARI ? scale : 1);
      context.lineCap = strokeState.lineCap;
      context.lineJoin = strokeState.lineJoin;
      context.miterLimit = strokeState.miterLimit;
      if (has["a" /* default */].CANVAS_LINE_DASH && strokeState.lineDash.length) {
        context.setLineDash(strokeState.lineDash);
        context.lineDashOffset = strokeState.lineDashOffset;
      }
    }
    if (fillKey) {
      context.fillStyle = fillState.fillStyle;
    }
    context.textBaseline = 'middle';
    context.textAlign = 'center';
    var leftRight = 0.5 - align;
    var x = align * label.width / scale + leftRight * strokeWidth;
    var i;
    if (strokeKey) {
      for (i = 0; i < numLines; ++i) {
        context.strokeText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);
      }
    }
    if (fillKey) {
      for (i = 0; i < numLines; ++i) {
        context.fillText(lines[i], x + leftRight * widths[i], 0.5 * (strokeWidth + lineHeight) + i * lineHeight);
      }
    }
  }
  return labelCache.get(key);
};

/**
 * @private
 * @param {HTMLCanvasElement} label Label.
 * @param {number} begin Begin.
 * @param {number} end End.
 */
textreplay__ol_render_canvas_TextReplay_.prototype.drawTextImage_ = function (label, begin, end) {
  var textState = this.textState_;
  var strokeState = this.textStrokeState_;
  var pixelRatio = this.pixelRatio;
  var align = render_replay.TEXT_ALIGN[textState.textAlign || render_canvas["a" /* default */].defaultTextAlign];
  var baseline = render_replay.TEXT_ALIGN[textState.textBaseline];
  var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;

  var anchorX = align * label.width / pixelRatio + 2 * (0.5 - align) * strokeWidth;
  var anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
  this.instructions.push([canvas_instruction.DRAW_IMAGE, begin, end, label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio, this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1, true, label.width, textState.padding == render_canvas["a" /* default */].defaultPadding ? render_canvas["a" /* default */].defaultPadding : textState.padding.map(function (p) {
    return p * pixelRatio;
  }), !!textState.backgroundFill, !!textState.backgroundStroke]);
  this.hitDetectionInstructions.push([canvas_instruction.DRAW_IMAGE, begin, end, label, (anchorX - this.textOffsetX_) * pixelRatio, (anchorY - this.textOffsetY_) * pixelRatio, this.declutterGroup_, label.height, 1, 0, 0, this.textRotateWithView_, this.textRotation_, 1 / pixelRatio, true, label.width, textState.padding, !!textState.backgroundFill, !!textState.backgroundStroke]);
};

/**
 * @private
 * @param {number} begin Begin.
 * @param {number} end End.
 * @param {ol.DeclutterGroup} declutterGroup Declutter group.
 */
textreplay__ol_render_canvas_TextReplay_.prototype.drawChars_ = function (begin, end, declutterGroup) {
  var strokeState = this.textStrokeState_;
  var textState = this.textState_;
  var fillState = this.textFillState_;

  var strokeKey = this.strokeKey_;
  if (strokeState) {
    if (!(strokeKey in this.strokeStates)) {
      this.strokeStates[strokeKey] = /** @type {ol.CanvasStrokeState} */{
        strokeStyle: strokeState.strokeStyle,
        lineCap: strokeState.lineCap,
        lineDashOffset: strokeState.lineDashOffset,
        lineWidth: strokeState.lineWidth,
        lineJoin: strokeState.lineJoin,
        miterLimit: strokeState.miterLimit,
        lineDash: strokeState.lineDash
      };
    }
  }
  var textKey = this.textKey_;
  if (!(this.textKey_ in this.textStates)) {
    this.textStates[this.textKey_] = /** @type {ol.CanvasTextState} */{
      font: textState.font,
      textAlign: textState.textAlign || render_canvas["a" /* default */].defaultTextAlign,
      scale: textState.scale
    };
  }
  var fillKey = this.fillKey_;
  if (fillState) {
    if (!(fillKey in this.fillStates)) {
      this.fillStates[fillKey] = /** @type {ol.CanvasFillState} */{
        fillStyle: fillState.fillStyle
      };
    }
  }

  var pixelRatio = this.pixelRatio;
  var baseline = render_replay.TEXT_ALIGN[textState.textBaseline];

  var offsetY = this.textOffsetY_ * pixelRatio;
  var text = this.text_;
  var font = textState.font;
  var textScale = textState.scale;
  var strokeWidth = strokeState ? strokeState.lineWidth * textScale / 2 : 0;
  var widths = this.widths_[font];
  if (!widths) {
    this.widths_[font] = widths = {};
  }
  this.instructions.push([canvas_instruction.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, function (text) {
    var width = widths[text];
    if (!width) {
      width = widths[text] = render_canvas["a" /* default */].measureTextWidth(font, text);
    }
    return width * textScale * pixelRatio;
  }, offsetY, strokeKey, strokeWidth * pixelRatio, text, textKey, 1]);
  this.hitDetectionInstructions.push([canvas_instruction.DRAW_CHARS, begin, end, baseline, declutterGroup, textState.overflow, fillKey, textState.maxAngle, function (text) {
    var width = widths[text];
    if (!width) {
      width = widths[text] = render_canvas["a" /* default */].measureTextWidth(font, text);
    }
    return width * textScale;
  }, offsetY, strokeKey, strokeWidth, text, textKey, 1 / pixelRatio]);
};

/**
 * @inheritDoc
 */
textreplay__ol_render_canvas_TextReplay_.prototype.setTextStyle = function (textStyle, declutterGroup) {
  var textState, fillState, strokeState;
  if (!textStyle) {
    this.text_ = '';
  } else {
    this.declutterGroup_ = /** @type {ol.DeclutterGroup} */declutterGroup;

    var textFillStyle = textStyle.getFill();
    if (!textFillStyle) {
      fillState = this.textFillState_ = null;
    } else {
      fillState = this.textFillState_;
      if (!fillState) {
        fillState = this.textFillState_ = /** @type {ol.CanvasFillState} */{};
      }
      fillState.fillStyle = colorlike["a" /* default */].asColorLike(textFillStyle.getColor() || render_canvas["a" /* default */].defaultFillStyle);
    }

    var textStrokeStyle = textStyle.getStroke();
    if (!textStrokeStyle) {
      strokeState = this.textStrokeState_ = null;
    } else {
      strokeState = this.textStrokeState_;
      if (!strokeState) {
        strokeState = this.textStrokeState_ = /** @type {ol.CanvasStrokeState} */{};
      }
      var lineDash = textStrokeStyle.getLineDash();
      var lineDashOffset = textStrokeStyle.getLineDashOffset();
      var lineWidth = textStrokeStyle.getWidth();
      var miterLimit = textStrokeStyle.getMiterLimit();
      strokeState.lineCap = textStrokeStyle.getLineCap() || render_canvas["a" /* default */].defaultLineCap;
      strokeState.lineDash = lineDash ? lineDash.slice() : render_canvas["a" /* default */].defaultLineDash;
      strokeState.lineDashOffset = lineDashOffset === undefined ? render_canvas["a" /* default */].defaultLineDashOffset : lineDashOffset;
      strokeState.lineJoin = textStrokeStyle.getLineJoin() || render_canvas["a" /* default */].defaultLineJoin;
      strokeState.lineWidth = lineWidth === undefined ? render_canvas["a" /* default */].defaultLineWidth : lineWidth;
      strokeState.miterLimit = miterLimit === undefined ? render_canvas["a" /* default */].defaultMiterLimit : miterLimit;
      strokeState.strokeStyle = colorlike["a" /* default */].asColorLike(textStrokeStyle.getColor() || render_canvas["a" /* default */].defaultStrokeStyle);
    }

    textState = this.textState_;
    var font = textStyle.getFont() || render_canvas["a" /* default */].defaultFont;
    render_canvas["a" /* default */].checkFont(font);
    var textScale = textStyle.getScale();
    textState.overflow = textStyle.getOverflow();
    textState.font = font;
    textState.maxAngle = textStyle.getMaxAngle();
    textState.placement = textStyle.getPlacement();
    textState.textAlign = textStyle.getTextAlign();
    textState.textBaseline = textStyle.getTextBaseline() || render_canvas["a" /* default */].defaultTextBaseline;
    textState.backgroundFill = textStyle.getBackgroundFill();
    textState.backgroundStroke = textStyle.getBackgroundStroke();
    textState.padding = textStyle.getPadding() || render_canvas["a" /* default */].defaultPadding;
    textState.scale = textScale === undefined ? 1 : textScale;

    var textOffsetX = textStyle.getOffsetX();
    var textOffsetY = textStyle.getOffsetY();
    var textRotateWithView = textStyle.getRotateWithView();
    var textRotation = textStyle.getRotation();
    this.text_ = textStyle.getText() || '';
    this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
    this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
    this.textRotateWithView_ = textRotateWithView === undefined ? false : textRotateWithView;
    this.textRotation_ = textRotation === undefined ? 0 : textRotation;

    this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == 'string' ? strokeState.strokeStyle : ol["a" /* default */].getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + '|' + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + '[' + strokeState.lineDash.join() + ']' : '';
    this.textKey_ = textState.font + textState.scale + (textState.textAlign || '?');
    this.fillKey_ = fillState ? typeof fillState.fillStyle == 'string' ? fillState.fillStyle : '|' + ol["a" /* default */].getUid(fillState.fillStyle) : '';
  }
};
/* harmony default export */ var textreplay = (textreplay__ol_render_canvas_TextReplay_);
// CONCATENATED MODULE: ./node_modules/ol/render/canvas/replaygroup.js
















/**
 * @constructor
 * @extends {ol.render.ReplayGroup}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {boolean} overlaps The replay group can have overlapping geometries.
 * @param {?} declutterTree Declutter tree
 * for declutter processing in postrender.
 * @param {number=} opt_renderBuffer Optional rendering buffer.
 * @struct
 */
var replaygroup__ol_render_canvas_ReplayGroup_ = function _ol_render_canvas_ReplayGroup_(tolerance, maxExtent, resolution, pixelRatio, overlaps, declutterTree, opt_renderBuffer) {
  replaygroup.call(this);

  /**
   * Declutter tree.
   * @private
   */
  this.declutterTree_ = declutterTree;

  /**
   * @type {ol.DeclutterGroup}
   * @private
   */
  this.declutterGroup_ = null;

  /**
   * @private
   * @type {number}
   */
  this.tolerance_ = tolerance;

  /**
   * @private
   * @type {ol.Extent}
   */
  this.maxExtent_ = maxExtent;

  /**
   * @private
   * @type {boolean}
   */
  this.overlaps_ = overlaps;

  /**
   * @private
   * @type {number}
   */
  this.pixelRatio_ = pixelRatio;

  /**
   * @private
   * @type {number}
   */
  this.resolution_ = resolution;

  /**
   * @private
   * @type {number|undefined}
   */
  this.renderBuffer_ = opt_renderBuffer;

  /**
   * @private
   * @type {!Object.<string,
   *        Object.<ol.render.ReplayType, ol.render.canvas.Replay>>}
   */
  this.replaysByZIndex_ = {};

  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */
  this.hitDetectionContext_ = dom["a" /* default */].createCanvasContext2D(1, 1);

  /**
   * @private
   * @type {ol.Transform}
   */
  this.hitDetectionTransform_ = ol_transform["a" /* default */].create();
};

ol["a" /* default */].inherits(replaygroup__ol_render_canvas_ReplayGroup_, replaygroup);

/**
 * This cache is used for storing calculated pixel circles for increasing performance.
 * It is a static property to allow each Replaygroup to access it.
 * @type {Object.<number, Array.<Array.<(boolean|undefined)>>>}
 * @private
 */
replaygroup__ol_render_canvas_ReplayGroup_.circleArrayCache_ = {
  0: [[true]]
};

/**
 * This method fills a row in the array from the given coordinate to the
 * middle with `true`.
 * @param {Array.<Array.<(boolean|undefined)>>} array The array that will be altered.
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @private
 */
replaygroup__ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_ = function (array, x, y) {
  var i;
  var radius = Math.floor(array.length / 2);
  if (x >= radius) {
    for (i = radius; i < x; i++) {
      array[i][y] = true;
    }
  } else if (x < radius) {
    for (i = x + 1; i < radius; i++) {
      array[i][y] = true;
    }
  }
};

/**
 * This methods creates a circle inside a fitting array. Points inside the
 * circle are marked by true, points on the outside are undefined.
 * It uses the midpoint circle algorithm.
 * A cache is used to increase performance.
 * @param {number} radius Radius.
 * @returns {Array.<Array.<(boolean|undefined)>>} An array with marked circle points.
 * @private
 */
replaygroup__ol_render_canvas_ReplayGroup_.getCircleArray_ = function (radius) {
  if (replaygroup__ol_render_canvas_ReplayGroup_.circleArrayCache_[radius] !== undefined) {
    return replaygroup__ol_render_canvas_ReplayGroup_.circleArrayCache_[radius];
  }

  var arraySize = radius * 2 + 1;
  var arr = new Array(arraySize);
  for (var i = 0; i < arraySize; i++) {
    arr[i] = new Array(arraySize);
  }

  var x = radius;
  var y = 0;
  var error = 0;

  while (x >= y) {
    replaygroup__ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius + x, radius + y);
    replaygroup__ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius + y, radius + x);
    replaygroup__ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius - y, radius + x);
    replaygroup__ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius - x, radius + y);
    replaygroup__ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius - x, radius - y);
    replaygroup__ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius - y, radius - x);
    replaygroup__ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius + y, radius - x);
    replaygroup__ol_render_canvas_ReplayGroup_.fillCircleArrayRowToMiddle_(arr, radius + x, radius - y);

    y++;
    error += 1 + 2 * y;
    if (2 * (error - x) + 1 > 0) {
      x -= 1;
      error += 1 - 2 * x;
    }
  }

  replaygroup__ol_render_canvas_ReplayGroup_.circleArrayCache_[radius] = arr;
  return arr;
};

/**
 * @param {!Object.<string, Array.<*>>} declutterReplays Declutter replays.
 * @param {CanvasRenderingContext2D} context Context.
 * @param {number} rotation Rotation.
 */
replaygroup__ol_render_canvas_ReplayGroup_.replayDeclutter = function (declutterReplays, context, rotation) {
  var zs = Object.keys(declutterReplays).map(Number).sort(array["a" /* default */].numberSafeCompareFunction);
  var skippedFeatureUids = {};
  for (var z = 0, zz = zs.length; z < zz; ++z) {
    var replayData = declutterReplays[zs[z].toString()];
    for (var i = 0, ii = replayData.length; i < ii;) {
      var replay = replayData[i++];
      var transform = replayData[i++];
      replay.replay(context, transform, rotation, skippedFeatureUids);
    }
  }
};

/**
 * @param {boolean} group Group with previous replay.
 * @return {ol.DeclutterGroup} Declutter instruction group.
 */
replaygroup__ol_render_canvas_ReplayGroup_.prototype.addDeclutter = function (group) {
  var declutter = null;
  if (this.declutterTree_) {
    if (group) {
      declutter = this.declutterGroup_;
      /** @type {number} */declutter[4]++;
    } else {
      declutter = this.declutterGroup_ = ol_extent["a" /* default */].createEmpty();
      declutter.push(1);
    }
  }
  return declutter;
};

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 */
replaygroup__ol_render_canvas_ReplayGroup_.prototype.clip = function (context, transform) {
  var flatClipCoords = this.getClipCoords(transform);
  context.beginPath();
  context.moveTo(flatClipCoords[0], flatClipCoords[1]);
  context.lineTo(flatClipCoords[2], flatClipCoords[3]);
  context.lineTo(flatClipCoords[4], flatClipCoords[5]);
  context.lineTo(flatClipCoords[6], flatClipCoords[7]);
  context.clip();
};

/**
 * @param {Array.<ol.render.ReplayType>} replays Replays.
 * @return {boolean} Has replays of the provided types.
 */
replaygroup__ol_render_canvas_ReplayGroup_.prototype.hasReplays = function (replays) {
  for (var zIndex in this.replaysByZIndex_) {
    var candidates = this.replaysByZIndex_[zIndex];
    for (var i = 0, ii = replays.length; i < ii; ++i) {
      if (replays[i] in candidates) {
        return true;
      }
    }
  }
  return false;
};

/**
 * FIXME empty description for jsdoc
 */
replaygroup__ol_render_canvas_ReplayGroup_.prototype.finish = function () {
  var zKey;
  for (zKey in this.replaysByZIndex_) {
    var replays = this.replaysByZIndex_[zKey];
    var replayKey;
    for (replayKey in replays) {
      replays[replayKey].finish();
    }
  }
};

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T} callback Feature
 *     callback.
 * @param {Object.<string, ol.DeclutterGroup>} declutterReplays Declutter
 *     replays.
 * @return {T|undefined} Callback result.
 * @template T
 */
replaygroup__ol_render_canvas_ReplayGroup_.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, skippedFeaturesHash, callback, declutterReplays) {

  hitTolerance = Math.round(hitTolerance);
  var contextSize = hitTolerance * 2 + 1;
  var transform = ol_transform["a" /* default */].compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
  var context = this.hitDetectionContext_;

  if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
    context.canvas.width = contextSize;
    context.canvas.height = contextSize;
  } else {
    context.clearRect(0, 0, contextSize, contextSize);
  }

  /**
   * @type {ol.Extent}
   */
  var hitExtent;
  if (this.renderBuffer_ !== undefined) {
    hitExtent = ol_extent["a" /* default */].createEmpty();
    ol_extent["a" /* default */].extendCoordinate(hitExtent, coordinate);
    ol_extent["a" /* default */].buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
  }

  var mask = replaygroup__ol_render_canvas_ReplayGroup_.getCircleArray_(hitTolerance);
  var declutteredFeatures;
  if (this.declutterTree_) {
    declutteredFeatures = this.declutterTree_.all().map(function (entry) {
      return entry.value;
    });
  }

  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {?} Callback result.
   */
  function hitDetectionCallback(feature) {
    var imageData = context.getImageData(0, 0, contextSize, contextSize).data;
    for (var i = 0; i < contextSize; i++) {
      for (var j = 0; j < contextSize; j++) {
        if (mask[i][j]) {
          if (imageData[(j * contextSize + i) * 4 + 3] > 0) {
            var result;
            if (!declutteredFeatures || declutteredFeatures.indexOf(feature) !== -1) {
              result = callback(feature);
            }
            if (result) {
              return result;
            } else {
              context.clearRect(0, 0, contextSize, contextSize);
              return undefined;
            }
          }
        }
      }
    }
  }

  return this.replayHitDetection_(context, transform, rotation, skippedFeaturesHash, hitDetectionCallback, hitExtent, declutterReplays);
};

/**
 * @param {ol.Transform} transform Transform.
 * @return {Array.<number>} Clip coordinates.
 */
replaygroup__ol_render_canvas_ReplayGroup_.prototype.getClipCoords = function (transform) {
  var maxExtent = this.maxExtent_;
  var minX = maxExtent[0];
  var minY = maxExtent[1];
  var maxX = maxExtent[2];
  var maxY = maxExtent[3];
  var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
  flat_transform["a" /* default */].transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
  return flatClipCoords;
};

/**
 * @inheritDoc
 */
replaygroup__ol_render_canvas_ReplayGroup_.prototype.getReplay = function (zIndex, replayType) {
  var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
  var replays = this.replaysByZIndex_[zIndexKey];
  if (replays === undefined) {
    replays = {};
    this.replaysByZIndex_[zIndexKey] = replays;
  }
  var replay = replays[replayType];
  if (replay === undefined) {
    var Constructor = replaygroup__ol_render_canvas_ReplayGroup_.BATCH_CONSTRUCTORS_[replayType];
    replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_, this.overlaps_, this.declutterTree_);
    replays[replayType] = replay;
  }
  return replay;
};

/**
 * @return {Object.<string, Object.<ol.render.ReplayType, ol.render.canvas.Replay>>} Replays.
 */
replaygroup__ol_render_canvas_ReplayGroup_.prototype.getReplays = function () {
  return this.replaysByZIndex_;
};

/**
 * @inheritDoc
 */
replaygroup__ol_render_canvas_ReplayGroup_.prototype.isEmpty = function () {
  return obj["a" /* default */].isEmpty(this.replaysByZIndex_);
};

/**
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {Array.<ol.render.ReplayType>=} opt_replayTypes Ordered replay types
 *     to replay. Default is {@link ol.render.replay.ORDER}
 * @param {Object.<string, ol.DeclutterGroup>=} opt_declutterReplays Declutter
 *     replays.
 */
replaygroup__ol_render_canvas_ReplayGroup_.prototype.replay = function (context, transform, viewRotation, skippedFeaturesHash, opt_replayTypes, opt_declutterReplays) {

  /** @type {Array.<number>} */
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(array["a" /* default */].numberSafeCompareFunction);

  // setup clipping so that the parts of over-simplified geometries are not
  // visible outside the current extent when panning
  context.save();
  this.clip(context, transform);

  var replayTypes = opt_replayTypes ? opt_replayTypes : render_replay.ORDER;
  var i, ii, j, jj, replays, replay;
  for (i = 0, ii = zs.length; i < ii; ++i) {
    var zIndexKey = zs[i].toString();
    replays = this.replaysByZIndex_[zIndexKey];
    for (j = 0, jj = replayTypes.length; j < jj; ++j) {
      var replayType = replayTypes[j];
      replay = replays[replayType];
      if (replay !== undefined) {
        if (opt_declutterReplays && (replayType == replaytype.IMAGE || replayType == replaytype.TEXT)) {
          var declutter = opt_declutterReplays[zIndexKey];
          if (!declutter) {
            opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];
          } else {
            declutter.push(replay, transform.slice(0));
          }
        } else {
          replay.replay(context, transform, viewRotation, skippedFeaturesHash);
        }
      }
    }
  }

  context.restore();
};

/**
 * @private
 * @param {CanvasRenderingContext2D} context Context.
 * @param {ol.Transform} transform Transform.
 * @param {number} viewRotation View rotation.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *     to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T} featureCallback
 *     Feature callback.
 * @param {ol.Extent=} opt_hitExtent Only check features that intersect this
 *     extent.
 * @param {Object.<string, ol.DeclutterGroup>=} opt_declutterReplays Declutter
 *     replays.
 * @return {T|undefined} Callback result.
 * @template T
 */
replaygroup__ol_render_canvas_ReplayGroup_.prototype.replayHitDetection_ = function (context, transform, viewRotation, skippedFeaturesHash, featureCallback, opt_hitExtent, opt_declutterReplays) {
  /** @type {Array.<number>} */
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(array["a" /* default */].numberSafeCompareFunction);

  var i, j, replays, replay, result;
  for (i = zs.length - 1; i >= 0; --i) {
    var zIndexKey = zs[i].toString();
    replays = this.replaysByZIndex_[zIndexKey];
    for (j = render_replay.ORDER.length - 1; j >= 0; --j) {
      var replayType = render_replay.ORDER[j];
      replay = replays[replayType];
      if (replay !== undefined) {
        if (opt_declutterReplays && (replayType == replaytype.IMAGE || replayType == replaytype.TEXT)) {
          var declutter = opt_declutterReplays[zIndexKey];
          if (!declutter) {
            opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];
          } else {
            declutter.push(replay, transform.slice(0));
          }
        } else {
          result = replay.replayHitDetection(context, transform, viewRotation, skippedFeaturesHash, featureCallback, opt_hitExtent);
          if (result) {
            return result;
          }
        }
      }
    }
  }
  return undefined;
};

/**
 * @const
 * @private
 * @type {Object.<ol.render.ReplayType,
 *                function(new: ol.render.canvas.Replay, number, ol.Extent,
 *                number, number, boolean, Array.<ol.DeclutterGroup>)>}
 */
replaygroup__ol_render_canvas_ReplayGroup_.BATCH_CONSTRUCTORS_ = {
  'Circle': polygonreplay,
  'Default': canvas_replay,
  'Image': imagereplay,
  'LineString': linestringreplay,
  'Polygon': polygonreplay,
  'Text': textreplay
};
/* harmony default export */ var canvas_replaygroup = (replaygroup__ol_render_canvas_ReplayGroup_);
// CONCATENATED MODULE: ./node_modules/ol/renderer/vector.js




var _ol_renderer_vector_ = {};

/**
 * @param {ol.Feature|ol.render.Feature} feature1 Feature 1.
 * @param {ol.Feature|ol.render.Feature} feature2 Feature 2.
 * @return {number} Order.
 */
_ol_renderer_vector_.defaultOrder = function (feature1, feature2) {
  return ol["a" /* default */].getUid(feature1) - ol["a" /* default */].getUid(feature2);
};

/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Squared pixel tolerance.
 */
_ol_renderer_vector_.getSquaredTolerance = function (resolution, pixelRatio) {
  var tolerance = _ol_renderer_vector_.getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
};

/**
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Pixel tolerance.
 */
_ol_renderer_vector_.getTolerance = function (resolution, pixelRatio) {
  return ol["a" /* default */].SIMPLIFY_TOLERANCE * resolution / pixelRatio;
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Circle} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderCircleGeometry_ = function (replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    var circleReplay = replayGroup.getReplay(style.getZIndex(), replaytype.CIRCLE);
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), replaytype.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {function(this: T, ol.events.Event)} listener Listener function.
 * @param {T} thisArg Value to use as `this` when executing `listener`.
 * @return {boolean} `true` if style is loading.
 * @template T
 */
_ol_renderer_vector_.renderFeature = function (replayGroup, feature, style, squaredTolerance, listener, thisArg) {
  var loading = false;
  var imageStyle, imageState;
  imageStyle = style.getImage();
  if (imageStyle) {
    imageState = imageStyle.getImageState();
    if (imageState == imagestate["a" /* default */].LOADED || imageState == imagestate["a" /* default */].ERROR) {
      imageStyle.unlistenImageChange(listener, thisArg);
    } else {
      if (imageState == imagestate["a" /* default */].IDLE) {
        imageStyle.load();
      }
      imageState = imageStyle.getImageState();
      imageStyle.listenImageChange(listener, thisArg);
      loading = true;
    }
  }
  _ol_renderer_vector_.renderFeature_(replayGroup, feature, style, squaredTolerance);

  return loading;
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {ol.style.Style} style Style.
 * @param {number} squaredTolerance Squared tolerance.
 * @private
 */
_ol_renderer_vector_.renderFeature_ = function (replayGroup, feature, style, squaredTolerance) {
  var geometry = style.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
  var renderer = style.getRenderer();
  if (renderer) {
    _ol_renderer_vector_.renderGeometry_(replayGroup, simplifiedGeometry, style, feature);
  } else {
    var geometryRenderer = _ol_renderer_vector_.GEOMETRY_RENDERERS_[simplifiedGeometry.getType()];
    geometryRenderer(replayGroup, simplifiedGeometry, style, feature);
  }
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Geometry} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderGeometry_ = function (replayGroup, geometry, style, feature) {
  if (geometry.getType() == geometrytype["a" /* default */].GEOMETRY_COLLECTION) {
    var geometries = /** @type {ol.geom.GeometryCollection} */geometry.getGeometries();
    for (var i = 0, ii = geometries.length; i < ii; ++i) {
      _ol_renderer_vector_.renderGeometry_(replayGroup, geometries[i], style, feature);
    }
    return;
  }
  var replay = replayGroup.getReplay(style.getZIndex(), replaytype.DEFAULT);
  replay.drawCustom( /** @type {ol.geom.SimpleGeometry} */geometry, feature, style.getRenderer());
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.GeometryCollection} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderGeometryCollectionGeometry_ = function (replayGroup, geometry, style, feature) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    var geometryRenderer = _ol_renderer_vector_.GEOMETRY_RENDERERS_[geometries[i].getType()];
    geometryRenderer(replayGroup, geometries[i], style, feature);
  }
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.LineString|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderLineStringGeometry_ = function (replayGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();
  if (strokeStyle) {
    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), replaytype.LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), replaytype.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.MultiLineString|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderMultiLineStringGeometry_ = function (replayGroup, geometry, style, feature) {
  var strokeStyle = style.getStroke();
  if (strokeStyle) {
    var lineStringReplay = replayGroup.getReplay(style.getZIndex(), replaytype.LINE_STRING);
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), replaytype.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.MultiPolygon} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderMultiPolygonGeometry_ = function (replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (strokeStyle || fillStyle) {
    var polygonReplay = replayGroup.getReplay(style.getZIndex(), replaytype.POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), replaytype.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Point|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderPointGeometry_ = function (replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();
  if (imageStyle) {
    if (imageStyle.getImageState() != imagestate["a" /* default */].LOADED) {
      return;
    }
    var imageReplay = replayGroup.getReplay(style.getZIndex(), replaytype.IMAGE);
    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));
    imageReplay.drawPoint(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), replaytype.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));
    textReplay.drawText(geometry, feature);
  }
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.MultiPoint|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderMultiPointGeometry_ = function (replayGroup, geometry, style, feature) {
  var imageStyle = style.getImage();
  if (imageStyle) {
    if (imageStyle.getImageState() != imagestate["a" /* default */].LOADED) {
      return;
    }
    var imageReplay = replayGroup.getReplay(style.getZIndex(), replaytype.IMAGE);
    imageReplay.setImageStyle(imageStyle, replayGroup.addDeclutter(false));
    imageReplay.drawMultiPoint(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), replaytype.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(!!imageStyle));
    textReplay.drawText(geometry, feature);
  }
};

/**
 * @param {ol.render.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Polygon|ol.render.Feature} geometry Geometry.
 * @param {ol.style.Style} style Style.
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */
_ol_renderer_vector_.renderPolygonGeometry_ = function (replayGroup, geometry, style, feature) {
  var fillStyle = style.getFill();
  var strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    var polygonReplay = replayGroup.getReplay(style.getZIndex(), replaytype.POLYGON);
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }
  var textStyle = style.getText();
  if (textStyle) {
    var textReplay = replayGroup.getReplay(style.getZIndex(), replaytype.TEXT);
    textReplay.setTextStyle(textStyle, replayGroup.addDeclutter(false));
    textReplay.drawText(geometry, feature);
  }
};

/**
 * @const
 * @private
 * @type {Object.<ol.geom.GeometryType,
 *                function(ol.render.ReplayGroup, ol.geom.Geometry,
 *                         ol.style.Style, Object)>}
 */
_ol_renderer_vector_.GEOMETRY_RENDERERS_ = {
  'Point': _ol_renderer_vector_.renderPointGeometry_,
  'LineString': _ol_renderer_vector_.renderLineStringGeometry_,
  'Polygon': _ol_renderer_vector_.renderPolygonGeometry_,
  'MultiPoint': _ol_renderer_vector_.renderMultiPointGeometry_,
  'MultiLineString': _ol_renderer_vector_.renderMultiLineStringGeometry_,
  'MultiPolygon': _ol_renderer_vector_.renderMultiPolygonGeometry_,
  'GeometryCollection': _ol_renderer_vector_.renderGeometryCollectionGeometry_,
  'Circle': _ol_renderer_vector_.renderCircleGeometry_
};
/* harmony default export */ var vector = (_ol_renderer_vector_);
// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/vectorlayer.js















/**
 * @constructor
 * @extends {ol.renderer.canvas.Layer}
 * @param {ol.layer.Vector} vectorLayer Vector layer.
 * @api
 */
var vectorlayer__ol_renderer_canvas_VectorLayer_ = function _ol_renderer_canvas_VectorLayer_(vectorLayer) {

  canvas_layer.call(this, vectorLayer);

  /**
   * Declutter tree.
   * @private
   */
  this.declutterTree_ = vectorLayer.getDeclutter() ? external__rbush__default()(9) : null;

  /**
   * @private
   * @type {boolean}
   */
  this.dirty_ = false;

  /**
   * @private
   * @type {number}
   */
  this.renderedRevision_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.renderedResolution_ = NaN;

  /**
   * @private
   * @type {ol.Extent}
   */
  this.renderedExtent_ = ol_extent["a" /* default */].createEmpty();

  /**
   * @private
   * @type {function(ol.Feature, ol.Feature): number|null}
   */
  this.renderedRenderOrder_ = null;

  /**
   * @private
   * @type {ol.render.canvas.ReplayGroup}
   */
  this.replayGroup_ = null;

  /**
   * A new replay group had to be created by `prepareFrame()`
   * @type {boolean}
   */
  this.replayGroupChanged = true;

  /**
   * @type {CanvasRenderingContext2D}
   */
  this.context = dom["a" /* default */].createCanvasContext2D();

  ol_events["a" /* default */].listen(render_canvas["a" /* default */].labelCache, events_eventtype["a" /* default */].CLEAR, this.handleFontsChanged_, this);
};

ol["a" /* default */].inherits(vectorlayer__ol_renderer_canvas_VectorLayer_, canvas_layer);

/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
vectorlayer__ol_renderer_canvas_VectorLayer_['handles'] = function (type, layer) {
  return type === renderer_type.CANVAS && layer.getType() === layertype["a" /* default */].VECTOR;
};

/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.canvas.VectorLayer} The layer renderer.
 */
vectorlayer__ol_renderer_canvas_VectorLayer_['create'] = function (mapRenderer, layer) {
  return new vectorlayer__ol_renderer_canvas_VectorLayer_( /** @type {ol.layer.Vector} */layer);
};

/**
 * @inheritDoc
 */
vectorlayer__ol_renderer_canvas_VectorLayer_.prototype.disposeInternal = function () {
  ol_events["a" /* default */].unlisten(render_canvas["a" /* default */].labelCache, events_eventtype["a" /* default */].CLEAR, this.handleFontsChanged_, this);
  canvas_layer.prototype.disposeInternal.call(this);
};

/**
 * @inheritDoc
 */
vectorlayer__ol_renderer_canvas_VectorLayer_.prototype.composeFrame = function (frameState, layerState, context) {

  var extent = frameState.extent;
  var pixelRatio = frameState.pixelRatio;
  var skippedFeatureUids = layerState.managed ? frameState.skippedFeatureUids : {};
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var rotation = viewState.rotation;
  var projectionExtent = projection.getExtent();
  var vectorSource = /** @type {ol.source.Vector} */this.getLayer().getSource();

  var transform = this.getTransform(frameState, 0);

  this.preCompose(context, frameState, transform);

  // clipped rendering if layer extent is set
  var clipExtent = layerState.extent;
  var clipped = clipExtent !== undefined;
  if (clipped) {
    this.clip(context, frameState, /** @type {ol.Extent} */clipExtent);
  }
  var replayGroup = this.replayGroup_;
  if (replayGroup && !replayGroup.isEmpty()) {
    if (this.declutterTree_) {
      this.declutterTree_.clear();
    }
    var layer = /** @type {ol.layer.Vector} */this.getLayer();
    var drawOffsetX = 0;
    var drawOffsetY = 0;
    var replayContext;
    var transparentLayer = layerState.opacity !== 1;
    var hasRenderListeners = layer.hasListener(render_eventtype["a" /* default */].RENDER);
    if (transparentLayer || hasRenderListeners) {
      var drawWidth = context.canvas.width;
      var drawHeight = context.canvas.height;
      if (rotation) {
        var drawSize = Math.round(Math.sqrt(drawWidth * drawWidth + drawHeight * drawHeight));
        drawOffsetX = (drawSize - drawWidth) / 2;
        drawOffsetY = (drawSize - drawHeight) / 2;
        drawWidth = drawHeight = drawSize;
      }
      // resize and clear
      this.context.canvas.width = drawWidth;
      this.context.canvas.height = drawHeight;
      replayContext = this.context;
    } else {
      replayContext = context;
    }

    var alpha = replayContext.globalAlpha;
    if (!transparentLayer) {
      // for performance reasons, context.save / context.restore is not used
      // to save and restore the transformation matrix and the opacity.
      // see http://jsperf.com/context-save-restore-versus-variable
      replayContext.globalAlpha = layerState.opacity;
    }

    if (replayContext != context) {
      replayContext.translate(drawOffsetX, drawOffsetY);
    }

    var width = frameState.size[0] * pixelRatio;
    var height = frameState.size[1] * pixelRatio;
    render_canvas["a" /* default */].rotateAtOffset(replayContext, -rotation, width / 2, height / 2);
    replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);
    if (vectorSource.getWrapX() && projection.canWrapX() && !ol_extent["a" /* default */].containsExtent(projectionExtent, extent)) {
      var startX = extent[0];
      var worldWidth = ol_extent["a" /* default */].getWidth(projectionExtent);
      var world = 0;
      var offsetX;
      while (startX < projectionExtent[0]) {
        --world;
        offsetX = worldWidth * world;
        transform = this.getTransform(frameState, offsetX);
        replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);
        startX += worldWidth;
      }
      world = 0;
      startX = extent[2];
      while (startX > projectionExtent[2]) {
        ++world;
        offsetX = worldWidth * world;
        transform = this.getTransform(frameState, offsetX);
        replayGroup.replay(replayContext, transform, rotation, skippedFeatureUids);
        startX -= worldWidth;
      }
      // restore original transform for render and compose events
      transform = this.getTransform(frameState, 0);
    }
    render_canvas["a" /* default */].rotateAtOffset(replayContext, rotation, width / 2, height / 2);

    if (replayContext != context) {
      if (hasRenderListeners) {
        this.dispatchRenderEvent(replayContext, frameState, transform);
      }
      if (transparentLayer) {
        var mainContextAlpha = context.globalAlpha;
        context.globalAlpha = layerState.opacity;
        context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
        context.globalAlpha = mainContextAlpha;
      } else {
        context.drawImage(replayContext.canvas, -drawOffsetX, -drawOffsetY);
      }
      replayContext.translate(-drawOffsetX, -drawOffsetY);
    }

    if (!transparentLayer) {
      replayContext.globalAlpha = alpha;
    }
  }

  if (clipped) {
    context.restore();
  }
  this.postCompose(context, frameState, layerState, transform);
};

/**
 * @inheritDoc
 */
vectorlayer__ol_renderer_canvas_VectorLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  if (!this.replayGroup_) {
    return undefined;
  } else {
    var resolution = frameState.viewState.resolution;
    var rotation = frameState.viewState.rotation;
    var layer = /** @type {ol.layer.Vector} */this.getLayer();
    /** @type {Object.<string, boolean>} */
    var features = {};
    var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},
    /**
     * @param {ol.Feature|ol.render.Feature} feature Feature.
     * @return {?} Callback result.
     */
    function (feature) {
      var key = ol["a" /* default */].getUid(feature).toString();
      if (!(key in features)) {
        features[key] = true;
        return callback.call(thisArg, feature, layer);
      }
    }, null);
    return result;
  }
};

/**
 * @param {ol.events.Event} event Event.
 */
vectorlayer__ol_renderer_canvas_VectorLayer_.prototype.handleFontsChanged_ = function (event) {
  var layer = this.getLayer();
  if (layer.getVisible() && this.replayGroup_) {
    layer.changed();
  }
};

/**
 * Handle changes in image style state.
 * @param {ol.events.Event} event Image style change event.
 * @private
 */
vectorlayer__ol_renderer_canvas_VectorLayer_.prototype.handleStyleImageChange_ = function (event) {
  this.renderIfReadyAndVisible();
};

/**
 * @inheritDoc
 */
vectorlayer__ol_renderer_canvas_VectorLayer_.prototype.prepareFrame = function (frameState, layerState) {

  var vectorLayer = /** @type {ol.layer.Vector} */this.getLayer();
  var vectorSource = vectorLayer.getSource();

  this.updateLogos(frameState, vectorSource);

  var animating = frameState.viewHints[viewhint["a" /* default */].ANIMATING];
  var interacting = frameState.viewHints[viewhint["a" /* default */].INTERACTING];
  var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
  var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

  if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
    return true;
  }

  var frameStateExtent = frameState.extent;
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var resolution = viewState.resolution;
  var pixelRatio = frameState.pixelRatio;
  var vectorLayerRevision = vectorLayer.getRevision();
  var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
  var vectorLayerRenderOrder = vectorLayer.getRenderOrder();

  if (vectorLayerRenderOrder === undefined) {
    vectorLayerRenderOrder = vector.defaultOrder;
  }

  var extent = ol_extent["a" /* default */].buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);
  var projectionExtent = viewState.projection.getExtent();

  if (vectorSource.getWrapX() && viewState.projection.canWrapX() && !ol_extent["a" /* default */].containsExtent(projectionExtent, frameState.extent)) {
    // For the replay group, we need an extent that intersects the real world
    // (-180° to +180°). To support geometries in a coordinate range from -540°
    // to +540°, we add at least 1 world width on each side of the projection
    // extent. If the viewport is wider than the world, we need to add half of
    // the viewport width to make sure we cover the whole viewport.
    var worldWidth = ol_extent["a" /* default */].getWidth(projectionExtent);
    var buffer = Math.max(ol_extent["a" /* default */].getWidth(extent) / 2, worldWidth);
    extent[0] = projectionExtent[0] - buffer;
    extent[2] = projectionExtent[2] + buffer;
  }

  if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && ol_extent["a" /* default */].containsExtent(this.renderedExtent_, extent)) {
    this.replayGroupChanged = false;
    return true;
  }

  this.replayGroup_ = null;

  this.dirty_ = false;

  var replayGroup = new canvas_replaygroup(vector.getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio, vectorSource.getOverlaps(), this.declutterTree_, vectorLayer.getRenderBuffer());
  vectorSource.loadFeatures(extent, resolution, projection);
  /**
   * @param {ol.Feature} feature Feature.
   * @this {ol.renderer.canvas.VectorLayer}
   */
  var renderFeature = function (feature) {
    var styles;
    var styleFunction = feature.getStyleFunction();
    if (styleFunction) {
      styles = styleFunction.call(feature, resolution);
    } else {
      styleFunction = vectorLayer.getStyleFunction();
      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }
    }
    if (styles) {
      var dirty = this.renderFeature(feature, resolution, pixelRatio, styles, replayGroup);
      this.dirty_ = this.dirty_ || dirty;
    }
  }.bind(this);
  if (vectorLayerRenderOrder) {
    /** @type {Array.<ol.Feature>} */
    var features = [];
    vectorSource.forEachFeatureInExtent(extent,
    /**
     * @param {ol.Feature} feature Feature.
     */
    function (feature) {
      features.push(feature);
    }, this);
    features.sort(vectorLayerRenderOrder);
    for (var i = 0, ii = features.length; i < ii; ++i) {
      renderFeature(features[i]);
    }
  } else {
    vectorSource.forEachFeatureInExtent(extent, renderFeature, this);
  }
  replayGroup.finish();

  this.renderedResolution_ = resolution;
  this.renderedRevision_ = vectorLayerRevision;
  this.renderedRenderOrder_ = vectorLayerRenderOrder;
  this.renderedExtent_ = extent;
  this.replayGroup_ = replayGroup;

  this.replayGroupChanged = true;
  return true;
};

/**
 * @param {ol.Feature} feature Feature.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {(ol.style.Style|Array.<ol.style.Style>)} styles The style or array of
 *     styles.
 * @param {ol.render.canvas.ReplayGroup} replayGroup Replay group.
 * @return {boolean} `true` if an image is loading.
 */
vectorlayer__ol_renderer_canvas_VectorLayer_.prototype.renderFeature = function (feature, resolution, pixelRatio, styles, replayGroup) {
  if (!styles) {
    return false;
  }
  var loading = false;
  if (Array.isArray(styles)) {
    for (var i = 0, ii = styles.length; i < ii; ++i) {
      loading = vector.renderFeature(replayGroup, feature, styles[i], vector.getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;
    }
  } else {
    loading = vector.renderFeature(replayGroup, feature, styles, vector.getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this);
  }
  return loading;
};
/* harmony default export */ var vectorlayer = (vectorlayer__ol_renderer_canvas_VectorLayer_);
// CONCATENATED MODULE: ./node_modules/ol/layer/vectortilerendertype.js
/**
 * @enum {string}
 * Render mode for vector tiles:
 *  * `'image'`: Vector tiles are rendered as images. Great performance, but
 *    point symbols and texts are always rotated with the view and pixels are
 *    scaled during zoom animations.
 *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels
 *    are scaled during zoom animations. Point symbols and texts are accurately
 *    rendered as vectors and can stay upright on rotated views.
 *  * `'vector'`: Vector tiles are rendered as vectors. Most accurate rendering
 *    even during animations, but slower performance than the other options.
 * @api
 */
var _ol_layer_VectorTileRenderType_ = {
  IMAGE: 'image',
  HYBRID: 'hybrid',
  VECTOR: 'vector'
};

/* harmony default export */ var vectortilerendertype = (_ol_layer_VectorTileRenderType_);
// EXTERNAL MODULE: ./node_modules/ol/proj.js + 7 modules
var proj = __webpack_require__(16);

// EXTERNAL MODULE: ./node_modules/ol/proj/units.js
var units = __webpack_require__(26);

// CONCATENATED MODULE: ./node_modules/ol/renderer/canvas/vectortilelayer.js




















/**
 * @constructor
 * @extends {ol.renderer.canvas.TileLayer}
 * @param {ol.layer.VectorTile} layer VectorTile layer.
 * @api
 */
var vectortilelayer__ol_renderer_canvas_VectorTileLayer_ = function _ol_renderer_canvas_VectorTileLayer_(layer) {

  /**
   * @type {CanvasRenderingContext2D}
   */
  this.context = null;

  tilelayer.call(this, layer);

  /**
   * Declutter tree.
   * @private
     */
  this.declutterTree_ = layer.getDeclutter() ? external__rbush__default()(9) : null;

  /**
   * @private
   * @type {boolean}
   */
  this.dirty_ = false;

  /**
   * @private
   * @type {number}
   */
  this.renderedLayerRevision_;

  /**
   * @private
   * @type {ol.Transform}
   */
  this.tmpTransform_ = ol_transform["a" /* default */].create();

  // Use lower resolution for pure vector rendering. Closest resolution otherwise.
  this.zDirection = layer.getRenderMode() == vectortilerendertype.VECTOR ? 1 : 0;

  ol_events["a" /* default */].listen(render_canvas["a" /* default */].labelCache, events_eventtype["a" /* default */].CLEAR, this.handleFontsChanged_, this);
};

ol["a" /* default */].inherits(vectortilelayer__ol_renderer_canvas_VectorTileLayer_, tilelayer);

/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
vectortilelayer__ol_renderer_canvas_VectorTileLayer_['handles'] = function (type, layer) {
  return type === renderer_type.CANVAS && layer.getType() === layertype["a" /* default */].VECTOR_TILE;
};

/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.canvas.VectorTileLayer} The layer renderer.
 */
vectortilelayer__ol_renderer_canvas_VectorTileLayer_['create'] = function (mapRenderer, layer) {
  return new vectortilelayer__ol_renderer_canvas_VectorTileLayer_( /** @type {ol.layer.VectorTile} */layer);
};

/**
 * @const
 * @type {!Object.<string, Array.<ol.render.ReplayType>>}
 */
vectortilelayer__ol_renderer_canvas_VectorTileLayer_.IMAGE_REPLAYS = {
  'image': [replaytype.POLYGON, replaytype.CIRCLE, replaytype.LINE_STRING, replaytype.IMAGE, replaytype.TEXT],
  'hybrid': [replaytype.POLYGON, replaytype.LINE_STRING]
};

/**
 * @const
 * @type {!Object.<string, Array.<ol.render.ReplayType>>}
 */
vectortilelayer__ol_renderer_canvas_VectorTileLayer_.VECTOR_REPLAYS = {
  'image': [replaytype.DEFAULT],
  'hybrid': [replaytype.IMAGE, replaytype.TEXT, replaytype.DEFAULT],
  'vector': render_replay.ORDER
};

/**
 * @inheritDoc
 */
vectortilelayer__ol_renderer_canvas_VectorTileLayer_.prototype.disposeInternal = function () {
  ol_events["a" /* default */].unlisten(render_canvas["a" /* default */].labelCache, events_eventtype["a" /* default */].CLEAR, this.handleFontsChanged_, this);
  tilelayer.prototype.disposeInternal.call(this);
};

/**
 * @inheritDoc
 */
vectortilelayer__ol_renderer_canvas_VectorTileLayer_.prototype.prepareFrame = function (frameState, layerState) {
  var layer = this.getLayer();
  var layerRevision = layer.getRevision();
  if (this.renderedLayerRevision_ != layerRevision) {
    this.renderedTiles.length = 0;
    var renderMode = layer.getRenderMode();
    if (!this.context && renderMode != vectortilerendertype.VECTOR) {
      this.context = dom["a" /* default */].createCanvasContext2D();
    }
    if (this.context && renderMode == vectortilerendertype.VECTOR) {
      this.context = null;
    }
  }
  this.renderedLayerRevision_ = layerRevision;
  return tilelayer.prototype.prepareFrame.apply(this, arguments);
};

/**
 * @param {ol.VectorImageTile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */
vectortilelayer__ol_renderer_canvas_VectorTileLayer_.prototype.createReplayGroup_ = function (tile, frameState) {
  var layer = this.getLayer();
  var pixelRatio = frameState.pixelRatio;
  var projection = frameState.viewState.projection;
  var revision = layer.getRevision();
  var renderOrder = /** @type {ol.RenderOrderFunction} */
  layer.getRenderOrder() || null;

  var replayState = tile.getReplayState(layer);
  if (!replayState.dirty && replayState.renderedRevision == revision && replayState.renderedRenderOrder == renderOrder) {
    return;
  }

  var source = /** @type {ol.source.VectorTile} */layer.getSource();
  var sourceTileGrid = source.getTileGrid();
  var tileGrid = source.getTileGridForProjection(projection);
  var resolution = tileGrid.getResolution(tile.tileCoord[0]);
  var tileExtent = tileGrid.getTileCoordExtent(tile.wrappedTileCoord);

  var zIndexKeys = {};
  for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
    var sourceTile = tile.getTile(tile.tileKeys[t]);
    if (sourceTile.getState() == tilestate["a" /* default */].ERROR) {
      continue;
    }

    var sourceTileCoord = sourceTile.tileCoord;
    var sourceTileExtent = sourceTileGrid.getTileCoordExtent(sourceTileCoord);
    var sharedExtent = ol_extent["a" /* default */].getIntersection(tileExtent, sourceTileExtent);
    var bufferedExtent = ol_extent["a" /* default */].equals(sourceTileExtent, sharedExtent) ? null : ol_extent["a" /* default */].buffer(sharedExtent, layer.getRenderBuffer() * resolution);
    var tileProjection = sourceTile.getProjection();
    var reproject = false;
    if (!proj["default"].equivalent(projection, tileProjection)) {
      reproject = true;
      sourceTile.setProjection(projection);
    }
    replayState.dirty = false;
    var replayGroup = new canvas_replaygroup(0, sharedExtent, resolution, pixelRatio, source.getOverlaps(), this.declutterTree_, layer.getRenderBuffer());
    var squaredTolerance = vector.getSquaredTolerance(resolution, pixelRatio);

    /**
     * @param {ol.Feature|ol.render.Feature} feature Feature.
     * @this {ol.renderer.canvas.VectorTileLayer}
     */
    var renderFeature = function renderFeature(feature) {
      var styles;
      var styleFunction = feature.getStyleFunction();
      if (styleFunction) {
        styles = styleFunction.call( /** @type {ol.Feature} */feature, resolution);
      } else {
        styleFunction = layer.getStyleFunction();
        if (styleFunction) {
          styles = styleFunction(feature, resolution);
        }
      }
      if (styles) {
        var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup);
        this.dirty_ = this.dirty_ || dirty;
        replayState.dirty = replayState.dirty || dirty;
      }
    };

    var features = sourceTile.getFeatures();
    if (renderOrder && renderOrder !== replayState.renderedRenderOrder) {
      features.sort(renderOrder);
    }
    var feature;
    for (var i = 0, ii = features.length; i < ii; ++i) {
      feature = features[i];
      if (reproject) {
        if (tileProjection.getUnits() == units["a" /* default */].TILE_PIXELS) {
          // projected tile extent
          tileProjection.setWorldExtent(sourceTileExtent);
          // tile extent in tile pixel space
          tileProjection.setExtent(sourceTile.getExtent());
        }
        feature.getGeometry().transform(tileProjection, projection);
      }
      if (!bufferedExtent || ol_extent["a" /* default */].intersects(bufferedExtent, feature.getGeometry().getExtent())) {
        renderFeature.call(this, feature);
      }
    }
    replayGroup.finish();
    for (var r in replayGroup.getReplays()) {
      zIndexKeys[r] = true;
    }
    sourceTile.setReplayGroup(layer, tile.tileCoord.toString(), replayGroup);
  }
  replayState.renderedRevision = revision;
  replayState.renderedRenderOrder = renderOrder;
};

/**
 * @inheritDoc
 */
vectortilelayer__ol_renderer_canvas_VectorTileLayer_.prototype.drawTileImage = function (tile, frameState, layerState, x, y, w, h, gutter, transition) {
  var vectorImageTile = /** @type {ol.VectorImageTile} */tile;
  this.createReplayGroup_(vectorImageTile, frameState);
  if (this.context) {
    this.renderTileImage_(vectorImageTile, frameState, layerState);
    tilelayer.prototype.drawTileImage.apply(this, arguments);
  }
};

/**
 * @inheritDoc
 */
vectortilelayer__ol_renderer_canvas_VectorTileLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  var resolution = frameState.viewState.resolution;
  var rotation = frameState.viewState.rotation;
  hitTolerance = hitTolerance == undefined ? 0 : hitTolerance;
  var layer = this.getLayer();
  /** @type {Object.<string, boolean>} */
  var features = {};

  /** @type {Array.<ol.VectorImageTile>} */
  var renderedTiles = this.renderedTiles;

  var source = /** @type {ol.source.VectorTile} */layer.getSource();
  var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
  var bufferedExtent, found;
  var i, ii, replayGroup;
  var tile, tileCoord, tileExtent;
  for (i = 0, ii = renderedTiles.length; i < ii; ++i) {
    tile = renderedTiles[i];
    tileCoord = tile.wrappedTileCoord;
    tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
    bufferedExtent = ol_extent["a" /* default */].buffer(tileExtent, hitTolerance * resolution, bufferedExtent);
    if (!ol_extent["a" /* default */].containsCoordinate(bufferedExtent, coordinate)) {
      continue;
    }
    for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
      var sourceTile = tile.getTile(tile.tileKeys[t]);
      if (sourceTile.getState() == tilestate["a" /* default */].ERROR) {
        continue;
      }
      replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());
      found = found || replayGroup.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, {},
      /**
       * @param {ol.Feature|ol.render.Feature} feature Feature.
       * @return {?} Callback result.
       */
      function (feature) {
        var key = ol["a" /* default */].getUid(feature).toString();
        if (!(key in features)) {
          features[key] = true;
          return callback.call(thisArg, feature, layer);
        }
      }, null);
    }
  }
  return found;
};

/**
 * @param {ol.VectorTile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @return {ol.Transform} transform Transform.
 * @private
 */
vectortilelayer__ol_renderer_canvas_VectorTileLayer_.prototype.getReplayTransform_ = function (tile, frameState) {
  var layer = this.getLayer();
  var source = /** @type {ol.source.VectorTile} */layer.getSource();
  var tileGrid = source.getTileGrid();
  var tileCoord = tile.tileCoord;
  var tileResolution = tileGrid.getResolution(tileCoord[0]);
  var viewState = frameState.viewState;
  var pixelRatio = frameState.pixelRatio;
  var renderResolution = viewState.resolution / pixelRatio;
  var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent);
  var center = viewState.center;
  var origin = ol_extent["a" /* default */].getTopLeft(tileExtent);
  var size = frameState.size;
  var offsetX = Math.round(pixelRatio * size[0] / 2);
  var offsetY = Math.round(pixelRatio * size[1] / 2);
  return ol_transform["a" /* default */].compose(this.tmpTransform_, offsetX, offsetY, tileResolution / renderResolution, tileResolution / renderResolution, viewState.rotation, (origin[0] - center[0]) / tileResolution, (center[1] - origin[1]) / tileResolution);
};

/**
 * @param {ol.events.Event} event Event.
 */
vectortilelayer__ol_renderer_canvas_VectorTileLayer_.prototype.handleFontsChanged_ = function (event) {
  var layer = this.getLayer();
  if (layer.getVisible() && this.renderedLayerRevision_ !== undefined) {
    layer.changed();
  }
};

/**
 * Handle changes in image style state.
 * @param {ol.events.Event} event Image style change event.
 * @private
 */
vectortilelayer__ol_renderer_canvas_VectorTileLayer_.prototype.handleStyleImageChange_ = function (event) {
  this.renderIfReadyAndVisible();
};

/**
 * @inheritDoc
 */
vectortilelayer__ol_renderer_canvas_VectorTileLayer_.prototype.postCompose = function (context, frameState, layerState) {
  var layer = this.getLayer();
  var declutterReplays = layer.getDeclutter() ? {} : null;
  var source = /** @type {ol.source.VectorTile} */layer.getSource();
  var renderMode = layer.getRenderMode();
  var replayTypes = vectortilelayer__ol_renderer_canvas_VectorTileLayer_.VECTOR_REPLAYS[renderMode];
  var pixelRatio = frameState.pixelRatio;
  var rotation = frameState.viewState.rotation;
  var size = frameState.size;
  var offsetX, offsetY;
  if (rotation) {
    offsetX = Math.round(pixelRatio * size[0] / 2);
    offsetY = Math.round(pixelRatio * size[1] / 2);
    render_canvas["a" /* default */].rotateAtOffset(context, -rotation, offsetX, offsetY);
  }
  if (declutterReplays) {
    this.declutterTree_.clear();
  }
  var tiles = this.renderedTiles;
  var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
  var clips = [];
  var zs = [];
  for (var i = tiles.length - 1; i >= 0; --i) {
    var tile = /** @type {ol.VectorImageTile} */tiles[i];
    if (tile.getState() == tilestate["a" /* default */].ABORT) {
      continue;
    }
    var tileCoord = tile.tileCoord;
    var worldOffset = tileGrid.getTileCoordExtent(tileCoord)[0] - tileGrid.getTileCoordExtent(tile.wrappedTileCoord)[0];
    var transform = undefined;
    for (var t = 0, tt = tile.tileKeys.length; t < tt; ++t) {
      var sourceTile = tile.getTile(tile.tileKeys[t]);
      if (sourceTile.getState() == tilestate["a" /* default */].ERROR) {
        continue;
      }
      var replayGroup = sourceTile.getReplayGroup(layer, tileCoord.toString());
      if (renderMode != vectortilerendertype.VECTOR && !replayGroup.hasReplays(replayTypes)) {
        continue;
      }
      if (!transform) {
        transform = this.getTransform(frameState, worldOffset);
      }
      var currentZ = sourceTile.tileCoord[0];
      var currentClip = replayGroup.getClipCoords(transform);
      context.save();
      context.globalAlpha = layerState.opacity;
      // Create a clip mask for regions in this low resolution tile that are
      // already filled by a higher resolution tile
      for (var j = 0, jj = clips.length; j < jj; ++j) {
        var clip = clips[j];
        if (currentZ < zs[j]) {
          context.beginPath();
          // counter-clockwise (outer ring) for current tile
          context.moveTo(currentClip[0], currentClip[1]);
          context.lineTo(currentClip[2], currentClip[3]);
          context.lineTo(currentClip[4], currentClip[5]);
          context.lineTo(currentClip[6], currentClip[7]);
          // clockwise (inner ring) for higher resolution tile
          context.moveTo(clip[6], clip[7]);
          context.lineTo(clip[4], clip[5]);
          context.lineTo(clip[2], clip[3]);
          context.lineTo(clip[0], clip[1]);
          context.clip();
        }
      }
      replayGroup.replay(context, transform, rotation, {}, replayTypes, declutterReplays);
      context.restore();
      clips.push(currentClip);
      zs.push(currentZ);
    }
  }
  if (declutterReplays) {
    canvas_replaygroup.replayDeclutter(declutterReplays, context, rotation);
  }
  if (rotation) {
    render_canvas["a" /* default */].rotateAtOffset(context, rotation,
    /** @type {number} */offsetX, /** @type {number} */offsetY);
  }
  tilelayer.prototype.postCompose.apply(this, arguments);
};

/**
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {number} squaredTolerance Squared tolerance.
 * @param {(ol.style.Style|Array.<ol.style.Style>)} styles The style or array of
 *     styles.
 * @param {ol.render.canvas.ReplayGroup} replayGroup Replay group.
 * @return {boolean} `true` if an image is loading.
 */
vectortilelayer__ol_renderer_canvas_VectorTileLayer_.prototype.renderFeature = function (feature, squaredTolerance, styles, replayGroup) {
  if (!styles) {
    return false;
  }
  var loading = false;
  if (Array.isArray(styles)) {
    for (var i = 0, ii = styles.length; i < ii; ++i) {
      loading = vector.renderFeature(replayGroup, feature, styles[i], squaredTolerance, this.handleStyleImageChange_, this) || loading;
    }
  } else {
    loading = vector.renderFeature(replayGroup, feature, styles, squaredTolerance, this.handleStyleImageChange_, this);
  }
  return loading;
};

/**
 * @param {ol.VectorImageTile} tile Tile.
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @private
 */
vectortilelayer__ol_renderer_canvas_VectorTileLayer_.prototype.renderTileImage_ = function (tile, frameState, layerState) {
  var layer = this.getLayer();
  var replayState = tile.getReplayState(layer);
  var revision = layer.getRevision();
  var replays = vectortilelayer__ol_renderer_canvas_VectorTileLayer_.IMAGE_REPLAYS[layer.getRenderMode()];
  if (replays && replayState.renderedTileRevision !== revision) {
    replayState.renderedTileRevision = revision;
    var tileCoord = tile.wrappedTileCoord;
    var z = tileCoord[0];
    var pixelRatio = frameState.pixelRatio;
    var source = /** @type {ol.source.VectorTile} */layer.getSource();
    var tileGrid = source.getTileGridForProjection(frameState.viewState.projection);
    var resolution = tileGrid.getResolution(z);
    var context = tile.getContext(layer);
    var size = source.getTilePixelSize(z, pixelRatio, frameState.viewState.projection);
    context.canvas.width = size[0];
    context.canvas.height = size[1];
    var tileExtent = tileGrid.getTileCoordExtent(tileCoord);
    for (var i = 0, ii = tile.tileKeys.length; i < ii; ++i) {
      var sourceTile = tile.getTile(tile.tileKeys[i]);
      if (sourceTile.getState() == tilestate["a" /* default */].ERROR) {
        continue;
      }
      var pixelScale = pixelRatio / resolution;
      var transform = ol_transform["a" /* default */].reset(this.tmpTransform_);
      ol_transform["a" /* default */].scale(transform, pixelScale, -pixelScale);
      ol_transform["a" /* default */].translate(transform, -tileExtent[0], -tileExtent[3]);
      var replayGroup = sourceTile.getReplayGroup(layer, tile.tileCoord.toString());
      replayGroup.replay(context, transform, 0, {}, replays);
    }
  }
};
/* harmony default export */ var vectortilelayer = (vectortilelayer__ol_renderer_canvas_VectorTileLayer_);
// EXTERNAL MODULE: ./node_modules/ol/webgl.js
var webgl = __webpack_require__(14);

// CONCATENATED MODULE: ./node_modules/ol/webgl/shader.js


/**
 * @constructor
 * @abstract
 * @param {string} source Source.
 * @struct
 */
var _ol_webgl_Shader_ = function _ol_webgl_Shader_(source) {

  /**
   * @private
   * @type {string}
   */
  this.source_ = source;
};

/**
 * @abstract
 * @return {number} Type.
 */
_ol_webgl_Shader_.prototype.getType = function () {};

/**
 * @return {string} Source.
 */
_ol_webgl_Shader_.prototype.getSource = function () {
  return this.source_;
};

/**
 * @return {boolean} Is animated?
 */
_ol_webgl_Shader_.prototype.isAnimated = functions["a" /* default */].FALSE;
/* harmony default export */ var webgl_shader = (_ol_webgl_Shader_);
// CONCATENATED MODULE: ./node_modules/ol/webgl/fragment.js




/**
 * @constructor
 * @extends {ol.webgl.Shader}
 * @param {string} source Source.
 * @struct
 */
var fragment__ol_webgl_Fragment_ = function _ol_webgl_Fragment_(source) {
  webgl_shader.call(this, source);
};

ol["a" /* default */].inherits(fragment__ol_webgl_Fragment_, webgl_shader);

/**
 * @inheritDoc
 */
fragment__ol_webgl_Fragment_.prototype.getType = function () {
  return webgl["a" /* default */].FRAGMENT_SHADER;
};
/* harmony default export */ var fragment = (fragment__ol_webgl_Fragment_);
// CONCATENATED MODULE: ./node_modules/ol/webgl/vertex.js




/**
 * @constructor
 * @extends {ol.webgl.Shader}
 * @param {string} source Source.
 * @struct
 */
var vertex__ol_webgl_Vertex_ = function _ol_webgl_Vertex_(source) {
  webgl_shader.call(this, source);
};

ol["a" /* default */].inherits(vertex__ol_webgl_Vertex_, webgl_shader);

/**
 * @inheritDoc
 */
vertex__ol_webgl_Vertex_.prototype.getType = function () {
  return webgl["a" /* default */].VERTEX_SHADER;
};
/* harmony default export */ var vertex = (vertex__ol_webgl_Vertex_);
// CONCATENATED MODULE: ./node_modules/ol/render/webgl/circlereplay/defaultshader.js
// This file is automatically generated, do not edit



var _ol_render_webgl_circlereplay_defaultshader_ = {};

_ol_render_webgl_circlereplay_defaultshader_.fragment = new fragment(ol["a" /* default */].DEBUG_WEBGL ? 'precision mediump float;\nvarying vec2 v_center;\nvarying vec2 v_offset;\nvarying float v_halfWidth;\nvarying float v_pixelRatio;\n\n\n\nuniform float u_opacity;\nuniform vec4 u_fillColor;\nuniform vec4 u_strokeColor;\nuniform vec2 u_size;\n\nvoid main(void) {\n  vec2 windowCenter = vec2((v_center.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\n      (v_center.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\n  vec2 windowOffset = vec2((v_offset.x + 1.0) / 2.0 * u_size.x * v_pixelRatio,\n      (v_offset.y + 1.0) / 2.0 * u_size.y * v_pixelRatio);\n  float radius = length(windowCenter - windowOffset);\n  float dist = length(windowCenter - gl_FragCoord.xy);\n  if (dist > radius + v_halfWidth) {\n    if (u_strokeColor.a == 0.0) {\n      gl_FragColor = u_fillColor;\n    } else {\n      gl_FragColor = u_strokeColor;\n    }\n    gl_FragColor.a = gl_FragColor.a - (dist - (radius + v_halfWidth));\n  } else if (u_fillColor.a == 0.0) {\n    // Hooray, no fill, just stroke. We can use real antialiasing.\n    gl_FragColor = u_strokeColor;\n    if (dist < radius - v_halfWidth) {\n      gl_FragColor.a = gl_FragColor.a - (radius - v_halfWidth - dist);\n    }\n  } else {\n    gl_FragColor = u_fillColor;\n    float strokeDist = radius - v_halfWidth;\n    float antialias = 2.0 * v_pixelRatio;\n    if (dist > strokeDist) {\n      gl_FragColor = u_strokeColor;\n    } else if (dist >= strokeDist - antialias) {\n      float step = smoothstep(strokeDist - antialias, strokeDist, dist);\n      gl_FragColor = mix(u_fillColor, u_strokeColor, step);\n    }\n  }\n  gl_FragColor.a = gl_FragColor.a * u_opacity;\n  if (gl_FragColor.a <= 0.0) {\n    discard;\n  }\n}\n' : 'precision mediump float;varying vec2 a;varying vec2 b;varying float c;varying float d;uniform float m;uniform vec4 n;uniform vec4 o;uniform vec2 p;void main(void){vec2 windowCenter=vec2((a.x+1.0)/2.0*p.x*d,(a.y+1.0)/2.0*p.y*d);vec2 windowOffset=vec2((b.x+1.0)/2.0*p.x*d,(b.y+1.0)/2.0*p.y*d);float radius=length(windowCenter-windowOffset);float dist=length(windowCenter-gl_FragCoord.xy);if(dist>radius+c){if(o.a==0.0){gl_FragColor=n;}else{gl_FragColor=o;}gl_FragColor.a=gl_FragColor.a-(dist-(radius+c));}else if(n.a==0.0){gl_FragColor=o;if(dist<radius-c){gl_FragColor.a=gl_FragColor.a-(radius-c-dist);}} else{gl_FragColor=n;float strokeDist=radius-c;float antialias=2.0*d;if(dist>strokeDist){gl_FragColor=o;}else if(dist>=strokeDist-antialias){float step=smoothstep(strokeDist-antialias,strokeDist,dist);gl_FragColor=mix(n,o,step);}} gl_FragColor.a=gl_FragColor.a*m;if(gl_FragColor.a<=0.0){discard;}}');

_ol_render_webgl_circlereplay_defaultshader_.vertex = new vertex(ol["a" /* default */].DEBUG_WEBGL ? 'varying vec2 v_center;\nvarying vec2 v_offset;\nvarying float v_halfWidth;\nvarying float v_pixelRatio;\n\n\nattribute vec2 a_position;\nattribute float a_instruction;\nattribute float a_radius;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_lineWidth;\nuniform float u_pixelRatio;\n\nvoid main(void) {\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  v_center = vec4(u_projectionMatrix * vec4(a_position, 0.0, 1.0)).xy;\n  v_pixelRatio = u_pixelRatio;\n  float lineWidth = u_lineWidth * u_pixelRatio;\n  v_halfWidth = lineWidth / 2.0;\n  if (lineWidth == 0.0) {\n    lineWidth = 2.0 * u_pixelRatio;\n  }\n  vec2 offset;\n  // Radius with anitaliasing (roughly).\n  float radius = a_radius + 3.0 * u_pixelRatio;\n  // Until we get gl_VertexID in WebGL, we store an instruction.\n  if (a_instruction == 0.0) {\n    // Offsetting the edges of the triangle by lineWidth / 2 is necessary, however\n    // we should also leave some space for the antialiasing, thus we offset by lineWidth.\n    offset = vec2(-1.0, 1.0);\n  } else if (a_instruction == 1.0) {\n    offset = vec2(-1.0, -1.0);\n  } else if (a_instruction == 2.0) {\n    offset = vec2(1.0, -1.0);\n  } else {\n    offset = vec2(1.0, 1.0);\n  }\n\n  gl_Position = u_projectionMatrix * vec4(a_position + offset * radius, 0.0, 1.0) +\n      offsetMatrix * vec4(offset * lineWidth, 0.0, 0.0);\n  v_offset = vec4(u_projectionMatrix * vec4(a_position.x + a_radius, a_position.y,\n      0.0, 1.0)).xy;\n\n  if (distance(v_center, v_offset) > 20000.0) {\n    gl_Position = vec4(v_center, 0.0, 1.0);\n  }\n}\n\n\n' : 'varying vec2 a;varying vec2 b;varying float c;varying float d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;void main(void){mat4 offsetMatrix=i*j;a=vec4(h*vec4(e,0.0,1.0)).xy;d=l;float lineWidth=k*l;c=lineWidth/2.0;if(lineWidth==0.0){lineWidth=2.0*l;}vec2 offset;float radius=g+3.0*l;//Until we get gl_VertexID in WebGL,we store an instruction.if(f==0.0){//Offsetting the edges of the triangle by lineWidth/2 is necessary,however//we should also leave some space for the antialiasing,thus we offset by lineWidth.offset=vec2(-1.0,1.0);}else if(f==1.0){offset=vec2(-1.0,-1.0);}else if(f==2.0){offset=vec2(1.0,-1.0);}else{offset=vec2(1.0,1.0);}gl_Position=h*vec4(e+offset*radius,0.0,1.0)+offsetMatrix*vec4(offset*lineWidth,0.0,0.0);b=vec4(h*vec4(e.x+g,e.y,0.0,1.0)).xy;if(distance(a,b)>20000.0){gl_Position=vec4(a,0.0,1.0);}}');
/* harmony default export */ var defaultshader = (_ol_render_webgl_circlereplay_defaultshader_);
// CONCATENATED MODULE: ./node_modules/ol/render/webgl/circlereplay/defaultshader/locations.js
// This file is automatically generated, do not edit


/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */
var locations__ol_render_webgl_circlereplay_defaultshader_Locations_ = function _ol_render_webgl_circlereplay_defaultshader_Locations_(gl, program) {

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_projectionMatrix = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_projectionMatrix' : 'h');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_offsetScaleMatrix = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'i');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_offsetRotateMatrix = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'j');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_lineWidth = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_lineWidth' : 'k');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_pixelRatio = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_pixelRatio' : 'l');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_opacity = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_opacity' : 'm');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_fillColor = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_fillColor' : 'n');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_strokeColor = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_strokeColor' : 'o');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_size = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_size' : 'p');

  /**
   * @type {number}
   */
  this.a_position = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_position' : 'e');

  /**
   * @type {number}
   */
  this.a_instruction = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_instruction' : 'f');

  /**
   * @type {number}
   */
  this.a_radius = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_radius' : 'g');
};

/* harmony default export */ var defaultshader_locations = (locations__ol_render_webgl_circlereplay_defaultshader_Locations_);
// CONCATENATED MODULE: ./node_modules/ol/vec/mat4.js
var _ol_vec_Mat4_ = {};

/**
 * @return {Array.<number>} 4x4 matrix representing a 3D identity transform.
 */
_ol_vec_Mat4_.create = function () {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
};

/**
 * @param {Array.<number>} mat4 Flattened 4x4 matrix receiving the result.
 * @param {ol.Transform} transform Transformation matrix.
 * @return {Array.<number>} 2D transformation matrix as flattened 4x4 matrix.
 */
_ol_vec_Mat4_.fromTransform = function (mat4, transform) {
  mat4[0] = transform[0];
  mat4[1] = transform[1];
  mat4[4] = transform[2];
  mat4[5] = transform[3];
  mat4[12] = transform[4];
  mat4[13] = transform[5];
  return mat4;
};
/* harmony default export */ var mat4 = (_ol_vec_Mat4_);
// CONCATENATED MODULE: ./node_modules/ol/render/webgl/replay.js







/**
 * @constructor
 * @abstract
 * @extends {ol.render.VectorContext}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */
var replay__ol_render_webgl_Replay_ = function _ol_render_webgl_Replay_(tolerance, maxExtent) {
  vectorcontext.call(this);

  /**
   * @protected
   * @type {number}
   */
  this.tolerance = tolerance;

  /**
   * @protected
   * @const
   * @type {ol.Extent}
   */
  this.maxExtent = maxExtent;

  /**
   * The origin of the coordinate system for the point coordinates sent to
   * the GPU. To eliminate jitter caused by precision problems in the GPU
   * we use the "Rendering Relative to Eye" technique described in the "3D
   * Engine Design for Virtual Globes" book.
   * @protected
   * @type {ol.Coordinate}
   */
  this.origin = ol_extent["a" /* default */].getCenter(maxExtent);

  /**
   * @private
   * @type {ol.Transform}
   */
  this.projectionMatrix_ = ol_transform["a" /* default */].create();

  /**
   * @private
   * @type {ol.Transform}
   */
  this.offsetRotateMatrix_ = ol_transform["a" /* default */].create();

  /**
   * @private
   * @type {ol.Transform}
   */
  this.offsetScaleMatrix_ = ol_transform["a" /* default */].create();

  /**
   * @private
   * @type {Array.<number>}
   */
  this.tmpMat4_ = mat4.create();

  /**
   * @protected
   * @type {Array.<number>}
   */
  this.indices = [];

  /**
   * @protected
   * @type {?ol.webgl.Buffer}
   */
  this.indicesBuffer = null;

  /**
   * Start index per feature (the index).
   * @protected
   * @type {Array.<number>}
   */
  this.startIndices = [];

  /**
   * Start index per feature (the feature).
   * @protected
   * @type {Array.<ol.Feature|ol.render.Feature>}
   */
  this.startIndicesFeature = [];

  /**
   * @protected
   * @type {Array.<number>}
   */
  this.vertices = [];

  /**
   * @protected
   * @type {?ol.webgl.Buffer}
   */
  this.verticesBuffer = null;

  /**
   * Optional parameter for PolygonReplay instances.
   * @protected
   * @type {ol.render.webgl.LineStringReplay|undefined}
   */
  this.lineStringReplay = undefined;
};

ol["a" /* default */].inherits(replay__ol_render_webgl_Replay_, vectorcontext);

/**
 * @abstract
 * @param {ol.webgl.Context} context WebGL context.
 * @return {function()} Delete resources function.
 */
replay__ol_render_webgl_Replay_.prototype.getDeleteResourcesFunction = function (context) {};

/**
 * @abstract
 * @param {ol.webgl.Context} context Context.
 */
replay__ol_render_webgl_Replay_.prototype.finish = function (context) {};

/**
 * @abstract
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @return {ol.render.webgl.circlereplay.defaultshader.Locations|
            ol.render.webgl.linestringreplay.defaultshader.Locations|
            ol.render.webgl.polygonreplay.defaultshader.Locations|
            ol.render.webgl.texturereplay.defaultshader.Locations} Locations.
 */
replay__ol_render_webgl_Replay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {};

/**
 * @abstract
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.render.webgl.circlereplay.defaultshader.Locations|
           ol.render.webgl.linestringreplay.defaultshader.Locations|
           ol.render.webgl.polygonreplay.defaultshader.Locations|
           ol.render.webgl.texturereplay.defaultshader.Locations} locations Locations.
 */
replay__ol_render_webgl_Replay_.prototype.shutDownProgram = function (gl, locations) {};

/**
 * @abstract
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {boolean} hitDetection Hit detection mode.
 */
replay__ol_render_webgl_Replay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {};

/**
 * @abstract
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
 * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
 *  this extent are checked.
 * @return {T|undefined} Callback result.
 * @template T
 */
replay__ol_render_webgl_Replay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {};

/**
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
 * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.
 * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
 *  this extent are checked.
 * @return {T|undefined} Callback result.
 * @template T
 */
replay__ol_render_webgl_Replay_.prototype.drawHitDetectionReplay = function (gl, context, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {
  if (!oneByOne) {
    // draw all hit-detection features in "once" (by texture group)
    return this.drawHitDetectionReplayAll(gl, context, skippedFeaturesHash, featureCallback);
  } else {
    // draw hit-detection features one by one
    return this.drawHitDetectionReplayOneByOne(gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent);
  }
};

/**
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
 * @return {T|undefined} Callback result.
 * @template T
 */
replay__ol_render_webgl_Replay_.prototype.drawHitDetectionReplayAll = function (gl, context, skippedFeaturesHash, featureCallback) {
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  this.drawReplay(gl, context, skippedFeaturesHash, true);

  var result = featureCallback(null);
  if (result) {
    return result;
  } else {
    return undefined;
  }
};

/**
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} opacity Global opacity.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
 * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.
 * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
 *  this extent are checked.
 * @return {T|undefined} Callback result.
 * @template T
 */
replay__ol_render_webgl_Replay_.prototype.replay = function (context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {
  var gl = context.getGL();
  var tmpStencil, tmpStencilFunc, tmpStencilMaskVal, tmpStencilRef, tmpStencilMask, tmpStencilOpFail, tmpStencilOpPass, tmpStencilOpZFail;

  if (this.lineStringReplay) {
    tmpStencil = gl.isEnabled(gl.STENCIL_TEST);
    tmpStencilFunc = gl.getParameter(gl.STENCIL_FUNC);
    tmpStencilMaskVal = gl.getParameter(gl.STENCIL_VALUE_MASK);
    tmpStencilRef = gl.getParameter(gl.STENCIL_REF);
    tmpStencilMask = gl.getParameter(gl.STENCIL_WRITEMASK);
    tmpStencilOpFail = gl.getParameter(gl.STENCIL_FAIL);
    tmpStencilOpPass = gl.getParameter(gl.STENCIL_PASS_DEPTH_PASS);
    tmpStencilOpZFail = gl.getParameter(gl.STENCIL_PASS_DEPTH_FAIL);

    gl.enable(gl.STENCIL_TEST);
    gl.clear(gl.STENCIL_BUFFER_BIT);
    gl.stencilMask(255);
    gl.stencilFunc(gl.ALWAYS, 1, 255);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);

    this.lineStringReplay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);

    gl.stencilMask(0);
    gl.stencilFunc(gl.NOTEQUAL, 1, 255);
  }

  context.bindBuffer(webgl["a" /* default */].ARRAY_BUFFER, this.verticesBuffer);

  context.bindBuffer(webgl["a" /* default */].ELEMENT_ARRAY_BUFFER, this.indicesBuffer);

  var locations = this.setUpProgram(gl, context, size, pixelRatio);

  // set the "uniform" values
  var projectionMatrix = ol_transform["a" /* default */].reset(this.projectionMatrix_);
  ol_transform["a" /* default */].scale(projectionMatrix, 2 / (resolution * size[0]), 2 / (resolution * size[1]));
  ol_transform["a" /* default */].rotate(projectionMatrix, -rotation);
  ol_transform["a" /* default */].translate(projectionMatrix, -(center[0] - this.origin[0]), -(center[1] - this.origin[1]));

  var offsetScaleMatrix = ol_transform["a" /* default */].reset(this.offsetScaleMatrix_);
  ol_transform["a" /* default */].scale(offsetScaleMatrix, 2 / size[0], 2 / size[1]);

  var offsetRotateMatrix = ol_transform["a" /* default */].reset(this.offsetRotateMatrix_);
  if (rotation !== 0) {
    ol_transform["a" /* default */].rotate(offsetRotateMatrix, -rotation);
  }

  gl.uniformMatrix4fv(locations.u_projectionMatrix, false, mat4.fromTransform(this.tmpMat4_, projectionMatrix));
  gl.uniformMatrix4fv(locations.u_offsetScaleMatrix, false, mat4.fromTransform(this.tmpMat4_, offsetScaleMatrix));
  gl.uniformMatrix4fv(locations.u_offsetRotateMatrix, false, mat4.fromTransform(this.tmpMat4_, offsetRotateMatrix));
  gl.uniform1f(locations.u_opacity, opacity);

  // draw!
  var result;
  if (featureCallback === undefined) {
    this.drawReplay(gl, context, skippedFeaturesHash, false);
  } else {
    // draw feature by feature for the hit-detection
    result = this.drawHitDetectionReplay(gl, context, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);
  }

  // disable the vertex attrib arrays
  this.shutDownProgram(gl, locations);

  if (this.lineStringReplay) {
    if (!tmpStencil) {
      gl.disable(gl.STENCIL_TEST);
    }
    gl.clear(gl.STENCIL_BUFFER_BIT);
    gl.stencilFunc( /** @type {number} */tmpStencilFunc,
    /** @type {number} */tmpStencilRef, /** @type {number} */tmpStencilMaskVal);
    gl.stencilMask( /** @type {number} */tmpStencilMask);
    gl.stencilOp( /** @type {number} */tmpStencilOpFail,
    /** @type {number} */tmpStencilOpZFail, /** @type {number} */tmpStencilOpPass);
  }

  return result;
};

/**
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {number} start Start index.
 * @param {number} end End index.
 */
replay__ol_render_webgl_Replay_.prototype.drawElements = function (gl, context, start, end) {
  var elementType = context.hasOESElementIndexUint ? webgl["a" /* default */].UNSIGNED_INT : webgl["a" /* default */].UNSIGNED_SHORT;
  var elementSize = context.hasOESElementIndexUint ? 4 : 2;

  var numItems = end - start;
  var offsetInBytes = start * elementSize;
  gl.drawElements(webgl["a" /* default */].TRIANGLES, numItems, elementType, offsetInBytes);
};
/* harmony default export */ var webgl_replay = (replay__ol_render_webgl_Replay_);
// CONCATENATED MODULE: ./node_modules/ol/render/webgl.js
var _ol_render_webgl_ = {};

/**
 * @const
 * @type {string}
 */
_ol_render_webgl_.defaultFont = '10px sans-serif';

/**
 * @const
 * @type {ol.Color}
 */
_ol_render_webgl_.defaultFillStyle = [0.0, 0.0, 0.0, 1.0];

/**
 * @const
 * @type {string}
 */
_ol_render_webgl_.defaultLineCap = 'round';

/**
 * @const
 * @type {Array.<number>}
 */
_ol_render_webgl_.defaultLineDash = [];

/**
 * @const
 * @type {number}
 */
_ol_render_webgl_.defaultLineDashOffset = 0;

/**
 * @const
 * @type {string}
 */
_ol_render_webgl_.defaultLineJoin = 'round';

/**
 * @const
 * @type {number}
 */
_ol_render_webgl_.defaultMiterLimit = 10;

/**
 * @const
 * @type {ol.Color}
 */
_ol_render_webgl_.defaultStrokeStyle = [0.0, 0.0, 0.0, 1.0];

/**
 * @const
 * @type {number}
 */
_ol_render_webgl_.defaultTextAlign = 0.5;

/**
 * @const
 * @type {number}
 */
_ol_render_webgl_.defaultTextBaseline = 0.5;

/**
 * @const
 * @type {number}
 */
_ol_render_webgl_.defaultLineWidth = 1;

/**
 * Calculates the orientation of a triangle based on the determinant method.
 * @param {number} x1 First X coordinate.
 * @param {number} y1 First Y coordinate.
 * @param {number} x2 Second X coordinate.
 * @param {number} y2 Second Y coordinate.
 * @param {number} x3 Third X coordinate.
 * @param {number} y3 Third Y coordinate.
 * @return {boolean|undefined} Triangle is clockwise.
 */
_ol_render_webgl_.triangleIsCounterClockwise = function (x1, y1, x2, y2, x3, y3) {
  var area = (x2 - x1) * (y3 - y1) - (x3 - x1) * (y2 - y1);
  return area <= _ol_render_webgl_.EPSILON && area >= -_ol_render_webgl_.EPSILON ? undefined : area > 0;
};

/**
 * @const
 * @type {number}
 */
_ol_render_webgl_.EPSILON = Number.EPSILON || 2.220446049250313e-16;
/* harmony default export */ var render_webgl = (_ol_render_webgl_);
// CONCATENATED MODULE: ./node_modules/ol/webgl/buffer.js


/**
 * @constructor
 * @param {Array.<number>=} opt_arr Array.
 * @param {number=} opt_usage Usage.
 * @struct
 */
var _ol_webgl_Buffer_ = function _ol_webgl_Buffer_(opt_arr, opt_usage) {

  /**
   * @private
   * @type {Array.<number>}
   */
  this.arr_ = opt_arr !== undefined ? opt_arr : [];

  /**
   * @private
   * @type {number}
   */
  this.usage_ = opt_usage !== undefined ? opt_usage : _ol_webgl_Buffer_.Usage_.STATIC_DRAW;
};

/**
 * @return {Array.<number>} Array.
 */
_ol_webgl_Buffer_.prototype.getArray = function () {
  return this.arr_;
};

/**
 * @return {number} Usage.
 */
_ol_webgl_Buffer_.prototype.getUsage = function () {
  return this.usage_;
};

/**
 * @enum {number}
 * @private
 */
_ol_webgl_Buffer_.Usage_ = {
  STATIC_DRAW: webgl["a" /* default */].STATIC_DRAW,
  STREAM_DRAW: webgl["a" /* default */].STREAM_DRAW,
  DYNAMIC_DRAW: webgl["a" /* default */].DYNAMIC_DRAW
};
/* harmony default export */ var webgl_buffer = (_ol_webgl_Buffer_);
// CONCATENATED MODULE: ./node_modules/ol/render/webgl/circlereplay.js













/**
 * @constructor
 * @extends {ol.render.webgl.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */
var circlereplay__ol_render_webgl_CircleReplay_ = function _ol_render_webgl_CircleReplay_(tolerance, maxExtent) {
  webgl_replay.call(this, tolerance, maxExtent);

  /**
   * @private
   * @type {ol.render.webgl.circlereplay.defaultshader.Locations}
   */
  this.defaultLocations_ = null;

  /**
   * @private
   * @type {Array.<Array.<Array.<number>|number>>}
   */
  this.styles_ = [];

  /**
   * @private
   * @type {Array.<number>}
   */
  this.styleIndices_ = [];

  /**
   * @private
   * @type {number}
   */
  this.radius_ = 0;

  /**
   * @private
   * @type {{fillColor: (Array.<number>|null),
   *         strokeColor: (Array.<number>|null),
   *         lineDash: Array.<number>,
   *         lineDashOffset: (number|undefined),
   *         lineWidth: (number|undefined),
   *         changed: boolean}|null}
   */
  this.state_ = {
    fillColor: null,
    strokeColor: null,
    lineDash: null,
    lineDashOffset: undefined,
    lineWidth: undefined,
    changed: false
  };
};

ol["a" /* default */].inherits(circlereplay__ol_render_webgl_CircleReplay_, webgl_replay);

/**
 * @private
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
circlereplay__ol_render_webgl_CircleReplay_.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {
  var numVertices = this.vertices.length;
  var numIndices = this.indices.length;
  var n = numVertices / 4;
  var i, ii;
  for (i = offset, ii = end; i < ii; i += stride) {
    this.vertices[numVertices++] = flatCoordinates[i];
    this.vertices[numVertices++] = flatCoordinates[i + 1];
    this.vertices[numVertices++] = 0;
    this.vertices[numVertices++] = this.radius_;

    this.vertices[numVertices++] = flatCoordinates[i];
    this.vertices[numVertices++] = flatCoordinates[i + 1];
    this.vertices[numVertices++] = 1;
    this.vertices[numVertices++] = this.radius_;

    this.vertices[numVertices++] = flatCoordinates[i];
    this.vertices[numVertices++] = flatCoordinates[i + 1];
    this.vertices[numVertices++] = 2;
    this.vertices[numVertices++] = this.radius_;

    this.vertices[numVertices++] = flatCoordinates[i];
    this.vertices[numVertices++] = flatCoordinates[i + 1];
    this.vertices[numVertices++] = 3;
    this.vertices[numVertices++] = this.radius_;

    this.indices[numIndices++] = n;
    this.indices[numIndices++] = n + 1;
    this.indices[numIndices++] = n + 2;

    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n + 3;
    this.indices[numIndices++] = n;

    n += 4;
  }
};

/**
 * @inheritDoc
 */
circlereplay__ol_render_webgl_CircleReplay_.prototype.drawCircle = function (circleGeometry, feature) {
  var radius = circleGeometry.getRadius();
  var stride = circleGeometry.getStride();
  if (radius) {
    this.startIndices.push(this.indices.length);
    this.startIndicesFeature.push(feature);
    if (this.state_.changed) {
      this.styleIndices_.push(this.indices.length);
      this.state_.changed = false;
    }

    this.radius_ = radius;
    var flatCoordinates = circleGeometry.getFlatCoordinates();
    flatCoordinates = flat_transform["a" /* default */].translate(flatCoordinates, 0, 2, stride, -this.origin[0], -this.origin[1]);
    this.drawCoordinates_(flatCoordinates, 0, 2, stride);
  } else {
    if (this.state_.changed) {
      this.styles_.pop();
      if (this.styles_.length) {
        var lastState = this.styles_[this.styles_.length - 1];
        this.state_.fillColor = /** @type {Array.<number>} */lastState[0];
        this.state_.strokeColor = /** @type {Array.<number>} */lastState[1];
        this.state_.lineWidth = /** @type {number} */lastState[2];
        this.state_.changed = false;
      }
    }
  }
};

/**
 * @inheritDoc
 **/
circlereplay__ol_render_webgl_CircleReplay_.prototype.finish = function (context) {
  // create, bind, and populate the vertices buffer
  this.verticesBuffer = new webgl_buffer(this.vertices);

  // create, bind, and populate the indices buffer
  this.indicesBuffer = new webgl_buffer(this.indices);

  this.startIndices.push(this.indices.length);

  //Clean up, if there is nothing to draw
  if (this.styleIndices_.length === 0 && this.styles_.length > 0) {
    this.styles_ = [];
  }

  this.vertices = null;
  this.indices = null;
};

/**
 * @inheritDoc
 */
circlereplay__ol_render_webgl_CircleReplay_.prototype.getDeleteResourcesFunction = function (context) {
  // We only delete our stuff here. The shaders and the program may
  // be used by other CircleReplay instances (for other layers). And
  // they will be deleted when disposing of the ol.webgl.Context
  // object.
  var verticesBuffer = this.verticesBuffer;
  var indicesBuffer = this.indicesBuffer;
  return function () {
    context.deleteBuffer(verticesBuffer);
    context.deleteBuffer(indicesBuffer);
  };
};

/**
 * @inheritDoc
 */
circlereplay__ol_render_webgl_CircleReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {
  // get the program
  var fragmentShader, vertexShader;
  fragmentShader = defaultshader.fragment;
  vertexShader = defaultshader.vertex;
  var program = context.getProgram(fragmentShader, vertexShader);

  // get the locations
  var locations;
  if (!this.defaultLocations_) {
    locations = new defaultshader_locations(gl, program);
    this.defaultLocations_ = locations;
  } else {
    locations = this.defaultLocations_;
  }

  context.useProgram(program);

  // enable the vertex attrib arrays
  gl.enableVertexAttribArray(locations.a_position);
  gl.vertexAttribPointer(locations.a_position, 2, webgl["a" /* default */].FLOAT, false, 16, 0);

  gl.enableVertexAttribArray(locations.a_instruction);
  gl.vertexAttribPointer(locations.a_instruction, 1, webgl["a" /* default */].FLOAT, false, 16, 8);

  gl.enableVertexAttribArray(locations.a_radius);
  gl.vertexAttribPointer(locations.a_radius, 1, webgl["a" /* default */].FLOAT, false, 16, 12);

  // Enable renderer specific uniforms.
  gl.uniform2fv(locations.u_size, size);
  gl.uniform1f(locations.u_pixelRatio, pixelRatio);

  return locations;
};

/**
 * @inheritDoc
 */
circlereplay__ol_render_webgl_CircleReplay_.prototype.shutDownProgram = function (gl, locations) {
  gl.disableVertexAttribArray(locations.a_position);
  gl.disableVertexAttribArray(locations.a_instruction);
  gl.disableVertexAttribArray(locations.a_radius);
};

/**
 * @inheritDoc
 */
circlereplay__ol_render_webgl_CircleReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {
  if (!obj["a" /* default */].isEmpty(skippedFeaturesHash)) {
    this.drawReplaySkipping_(gl, context, skippedFeaturesHash);
  } else {
    //Draw by style groups to minimize drawElements() calls.
    var i, start, end, nextStyle;
    end = this.startIndices[this.startIndices.length - 1];
    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      start = this.styleIndices_[i];
      nextStyle = this.styles_[i];
      this.setFillStyle_(gl, /** @type {Array.<number>} */nextStyle[0]);
      this.setStrokeStyle_(gl, /** @type {Array.<number>} */nextStyle[1],
      /** @type {number} */nextStyle[2]);
      this.drawElements(gl, context, start, end);
      end = start;
    }
  }
};

/**
 * @inheritDoc
 */
circlereplay__ol_render_webgl_CircleReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;
  featureIndex = this.startIndices.length - 2;
  end = this.startIndices[featureIndex + 1];
  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setFillStyle_(gl, /** @type {Array.<number>} */nextStyle[0]);
    this.setStrokeStyle_(gl, /** @type {Array.<number>} */nextStyle[1],
    /** @type {number} */nextStyle[2]);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      start = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = ol["a" /* default */].getUid(feature).toString();

      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || ol_extent["a" /* default */].intersects(
      /** @type {Array<number>} */opt_hitExtent, feature.getGeometry().getExtent()))) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.drawElements(gl, context, start, end);

        var result = featureCallback(feature);

        if (result) {
          return result;
        }
      }
      featureIndex--;
      end = start;
    }
  }
  return undefined;
};

/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object} skippedFeaturesHash Ids of features to skip.
 */
circlereplay__ol_render_webgl_CircleReplay_.prototype.drawReplaySkipping_ = function (gl, context, skippedFeaturesHash) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;
  featureIndex = this.startIndices.length - 2;
  end = start = this.startIndices[featureIndex + 1];
  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setFillStyle_(gl, /** @type {Array.<number>} */nextStyle[0]);
    this.setStrokeStyle_(gl, /** @type {Array.<number>} */nextStyle[1],
    /** @type {number} */nextStyle[2]);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      featureStart = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = ol["a" /* default */].getUid(feature).toString();

      if (skippedFeaturesHash[featureUid]) {
        if (start !== end) {
          this.drawElements(gl, context, start, end);
        }
        end = featureStart;
      }
      featureIndex--;
      start = featureStart;
    }
    if (start !== end) {
      this.drawElements(gl, context, start, end);
    }
    start = end = groupStart;
  }
};

/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {Array.<number>} color Color.
 */
circlereplay__ol_render_webgl_CircleReplay_.prototype.setFillStyle_ = function (gl, color) {
  gl.uniform4fv(this.defaultLocations_.u_fillColor, color);
};

/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {Array.<number>} color Color.
 * @param {number} lineWidth Line width.
 */
circlereplay__ol_render_webgl_CircleReplay_.prototype.setStrokeStyle_ = function (gl, color, lineWidth) {
  gl.uniform4fv(this.defaultLocations_.u_strokeColor, color);
  gl.uniform1f(this.defaultLocations_.u_lineWidth, lineWidth);
};

/**
 * @inheritDoc
 */
circlereplay__ol_render_webgl_CircleReplay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  var strokeStyleColor, strokeStyleWidth;
  if (strokeStyle) {
    var strokeStyleLineDash = strokeStyle.getLineDash();
    this.state_.lineDash = strokeStyleLineDash ? strokeStyleLineDash : render_webgl.defaultLineDash;
    var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
    this.state_.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : render_webgl.defaultLineDashOffset;
    strokeStyleColor = strokeStyle.getColor();
    if (!(strokeStyleColor instanceof CanvasGradient) && !(strokeStyleColor instanceof CanvasPattern)) {
      strokeStyleColor = color["a" /* default */].asArray(strokeStyleColor).map(function (c, i) {
        return i != 3 ? c / 255 : c;
      }) || render_webgl.defaultStrokeStyle;
    } else {
      strokeStyleColor = render_webgl.defaultStrokeStyle;
    }
    strokeStyleWidth = strokeStyle.getWidth();
    strokeStyleWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : render_webgl.defaultLineWidth;
  } else {
    strokeStyleColor = [0, 0, 0, 0];
    strokeStyleWidth = 0;
  }
  var fillStyleColor = fillStyle ? fillStyle.getColor() : [0, 0, 0, 0];
  if (!(fillStyleColor instanceof CanvasGradient) && !(fillStyleColor instanceof CanvasPattern)) {
    fillStyleColor = color["a" /* default */].asArray(fillStyleColor).map(function (c, i) {
      return i != 3 ? c / 255 : c;
    }) || render_webgl.defaultFillStyle;
  } else {
    fillStyleColor = render_webgl.defaultFillStyle;
  }
  if (!this.state_.strokeColor || !array["a" /* default */].equals(this.state_.strokeColor, strokeStyleColor) || !this.state_.fillColor || !array["a" /* default */].equals(this.state_.fillColor, fillStyleColor) || this.state_.lineWidth !== strokeStyleWidth) {
    this.state_.changed = true;
    this.state_.fillColor = fillStyleColor;
    this.state_.strokeColor = strokeStyleColor;
    this.state_.lineWidth = strokeStyleWidth;
    this.styles_.push([fillStyleColor, strokeStyleColor, strokeStyleWidth]);
  }
};
/* harmony default export */ var circlereplay = (circlereplay__ol_render_webgl_CircleReplay_);
// CONCATENATED MODULE: ./node_modules/ol/render/webgl/texturereplay/defaultshader.js
// This file is automatically generated, do not edit



var _ol_render_webgl_texturereplay_defaultshader_ = {};

_ol_render_webgl_texturereplay_defaultshader_.fragment = new fragment(ol["a" /* default */].DEBUG_WEBGL ? 'precision mediump float;\nvarying vec2 v_texCoord;\nvarying float v_opacity;\n\nuniform float u_opacity;\nuniform sampler2D u_image;\n\nvoid main(void) {\n  vec4 texColor = texture2D(u_image, v_texCoord);\n  gl_FragColor.rgb = texColor.rgb;\n  float alpha = texColor.a * v_opacity * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n' : 'precision mediump float;varying vec2 a;varying float b;uniform float k;uniform sampler2D l;void main(void){vec4 texColor=texture2D(l,a);gl_FragColor.rgb=texColor.rgb;float alpha=texColor.a*b*k;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}');

_ol_render_webgl_texturereplay_defaultshader_.vertex = new vertex(ol["a" /* default */].DEBUG_WEBGL ? 'varying vec2 v_texCoord;\nvarying float v_opacity;\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nattribute vec2 a_offsets;\nattribute float a_opacity;\nattribute float a_rotateWithView;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\n\nvoid main(void) {\n  mat4 offsetMatrix = u_offsetScaleMatrix;\n  if (a_rotateWithView == 1.0) {\n    offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  }\n  vec4 offsets = offsetMatrix * vec4(a_offsets, 0.0, 0.0);\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0) + offsets;\n  v_texCoord = a_texCoord;\n  v_opacity = a_opacity;\n}\n\n\n' : 'varying vec2 a;varying float b;attribute vec2 c;attribute vec2 d;attribute vec2 e;attribute float f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;void main(void){mat4 offsetMatrix=i;if(g==1.0){offsetMatrix=i*j;}vec4 offsets=offsetMatrix*vec4(e,0.0,0.0);gl_Position=h*vec4(c,0.0,1.0)+offsets;a=d;b=f;}');
/* harmony default export */ var texturereplay_defaultshader = (_ol_render_webgl_texturereplay_defaultshader_);
// CONCATENATED MODULE: ./node_modules/ol/render/webgl/texturereplay/defaultshader/locations.js
// This file is automatically generated, do not edit


/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */
var locations__ol_render_webgl_texturereplay_defaultshader_Locations_ = function _ol_render_webgl_texturereplay_defaultshader_Locations_(gl, program) {

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_projectionMatrix = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_projectionMatrix' : 'h');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_offsetScaleMatrix = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'i');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_offsetRotateMatrix = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'j');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_opacity = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_opacity' : 'k');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_image = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_image' : 'l');

  /**
   * @type {number}
   */
  this.a_position = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_position' : 'c');

  /**
   * @type {number}
   */
  this.a_texCoord = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_texCoord' : 'd');

  /**
   * @type {number}
   */
  this.a_offsets = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_offsets' : 'e');

  /**
   * @type {number}
   */
  this.a_opacity = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_opacity' : 'f');

  /**
   * @type {number}
   */
  this.a_rotateWithView = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_rotateWithView' : 'g');
};

/* harmony default export */ var texturereplay_defaultshader_locations = (locations__ol_render_webgl_texturereplay_defaultshader_Locations_);
// CONCATENATED MODULE: ./node_modules/ol/webgl/contexteventtype.js
/**
 * @enum {string}
 */
var _ol_webgl_ContextEventType_ = {
  LOST: 'webglcontextlost',
  RESTORED: 'webglcontextrestored'
};

/* harmony default export */ var contexteventtype = (_ol_webgl_ContextEventType_);
// CONCATENATED MODULE: ./node_modules/ol/webgl/context.js








/**
 * @classdesc
 * A WebGL context for accessing low-level WebGL capabilities.
 *
 * @constructor
 * @extends {ol.Disposable}
 * @param {HTMLCanvasElement} canvas Canvas.
 * @param {WebGLRenderingContext} gl GL.
 */
var context__ol_webgl_Context_ = function _ol_webgl_Context_(canvas, gl) {

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = canvas;

  /**
   * @private
   * @type {WebGLRenderingContext}
   */
  this.gl_ = gl;

  /**
   * @private
   * @type {Object.<string, ol.WebglBufferCacheEntry>}
   */
  this.bufferCache_ = {};

  /**
   * @private
   * @type {Object.<string, WebGLShader>}
   */
  this.shaderCache_ = {};

  /**
   * @private
   * @type {Object.<string, WebGLProgram>}
   */
  this.programCache_ = {};

  /**
   * @private
   * @type {WebGLProgram}
   */
  this.currentProgram_ = null;

  /**
   * @private
   * @type {WebGLFramebuffer}
   */
  this.hitDetectionFramebuffer_ = null;

  /**
   * @private
   * @type {WebGLTexture}
   */
  this.hitDetectionTexture_ = null;

  /**
   * @private
   * @type {WebGLRenderbuffer}
   */
  this.hitDetectionRenderbuffer_ = null;

  /**
   * @type {boolean}
   */
  this.hasOESElementIndexUint = array["a" /* default */].includes(ol["a" /* default */].WEBGL_EXTENSIONS, 'OES_element_index_uint');

  // use the OES_element_index_uint extension if available
  if (this.hasOESElementIndexUint) {
    gl.getExtension('OES_element_index_uint');
  }

  ol_events["a" /* default */].listen(this.canvas_, contexteventtype.LOST, this.handleWebGLContextLost, this);
  ol_events["a" /* default */].listen(this.canvas_, contexteventtype.RESTORED, this.handleWebGLContextRestored, this);
};

ol["a" /* default */].inherits(context__ol_webgl_Context_, disposable["a" /* default */]);

/**
 * Just bind the buffer if it's in the cache. Otherwise create
 * the WebGL buffer, bind it, populate it, and add an entry to
 * the cache.
 * @param {number} target Target.
 * @param {ol.webgl.Buffer} buf Buffer.
 */
context__ol_webgl_Context_.prototype.bindBuffer = function (target, buf) {
  var gl = this.getGL();
  var arr = buf.getArray();
  var bufferKey = String(ol["a" /* default */].getUid(buf));
  if (bufferKey in this.bufferCache_) {
    var bufferCacheEntry = this.bufferCache_[bufferKey];
    gl.bindBuffer(target, bufferCacheEntry.buffer);
  } else {
    var buffer = gl.createBuffer();
    gl.bindBuffer(target, buffer);
    var /** @type {ArrayBufferView} */arrayBuffer;
    if (target == webgl["a" /* default */].ARRAY_BUFFER) {
      arrayBuffer = new Float32Array(arr);
    } else if (target == webgl["a" /* default */].ELEMENT_ARRAY_BUFFER) {
      arrayBuffer = this.hasOESElementIndexUint ? new Uint32Array(arr) : new Uint16Array(arr);
    }
    gl.bufferData(target, arrayBuffer, buf.getUsage());
    this.bufferCache_[bufferKey] = {
      buf: buf,
      buffer: buffer
    };
  }
};

/**
 * @param {ol.webgl.Buffer} buf Buffer.
 */
context__ol_webgl_Context_.prototype.deleteBuffer = function (buf) {
  var gl = this.getGL();
  var bufferKey = String(ol["a" /* default */].getUid(buf));
  var bufferCacheEntry = this.bufferCache_[bufferKey];
  if (!gl.isContextLost()) {
    gl.deleteBuffer(bufferCacheEntry.buffer);
  }
  delete this.bufferCache_[bufferKey];
};

/**
 * @inheritDoc
 */
context__ol_webgl_Context_.prototype.disposeInternal = function () {
  ol_events["a" /* default */].unlistenAll(this.canvas_);
  var gl = this.getGL();
  if (!gl.isContextLost()) {
    var key;
    for (key in this.bufferCache_) {
      gl.deleteBuffer(this.bufferCache_[key].buffer);
    }
    for (key in this.programCache_) {
      gl.deleteProgram(this.programCache_[key]);
    }
    for (key in this.shaderCache_) {
      gl.deleteShader(this.shaderCache_[key]);
    }
    // delete objects for hit-detection
    gl.deleteFramebuffer(this.hitDetectionFramebuffer_);
    gl.deleteRenderbuffer(this.hitDetectionRenderbuffer_);
    gl.deleteTexture(this.hitDetectionTexture_);
  }
};

/**
 * @return {HTMLCanvasElement} Canvas.
 */
context__ol_webgl_Context_.prototype.getCanvas = function () {
  return this.canvas_;
};

/**
 * Get the WebGL rendering context
 * @return {WebGLRenderingContext} The rendering context.
 * @api
 */
context__ol_webgl_Context_.prototype.getGL = function () {
  return this.gl_;
};

/**
 * Get the frame buffer for hit detection.
 * @return {WebGLFramebuffer} The hit detection frame buffer.
 */
context__ol_webgl_Context_.prototype.getHitDetectionFramebuffer = function () {
  if (!this.hitDetectionFramebuffer_) {
    this.initHitDetectionFramebuffer_();
  }
  return this.hitDetectionFramebuffer_;
};

/**
 * Get shader from the cache if it's in the cache. Otherwise, create
 * the WebGL shader, compile it, and add entry to cache.
 * @param {ol.webgl.Shader} shaderObject Shader object.
 * @return {WebGLShader} Shader.
 */
context__ol_webgl_Context_.prototype.getShader = function (shaderObject) {
  var shaderKey = String(ol["a" /* default */].getUid(shaderObject));
  if (shaderKey in this.shaderCache_) {
    return this.shaderCache_[shaderKey];
  } else {
    var gl = this.getGL();
    var shader = gl.createShader(shaderObject.getType());
    gl.shaderSource(shader, shaderObject.getSource());
    gl.compileShader(shader);
    this.shaderCache_[shaderKey] = shader;
    return shader;
  }
};

/**
 * Get the program from the cache if it's in the cache. Otherwise create
 * the WebGL program, attach the shaders to it, and add an entry to the
 * cache.
 * @param {ol.webgl.Fragment} fragmentShaderObject Fragment shader.
 * @param {ol.webgl.Vertex} vertexShaderObject Vertex shader.
 * @return {WebGLProgram} Program.
 */
context__ol_webgl_Context_.prototype.getProgram = function (fragmentShaderObject, vertexShaderObject) {
  var programKey = ol["a" /* default */].getUid(fragmentShaderObject) + '/' + ol["a" /* default */].getUid(vertexShaderObject);
  if (programKey in this.programCache_) {
    return this.programCache_[programKey];
  } else {
    var gl = this.getGL();
    var program = gl.createProgram();
    gl.attachShader(program, this.getShader(fragmentShaderObject));
    gl.attachShader(program, this.getShader(vertexShaderObject));
    gl.linkProgram(program);
    this.programCache_[programKey] = program;
    return program;
  }
};

/**
 * FIXME empy description for jsdoc
 */
context__ol_webgl_Context_.prototype.handleWebGLContextLost = function () {
  obj["a" /* default */].clear(this.bufferCache_);
  obj["a" /* default */].clear(this.shaderCache_);
  obj["a" /* default */].clear(this.programCache_);
  this.currentProgram_ = null;
  this.hitDetectionFramebuffer_ = null;
  this.hitDetectionTexture_ = null;
  this.hitDetectionRenderbuffer_ = null;
};

/**
 * FIXME empy description for jsdoc
 */
context__ol_webgl_Context_.prototype.handleWebGLContextRestored = function () {};

/**
 * Creates a 1x1 pixel framebuffer for the hit-detection.
 * @private
 */
context__ol_webgl_Context_.prototype.initHitDetectionFramebuffer_ = function () {
  var gl = this.gl_;
  var framebuffer = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);

  var texture = context__ol_webgl_Context_.createEmptyTexture(gl, 1, 1);
  var renderbuffer = gl.createRenderbuffer();
  gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
  gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, 1, 1);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.bindRenderbuffer(gl.RENDERBUFFER, null);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);

  this.hitDetectionFramebuffer_ = framebuffer;
  this.hitDetectionTexture_ = texture;
  this.hitDetectionRenderbuffer_ = renderbuffer;
};

/**
 * Use a program.  If the program is already in use, this will return `false`.
 * @param {WebGLProgram} program Program.
 * @return {boolean} Changed.
 * @api
 */
context__ol_webgl_Context_.prototype.useProgram = function (program) {
  if (program == this.currentProgram_) {
    return false;
  } else {
    var gl = this.getGL();
    gl.useProgram(program);
    this.currentProgram_ = program;
    return true;
  }
};

/**
 * @param {WebGLRenderingContext} gl WebGL rendering context.
 * @param {number=} opt_wrapS wrapS.
 * @param {number=} opt_wrapT wrapT.
 * @return {WebGLTexture} The texture.
 * @private
 */
context__ol_webgl_Context_.createTexture_ = function (gl, opt_wrapS, opt_wrapT) {
  var texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

  if (opt_wrapS !== undefined) {
    gl.texParameteri(webgl["a" /* default */].TEXTURE_2D, webgl["a" /* default */].TEXTURE_WRAP_S, opt_wrapS);
  }
  if (opt_wrapT !== undefined) {
    gl.texParameteri(webgl["a" /* default */].TEXTURE_2D, webgl["a" /* default */].TEXTURE_WRAP_T, opt_wrapT);
  }

  return texture;
};

/**
 * @param {WebGLRenderingContext} gl WebGL rendering context.
 * @param {number} width Width.
 * @param {number} height Height.
 * @param {number=} opt_wrapS wrapS.
 * @param {number=} opt_wrapT wrapT.
 * @return {WebGLTexture} The texture.
 */
context__ol_webgl_Context_.createEmptyTexture = function (gl, width, height, opt_wrapS, opt_wrapT) {
  var texture = context__ol_webgl_Context_.createTexture_(gl, opt_wrapS, opt_wrapT);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

  return texture;
};

/**
 * @param {WebGLRenderingContext} gl WebGL rendering context.
 * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
 * @param {number=} opt_wrapS wrapS.
 * @param {number=} opt_wrapT wrapT.
 * @return {WebGLTexture} The texture.
 */
context__ol_webgl_Context_.createTexture = function (gl, image, opt_wrapS, opt_wrapT) {
  var texture = context__ol_webgl_Context_.createTexture_(gl, opt_wrapS, opt_wrapT);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

  return texture;
};
/* harmony default export */ var webgl_context = (context__ol_webgl_Context_);
// CONCATENATED MODULE: ./node_modules/ol/render/webgl/texturereplay.js









/**
 * @constructor
 * @abstract
 * @extends {ol.render.webgl.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */
var texturereplay__ol_render_webgl_TextureReplay_ = function _ol_render_webgl_TextureReplay_(tolerance, maxExtent) {
  webgl_replay.call(this, tolerance, maxExtent);

  /**
   * @type {number|undefined}
   * @protected
   */
  this.anchorX = undefined;

  /**
   * @type {number|undefined}
   * @protected
   */
  this.anchorY = undefined;

  /**
   * @type {Array.<number>}
   * @protected
   */
  this.groupIndices = [];

  /**
   * @type {Array.<number>}
   * @protected
   */
  this.hitDetectionGroupIndices = [];

  /**
   * @type {number|undefined}
   * @protected
   */
  this.height = undefined;

  /**
   * @type {number|undefined}
   * @protected
   */
  this.imageHeight = undefined;

  /**
   * @type {number|undefined}
   * @protected
   */
  this.imageWidth = undefined;

  /**
   * @protected
   * @type {ol.render.webgl.texturereplay.defaultshader.Locations}
   */
  this.defaultLocations = null;

  /**
   * @protected
   * @type {number|undefined}
   */
  this.opacity = undefined;

  /**
   * @type {number|undefined}
   * @protected
   */
  this.originX = undefined;

  /**
   * @type {number|undefined}
   * @protected
   */
  this.originY = undefined;

  /**
   * @protected
   * @type {boolean|undefined}
   */
  this.rotateWithView = undefined;

  /**
   * @protected
   * @type {number|undefined}
   */
  this.rotation = undefined;

  /**
   * @protected
   * @type {number|undefined}
   */
  this.scale = undefined;

  /**
   * @type {number|undefined}
   * @protected
   */
  this.width = undefined;
};

ol["a" /* default */].inherits(texturereplay__ol_render_webgl_TextureReplay_, webgl_replay);

/**
 * @inheritDoc
 */
texturereplay__ol_render_webgl_TextureReplay_.prototype.getDeleteResourcesFunction = function (context) {
  var verticesBuffer = this.verticesBuffer;
  var indicesBuffer = this.indicesBuffer;
  var textures = this.getTextures(true);
  var gl = context.getGL();
  return function () {
    if (!gl.isContextLost()) {
      var i, ii;
      for (i = 0, ii = textures.length; i < ii; ++i) {
        gl.deleteTexture(textures[i]);
      }
    }
    context.deleteBuffer(verticesBuffer);
    context.deleteBuffer(indicesBuffer);
  };
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {number} My end.
 * @protected
 */
texturereplay__ol_render_webgl_TextureReplay_.prototype.drawCoordinates = function (flatCoordinates, offset, end, stride) {
  var anchorX = /** @type {number} */this.anchorX;
  var anchorY = /** @type {number} */this.anchorY;
  var height = /** @type {number} */this.height;
  var imageHeight = /** @type {number} */this.imageHeight;
  var imageWidth = /** @type {number} */this.imageWidth;
  var opacity = /** @type {number} */this.opacity;
  var originX = /** @type {number} */this.originX;
  var originY = /** @type {number} */this.originY;
  var rotateWithView = this.rotateWithView ? 1.0 : 0.0;
  // this.rotation_ is anti-clockwise, but rotation is clockwise
  var rotation = /** @type {number} */-this.rotation;
  var scale = /** @type {number} */this.scale;
  var width = /** @type {number} */this.width;
  var cos = Math.cos(rotation);
  var sin = Math.sin(rotation);
  var numIndices = this.indices.length;
  var numVertices = this.vertices.length;
  var i, n, offsetX, offsetY, x, y;
  for (i = offset; i < end; i += stride) {
    x = flatCoordinates[i] - this.origin[0];
    y = flatCoordinates[i + 1] - this.origin[1];

    // There are 4 vertices per [x, y] point, one for each corner of the
    // rectangle we're going to draw. We'd use 1 vertex per [x, y] point if
    // WebGL supported Geometry Shaders (which can emit new vertices), but that
    // is not currently the case.
    //
    // And each vertex includes 8 values: the x and y coordinates, the x and
    // y offsets used to calculate the position of the corner, the u and
    // v texture coordinates for the corner, the opacity, and whether the
    // the image should be rotated with the view (rotateWithView).

    n = numVertices / 8;

    // bottom-left corner
    offsetX = -scale * anchorX;
    offsetY = -scale * (height - anchorY);
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;
    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;
    this.vertices[numVertices++] = originX / imageWidth;
    this.vertices[numVertices++] = (originY + height) / imageHeight;
    this.vertices[numVertices++] = opacity;
    this.vertices[numVertices++] = rotateWithView;

    // bottom-right corner
    offsetX = scale * (width - anchorX);
    offsetY = -scale * (height - anchorY);
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;
    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;
    this.vertices[numVertices++] = (originX + width) / imageWidth;
    this.vertices[numVertices++] = (originY + height) / imageHeight;
    this.vertices[numVertices++] = opacity;
    this.vertices[numVertices++] = rotateWithView;

    // top-right corner
    offsetX = scale * (width - anchorX);
    offsetY = scale * anchorY;
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;
    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;
    this.vertices[numVertices++] = (originX + width) / imageWidth;
    this.vertices[numVertices++] = originY / imageHeight;
    this.vertices[numVertices++] = opacity;
    this.vertices[numVertices++] = rotateWithView;

    // top-left corner
    offsetX = -scale * anchorX;
    offsetY = scale * anchorY;
    this.vertices[numVertices++] = x;
    this.vertices[numVertices++] = y;
    this.vertices[numVertices++] = offsetX * cos - offsetY * sin;
    this.vertices[numVertices++] = offsetX * sin + offsetY * cos;
    this.vertices[numVertices++] = originX / imageWidth;
    this.vertices[numVertices++] = originY / imageHeight;
    this.vertices[numVertices++] = opacity;
    this.vertices[numVertices++] = rotateWithView;

    this.indices[numIndices++] = n;
    this.indices[numIndices++] = n + 1;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n + 3;
  }

  return numVertices;
};

/**
 * @protected
 * @param {Array.<WebGLTexture>} textures Textures.
 * @param {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>} images
 *    Images.
 * @param {Object.<string, WebGLTexture>} texturePerImage Texture cache.
 * @param {WebGLRenderingContext} gl Gl.
 */
texturereplay__ol_render_webgl_TextureReplay_.prototype.createTextures = function (textures, images, texturePerImage, gl) {
  var texture, image, uid, i;
  var ii = images.length;
  for (i = 0; i < ii; ++i) {
    image = images[i];

    uid = ol["a" /* default */].getUid(image).toString();
    if (uid in texturePerImage) {
      texture = texturePerImage[uid];
    } else {
      texture = webgl_context.createTexture(gl, image, webgl["a" /* default */].CLAMP_TO_EDGE, webgl["a" /* default */].CLAMP_TO_EDGE);
      texturePerImage[uid] = texture;
    }
    textures[i] = texture;
  }
};

/**
 * @inheritDoc
 */
texturereplay__ol_render_webgl_TextureReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {
  // get the program
  var fragmentShader = texturereplay_defaultshader.fragment;
  var vertexShader = texturereplay_defaultshader.vertex;
  var program = context.getProgram(fragmentShader, vertexShader);

  // get the locations
  var locations;
  if (!this.defaultLocations) {
    locations = new texturereplay_defaultshader_locations(gl, program);
    this.defaultLocations = locations;
  } else {
    locations = this.defaultLocations;
  }

  // use the program (FIXME: use the return value)
  context.useProgram(program);

  // enable the vertex attrib arrays
  gl.enableVertexAttribArray(locations.a_position);
  gl.vertexAttribPointer(locations.a_position, 2, webgl["a" /* default */].FLOAT, false, 32, 0);

  gl.enableVertexAttribArray(locations.a_offsets);
  gl.vertexAttribPointer(locations.a_offsets, 2, webgl["a" /* default */].FLOAT, false, 32, 8);

  gl.enableVertexAttribArray(locations.a_texCoord);
  gl.vertexAttribPointer(locations.a_texCoord, 2, webgl["a" /* default */].FLOAT, false, 32, 16);

  gl.enableVertexAttribArray(locations.a_opacity);
  gl.vertexAttribPointer(locations.a_opacity, 1, webgl["a" /* default */].FLOAT, false, 32, 24);

  gl.enableVertexAttribArray(locations.a_rotateWithView);
  gl.vertexAttribPointer(locations.a_rotateWithView, 1, webgl["a" /* default */].FLOAT, false, 32, 28);

  return locations;
};

/**
 * @inheritDoc
 */
texturereplay__ol_render_webgl_TextureReplay_.prototype.shutDownProgram = function (gl, locations) {
  gl.disableVertexAttribArray(locations.a_position);
  gl.disableVertexAttribArray(locations.a_offsets);
  gl.disableVertexAttribArray(locations.a_texCoord);
  gl.disableVertexAttribArray(locations.a_opacity);
  gl.disableVertexAttribArray(locations.a_rotateWithView);
};

/**
 * @inheritDoc
 */
texturereplay__ol_render_webgl_TextureReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {
  var textures = hitDetection ? this.getHitDetectionTextures() : this.getTextures();
  var groupIndices = hitDetection ? this.hitDetectionGroupIndices : this.groupIndices;

  if (!obj["a" /* default */].isEmpty(skippedFeaturesHash)) {
    this.drawReplaySkipping(gl, context, skippedFeaturesHash, textures, groupIndices);
  } else {
    var i, ii, start;
    for (i = 0, ii = textures.length, start = 0; i < ii; ++i) {
      gl.bindTexture(webgl["a" /* default */].TEXTURE_2D, textures[i]);
      var end = groupIndices[i];
      this.drawElements(gl, context, start, end);
      start = end;
    }
  }
};

/**
 * Draw the replay while paying attention to skipped features.
 *
 * This functions creates groups of features that can be drawn to together,
 * so that the number of `drawElements` calls is minimized.
 *
 * For example given the following texture groups:
 *
 *    Group 1: A B C
 *    Group 2: D [E] F G
 *
 * If feature E should be skipped, the following `drawElements` calls will be
 * made:
 *
 *    drawElements with feature A, B and C
 *    drawElements with feature D
 *    drawElements with feature F and G
 *
 * @protected
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {Array.<WebGLTexture>} textures Textures.
 * @param {Array.<number>} groupIndices Texture group indices.
 */
texturereplay__ol_render_webgl_TextureReplay_.prototype.drawReplaySkipping = function (gl, context, skippedFeaturesHash, textures, groupIndices) {
  var featureIndex = 0;

  var i, ii;
  for (i = 0, ii = textures.length; i < ii; ++i) {
    gl.bindTexture(webgl["a" /* default */].TEXTURE_2D, textures[i]);
    var groupStart = i > 0 ? groupIndices[i - 1] : 0;
    var groupEnd = groupIndices[i];

    var start = groupStart;
    var end = groupStart;
    while (featureIndex < this.startIndices.length && this.startIndices[featureIndex] <= groupEnd) {
      var feature = this.startIndicesFeature[featureIndex];

      var featureUid = ol["a" /* default */].getUid(feature).toString();
      if (skippedFeaturesHash[featureUid] !== undefined) {
        // feature should be skipped
        if (start !== end) {
          // draw the features so far
          this.drawElements(gl, context, start, end);
        }
        // continue with the next feature
        start = featureIndex === this.startIndices.length - 1 ? groupEnd : this.startIndices[featureIndex + 1];
        end = start;
      } else {
        // the feature is not skipped, augment the end index
        end = featureIndex === this.startIndices.length - 1 ? groupEnd : this.startIndices[featureIndex + 1];
      }
      featureIndex++;
    }

    if (start !== end) {
      // draw the remaining features (in case there was no skipped feature
      // in this texture group, all features of a group are drawn together)
      this.drawElements(gl, context, start, end);
    }
  }
};

/**
 * @inheritDoc
 */
texturereplay__ol_render_webgl_TextureReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var i, groupStart, start, end, feature, featureUid;
  var featureIndex = this.startIndices.length - 1;
  var hitDetectionTextures = this.getHitDetectionTextures();
  for (i = hitDetectionTextures.length - 1; i >= 0; --i) {
    gl.bindTexture(webgl["a" /* default */].TEXTURE_2D, hitDetectionTextures[i]);
    groupStart = i > 0 ? this.hitDetectionGroupIndices[i - 1] : 0;
    end = this.hitDetectionGroupIndices[i];

    // draw all features for this texture group
    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      start = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = ol["a" /* default */].getUid(feature).toString();

      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || ol_extent["a" /* default */].intersects(
      /** @type {Array<number>} */opt_hitExtent, feature.getGeometry().getExtent()))) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.drawElements(gl, context, start, end);

        var result = featureCallback(feature);
        if (result) {
          return result;
        }
      }

      end = start;
      featureIndex--;
    }
  }
  return undefined;
};

/**
 * @inheritDoc
 */
texturereplay__ol_render_webgl_TextureReplay_.prototype.finish = function (context) {
  this.anchorX = undefined;
  this.anchorY = undefined;
  this.height = undefined;
  this.imageHeight = undefined;
  this.imageWidth = undefined;
  this.indices = null;
  this.opacity = undefined;
  this.originX = undefined;
  this.originY = undefined;
  this.rotateWithView = undefined;
  this.rotation = undefined;
  this.scale = undefined;
  this.vertices = null;
  this.width = undefined;
};

/**
 * @abstract
 * @protected
 * @param {boolean=} opt_all Return hit detection textures with regular ones.
 * @returns {Array.<WebGLTexture>} Textures.
 */
texturereplay__ol_render_webgl_TextureReplay_.prototype.getTextures = function (opt_all) {};

/**
 * @abstract
 * @protected
 * @returns {Array.<WebGLTexture>} Textures.
 */
texturereplay__ol_render_webgl_TextureReplay_.prototype.getHitDetectionTextures = function () {};
/* harmony default export */ var texturereplay = (texturereplay__ol_render_webgl_TextureReplay_);
// CONCATENATED MODULE: ./node_modules/ol/render/webgl/imagereplay.js




/**
 * @constructor
 * @extends {ol.render.webgl.TextureReplay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */
var imagereplay__ol_render_webgl_ImageReplay_ = function _ol_render_webgl_ImageReplay_(tolerance, maxExtent) {
  texturereplay.call(this, tolerance, maxExtent);

  /**
   * @type {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>}
   * @protected
   */
  this.images_ = [];

  /**
   * @type {Array.<HTMLCanvasElement|HTMLImageElement|HTMLVideoElement>}
   * @protected
   */
  this.hitDetectionImages_ = [];

  /**
   * @type {Array.<WebGLTexture>}
   * @private
   */
  this.textures_ = [];

  /**
   * @type {Array.<WebGLTexture>}
   * @private
   */
  this.hitDetectionTextures_ = [];
};

ol["a" /* default */].inherits(imagereplay__ol_render_webgl_ImageReplay_, texturereplay);

/**
 * @inheritDoc
 */
imagereplay__ol_render_webgl_ImageReplay_.prototype.drawMultiPoint = function (multiPointGeometry, feature) {
  this.startIndices.push(this.indices.length);
  this.startIndicesFeature.push(feature);
  var flatCoordinates = multiPointGeometry.getFlatCoordinates();
  var stride = multiPointGeometry.getStride();
  this.drawCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);
};

/**
 * @inheritDoc
 */
imagereplay__ol_render_webgl_ImageReplay_.prototype.drawPoint = function (pointGeometry, feature) {
  this.startIndices.push(this.indices.length);
  this.startIndicesFeature.push(feature);
  var flatCoordinates = pointGeometry.getFlatCoordinates();
  var stride = pointGeometry.getStride();
  this.drawCoordinates(flatCoordinates, 0, flatCoordinates.length, stride);
};

/**
 * @inheritDoc
 */
imagereplay__ol_render_webgl_ImageReplay_.prototype.finish = function (context) {
  var gl = context.getGL();

  this.groupIndices.push(this.indices.length);
  this.hitDetectionGroupIndices.push(this.indices.length);

  // create, bind, and populate the vertices buffer
  this.verticesBuffer = new webgl_buffer(this.vertices);

  var indices = this.indices;

  // create, bind, and populate the indices buffer
  this.indicesBuffer = new webgl_buffer(indices);

  // create textures
  /** @type {Object.<string, WebGLTexture>} */
  var texturePerImage = {};

  this.createTextures(this.textures_, this.images_, texturePerImage, gl);

  this.createTextures(this.hitDetectionTextures_, this.hitDetectionImages_, texturePerImage, gl);

  this.images_ = null;
  this.hitDetectionImages_ = null;
  texturereplay.prototype.finish.call(this, context);
};

/**
 * @inheritDoc
 */
imagereplay__ol_render_webgl_ImageReplay_.prototype.setImageStyle = function (imageStyle) {
  var anchor = imageStyle.getAnchor();
  var image = imageStyle.getImage(1);
  var imageSize = imageStyle.getImageSize();
  var hitDetectionImage = imageStyle.getHitDetectionImage(1);
  var opacity = imageStyle.getOpacity();
  var origin = imageStyle.getOrigin();
  var rotateWithView = imageStyle.getRotateWithView();
  var rotation = imageStyle.getRotation();
  var size = imageStyle.getSize();
  var scale = imageStyle.getScale();

  var currentImage;
  if (this.images_.length === 0) {
    this.images_.push(image);
  } else {
    currentImage = this.images_[this.images_.length - 1];
    if (ol["a" /* default */].getUid(currentImage) != ol["a" /* default */].getUid(image)) {
      this.groupIndices.push(this.indices.length);
      this.images_.push(image);
    }
  }

  if (this.hitDetectionImages_.length === 0) {
    this.hitDetectionImages_.push(hitDetectionImage);
  } else {
    currentImage = this.hitDetectionImages_[this.hitDetectionImages_.length - 1];
    if (ol["a" /* default */].getUid(currentImage) != ol["a" /* default */].getUid(hitDetectionImage)) {
      this.hitDetectionGroupIndices.push(this.indices.length);
      this.hitDetectionImages_.push(hitDetectionImage);
    }
  }

  this.anchorX = anchor[0];
  this.anchorY = anchor[1];
  this.height = size[1];
  this.imageHeight = imageSize[1];
  this.imageWidth = imageSize[0];
  this.opacity = opacity;
  this.originX = origin[0];
  this.originY = origin[1];
  this.rotation = rotation;
  this.rotateWithView = rotateWithView;
  this.scale = scale;
  this.width = size[0];
};

/**
 * @inheritDoc
 */
imagereplay__ol_render_webgl_ImageReplay_.prototype.getTextures = function (opt_all) {
  return opt_all ? this.textures_.concat(this.hitDetectionTextures_) : this.textures_;
};

/**
 * @inheritDoc
 */
imagereplay__ol_render_webgl_ImageReplay_.prototype.getHitDetectionTextures = function () {
  return this.hitDetectionTextures_;
};
/* harmony default export */ var webgl_imagereplay = (imagereplay__ol_render_webgl_ImageReplay_);
// EXTERNAL MODULE: ./node_modules/ol/geom/flat/orient.js + 1 modules
var orient = __webpack_require__(61);

// EXTERNAL MODULE: ./node_modules/ol/geom/flat/area.js
var flat_area = __webpack_require__(60);

// CONCATENATED MODULE: ./node_modules/ol/geom/flat/topology.js

var _ol_geom_flat_topology_ = {};

/**
 * Check if the linestring is a boundary.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} The linestring is a boundary.
 */
_ol_geom_flat_topology_.lineStringIsClosed = function (flatCoordinates, offset, end, stride) {
  var lastCoord = end - stride;
  if (flatCoordinates[offset] === flatCoordinates[lastCoord] && flatCoordinates[offset + 1] === flatCoordinates[lastCoord + 1] && (end - offset) / stride > 3) {
    return !!flat_area["a" /* default */].linearRing(flatCoordinates, offset, end, stride);
  }
  return false;
};
/* harmony default export */ var topology = (_ol_geom_flat_topology_);
// CONCATENATED MODULE: ./node_modules/ol/render/webgl/linestringreplay/defaultshader.js
// This file is automatically generated, do not edit



var _ol_render_webgl_linestringreplay_defaultshader_ = {};

_ol_render_webgl_linestringreplay_defaultshader_.fragment = new fragment(ol["a" /* default */].DEBUG_WEBGL ? 'precision mediump float;\nvarying float v_round;\nvarying vec2 v_roundVertex;\nvarying float v_halfWidth;\n\n\n\nuniform float u_opacity;\nuniform vec4 u_color;\nuniform vec2 u_size;\nuniform float u_pixelRatio;\n\nvoid main(void) {\n  if (v_round > 0.0) {\n    vec2 windowCoords = vec2((v_roundVertex.x + 1.0) / 2.0 * u_size.x * u_pixelRatio,\n        (v_roundVertex.y + 1.0) / 2.0 * u_size.y * u_pixelRatio);\n    if (length(windowCoords - gl_FragCoord.xy) > v_halfWidth * u_pixelRatio) {\n      discard;\n    }\n  }\n  gl_FragColor = u_color;\n  float alpha = u_color.a * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n' : 'precision mediump float;varying float a;varying vec2 aVertex;varying float c;uniform float m;uniform vec4 n;uniform vec2 o;uniform float p;void main(void){if(a>0.0){vec2 windowCoords=vec2((aVertex.x+1.0)/2.0*o.x*p,(aVertex.y+1.0)/2.0*o.y*p);if(length(windowCoords-gl_FragCoord.xy)>c*p){discard;}} gl_FragColor=n;float alpha=n.a*m;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}');

_ol_render_webgl_linestringreplay_defaultshader_.vertex = new vertex(ol["a" /* default */].DEBUG_WEBGL ? 'varying float v_round;\nvarying vec2 v_roundVertex;\nvarying float v_halfWidth;\n\n\nattribute vec2 a_lastPos;\nattribute vec2 a_position;\nattribute vec2 a_nextPos;\nattribute float a_direction;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\nuniform float u_lineWidth;\nuniform float u_miterLimit;\n\nbool nearlyEquals(in float value, in float ref) {\n  float epsilon = 0.000000000001;\n  return value >= ref - epsilon && value <= ref + epsilon;\n}\n\nvoid alongNormal(out vec2 offset, in vec2 nextP, in float turnDir, in float direction) {\n  vec2 dirVect = nextP - a_position;\n  vec2 normal = normalize(vec2(-turnDir * dirVect.y, turnDir * dirVect.x));\n  offset = u_lineWidth / 2.0 * normal * direction;\n}\n\nvoid miterUp(out vec2 offset, out float round, in bool isRound, in float direction) {\n  float halfWidth = u_lineWidth / 2.0;\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 dirVect = a_nextPos - a_position;\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\n  float miterLength = abs(halfWidth / dot(normal, tmpNormal));\n  offset = normal * direction * miterLength;\n  round = 0.0;\n  if (isRound) {\n    round = 1.0;\n  } else if (miterLength > u_miterLimit + u_lineWidth) {\n    offset = halfWidth * tmpNormal * direction;\n  }\n}\n\nbool miterDown(out vec2 offset, in vec4 projPos, in mat4 offsetMatrix, in float direction) {\n  bool degenerate = false;\n  vec2 tangent = normalize(normalize(a_nextPos - a_position) + normalize(a_position - a_lastPos));\n  vec2 normal = vec2(-tangent.y, tangent.x);\n  vec2 dirVect = a_lastPos - a_position;\n  vec2 tmpNormal = normalize(vec2(-dirVect.y, dirVect.x));\n  vec2 longOffset, shortOffset, longVertex;\n  vec4 shortProjVertex;\n  float halfWidth = u_lineWidth / 2.0;\n  if (length(a_nextPos - a_position) > length(a_lastPos - a_position)) {\n    longOffset = tmpNormal * direction * halfWidth;\n    shortOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\n    longVertex = a_nextPos;\n    shortProjVertex = u_projectionMatrix * vec4(a_lastPos, 0.0, 1.0);\n  } else {\n    shortOffset = tmpNormal * direction * halfWidth;\n    longOffset = normalize(vec2(dirVect.y, -dirVect.x)) * direction * halfWidth;\n    longVertex = a_lastPos;\n    shortProjVertex = u_projectionMatrix * vec4(a_nextPos, 0.0, 1.0);\n  }\n  //Intersection algorithm based on theory by Paul Bourke (http://paulbourke.net/geometry/pointlineplane/).\n  vec4 p1 = u_projectionMatrix * vec4(longVertex, 0.0, 1.0) + offsetMatrix * vec4(longOffset, 0.0, 0.0);\n  vec4 p2 = projPos + offsetMatrix * vec4(longOffset, 0.0, 0.0);\n  vec4 p3 = shortProjVertex + offsetMatrix * vec4(-shortOffset, 0.0, 0.0);\n  vec4 p4 = shortProjVertex + offsetMatrix * vec4(shortOffset, 0.0, 0.0);\n  float denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n  float firstU = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;\n  float secondU = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;\n  float epsilon = 0.000000000001;\n  if (firstU > epsilon && firstU < 1.0 - epsilon && secondU > epsilon && secondU < 1.0 - epsilon) {\n    shortProjVertex.x = p1.x + firstU * (p2.x - p1.x);\n    shortProjVertex.y = p1.y + firstU * (p2.y - p1.y);\n    offset = shortProjVertex.xy;\n    degenerate = true;\n  } else {\n    float miterLength = abs(halfWidth / dot(normal, tmpNormal));\n    offset = normal * direction * miterLength;\n  }\n  return degenerate;\n}\n\nvoid squareCap(out vec2 offset, out float round, in bool isRound, in vec2 nextP,\n    in float turnDir, in float direction) {\n  round = 0.0;\n  vec2 dirVect = a_position - nextP;\n  vec2 firstNormal = normalize(dirVect);\n  vec2 secondNormal = vec2(turnDir * firstNormal.y * direction, -turnDir * firstNormal.x * direction);\n  vec2 hypotenuse = normalize(firstNormal - secondNormal);\n  vec2 normal = vec2(turnDir * hypotenuse.y * direction, -turnDir * hypotenuse.x * direction);\n  float length = sqrt(v_halfWidth * v_halfWidth * 2.0);\n  offset = normal * length;\n  if (isRound) {\n    round = 1.0;\n  }\n}\n\nvoid main(void) {\n  bool degenerate = false;\n  float direction = float(sign(a_direction));\n  mat4 offsetMatrix = u_offsetScaleMatrix * u_offsetRotateMatrix;\n  vec2 offset;\n  vec4 projPos = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n  bool round = nearlyEquals(mod(a_direction, 2.0), 0.0);\n\n  v_round = 0.0;\n  v_halfWidth = u_lineWidth / 2.0;\n  v_roundVertex = projPos.xy;\n\n  if (nearlyEquals(mod(a_direction, 3.0), 0.0) || nearlyEquals(mod(a_direction, 17.0), 0.0)) {\n    alongNormal(offset, a_nextPos, 1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 5.0), 0.0) || nearlyEquals(mod(a_direction, 13.0), 0.0)) {\n    alongNormal(offset, a_lastPos, -1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 23.0), 0.0)) {\n    miterUp(offset, v_round, round, direction);\n  } else if (nearlyEquals(mod(a_direction, 19.0), 0.0)) {\n    degenerate = miterDown(offset, projPos, offsetMatrix, direction);\n  } else if (nearlyEquals(mod(a_direction, 7.0), 0.0)) {\n    squareCap(offset, v_round, round, a_nextPos, 1.0, direction);\n  } else if (nearlyEquals(mod(a_direction, 11.0), 0.0)) {\n    squareCap(offset, v_round, round, a_lastPos, -1.0, direction);\n  }\n  if (!degenerate) {\n    vec4 offsets = offsetMatrix * vec4(offset, 0.0, 0.0);\n    gl_Position = projPos + offsets;\n  } else {\n    gl_Position = vec4(offset, 0.0, 1.0);\n  }\n}\n\n\n' : 'varying float a;varying vec2 aVertex;varying float c;attribute vec2 d;attribute vec2 e;attribute vec2 f;attribute float g;uniform mat4 h;uniform mat4 i;uniform mat4 j;uniform float k;uniform float l;bool nearlyEquals(in float value,in float ref){float epsilon=0.000000000001;return value>=ref-epsilon&&value<=ref+epsilon;}void alongNormal(out vec2 offset,in vec2 nextP,in float turnDir,in float direction){vec2 dirVect=nextP-e;vec2 normal=normalize(vec2(-turnDir*dirVect.y,turnDir*dirVect.x));offset=k/2.0*normal*direction;}void miterUp(out vec2 offset,out float round,in bool isRound,in float direction){float halfWidth=k/2.0;vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);vec2 dirVect=f-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));float miterLength=abs(halfWidth/dot(normal,tmpNormal));offset=normal*direction*miterLength;round=0.0;if(isRound){round=1.0;}else if(miterLength>l+k){offset=halfWidth*tmpNormal*direction;}} bool miterDown(out vec2 offset,in vec4 projPos,in mat4 offsetMatrix,in float direction){bool degenerate=false;vec2 tangent=normalize(normalize(f-e)+normalize(e-d));vec2 normal=vec2(-tangent.y,tangent.x);vec2 dirVect=d-e;vec2 tmpNormal=normalize(vec2(-dirVect.y,dirVect.x));vec2 longOffset,shortOffset,longVertex;vec4 shortProjVertex;float halfWidth=k/2.0;if(length(f-e)>length(d-e)){longOffset=tmpNormal*direction*halfWidth;shortOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*halfWidth;longVertex=f;shortProjVertex=h*vec4(d,0.0,1.0);}else{shortOffset=tmpNormal*direction*halfWidth;longOffset=normalize(vec2(dirVect.y,-dirVect.x))*direction*halfWidth;longVertex=d;shortProjVertex=h*vec4(f,0.0,1.0);}vec4 p1=h*vec4(longVertex,0.0,1.0)+offsetMatrix*vec4(longOffset,0.0,0.0);vec4 p2=projPos+offsetMatrix*vec4(longOffset,0.0,0.0);vec4 p3=shortProjVertex+offsetMatrix*vec4(-shortOffset,0.0,0.0);vec4 p4=shortProjVertex+offsetMatrix*vec4(shortOffset,0.0,0.0);float denom=(p4.y-p3.y)*(p2.x-p1.x)-(p4.x-p3.x)*(p2.y-p1.y);float firstU=((p4.x-p3.x)*(p1.y-p3.y)-(p4.y-p3.y)*(p1.x-p3.x))/denom;float secondU=((p2.x-p1.x)*(p1.y-p3.y)-(p2.y-p1.y)*(p1.x-p3.x))/denom;float epsilon=0.000000000001;if(firstU>epsilon&&firstU<1.0-epsilon&&secondU>epsilon&&secondU<1.0-epsilon){shortProjVertex.x=p1.x+firstU*(p2.x-p1.x);shortProjVertex.y=p1.y+firstU*(p2.y-p1.y);offset=shortProjVertex.xy;degenerate=true;}else{float miterLength=abs(halfWidth/dot(normal,tmpNormal));offset=normal*direction*miterLength;}return degenerate;}void squareCap(out vec2 offset,out float round,in bool isRound,in vec2 nextP,in float turnDir,in float direction){round=0.0;vec2 dirVect=e-nextP;vec2 firstNormal=normalize(dirVect);vec2 secondNormal=vec2(turnDir*firstNormal.y*direction,-turnDir*firstNormal.x*direction);vec2 hypotenuse=normalize(firstNormal-secondNormal);vec2 normal=vec2(turnDir*hypotenuse.y*direction,-turnDir*hypotenuse.x*direction);float length=sqrt(c*c*2.0);offset=normal*length;if(isRound){round=1.0;}} void main(void){bool degenerate=false;float direction=float(sign(g));mat4 offsetMatrix=i*j;vec2 offset;vec4 projPos=h*vec4(e,0.0,1.0);bool round=nearlyEquals(mod(g,2.0),0.0);a=0.0;c=k/2.0;aVertex=projPos.xy;if(nearlyEquals(mod(g,3.0),0.0)||nearlyEquals(mod(g,17.0),0.0)){alongNormal(offset,f,1.0,direction);}else if(nearlyEquals(mod(g,5.0),0.0)||nearlyEquals(mod(g,13.0),0.0)){alongNormal(offset,d,-1.0,direction);}else if(nearlyEquals(mod(g,23.0),0.0)){miterUp(offset,a,round,direction);}else if(nearlyEquals(mod(g,19.0),0.0)){degenerate=miterDown(offset,projPos,offsetMatrix,direction);}else if(nearlyEquals(mod(g,7.0),0.0)){squareCap(offset,a,round,f,1.0,direction);}else if(nearlyEquals(mod(g,11.0),0.0)){squareCap(offset,a,round,d,-1.0,direction);}if(!degenerate){vec4 offsets=offsetMatrix*vec4(offset,0.0,0.0);gl_Position=projPos+offsets;}else{gl_Position=vec4(offset,0.0,1.0);}}');
/* harmony default export */ var linestringreplay_defaultshader = (_ol_render_webgl_linestringreplay_defaultshader_);
// CONCATENATED MODULE: ./node_modules/ol/render/webgl/linestringreplay/defaultshader/locations.js
// This file is automatically generated, do not edit


/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */
var locations__ol_render_webgl_linestringreplay_defaultshader_Locations_ = function _ol_render_webgl_linestringreplay_defaultshader_Locations_(gl, program) {

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_projectionMatrix = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_projectionMatrix' : 'h');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_offsetScaleMatrix = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'i');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_offsetRotateMatrix = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'j');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_lineWidth = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_lineWidth' : 'k');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_miterLimit = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_miterLimit' : 'l');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_opacity = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_opacity' : 'm');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_color = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_color' : 'n');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_size = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_size' : 'o');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_pixelRatio = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_pixelRatio' : 'p');

  /**
   * @type {number}
   */
  this.a_lastPos = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_lastPos' : 'd');

  /**
   * @type {number}
   */
  this.a_position = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_position' : 'e');

  /**
   * @type {number}
   */
  this.a_nextPos = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_nextPos' : 'f');

  /**
   * @type {number}
   */
  this.a_direction = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_direction' : 'g');
};

/* harmony default export */ var linestringreplay_defaultshader_locations = (locations__ol_render_webgl_linestringreplay_defaultshader_Locations_);
// CONCATENATED MODULE: ./node_modules/ol/render/webgl/linestringreplay.js















/**
 * @constructor
 * @extends {ol.render.webgl.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */
var linestringreplay__ol_render_webgl_LineStringReplay_ = function _ol_render_webgl_LineStringReplay_(tolerance, maxExtent) {
  webgl_replay.call(this, tolerance, maxExtent);

  /**
   * @private
   * @type {ol.render.webgl.linestringreplay.defaultshader.Locations}
   */
  this.defaultLocations_ = null;

  /**
   * @private
   * @type {Array.<Array.<?>>}
   */
  this.styles_ = [];

  /**
   * @private
   * @type {Array.<number>}
   */
  this.styleIndices_ = [];

  /**
   * @private
   * @type {{strokeColor: (Array.<number>|null),
   *         lineCap: (string|undefined),
   *         lineDash: Array.<number>,
   *         lineDashOffset: (number|undefined),
   *         lineJoin: (string|undefined),
   *         lineWidth: (number|undefined),
   *         miterLimit: (number|undefined),
   *         changed: boolean}|null}
   */
  this.state_ = {
    strokeColor: null,
    lineCap: undefined,
    lineDash: null,
    lineDashOffset: undefined,
    lineJoin: undefined,
    lineWidth: undefined,
    miterLimit: undefined,
    changed: false
  };
};

ol["a" /* default */].inherits(linestringreplay__ol_render_webgl_LineStringReplay_, webgl_replay);

/**
 * Draw one segment.
 * @private
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {

  var i, ii;
  var numVertices = this.vertices.length;
  var numIndices = this.indices.length;
  //To save a vertex, the direction of a point is a product of the sign (1 or -1), a prime from
  //ol.render.webgl.LineStringReplay.Instruction_, and a rounding factor (1 or 2). If the product is even,
  //we round it. If it is odd, we don't.
  var lineJoin = this.state_.lineJoin === 'bevel' ? 0 : this.state_.lineJoin === 'miter' ? 1 : 2;
  var lineCap = this.state_.lineCap === 'butt' ? 0 : this.state_.lineCap === 'square' ? 1 : 2;
  var closed = topology.lineStringIsClosed(flatCoordinates, offset, end, stride);
  var startCoords, sign, n;
  var lastIndex = numIndices;
  var lastSign = 1;
  //We need the adjacent vertices to define normals in joins. p0 = last, p1 = current, p2 = next.
  var p0, p1, p2;

  for (i = offset, ii = end; i < ii; i += stride) {

    n = numVertices / 7;

    p0 = p1;
    p1 = p2 || [flatCoordinates[i], flatCoordinates[i + 1]];
    //First vertex.
    if (i === offset) {
      p2 = [flatCoordinates[i + stride], flatCoordinates[i + stride + 1]];
      if (end - offset === stride * 2 && array["a" /* default */].equals(p1, p2)) {
        break;
      }
      if (closed) {
        //A closed line! Complete the circle.
        p0 = [flatCoordinates[end - stride * 2], flatCoordinates[end - stride * 2 + 1]];

        startCoords = p2;
      } else {
        //Add the first two/four vertices.

        if (lineCap) {
          numVertices = this.addVertices_([0, 0], p1, p2, lastSign * linestringreplay__ol_render_webgl_LineStringReplay_.Instruction_.BEGIN_LINE_CAP * lineCap, numVertices);

          numVertices = this.addVertices_([0, 0], p1, p2, -lastSign * linestringreplay__ol_render_webgl_LineStringReplay_.Instruction_.BEGIN_LINE_CAP * lineCap, numVertices);

          this.indices[numIndices++] = n + 2;
          this.indices[numIndices++] = n;
          this.indices[numIndices++] = n + 1;

          this.indices[numIndices++] = n + 1;
          this.indices[numIndices++] = n + 3;
          this.indices[numIndices++] = n + 2;
        }

        numVertices = this.addVertices_([0, 0], p1, p2, lastSign * linestringreplay__ol_render_webgl_LineStringReplay_.Instruction_.BEGIN_LINE * (lineCap || 1), numVertices);

        numVertices = this.addVertices_([0, 0], p1, p2, -lastSign * linestringreplay__ol_render_webgl_LineStringReplay_.Instruction_.BEGIN_LINE * (lineCap || 1), numVertices);

        lastIndex = numVertices / 7 - 1;

        continue;
      }
    } else if (i === end - stride) {
      //Last vertex.
      if (closed) {
        //Same as the first vertex.
        p2 = startCoords;
        break;
      } else {
        p0 = p0 || [0, 0];

        numVertices = this.addVertices_(p0, p1, [0, 0], lastSign * linestringreplay__ol_render_webgl_LineStringReplay_.Instruction_.END_LINE * (lineCap || 1), numVertices);

        numVertices = this.addVertices_(p0, p1, [0, 0], -lastSign * linestringreplay__ol_render_webgl_LineStringReplay_.Instruction_.END_LINE * (lineCap || 1), numVertices);

        this.indices[numIndices++] = n;
        this.indices[numIndices++] = lastIndex - 1;
        this.indices[numIndices++] = lastIndex;

        this.indices[numIndices++] = lastIndex;
        this.indices[numIndices++] = n + 1;
        this.indices[numIndices++] = n;

        if (lineCap) {
          numVertices = this.addVertices_(p0, p1, [0, 0], lastSign * linestringreplay__ol_render_webgl_LineStringReplay_.Instruction_.END_LINE_CAP * lineCap, numVertices);

          numVertices = this.addVertices_(p0, p1, [0, 0], -lastSign * linestringreplay__ol_render_webgl_LineStringReplay_.Instruction_.END_LINE_CAP * lineCap, numVertices);

          this.indices[numIndices++] = n + 2;
          this.indices[numIndices++] = n;
          this.indices[numIndices++] = n + 1;

          this.indices[numIndices++] = n + 1;
          this.indices[numIndices++] = n + 3;
          this.indices[numIndices++] = n + 2;
        }

        break;
      }
    } else {
      p2 = [flatCoordinates[i + stride], flatCoordinates[i + stride + 1]];
    }

    // We group CW and straight lines, thus the not so inituitive CCW checking function.
    sign = render_webgl.triangleIsCounterClockwise(p0[0], p0[1], p1[0], p1[1], p2[0], p2[1]) ? -1 : 1;

    numVertices = this.addVertices_(p0, p1, p2, sign * linestringreplay__ol_render_webgl_LineStringReplay_.Instruction_.BEVEL_FIRST * (lineJoin || 1), numVertices);

    numVertices = this.addVertices_(p0, p1, p2, sign * linestringreplay__ol_render_webgl_LineStringReplay_.Instruction_.BEVEL_SECOND * (lineJoin || 1), numVertices);

    numVertices = this.addVertices_(p0, p1, p2, -sign * linestringreplay__ol_render_webgl_LineStringReplay_.Instruction_.MITER_BOTTOM * (lineJoin || 1), numVertices);

    if (i > offset) {
      this.indices[numIndices++] = n;
      this.indices[numIndices++] = lastIndex - 1;
      this.indices[numIndices++] = lastIndex;

      this.indices[numIndices++] = n + 2;
      this.indices[numIndices++] = n;
      this.indices[numIndices++] = lastSign * sign > 0 ? lastIndex : lastIndex - 1;
    }

    this.indices[numIndices++] = n;
    this.indices[numIndices++] = n + 2;
    this.indices[numIndices++] = n + 1;

    lastIndex = n + 2;
    lastSign = sign;

    //Add miter
    if (lineJoin) {
      numVertices = this.addVertices_(p0, p1, p2, sign * linestringreplay__ol_render_webgl_LineStringReplay_.Instruction_.MITER_TOP * lineJoin, numVertices);

      this.indices[numIndices++] = n + 1;
      this.indices[numIndices++] = n + 3;
      this.indices[numIndices++] = n;
    }
  }

  if (closed) {
    n = n || numVertices / 7;
    sign = orient["a" /* default */].linearRingIsClockwise([p0[0], p0[1], p1[0], p1[1], p2[0], p2[1]], 0, 6, 2) ? 1 : -1;

    numVertices = this.addVertices_(p0, p1, p2, sign * linestringreplay__ol_render_webgl_LineStringReplay_.Instruction_.BEVEL_FIRST * (lineJoin || 1), numVertices);

    numVertices = this.addVertices_(p0, p1, p2, -sign * linestringreplay__ol_render_webgl_LineStringReplay_.Instruction_.MITER_BOTTOM * (lineJoin || 1), numVertices);

    this.indices[numIndices++] = n;
    this.indices[numIndices++] = lastIndex - 1;
    this.indices[numIndices++] = lastIndex;

    this.indices[numIndices++] = n + 1;
    this.indices[numIndices++] = n;
    this.indices[numIndices++] = lastSign * sign > 0 ? lastIndex : lastIndex - 1;
  }
};

/**
 * @param {Array.<number>} p0 Last coordinates.
 * @param {Array.<number>} p1 Current coordinates.
 * @param {Array.<number>} p2 Next coordinates.
 * @param {number} product Sign, instruction, and rounding product.
 * @param {number} numVertices Vertex counter.
 * @return {number} Vertex counter.
 * @private
 */
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.addVertices_ = function (p0, p1, p2, product, numVertices) {
  this.vertices[numVertices++] = p0[0];
  this.vertices[numVertices++] = p0[1];
  this.vertices[numVertices++] = p1[0];
  this.vertices[numVertices++] = p1[1];
  this.vertices[numVertices++] = p2[0];
  this.vertices[numVertices++] = p2[1];
  this.vertices[numVertices++] = product;

  return numVertices;
};

/**
 * Check if the linestring can be drawn (i. e. valid).
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 * @return {boolean} The linestring can be drawn.
 * @private
 */
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.isValid_ = function (flatCoordinates, offset, end, stride) {
  var range = end - offset;
  if (range < stride * 2) {
    return false;
  } else if (range === stride * 2) {
    var firstP = [flatCoordinates[offset], flatCoordinates[offset + 1]];
    var lastP = [flatCoordinates[offset + stride], flatCoordinates[offset + stride + 1]];
    return !array["a" /* default */].equals(firstP, lastP);
  }

  return true;
};

/**
 * @inheritDoc
 */
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.drawLineString = function (lineStringGeometry, feature) {
  var flatCoordinates = lineStringGeometry.getFlatCoordinates();
  var stride = lineStringGeometry.getStride();
  if (this.isValid_(flatCoordinates, 0, flatCoordinates.length, stride)) {
    flatCoordinates = flat_transform["a" /* default */].translate(flatCoordinates, 0, flatCoordinates.length, stride, -this.origin[0], -this.origin[1]);
    if (this.state_.changed) {
      this.styleIndices_.push(this.indices.length);
      this.state_.changed = false;
    }
    this.startIndices.push(this.indices.length);
    this.startIndicesFeature.push(feature);
    this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  }
};

/**
 * @inheritDoc
 */
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {
  var indexCount = this.indices.length;
  var ends = multiLineStringGeometry.getEnds();
  ends.unshift(0);
  var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
  var stride = multiLineStringGeometry.getStride();
  var i, ii;
  if (ends.length > 1) {
    for (i = 1, ii = ends.length; i < ii; ++i) {
      if (this.isValid_(flatCoordinates, ends[i - 1], ends[i], stride)) {
        var lineString = flat_transform["a" /* default */].translate(flatCoordinates, ends[i - 1], ends[i], stride, -this.origin[0], -this.origin[1]);
        this.drawCoordinates_(lineString, 0, lineString.length, stride);
      }
    }
  }
  if (this.indices.length > indexCount) {
    this.startIndices.push(indexCount);
    this.startIndicesFeature.push(feature);
    if (this.state_.changed) {
      this.styleIndices_.push(indexCount);
      this.state_.changed = false;
    }
  }
};

/**
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<Array.<number>>} holeFlatCoordinates Hole flat coordinates.
 * @param {number} stride Stride.
 */
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.drawPolygonCoordinates = function (flatCoordinates, holeFlatCoordinates, stride) {
  if (!topology.lineStringIsClosed(flatCoordinates, 0, flatCoordinates.length, stride)) {
    flatCoordinates.push(flatCoordinates[0]);
    flatCoordinates.push(flatCoordinates[1]);
  }
  this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
  if (holeFlatCoordinates.length) {
    var i, ii;
    for (i = 0, ii = holeFlatCoordinates.length; i < ii; ++i) {
      if (!topology.lineStringIsClosed(holeFlatCoordinates[i], 0, holeFlatCoordinates[i].length, stride)) {
        holeFlatCoordinates[i].push(holeFlatCoordinates[i][0]);
        holeFlatCoordinates[i].push(holeFlatCoordinates[i][1]);
      }
      this.drawCoordinates_(holeFlatCoordinates[i], 0, holeFlatCoordinates[i].length, stride);
    }
  }
};

/**
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {number=} opt_index Index count.
 */
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.setPolygonStyle = function (feature, opt_index) {
  var index = opt_index === undefined ? this.indices.length : opt_index;
  this.startIndices.push(index);
  this.startIndicesFeature.push(feature);
  if (this.state_.changed) {
    this.styleIndices_.push(index);
    this.state_.changed = false;
  }
};

/**
 * @return {number} Current index.
 */
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.getCurrentIndex = function () {
  return this.indices.length;
};

/**
 * @inheritDoc
 **/
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.finish = function (context) {
  // create, bind, and populate the vertices buffer
  this.verticesBuffer = new webgl_buffer(this.vertices);

  // create, bind, and populate the indices buffer
  this.indicesBuffer = new webgl_buffer(this.indices);

  this.startIndices.push(this.indices.length);

  //Clean up, if there is nothing to draw
  if (this.styleIndices_.length === 0 && this.styles_.length > 0) {
    this.styles_ = [];
  }

  this.vertices = null;
  this.indices = null;
};

/**
 * @inheritDoc
 */
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.getDeleteResourcesFunction = function (context) {
  var verticesBuffer = this.verticesBuffer;
  var indicesBuffer = this.indicesBuffer;
  return function () {
    context.deleteBuffer(verticesBuffer);
    context.deleteBuffer(indicesBuffer);
  };
};

/**
 * @inheritDoc
 */
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {
  // get the program
  var fragmentShader, vertexShader;
  fragmentShader = linestringreplay_defaultshader.fragment;
  vertexShader = linestringreplay_defaultshader.vertex;
  var program = context.getProgram(fragmentShader, vertexShader);

  // get the locations
  var locations;
  if (!this.defaultLocations_) {
    locations = new linestringreplay_defaultshader_locations(gl, program);
    this.defaultLocations_ = locations;
  } else {
    locations = this.defaultLocations_;
  }

  context.useProgram(program);

  // enable the vertex attrib arrays
  gl.enableVertexAttribArray(locations.a_lastPos);
  gl.vertexAttribPointer(locations.a_lastPos, 2, webgl["a" /* default */].FLOAT, false, 28, 0);

  gl.enableVertexAttribArray(locations.a_position);
  gl.vertexAttribPointer(locations.a_position, 2, webgl["a" /* default */].FLOAT, false, 28, 8);

  gl.enableVertexAttribArray(locations.a_nextPos);
  gl.vertexAttribPointer(locations.a_nextPos, 2, webgl["a" /* default */].FLOAT, false, 28, 16);

  gl.enableVertexAttribArray(locations.a_direction);
  gl.vertexAttribPointer(locations.a_direction, 1, webgl["a" /* default */].FLOAT, false, 28, 24);

  // Enable renderer specific uniforms.
  gl.uniform2fv(locations.u_size, size);
  gl.uniform1f(locations.u_pixelRatio, pixelRatio);

  return locations;
};

/**
 * @inheritDoc
 */
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.shutDownProgram = function (gl, locations) {
  gl.disableVertexAttribArray(locations.a_lastPos);
  gl.disableVertexAttribArray(locations.a_position);
  gl.disableVertexAttribArray(locations.a_nextPos);
  gl.disableVertexAttribArray(locations.a_direction);
};

/**
 * @inheritDoc
 */
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {
  //Save GL parameters.
  var tmpDepthFunc = /** @type {number} */gl.getParameter(gl.DEPTH_FUNC);
  var tmpDepthMask = /** @type {boolean} */gl.getParameter(gl.DEPTH_WRITEMASK);

  if (!hitDetection) {
    gl.enable(gl.DEPTH_TEST);
    gl.depthMask(true);
    gl.depthFunc(gl.NOTEQUAL);
  }

  if (!obj["a" /* default */].isEmpty(skippedFeaturesHash)) {
    this.drawReplaySkipping_(gl, context, skippedFeaturesHash);
  } else {
    //Draw by style groups to minimize drawElements() calls.
    var i, start, end, nextStyle;
    end = this.startIndices[this.startIndices.length - 1];
    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      start = this.styleIndices_[i];
      nextStyle = this.styles_[i];
      this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);
      this.drawElements(gl, context, start, end);
      gl.clear(gl.DEPTH_BUFFER_BIT);
      end = start;
    }
  }
  if (!hitDetection) {
    gl.disable(gl.DEPTH_TEST);
    gl.clear(gl.DEPTH_BUFFER_BIT);
    //Restore GL parameters.
    gl.depthMask(tmpDepthMask);
    gl.depthFunc(tmpDepthFunc);
  }
};

/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object} skippedFeaturesHash Ids of features to skip.
 */
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.drawReplaySkipping_ = function (gl, context, skippedFeaturesHash) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;
  featureIndex = this.startIndices.length - 2;
  end = start = this.startIndices[featureIndex + 1];
  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      featureStart = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = ol["a" /* default */].getUid(feature).toString();

      if (skippedFeaturesHash[featureUid]) {
        if (start !== end) {
          this.drawElements(gl, context, start, end);
          gl.clear(gl.DEPTH_BUFFER_BIT);
        }
        end = featureStart;
      }
      featureIndex--;
      start = featureStart;
    }
    if (start !== end) {
      this.drawElements(gl, context, start, end);
      gl.clear(gl.DEPTH_BUFFER_BIT);
    }
    start = end = groupStart;
  }
};

/**
 * @inheritDoc
 */
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;
  featureIndex = this.startIndices.length - 2;
  end = this.startIndices[featureIndex + 1];
  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setStrokeStyle_(gl, nextStyle[0], nextStyle[1], nextStyle[2]);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      start = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = ol["a" /* default */].getUid(feature).toString();

      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || ol_extent["a" /* default */].intersects(
      /** @type {Array<number>} */opt_hitExtent, feature.getGeometry().getExtent()))) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.drawElements(gl, context, start, end);

        var result = featureCallback(feature);

        if (result) {
          return result;
        }
      }
      featureIndex--;
      end = start;
    }
  }
  return undefined;
};

/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {Array.<number>} color Color.
 * @param {number} lineWidth Line width.
 * @param {number} miterLimit Miter limit.
 */
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.setStrokeStyle_ = function (gl, color, lineWidth, miterLimit) {
  gl.uniform4fv(this.defaultLocations_.u_color, color);
  gl.uniform1f(this.defaultLocations_.u_lineWidth, lineWidth);
  gl.uniform1f(this.defaultLocations_.u_miterLimit, miterLimit);
};

/**
 * @inheritDoc
 */
linestringreplay__ol_render_webgl_LineStringReplay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  var strokeStyleLineCap = strokeStyle.getLineCap();
  this.state_.lineCap = strokeStyleLineCap !== undefined ? strokeStyleLineCap : render_webgl.defaultLineCap;
  var strokeStyleLineDash = strokeStyle.getLineDash();
  this.state_.lineDash = strokeStyleLineDash ? strokeStyleLineDash : render_webgl.defaultLineDash;
  var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
  this.state_.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : render_webgl.defaultLineDashOffset;
  var strokeStyleLineJoin = strokeStyle.getLineJoin();
  this.state_.lineJoin = strokeStyleLineJoin !== undefined ? strokeStyleLineJoin : render_webgl.defaultLineJoin;
  var strokeStyleColor = strokeStyle.getColor();
  if (!(strokeStyleColor instanceof CanvasGradient) && !(strokeStyleColor instanceof CanvasPattern)) {
    strokeStyleColor = color["a" /* default */].asArray(strokeStyleColor).map(function (c, i) {
      return i != 3 ? c / 255 : c;
    }) || render_webgl.defaultStrokeStyle;
  } else {
    strokeStyleColor = render_webgl.defaultStrokeStyle;
  }
  var strokeStyleWidth = strokeStyle.getWidth();
  strokeStyleWidth = strokeStyleWidth !== undefined ? strokeStyleWidth : render_webgl.defaultLineWidth;
  var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
  strokeStyleMiterLimit = strokeStyleMiterLimit !== undefined ? strokeStyleMiterLimit : render_webgl.defaultMiterLimit;
  if (!this.state_.strokeColor || !array["a" /* default */].equals(this.state_.strokeColor, strokeStyleColor) || this.state_.lineWidth !== strokeStyleWidth || this.state_.miterLimit !== strokeStyleMiterLimit) {
    this.state_.changed = true;
    this.state_.strokeColor = strokeStyleColor;
    this.state_.lineWidth = strokeStyleWidth;
    this.state_.miterLimit = strokeStyleMiterLimit;
    this.styles_.push([strokeStyleColor, strokeStyleWidth, strokeStyleMiterLimit]);
  }
};

/**
 * @enum {number}
 * @private
 */
linestringreplay__ol_render_webgl_LineStringReplay_.Instruction_ = {
  ROUND: 2,
  BEGIN_LINE: 3,
  END_LINE: 5,
  BEGIN_LINE_CAP: 7,
  END_LINE_CAP: 11,
  BEVEL_FIRST: 13,
  BEVEL_SECOND: 17,
  MITER_BOTTOM: 19,
  MITER_TOP: 23
};
/* harmony default export */ var webgl_linestringreplay = (linestringreplay__ol_render_webgl_LineStringReplay_);
// EXTERNAL MODULE: ./node_modules/ol/geom/flat/contains.js
var flat_contains = __webpack_require__(48);

// CONCATENATED MODULE: ./node_modules/ol/render/webgl/polygonreplay/defaultshader.js
// This file is automatically generated, do not edit



var _ol_render_webgl_polygonreplay_defaultshader_ = {};

_ol_render_webgl_polygonreplay_defaultshader_.fragment = new fragment(ol["a" /* default */].DEBUG_WEBGL ? 'precision mediump float;\n\n\n\nuniform vec4 u_color;\nuniform float u_opacity;\n\nvoid main(void) {\n  gl_FragColor = u_color;\n  float alpha = u_color.a * u_opacity;\n  if (alpha == 0.0) {\n    discard;\n  }\n  gl_FragColor.a = alpha;\n}\n' : 'precision mediump float;uniform vec4 e;uniform float f;void main(void){gl_FragColor=e;float alpha=e.a*f;if(alpha==0.0){discard;}gl_FragColor.a=alpha;}');

_ol_render_webgl_polygonreplay_defaultshader_.vertex = new vertex(ol["a" /* default */].DEBUG_WEBGL ? '\n\nattribute vec2 a_position;\n\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_offsetScaleMatrix;\nuniform mat4 u_offsetRotateMatrix;\n\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0.0, 1.0);\n}\n\n\n' : 'attribute vec2 a;uniform mat4 b;uniform mat4 c;uniform mat4 d;void main(void){gl_Position=b*vec4(a,0.0,1.0);}');
/* harmony default export */ var polygonreplay_defaultshader = (_ol_render_webgl_polygonreplay_defaultshader_);
// CONCATENATED MODULE: ./node_modules/ol/render/webgl/polygonreplay/defaultshader/locations.js
// This file is automatically generated, do not edit


/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */
var locations__ol_render_webgl_polygonreplay_defaultshader_Locations_ = function _ol_render_webgl_polygonreplay_defaultshader_Locations_(gl, program) {

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_projectionMatrix = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_projectionMatrix' : 'b');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_offsetScaleMatrix = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_offsetScaleMatrix' : 'c');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_offsetRotateMatrix = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_offsetRotateMatrix' : 'd');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_color = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_color' : 'e');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_opacity = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_opacity' : 'f');

  /**
   * @type {number}
   */
  this.a_position = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_position' : 'a');
};

/* harmony default export */ var polygonreplay_defaultshader_locations = (locations__ol_render_webgl_polygonreplay_defaultshader_Locations_);
// EXTERNAL MODULE: ./node_modules/ol/style/stroke.js
var style_stroke = __webpack_require__(57);

// CONCATENATED MODULE: ./node_modules/ol/structs/linkedlist.js
/**
 * Creates an empty linked list structure.
 *
 * @constructor
 * @struct
 * @param {boolean=} opt_circular The last item is connected to the first one,
 * and the first item to the last one. Default is true.
 */
var _ol_structs_LinkedList_ = function _ol_structs_LinkedList_(opt_circular) {

  /**
   * @private
   * @type {ol.LinkedListItem|undefined}
   */
  this.first_ = undefined;

  /**
   * @private
   * @type {ol.LinkedListItem|undefined}
   */
  this.last_ = undefined;

  /**
   * @private
   * @type {ol.LinkedListItem|undefined}
   */
  this.head_ = undefined;

  /**
   * @private
   * @type {boolean}
   */
  this.circular_ = opt_circular === undefined ? true : opt_circular;

  /**
   * @private
   * @type {number}
   */
  this.length_ = 0;
};

/**
 * Inserts an item into the linked list right after the current one.
 *
 * @param {?} data Item data.
 */
_ol_structs_LinkedList_.prototype.insertItem = function (data) {

  /** @type {ol.LinkedListItem} */
  var item = {
    prev: undefined,
    next: undefined,
    data: data
  };

  var head = this.head_;

  //Initialize the list.
  if (!head) {
    this.first_ = item;
    this.last_ = item;
    if (this.circular_) {
      item.next = item;
      item.prev = item;
    }
  } else {
    //Link the new item to the adjacent ones.
    var next = head.next;
    item.prev = head;
    item.next = next;
    head.next = item;
    if (next) {
      next.prev = item;
    }

    if (head === this.last_) {
      this.last_ = item;
    }
  }
  this.head_ = item;
  this.length_++;
};

/**
 * Removes the current item from the list. Sets the cursor to the next item,
 * if possible.
 */
_ol_structs_LinkedList_.prototype.removeItem = function () {
  var head = this.head_;
  if (head) {
    var next = head.next;
    var prev = head.prev;
    if (next) {
      next.prev = prev;
    }
    if (prev) {
      prev.next = next;
    }
    this.head_ = next || prev;

    if (this.first_ === this.last_) {
      this.head_ = undefined;
      this.first_ = undefined;
      this.last_ = undefined;
    } else if (this.first_ === head) {
      this.first_ = this.head_;
    } else if (this.last_ === head) {
      this.last_ = prev ? this.head_.prev : this.head_;
    }
    this.length_--;
  }
};

/**
 * Sets the cursor to the first item, and returns the associated data.
 *
 * @return {?} Item data.
 */
_ol_structs_LinkedList_.prototype.firstItem = function () {
  this.head_ = this.first_;
  if (this.head_) {
    return this.head_.data;
  }
  return undefined;
};

/**
* Sets the cursor to the last item, and returns the associated data.
*
* @return {?} Item data.
*/
_ol_structs_LinkedList_.prototype.lastItem = function () {
  this.head_ = this.last_;
  if (this.head_) {
    return this.head_.data;
  }
  return undefined;
};

/**
 * Sets the cursor to the next item, and returns the associated data.
 *
 * @return {?} Item data.
 */
_ol_structs_LinkedList_.prototype.nextItem = function () {
  if (this.head_ && this.head_.next) {
    this.head_ = this.head_.next;
    return this.head_.data;
  }
  return undefined;
};

/**
 * Returns the next item's data without moving the cursor.
 *
 * @return {?} Item data.
 */
_ol_structs_LinkedList_.prototype.getNextItem = function () {
  if (this.head_ && this.head_.next) {
    return this.head_.next.data;
  }
  return undefined;
};

/**
 * Sets the cursor to the previous item, and returns the associated data.
 *
 * @return {?} Item data.
 */
_ol_structs_LinkedList_.prototype.prevItem = function () {
  if (this.head_ && this.head_.prev) {
    this.head_ = this.head_.prev;
    return this.head_.data;
  }
  return undefined;
};

/**
 * Returns the previous item's data without moving the cursor.
 *
 * @return {?} Item data.
 */
_ol_structs_LinkedList_.prototype.getPrevItem = function () {
  if (this.head_ && this.head_.prev) {
    return this.head_.prev.data;
  }
  return undefined;
};

/**
 * Returns the current item's data.
 *
 * @return {?} Item data.
 */
_ol_structs_LinkedList_.prototype.getCurrItem = function () {
  if (this.head_) {
    return this.head_.data;
  }
  return undefined;
};

/**
 * Sets the first item of the list. This only works for circular lists, and sets
 * the last item accordingly.
 */
_ol_structs_LinkedList_.prototype.setFirstItem = function () {
  if (this.circular_ && this.head_) {
    this.first_ = this.head_;
    this.last_ = this.head_.prev;
  }
};

/**
 * Concatenates two lists.
 * @param {ol.structs.LinkedList} list List to merge into the current list.
 */
_ol_structs_LinkedList_.prototype.concat = function (list) {
  if (list.head_) {
    if (this.head_) {
      var end = this.head_.next;
      this.head_.next = list.first_;
      list.first_.prev = this.head_;
      end.prev = list.last_;
      list.last_.next = end;
      this.length_ += list.length_;
    } else {
      this.head_ = list.head_;
      this.first_ = list.first_;
      this.last_ = list.last_;
      this.length_ = list.length_;
    }
    list.head_ = undefined;
    list.first_ = undefined;
    list.last_ = undefined;
    list.length_ = 0;
  }
};

/**
 * Returns the current length of the list.
 *
 * @return {number} Length.
 */
_ol_structs_LinkedList_.prototype.getLength = function () {
  return this.length_;
};
/* harmony default export */ var linkedlist = (_ol_structs_LinkedList_);
// EXTERNAL MODULE: ./node_modules/ol/structs/rbush.js
var rbush = __webpack_require__(87);

// CONCATENATED MODULE: ./node_modules/ol/render/webgl/polygonreplay.js
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };




















/**
 * @constructor
 * @extends {ol.render.webgl.Replay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */
var polygonreplay__ol_render_webgl_PolygonReplay_ = function _ol_render_webgl_PolygonReplay_(tolerance, maxExtent) {
  webgl_replay.call(this, tolerance, maxExtent);

  this.lineStringReplay = new webgl_linestringreplay(tolerance, maxExtent);

  /**
   * @private
   * @type {ol.render.webgl.polygonreplay.defaultshader.Locations}
   */
  this.defaultLocations_ = null;

  /**
   * @private
   * @type {Array.<Array.<number>>}
   */
  this.styles_ = [];

  /**
   * @private
   * @type {Array.<number>}
   */
  this.styleIndices_ = [];

  /**
   * @private
   * @type {{fillColor: (Array.<number>|null),
   *         changed: boolean}|null}
   */
  this.state_ = {
    fillColor: null,
    changed: false
  };
};

ol["a" /* default */].inherits(polygonreplay__ol_render_webgl_PolygonReplay_, webgl_replay);

/**
 * Draw one polygon.
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {Array.<Array.<number>>} holeFlatCoordinates Hole flat coordinates.
 * @param {number} stride Stride.
 * @private
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.drawCoordinates_ = function (flatCoordinates, holeFlatCoordinates, stride) {
  // Triangulate the polygon
  var outerRing = new linkedlist();
  var rtree = new rbush["a" /* default */]();
  // Initialize the outer ring
  this.processFlatCoordinates_(flatCoordinates, stride, outerRing, rtree, true);
  var maxCoords = this.getMaxCoords_(outerRing);

  // Eliminate holes, if there are any
  if (holeFlatCoordinates.length) {
    var i, ii;
    var holeLists = [];
    for (i = 0, ii = holeFlatCoordinates.length; i < ii; ++i) {
      var holeList = {
        list: new linkedlist(),
        maxCoords: undefined,
        rtree: new rbush["a" /* default */]()
      };
      holeLists.push(holeList);
      this.processFlatCoordinates_(holeFlatCoordinates[i], stride, holeList.list, holeList.rtree, false);
      this.classifyPoints_(holeList.list, holeList.rtree, true);
      holeList.maxCoords = this.getMaxCoords_(holeList.list);
    }
    holeLists.sort(function (a, b) {
      return b.maxCoords[0] === a.maxCoords[0] ? a.maxCoords[1] - b.maxCoords[1] : b.maxCoords[0] - a.maxCoords[0];
    });
    for (i = 0; i < holeLists.length; ++i) {
      var currList = holeLists[i].list;
      var start = currList.firstItem();
      var currItem = start;
      var intersection;
      do {
        //TODO: Triangulate holes when they intersect the outer ring.
        if (this.getIntersections_(currItem, rtree).length) {
          intersection = true;
          break;
        }
        currItem = currList.nextItem();
      } while (start !== currItem);
      if (!intersection) {
        if (this.bridgeHole_(currList, holeLists[i].maxCoords[0], outerRing, maxCoords[0], rtree)) {
          rtree.concat(holeLists[i].rtree);
          this.classifyPoints_(outerRing, rtree, false);
        }
      }
    }
  } else {
    this.classifyPoints_(outerRing, rtree, false);
  }
  this.triangulate_(outerRing, rtree);
};

/**
 * Inserts flat coordinates in a linked list and adds them to the vertex buffer.
 * @private
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} stride Stride.
 * @param {ol.structs.LinkedList} list Linked list.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean} clockwise Coordinate order should be clockwise.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.processFlatCoordinates_ = function (flatCoordinates, stride, list, rtree, clockwise) {
  var isClockwise = orient["a" /* default */].linearRingIsClockwise(flatCoordinates, 0, flatCoordinates.length, stride);
  var i, ii;
  var n = this.vertices.length / 2;
  /** @type {ol.WebglPolygonVertex} */
  var start;
  /** @type {ol.WebglPolygonVertex} */
  var p0;
  /** @type {ol.WebglPolygonVertex} */
  var p1;
  var extents = [];
  var segments = [];
  if (clockwise === isClockwise) {
    start = this.createPoint_(flatCoordinates[0], flatCoordinates[1], n++);
    p0 = start;
    for (i = stride, ii = flatCoordinates.length; i < ii; i += stride) {
      p1 = this.createPoint_(flatCoordinates[i], flatCoordinates[i + 1], n++);
      segments.push(this.insertItem_(p0, p1, list));
      extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
      p0 = p1;
    }
    segments.push(this.insertItem_(p1, start, list));
    extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
  } else {
    var end = flatCoordinates.length - stride;
    start = this.createPoint_(flatCoordinates[end], flatCoordinates[end + 1], n++);
    p0 = start;
    for (i = end - stride, ii = 0; i >= ii; i -= stride) {
      p1 = this.createPoint_(flatCoordinates[i], flatCoordinates[i + 1], n++);
      segments.push(this.insertItem_(p0, p1, list));
      extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
      p0 = p1;
    }
    segments.push(this.insertItem_(p1, start, list));
    extents.push([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
  }
  rtree.load(extents, segments);
};

/**
 * Returns the rightmost coordinates of a polygon on the X axis.
 * @private
 * @param {ol.structs.LinkedList} list Polygons ring.
 * @return {Array.<number>} Max X coordinates.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.getMaxCoords_ = function (list) {
  var start = list.firstItem();
  var seg = start;
  var maxCoords = [seg.p0.x, seg.p0.y];

  do {
    seg = list.nextItem();
    if (seg.p0.x > maxCoords[0]) {
      maxCoords = [seg.p0.x, seg.p0.y];
    }
  } while (seg !== start);

  return maxCoords;
};

/**
 * Classifies the points of a polygon list as convex, reflex. Removes collinear vertices.
 * @private
 * @param {ol.structs.LinkedList} list Polygon ring.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean} ccw The orientation of the polygon is counter-clockwise.
 * @return {boolean} There were reclassified points.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.classifyPoints_ = function (list, rtree, ccw) {
  var start = list.firstItem();
  var s0 = start;
  var s1 = list.nextItem();
  var pointsReclassified = false;
  do {
    var reflex = ccw ? render_webgl.triangleIsCounterClockwise(s1.p1.x, s1.p1.y, s0.p1.x, s0.p1.y, s0.p0.x, s0.p0.y) : render_webgl.triangleIsCounterClockwise(s0.p0.x, s0.p0.y, s0.p1.x, s0.p1.y, s1.p1.x, s1.p1.y);
    if (reflex === undefined) {
      this.removeItem_(s0, s1, list, rtree);
      pointsReclassified = true;
      if (s1 === start) {
        start = list.getNextItem();
      }
      s1 = s0;
      list.prevItem();
    } else if (s0.p1.reflex !== reflex) {
      s0.p1.reflex = reflex;
      pointsReclassified = true;
    }
    s0 = s1;
    s1 = list.nextItem();
  } while (s0 !== start);
  return pointsReclassified;
};

/**
 * @private
 * @param {ol.structs.LinkedList} hole Linked list of the hole.
 * @param {number} holeMaxX Maximum X value of the hole.
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {number} listMaxX Maximum X value of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @return {boolean} Bridging was successful.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.bridgeHole_ = function (hole, holeMaxX, list, listMaxX, rtree) {
  var seg = hole.firstItem();
  while (seg.p1.x !== holeMaxX) {
    seg = hole.nextItem();
  }

  var p1 = seg.p1;
  /** @type {ol.WebglPolygonVertex} */
  var p2 = { x: listMaxX, y: p1.y, i: -1 };
  var minDist = Infinity;
  var i, ii, bestPoint;
  /** @type {ol.WebglPolygonVertex} */
  var p5;

  var intersectingSegments = this.getIntersections_({ p0: p1, p1: p2 }, rtree, true);
  for (i = 0, ii = intersectingSegments.length; i < ii; ++i) {
    var currSeg = intersectingSegments[i];
    var intersection = this.calculateIntersection_(p1, p2, currSeg.p0, currSeg.p1, true);
    var dist = Math.abs(p1.x - intersection[0]);
    if (dist < minDist && render_webgl.triangleIsCounterClockwise(p1.x, p1.y, currSeg.p0.x, currSeg.p0.y, currSeg.p1.x, currSeg.p1.y) !== undefined) {
      minDist = dist;
      p5 = { x: intersection[0], y: intersection[1], i: -1 };
      seg = currSeg;
    }
  }
  if (minDist === Infinity) {
    return false;
  }
  bestPoint = seg.p1;

  if (minDist > 0) {
    var pointsInTriangle = this.getPointsInTriangle_(p1, p5, seg.p1, rtree);
    if (pointsInTriangle.length) {
      var theta = Infinity;
      for (i = 0, ii = pointsInTriangle.length; i < ii; ++i) {
        var currPoint = pointsInTriangle[i];
        var currTheta = Math.atan2(p1.y - currPoint.y, p2.x - currPoint.x);
        if (currTheta < theta || currTheta === theta && currPoint.x < bestPoint.x) {
          theta = currTheta;
          bestPoint = currPoint;
        }
      }
    }
  }

  seg = list.firstItem();
  while (seg.p1.x !== bestPoint.x || seg.p1.y !== bestPoint.y) {
    seg = list.nextItem();
  }

  //We clone the bridge points as they can have different convexity.
  var p0Bridge = { x: p1.x, y: p1.y, i: p1.i, reflex: undefined };
  var p1Bridge = { x: seg.p1.x, y: seg.p1.y, i: seg.p1.i, reflex: undefined };

  hole.getNextItem().p0 = p0Bridge;
  this.insertItem_(p1, seg.p1, hole, rtree);
  this.insertItem_(p1Bridge, p0Bridge, hole, rtree);
  seg.p1 = p1Bridge;
  hole.setFirstItem();
  list.concat(hole);

  return true;
};

/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.triangulate_ = function (list, rtree) {
  var ccw = false;
  var simple = this.isSimple_(list, rtree);

  // Start clipping ears
  while (list.getLength() > 3) {
    if (simple) {
      if (!this.clipEars_(list, rtree, simple, ccw)) {
        if (!this.classifyPoints_(list, rtree, ccw)) {
          // Due to the behavior of OL's PIP algorithm, the ear clipping cannot
          // introduce touching segments. However, the original data may have some.
          if (!this.resolveSelfIntersections_(list, rtree, true)) {
            break;
          }
        }
      }
    } else {
      if (!this.clipEars_(list, rtree, simple, ccw)) {
        // We ran out of ears, try to reclassify.
        if (!this.classifyPoints_(list, rtree, ccw)) {
          // We have a bad polygon, try to resolve local self-intersections.
          if (!this.resolveSelfIntersections_(list, rtree)) {
            simple = this.isSimple_(list, rtree);
            if (!simple) {
              // We have a really bad polygon, try more time consuming methods.
              this.splitPolygon_(list, rtree);
              break;
            } else {
              ccw = !this.isClockwise_(list);
              this.classifyPoints_(list, rtree, ccw);
            }
          }
        }
      }
    }
  }
  if (list.getLength() === 3) {
    var numIndices = this.indices.length;
    this.indices[numIndices++] = list.getPrevItem().p0.i;
    this.indices[numIndices++] = list.getCurrItem().p0.i;
    this.indices[numIndices++] = list.getNextItem().p0.i;
  }
};

/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean} simple The polygon is simple.
 * @param {boolean} ccw Orientation of the polygon is counter-clockwise.
 * @return {boolean} There were processed ears.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.clipEars_ = function (list, rtree, simple, ccw) {
  var numIndices = this.indices.length;
  var start = list.firstItem();
  var s0 = list.getPrevItem();
  var s1 = start;
  var s2 = list.nextItem();
  var s3 = list.getNextItem();
  var p0, p1, p2;
  var processedEars = false;
  do {
    p0 = s1.p0;
    p1 = s1.p1;
    p2 = s2.p1;
    if (p1.reflex === false) {
      // We might have a valid ear
      var variableCriterion;
      if (simple) {
        variableCriterion = this.getPointsInTriangle_(p0, p1, p2, rtree, true).length === 0;
      } else {
        variableCriterion = ccw ? this.diagonalIsInside_(s3.p1, p2, p1, p0, s0.p0) : this.diagonalIsInside_(s0.p0, p0, p1, p2, s3.p1);
      }
      if ((simple || this.getIntersections_({ p0: p0, p1: p2 }, rtree).length === 0) && variableCriterion) {
        //The diagonal is completely inside the polygon
        if (simple || p0.reflex === false || p2.reflex === false || orient["a" /* default */].linearRingIsClockwise([s0.p0.x, s0.p0.y, p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, s3.p1.x, s3.p1.y], 0, 10, 2) === !ccw) {
          //The diagonal is persumably valid, we have an ear
          this.indices[numIndices++] = p0.i;
          this.indices[numIndices++] = p1.i;
          this.indices[numIndices++] = p2.i;
          this.removeItem_(s1, s2, list, rtree);
          if (s2 === start) {
            start = s3;
          }
          processedEars = true;
        }
      }
    }
    // Else we have a reflex point.
    s0 = list.getPrevItem();
    s1 = list.getCurrItem();
    s2 = list.nextItem();
    s3 = list.getNextItem();
  } while (s1 !== start && list.getLength() > 3);

  return processedEars;
};

/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean=} opt_touch Resolve touching segments.
 * @return {boolean} There were resolved intersections.
*/
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.resolveSelfIntersections_ = function (list, rtree, opt_touch) {
  var start = list.firstItem();
  list.nextItem();
  var s0 = start;
  var s1 = list.nextItem();
  var resolvedIntersections = false;

  do {
    var intersection = this.calculateIntersection_(s0.p0, s0.p1, s1.p0, s1.p1, opt_touch);
    if (intersection) {
      var breakCond = false;
      var numVertices = this.vertices.length;
      var numIndices = this.indices.length;
      var n = numVertices / 2;
      var seg = list.prevItem();
      list.removeItem();
      rtree.remove(seg);
      breakCond = seg === start;
      var p;
      if (opt_touch) {
        if (intersection[0] === s0.p0.x && intersection[1] === s0.p0.y) {
          list.prevItem();
          p = s0.p0;
          s1.p0 = p;
          rtree.remove(s0);
          breakCond = breakCond || s0 === start;
        } else {
          p = s1.p1;
          s0.p1 = p;
          rtree.remove(s1);
          breakCond = breakCond || s1 === start;
        }
        list.removeItem();
      } else {
        p = this.createPoint_(intersection[0], intersection[1], n);
        s0.p1 = p;
        s1.p0 = p;
        rtree.update([Math.min(s0.p0.x, s0.p1.x), Math.min(s0.p0.y, s0.p1.y), Math.max(s0.p0.x, s0.p1.x), Math.max(s0.p0.y, s0.p1.y)], s0);
        rtree.update([Math.min(s1.p0.x, s1.p1.x), Math.min(s1.p0.y, s1.p1.y), Math.max(s1.p0.x, s1.p1.x), Math.max(s1.p0.y, s1.p1.y)], s1);
      }

      this.indices[numIndices++] = seg.p0.i;
      this.indices[numIndices++] = seg.p1.i;
      this.indices[numIndices++] = p.i;

      resolvedIntersections = true;
      if (breakCond) {
        break;
      }
    }

    s0 = list.getPrevItem();
    s1 = list.nextItem();
  } while (s0 !== start);
  return resolvedIntersections;
};

/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @return {boolean} The polygon is simple.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.isSimple_ = function (list, rtree) {
  var start = list.firstItem();
  var seg = start;
  do {
    if (this.getIntersections_(seg, rtree).length) {
      return false;
    }
    seg = list.nextItem();
  } while (seg !== start);
  return true;
};

/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @return {boolean} Orientation is clockwise.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.isClockwise_ = function (list) {
  var length = list.getLength() * 2;
  var flatCoordinates = new Array(length);
  var start = list.firstItem();
  var seg = start;
  var i = 0;
  do {
    flatCoordinates[i++] = seg.p0.x;
    flatCoordinates[i++] = seg.p0.y;
    seg = list.nextItem();
  } while (seg !== start);
  return orient["a" /* default */].linearRingIsClockwise(flatCoordinates, 0, length, 2);
};

/**
 * @private
 * @param {ol.structs.LinkedList} list Linked list of the polygon.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.splitPolygon_ = function (list, rtree) {
  var start = list.firstItem();
  var s0 = start;
  do {
    var intersections = this.getIntersections_(s0, rtree);
    if (intersections.length) {
      var s1 = intersections[0];
      var n = this.vertices.length / 2;
      var intersection = this.calculateIntersection_(s0.p0, s0.p1, s1.p0, s1.p1);
      var p = this.createPoint_(intersection[0], intersection[1], n);
      var newPolygon = new linkedlist();
      var newRtree = new rbush["a" /* default */]();
      this.insertItem_(p, s0.p1, newPolygon, newRtree);
      s0.p1 = p;
      rtree.update([Math.min(s0.p0.x, p.x), Math.min(s0.p0.y, p.y), Math.max(s0.p0.x, p.x), Math.max(s0.p0.y, p.y)], s0);
      var currItem = list.nextItem();
      while (currItem !== s1) {
        this.insertItem_(currItem.p0, currItem.p1, newPolygon, newRtree);
        rtree.remove(currItem);
        list.removeItem();
        currItem = list.getCurrItem();
      }
      this.insertItem_(s1.p0, p, newPolygon, newRtree);
      s1.p0 = p;
      rtree.update([Math.min(s1.p1.x, p.x), Math.min(s1.p1.y, p.y), Math.max(s1.p1.x, p.x), Math.max(s1.p1.y, p.y)], s1);
      this.classifyPoints_(list, rtree, false);
      this.triangulate_(list, rtree);
      this.classifyPoints_(newPolygon, newRtree, false);
      this.triangulate_(newPolygon, newRtree);
      break;
    }
    s0 = list.nextItem();
  } while (s0 !== start);
};

/**
 * @private
 * @param {number} x X coordinate.
 * @param {number} y Y coordinate.
 * @param {number} i Index.
 * @return {ol.WebglPolygonVertex} List item.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.createPoint_ = function (x, y, i) {
  var numVertices = this.vertices.length;
  this.vertices[numVertices++] = x;
  this.vertices[numVertices++] = y;
  /** @type {ol.WebglPolygonVertex} */
  var p = {
    x: x,
    y: y,
    i: i,
    reflex: undefined
  };
  return p;
};

/**
 * @private
 * @param {ol.WebglPolygonVertex} p0 First point of segment.
 * @param {ol.WebglPolygonVertex} p1 Second point of segment.
 * @param {ol.structs.LinkedList} list Polygon ring.
 * @param {ol.structs.RBush=} opt_rtree Insert the segment into the R-Tree.
 * @return {ol.WebglPolygonSegment} segment.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.insertItem_ = function (p0, p1, list, opt_rtree) {
  var seg = {
    p0: p0,
    p1: p1
  };
  list.insertItem(seg);
  if (opt_rtree) {
    opt_rtree.insert([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)], seg);
  }
  return seg;
};

/**
  * @private
  * @param {ol.WebglPolygonSegment} s0 Segment before the remove candidate.
  * @param {ol.WebglPolygonSegment} s1 Remove candidate segment.
  * @param {ol.structs.LinkedList} list Polygon ring.
  * @param {ol.structs.RBush} rtree R-Tree of the polygon.
  */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.removeItem_ = function (s0, s1, list, rtree) {
  if (list.getCurrItem() === s1) {
    list.removeItem();
    s0.p1 = s1.p1;
    rtree.remove(s1);
    rtree.update([Math.min(s0.p0.x, s0.p1.x), Math.min(s0.p0.y, s0.p1.y), Math.max(s0.p0.x, s0.p1.x), Math.max(s0.p0.y, s0.p1.y)], s0);
  }
};

/**
 * @private
 * @param {ol.WebglPolygonVertex} p0 First point.
 * @param {ol.WebglPolygonVertex} p1 Second point.
 * @param {ol.WebglPolygonVertex} p2 Third point.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean=} opt_reflex Only include reflex points.
 * @return {Array.<ol.WebglPolygonVertex>} Points in the triangle.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.getPointsInTriangle_ = function (p0, p1, p2, rtree, opt_reflex) {
  var i, ii, j, p;
  var result = [];
  var segmentsInExtent = rtree.getInExtent([Math.min(p0.x, p1.x, p2.x), Math.min(p0.y, p1.y, p2.y), Math.max(p0.x, p1.x, p2.x), Math.max(p0.y, p1.y, p2.y)]);
  for (i = 0, ii = segmentsInExtent.length; i < ii; ++i) {
    for (j in segmentsInExtent[i]) {
      p = segmentsInExtent[i][j];
      if ((typeof p === 'undefined' ? 'undefined' : _typeof(p)) === 'object' && (!opt_reflex || p.reflex)) {
        if ((p.x !== p0.x || p.y !== p0.y) && (p.x !== p1.x || p.y !== p1.y) && (p.x !== p2.x || p.y !== p2.y) && result.indexOf(p) === -1 && flat_contains["a" /* default */].linearRingContainsXY([p0.x, p0.y, p1.x, p1.y, p2.x, p2.y], 0, 6, 2, p.x, p.y)) {
          result.push(p);
        }
      }
    }
  }
  return result;
};

/**
 * @private
 * @param {ol.WebglPolygonSegment} segment Segment.
 * @param {ol.structs.RBush} rtree R-Tree of the polygon.
 * @param {boolean=} opt_touch Touching segments should be considered an intersection.
 * @return {Array.<ol.WebglPolygonSegment>} Intersecting segments.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.getIntersections_ = function (segment, rtree, opt_touch) {
  var p0 = segment.p0;
  var p1 = segment.p1;
  var segmentsInExtent = rtree.getInExtent([Math.min(p0.x, p1.x), Math.min(p0.y, p1.y), Math.max(p0.x, p1.x), Math.max(p0.y, p1.y)]);
  var result = [];
  var i, ii;
  for (i = 0, ii = segmentsInExtent.length; i < ii; ++i) {
    var currSeg = segmentsInExtent[i];
    if (segment !== currSeg && (opt_touch || currSeg.p0 !== p1 || currSeg.p1 !== p0) && this.calculateIntersection_(p0, p1, currSeg.p0, currSeg.p1, opt_touch)) {
      result.push(currSeg);
    }
  }
  return result;
};

/**
 * Line intersection algorithm by Paul Bourke.
 * @see http://paulbourke.net/geometry/pointlineplane/
 *
 * @private
 * @param {ol.WebglPolygonVertex} p0 First point.
 * @param {ol.WebglPolygonVertex} p1 Second point.
 * @param {ol.WebglPolygonVertex} p2 Third point.
 * @param {ol.WebglPolygonVertex} p3 Fourth point.
 * @param {boolean=} opt_touch Touching segments should be considered an intersection.
 * @return {Array.<number>|undefined} Intersection coordinates.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.calculateIntersection_ = function (p0, p1, p2, p3, opt_touch) {
  var denom = (p3.y - p2.y) * (p1.x - p0.x) - (p3.x - p2.x) * (p1.y - p0.y);
  if (denom !== 0) {
    var ua = ((p3.x - p2.x) * (p0.y - p2.y) - (p3.y - p2.y) * (p0.x - p2.x)) / denom;
    var ub = ((p1.x - p0.x) * (p0.y - p2.y) - (p1.y - p0.y) * (p0.x - p2.x)) / denom;
    if (!opt_touch && ua > render_webgl.EPSILON && ua < 1 - render_webgl.EPSILON && ub > render_webgl.EPSILON && ub < 1 - render_webgl.EPSILON || opt_touch && ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
      return [p0.x + ua * (p1.x - p0.x), p0.y + ua * (p1.y - p0.y)];
    }
  }
  return undefined;
};

/**
 * @private
 * @param {ol.WebglPolygonVertex} p0 Point before the start of the diagonal.
 * @param {ol.WebglPolygonVertex} p1 Start point of the diagonal.
 * @param {ol.WebglPolygonVertex} p2 Ear candidate.
 * @param {ol.WebglPolygonVertex} p3 End point of the diagonal.
 * @param {ol.WebglPolygonVertex} p4 Point after the end of the diagonal.
 * @return {boolean} Diagonal is inside the polygon.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.diagonalIsInside_ = function (p0, p1, p2, p3, p4) {
  if (p1.reflex === undefined || p3.reflex === undefined) {
    return false;
  }
  var p1IsLeftOf = (p2.x - p3.x) * (p1.y - p3.y) > (p2.y - p3.y) * (p1.x - p3.x);
  var p1IsRightOf = (p4.x - p3.x) * (p1.y - p3.y) < (p4.y - p3.y) * (p1.x - p3.x);
  var p3IsLeftOf = (p0.x - p1.x) * (p3.y - p1.y) > (p0.y - p1.y) * (p3.x - p1.x);
  var p3IsRightOf = (p2.x - p1.x) * (p3.y - p1.y) < (p2.y - p1.y) * (p3.x - p1.x);
  var p1InCone = p3.reflex ? p1IsRightOf || p1IsLeftOf : p1IsRightOf && p1IsLeftOf;
  var p3InCone = p1.reflex ? p3IsRightOf || p3IsLeftOf : p3IsRightOf && p3IsLeftOf;
  return p1InCone && p3InCone;
};

/**
 * @inheritDoc
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {
  var endss = multiPolygonGeometry.getEndss();
  var stride = multiPolygonGeometry.getStride();
  var currIndex = this.indices.length;
  var currLineIndex = this.lineStringReplay.getCurrentIndex();
  var flatCoordinates = multiPolygonGeometry.getFlatCoordinates();
  var i, ii, j, jj;
  var start = 0;
  for (i = 0, ii = endss.length; i < ii; ++i) {
    var ends = endss[i];
    if (ends.length > 0) {
      var outerRing = flat_transform["a" /* default */].translate(flatCoordinates, start, ends[0], stride, -this.origin[0], -this.origin[1]);
      if (outerRing.length) {
        var holes = [];
        var holeFlatCoords;
        for (j = 1, jj = ends.length; j < jj; ++j) {
          if (ends[j] !== ends[j - 1]) {
            holeFlatCoords = flat_transform["a" /* default */].translate(flatCoordinates, ends[j - 1], ends[j], stride, -this.origin[0], -this.origin[1]);
            holes.push(holeFlatCoords);
          }
        }
        this.lineStringReplay.drawPolygonCoordinates(outerRing, holes, stride);
        this.drawCoordinates_(outerRing, holes, stride);
      }
    }
    start = ends[ends.length - 1];
  }
  if (this.indices.length > currIndex) {
    this.startIndices.push(currIndex);
    this.startIndicesFeature.push(feature);
    if (this.state_.changed) {
      this.styleIndices_.push(currIndex);
      this.state_.changed = false;
    }
  }
  if (this.lineStringReplay.getCurrentIndex() > currLineIndex) {
    this.lineStringReplay.setPolygonStyle(feature, currLineIndex);
  }
};

/**
 * @inheritDoc
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.drawPolygon = function (polygonGeometry, feature) {
  var ends = polygonGeometry.getEnds();
  var stride = polygonGeometry.getStride();
  if (ends.length > 0) {
    var flatCoordinates = polygonGeometry.getFlatCoordinates().map(Number);
    var outerRing = flat_transform["a" /* default */].translate(flatCoordinates, 0, ends[0], stride, -this.origin[0], -this.origin[1]);
    if (outerRing.length) {
      var holes = [];
      var i, ii, holeFlatCoords;
      for (i = 1, ii = ends.length; i < ii; ++i) {
        if (ends[i] !== ends[i - 1]) {
          holeFlatCoords = flat_transform["a" /* default */].translate(flatCoordinates, ends[i - 1], ends[i], stride, -this.origin[0], -this.origin[1]);
          holes.push(holeFlatCoords);
        }
      }

      this.startIndices.push(this.indices.length);
      this.startIndicesFeature.push(feature);
      if (this.state_.changed) {
        this.styleIndices_.push(this.indices.length);
        this.state_.changed = false;
      }
      this.lineStringReplay.setPolygonStyle(feature);

      this.lineStringReplay.drawPolygonCoordinates(outerRing, holes, stride);
      this.drawCoordinates_(outerRing, holes, stride);
    }
  }
};

/**
 * @inheritDoc
 **/
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.finish = function (context) {
  // create, bind, and populate the vertices buffer
  this.verticesBuffer = new webgl_buffer(this.vertices);

  // create, bind, and populate the indices buffer
  this.indicesBuffer = new webgl_buffer(this.indices);

  this.startIndices.push(this.indices.length);

  this.lineStringReplay.finish(context);

  //Clean up, if there is nothing to draw
  if (this.styleIndices_.length === 0 && this.styles_.length > 0) {
    this.styles_ = [];
  }

  this.vertices = null;
  this.indices = null;
};

/**
 * @inheritDoc
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.getDeleteResourcesFunction = function (context) {
  var verticesBuffer = this.verticesBuffer;
  var indicesBuffer = this.indicesBuffer;
  var lineDeleter = this.lineStringReplay.getDeleteResourcesFunction(context);
  return function () {
    context.deleteBuffer(verticesBuffer);
    context.deleteBuffer(indicesBuffer);
    lineDeleter();
  };
};

/**
 * @inheritDoc
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.setUpProgram = function (gl, context, size, pixelRatio) {
  // get the program
  var fragmentShader, vertexShader;
  fragmentShader = polygonreplay_defaultshader.fragment;
  vertexShader = polygonreplay_defaultshader.vertex;
  var program = context.getProgram(fragmentShader, vertexShader);

  // get the locations
  var locations;
  if (!this.defaultLocations_) {
    locations = new polygonreplay_defaultshader_locations(gl, program);
    this.defaultLocations_ = locations;
  } else {
    locations = this.defaultLocations_;
  }

  context.useProgram(program);

  // enable the vertex attrib arrays
  gl.enableVertexAttribArray(locations.a_position);
  gl.vertexAttribPointer(locations.a_position, 2, webgl["a" /* default */].FLOAT, false, 8, 0);

  return locations;
};

/**
 * @inheritDoc
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.shutDownProgram = function (gl, locations) {
  gl.disableVertexAttribArray(locations.a_position);
};

/**
 * @inheritDoc
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.drawReplay = function (gl, context, skippedFeaturesHash, hitDetection) {
  //Save GL parameters.
  var tmpDepthFunc = /** @type {number} */gl.getParameter(gl.DEPTH_FUNC);
  var tmpDepthMask = /** @type {boolean} */gl.getParameter(gl.DEPTH_WRITEMASK);

  if (!hitDetection) {
    gl.enable(gl.DEPTH_TEST);
    gl.depthMask(true);
    gl.depthFunc(gl.NOTEQUAL);
  }

  if (!obj["a" /* default */].isEmpty(skippedFeaturesHash)) {
    this.drawReplaySkipping_(gl, context, skippedFeaturesHash);
  } else {
    //Draw by style groups to minimize drawElements() calls.
    var i, start, end, nextStyle;
    end = this.startIndices[this.startIndices.length - 1];
    for (i = this.styleIndices_.length - 1; i >= 0; --i) {
      start = this.styleIndices_[i];
      nextStyle = this.styles_[i];
      this.setFillStyle_(gl, nextStyle);
      this.drawElements(gl, context, start, end);
      end = start;
    }
  }
  if (!hitDetection) {
    gl.disable(gl.DEPTH_TEST);
    gl.clear(gl.DEPTH_BUFFER_BIT);
    //Restore GL parameters.
    gl.depthMask(tmpDepthMask);
    gl.depthFunc(tmpDepthFunc);
  }
};

/**
 * @inheritDoc
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.drawHitDetectionReplayOneByOne = function (gl, context, skippedFeaturesHash, featureCallback, opt_hitExtent) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex;
  featureIndex = this.startIndices.length - 2;
  end = this.startIndices[featureIndex + 1];
  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setFillStyle_(gl, nextStyle);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      start = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = ol["a" /* default */].getUid(feature).toString();

      if (skippedFeaturesHash[featureUid] === undefined && feature.getGeometry() && (opt_hitExtent === undefined || ol_extent["a" /* default */].intersects(
      /** @type {Array<number>} */opt_hitExtent, feature.getGeometry().getExtent()))) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        this.drawElements(gl, context, start, end);

        var result = featureCallback(feature);

        if (result) {
          return result;
        }
      }
      featureIndex--;
      end = start;
    }
  }
  return undefined;
};

/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {ol.webgl.Context} context Context.
 * @param {Object} skippedFeaturesHash Ids of features to skip.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.drawReplaySkipping_ = function (gl, context, skippedFeaturesHash) {
  var i, start, end, nextStyle, groupStart, feature, featureUid, featureIndex, featureStart;
  featureIndex = this.startIndices.length - 2;
  end = start = this.startIndices[featureIndex + 1];
  for (i = this.styleIndices_.length - 1; i >= 0; --i) {
    nextStyle = this.styles_[i];
    this.setFillStyle_(gl, nextStyle);
    groupStart = this.styleIndices_[i];

    while (featureIndex >= 0 && this.startIndices[featureIndex] >= groupStart) {
      featureStart = this.startIndices[featureIndex];
      feature = this.startIndicesFeature[featureIndex];
      featureUid = ol["a" /* default */].getUid(feature).toString();

      if (skippedFeaturesHash[featureUid]) {
        if (start !== end) {
          this.drawElements(gl, context, start, end);
          gl.clear(gl.DEPTH_BUFFER_BIT);
        }
        end = featureStart;
      }
      featureIndex--;
      start = featureStart;
    }
    if (start !== end) {
      this.drawElements(gl, context, start, end);
      gl.clear(gl.DEPTH_BUFFER_BIT);
    }
    start = end = groupStart;
  }
};

/**
 * @private
 * @param {WebGLRenderingContext} gl gl.
 * @param {Array.<number>} color Color.
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.setFillStyle_ = function (gl, color) {
  gl.uniform4fv(this.defaultLocations_.u_color, color);
};

/**
 * @inheritDoc
 */
polygonreplay__ol_render_webgl_PolygonReplay_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  var fillStyleColor = fillStyle ? fillStyle.getColor() : [0, 0, 0, 0];
  if (!(fillStyleColor instanceof CanvasGradient) && !(fillStyleColor instanceof CanvasPattern)) {
    fillStyleColor = color["a" /* default */].asArray(fillStyleColor).map(function (c, i) {
      return i != 3 ? c / 255 : c;
    }) || render_webgl.defaultFillStyle;
  } else {
    fillStyleColor = render_webgl.defaultFillStyle;
  }
  if (!this.state_.fillColor || !array["a" /* default */].equals(fillStyleColor, this.state_.fillColor)) {
    this.state_.fillColor = fillStyleColor;
    this.state_.changed = true;
    this.styles_.push(fillStyleColor);
  }
  //Provide a null stroke style, if no strokeStyle is provided. Required for the draw interaction to work.
  if (strokeStyle) {
    this.lineStringReplay.setFillStrokeStyle(null, strokeStyle);
  } else {
    var nullStrokeStyle = new style_stroke["default"]({
      color: [0, 0, 0, 0],
      lineWidth: 0
    });
    this.lineStringReplay.setFillStrokeStyle(null, nullStrokeStyle);
  }
};
/* harmony default export */ var webgl_polygonreplay = (polygonreplay__ol_render_webgl_PolygonReplay_);
// CONCATENATED MODULE: ./node_modules/ol/style/atlas.js


/**
 * This class facilitates the creation of image atlases.
 *
 * Images added to an atlas will be rendered onto a single
 * atlas canvas. The distribution of images on the canvas is
 * managed with the bin packing algorithm described in:
 * http://www.blackpawn.com/texts/lightmaps/
 *
 * @constructor
 * @struct
 * @param {number} size The size in pixels of the sprite image.
 * @param {number} space The space in pixels between images.
 *    Because texture coordinates are float values, the edges of
 *    images might not be completely correct (in a way that the
 *    edges overlap when being rendered). To avoid this we add a
 *    padding around each image.
 */
var atlas__ol_style_Atlas_ = function _ol_style_Atlas_(size, space) {

  /**
   * @private
   * @type {number}
   */
  this.space_ = space;

  /**
   * @private
   * @type {Array.<ol.AtlasBlock>}
   */
  this.emptyBlocks_ = [{ x: 0, y: 0, width: size, height: size }];

  /**
   * @private
   * @type {Object.<string, ol.AtlasInfo>}
   */
  this.entries_ = {};

  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */
  this.context_ = dom["a" /* default */].createCanvasContext2D(size, size);

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = this.context_.canvas;
};

/**
 * @param {string} id The identifier of the entry to check.
 * @return {?ol.AtlasInfo} The atlas info.
 */
atlas__ol_style_Atlas_.prototype.get = function (id) {
  return this.entries_[id] || null;
};

/**
 * @param {string} id The identifier of the entry to add.
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {function(CanvasRenderingContext2D, number, number)} renderCallback
 *    Called to render the new image onto an atlas image.
 * @param {Object=} opt_this Value to use as `this` when executing
 *    `renderCallback`.
 * @return {?ol.AtlasInfo} The position and atlas image for the entry.
 */
atlas__ol_style_Atlas_.prototype.add = function (id, width, height, renderCallback, opt_this) {
  var block, i, ii;
  for (i = 0, ii = this.emptyBlocks_.length; i < ii; ++i) {
    block = this.emptyBlocks_[i];
    if (block.width >= width + this.space_ && block.height >= height + this.space_) {
      // we found a block that is big enough for our entry
      var entry = {
        offsetX: block.x + this.space_,
        offsetY: block.y + this.space_,
        image: this.canvas_
      };
      this.entries_[id] = entry;

      // render the image on the atlas image
      renderCallback.call(opt_this, this.context_, block.x + this.space_, block.y + this.space_);

      // split the block after the insertion, either horizontally or vertically
      this.split_(i, block, width + this.space_, height + this.space_);

      return entry;
    }
  }

  // there is no space for the new entry in this atlas
  return null;
};

/**
 * @private
 * @param {number} index The index of the block.
 * @param {ol.AtlasBlock} block The block to split.
 * @param {number} width The width of the entry to insert.
 * @param {number} height The height of the entry to insert.
 */
atlas__ol_style_Atlas_.prototype.split_ = function (index, block, width, height) {
  var deltaWidth = block.width - width;
  var deltaHeight = block.height - height;

  /** @type {ol.AtlasBlock} */
  var newBlock1;
  /** @type {ol.AtlasBlock} */
  var newBlock2;

  if (deltaWidth > deltaHeight) {
    // split vertically
    // block right of the inserted entry
    newBlock1 = {
      x: block.x + width,
      y: block.y,
      width: block.width - width,
      height: block.height
    };

    // block below the inserted entry
    newBlock2 = {
      x: block.x,
      y: block.y + height,
      width: width,
      height: block.height - height
    };
    this.updateBlocks_(index, newBlock1, newBlock2);
  } else {
    // split horizontally
    // block right of the inserted entry
    newBlock1 = {
      x: block.x + width,
      y: block.y,
      width: block.width - width,
      height: height
    };

    // block below the inserted entry
    newBlock2 = {
      x: block.x,
      y: block.y + height,
      width: block.width,
      height: block.height - height
    };
    this.updateBlocks_(index, newBlock1, newBlock2);
  }
};

/**
 * Remove the old block and insert new blocks at the same array position.
 * The new blocks are inserted at the same position, so that splitted
 * blocks (that are potentially smaller) are filled first.
 * @private
 * @param {number} index The index of the block to remove.
 * @param {ol.AtlasBlock} newBlock1 The 1st block to add.
 * @param {ol.AtlasBlock} newBlock2 The 2nd block to add.
 */
atlas__ol_style_Atlas_.prototype.updateBlocks_ = function (index, newBlock1, newBlock2) {
  var args = [index, 1];
  if (newBlock1.width > 0 && newBlock1.height > 0) {
    args.push(newBlock1);
  }
  if (newBlock2.width > 0 && newBlock2.height > 0) {
    args.push(newBlock2);
  }
  this.emptyBlocks_.splice.apply(this.emptyBlocks_, args);
};
/* harmony default export */ var style_atlas = (atlas__ol_style_Atlas_);
// CONCATENATED MODULE: ./node_modules/ol/style/atlasmanager.js



/**
 * Manages the creation of image atlases.
 *
 * Images added to this manager will be inserted into an atlas, which
 * will be used for rendering.
 * The `size` given in the constructor is the size for the first
 * atlas. After that, when new atlases are created, they will have
 * twice the size as the latest atlas (until `maxSize` is reached).
 *
 * If an application uses many images or very large images, it is recommended
 * to set a higher `size` value to avoid the creation of too many atlases.
 *
 * @constructor
 * @struct
 * @api
 * @param {olx.style.AtlasManagerOptions=} opt_options Options.
 */
var atlasmanager__ol_style_AtlasManager_ = function _ol_style_AtlasManager_(opt_options) {

  var options = opt_options || {};

  /**
   * The size in pixels of the latest atlas image.
   * @private
   * @type {number}
   */
  this.currentSize_ = options.initialSize !== undefined ? options.initialSize : ol["a" /* default */].INITIAL_ATLAS_SIZE;

  /**
   * The maximum size in pixels of atlas images.
   * @private
   * @type {number}
   */
  this.maxSize_ = options.maxSize !== undefined ? options.maxSize : ol["a" /* default */].MAX_ATLAS_SIZE != -1 ? ol["a" /* default */].MAX_ATLAS_SIZE : ol["a" /* default */].WEBGL_MAX_TEXTURE_SIZE !== undefined ? ol["a" /* default */].WEBGL_MAX_TEXTURE_SIZE : 2048;

  /**
   * The size in pixels between images.
   * @private
   * @type {number}
   */
  this.space_ = options.space !== undefined ? options.space : 1;

  /**
   * @private
   * @type {Array.<ol.style.Atlas>}
   */
  this.atlases_ = [new style_atlas(this.currentSize_, this.space_)];

  /**
   * The size in pixels of the latest atlas image for hit-detection images.
   * @private
   * @type {number}
   */
  this.currentHitSize_ = this.currentSize_;

  /**
   * @private
   * @type {Array.<ol.style.Atlas>}
   */
  this.hitAtlases_ = [new style_atlas(this.currentHitSize_, this.space_)];
};

/**
 * @param {string} id The identifier of the entry to check.
 * @return {?ol.AtlasManagerInfo} The position and atlas image for the
 *    entry, or `null` if the entry is not part of the atlas manager.
 */
atlasmanager__ol_style_AtlasManager_.prototype.getInfo = function (id) {
  /** @type {?ol.AtlasInfo} */
  var info = this.getInfo_(this.atlases_, id);

  if (!info) {
    return null;
  }
  var hitInfo = /** @type {ol.AtlasInfo} */this.getInfo_(this.hitAtlases_, id);

  return this.mergeInfos_(info, hitInfo);
};

/**
 * @private
 * @param {Array.<ol.style.Atlas>} atlases The atlases to search.
 * @param {string} id The identifier of the entry to check.
 * @return {?ol.AtlasInfo} The position and atlas image for the entry,
 *    or `null` if the entry is not part of the atlases.
 */
atlasmanager__ol_style_AtlasManager_.prototype.getInfo_ = function (atlases, id) {
  var atlas, info, i, ii;
  for (i = 0, ii = atlases.length; i < ii; ++i) {
    atlas = atlases[i];
    info = atlas.get(id);
    if (info) {
      return info;
    }
  }
  return null;
};

/**
 * @private
 * @param {ol.AtlasInfo} info The info for the real image.
 * @param {ol.AtlasInfo} hitInfo The info for the hit-detection
 *    image.
 * @return {?ol.AtlasManagerInfo} The position and atlas image for the
 *    entry, or `null` if the entry is not part of the atlases.
 */
atlasmanager__ol_style_AtlasManager_.prototype.mergeInfos_ = function (info, hitInfo) {
  return (/** @type {ol.AtlasManagerInfo} */{
      offsetX: info.offsetX,
      offsetY: info.offsetY,
      image: info.image,
      hitImage: hitInfo.image
    }
  );
};

/**
 * Add an image to the atlas manager.
 *
 * If an entry for the given id already exists, the entry will
 * be overridden (but the space on the atlas graphic will not be freed).
 *
 * If `renderHitCallback` is provided, the image (or the hit-detection version
 * of the image) will be rendered into a separate hit-detection atlas image.
 *
 * @param {string} id The identifier of the entry to add.
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {function(CanvasRenderingContext2D, number, number)} renderCallback
 *    Called to render the new image onto an atlas image.
 * @param {function(CanvasRenderingContext2D, number, number)=}
 *    opt_renderHitCallback Called to render a hit-detection image onto a hit
 *    detection atlas image.
 * @param {Object=} opt_this Value to use as `this` when executing
 *    `renderCallback` and `renderHitCallback`.
 * @return {?ol.AtlasManagerInfo}  The position and atlas image for the
 *    entry, or `null` if the image is too big.
 */
atlasmanager__ol_style_AtlasManager_.prototype.add = function (id, width, height, renderCallback, opt_renderHitCallback, opt_this) {
  if (width + this.space_ > this.maxSize_ || height + this.space_ > this.maxSize_) {
    return null;
  }

  /** @type {?ol.AtlasInfo} */
  var info = this.add_(false, id, width, height, renderCallback, opt_this);
  if (!info) {
    return null;
  }

  // even if no hit-detection entry is requested, we insert a fake entry into
  // the hit-detection atlas, to make sure that the offset is the same for
  // the original image and the hit-detection image.
  var renderHitCallback = opt_renderHitCallback !== undefined ? opt_renderHitCallback : ol["a" /* default */].nullFunction;

  var hitInfo = /** @type {ol.AtlasInfo} */this.add_(true, id, width, height, renderHitCallback, opt_this);

  return this.mergeInfos_(info, hitInfo);
};

/**
 * @private
 * @param {boolean} isHitAtlas If the hit-detection atlases are used.
 * @param {string} id The identifier of the entry to add.
 * @param {number} width The width.
 * @param {number} height The height.
 * @param {function(CanvasRenderingContext2D, number, number)} renderCallback
 *    Called to render the new image onto an atlas image.
 * @param {Object=} opt_this Value to use as `this` when executing
 *    `renderCallback` and `renderHitCallback`.
 * @return {?ol.AtlasInfo}  The position and atlas image for the entry,
 *    or `null` if the image is too big.
 */
atlasmanager__ol_style_AtlasManager_.prototype.add_ = function (isHitAtlas, id, width, height, renderCallback, opt_this) {
  var atlases = isHitAtlas ? this.hitAtlases_ : this.atlases_;
  var atlas, info, i, ii;
  for (i = 0, ii = atlases.length; i < ii; ++i) {
    atlas = atlases[i];
    info = atlas.add(id, width, height, renderCallback, opt_this);
    if (info) {
      return info;
    } else if (!info && i === ii - 1) {
      // the entry could not be added to one of the existing atlases,
      // create a new atlas that is twice as big and try to add to this one.
      var size;
      if (isHitAtlas) {
        size = Math.min(this.currentHitSize_ * 2, this.maxSize_);
        this.currentHitSize_ = size;
      } else {
        size = Math.min(this.currentSize_ * 2, this.maxSize_);
        this.currentSize_ = size;
      }
      atlas = new style_atlas(size, this.space_);
      atlases.push(atlas);
      // run the loop another time
      ++ii;
    }
  }
  return null;
};
/* harmony default export */ var atlasmanager = (atlasmanager__ol_style_AtlasManager_);
// CONCATENATED MODULE: ./node_modules/ol/render/webgl/textreplay.js











/**
 * @constructor
 * @extends {ol.render.webgl.TextureReplay}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @struct
 */
var textreplay__ol_render_webgl_TextReplay_ = function _ol_render_webgl_TextReplay_(tolerance, maxExtent) {
  texturereplay.call(this, tolerance, maxExtent);

  /**
   * @private
   * @type {Array.<HTMLCanvasElement>}
   */
  this.images_ = [];

  /**
   * @private
   * @type {Array.<WebGLTexture>}
   */
  this.textures_ = [];

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.measureCanvas_ = dom["a" /* default */].createCanvasContext2D(0, 0).canvas;

  /**
   * @private
   * @type {{strokeColor: (ol.ColorLike|null),
   *         lineCap: (string|undefined),
   *         lineDash: Array.<number>,
   *         lineDashOffset: (number|undefined),
   *         lineJoin: (string|undefined),
   *         lineWidth: number,
   *         miterLimit: (number|undefined),
   *         fillColor: (ol.ColorLike|null),
   *         font: (string|undefined),
   *         scale: (number|undefined)}}
   */
  this.state_ = {
    strokeColor: null,
    lineCap: undefined,
    lineDash: null,
    lineDashOffset: undefined,
    lineJoin: undefined,
    lineWidth: 0,
    miterLimit: undefined,
    fillColor: null,
    font: undefined,
    scale: undefined
  };

  /**
   * @private
   * @type {string}
   */
  this.text_ = '';

  /**
   * @private
   * @type {number|undefined}
   */
  this.textAlign_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.textBaseline_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.offsetX_ = undefined;

  /**
   * @private
   * @type {number|undefined}
   */
  this.offsetY_ = undefined;

  /**
   * @private
   * @type {Object.<string, ol.WebglGlyphAtlas>}
   */
  this.atlases_ = {};

  /**
   * @private
   * @type {ol.WebglGlyphAtlas|undefined}
   */
  this.currAtlas_ = undefined;

  this.scale = 1;

  this.opacity = 1;
};

ol["a" /* default */].inherits(textreplay__ol_render_webgl_TextReplay_, texturereplay);

/**
 * @inheritDoc
 */
textreplay__ol_render_webgl_TextReplay_.prototype.drawText = function (geometry, feature) {
  if (this.text_) {
    var flatCoordinates = null;
    var offset = 0;
    var end = 2;
    var stride = 2;
    switch (geometry.getType()) {
      case geometrytype["a" /* default */].POINT:
      case geometrytype["a" /* default */].MULTI_POINT:
        flatCoordinates = geometry.getFlatCoordinates();
        end = flatCoordinates.length;
        stride = geometry.getStride();
        break;
      case geometrytype["a" /* default */].CIRCLE:
        flatCoordinates = /** @type {ol.geom.Circle} */geometry.getCenter();
        break;
      case geometrytype["a" /* default */].LINE_STRING:
        flatCoordinates = /** @type {ol.geom.LineString} */geometry.getFlatMidpoint();
        break;
      case geometrytype["a" /* default */].MULTI_LINE_STRING:
        flatCoordinates = /** @type {ol.geom.MultiLineString} */geometry.getFlatMidpoints();
        end = flatCoordinates.length;
        break;
      case geometrytype["a" /* default */].POLYGON:
        flatCoordinates = /** @type {ol.geom.Polygon} */geometry.getFlatInteriorPoint();
        break;
      case geometrytype["a" /* default */].MULTI_POLYGON:
        flatCoordinates = /** @type {ol.geom.MultiPolygon} */geometry.getFlatInteriorPoints();
        end = flatCoordinates.length;
        break;
      default:
    }
    this.startIndices.push(this.indices.length);
    this.startIndicesFeature.push(feature);

    var glyphAtlas = this.currAtlas_;
    var lines = this.text_.split('\n');
    var textSize = this.getTextSize_(lines);
    var i, ii, j, jj, currX, currY, charArr, charInfo;
    var anchorX = Math.round(textSize[0] * this.textAlign_ - this.offsetX_);
    var anchorY = Math.round(textSize[1] * this.textBaseline_ - this.offsetY_);
    var lineWidth = this.state_.lineWidth / 2 * this.state_.scale;

    for (i = 0, ii = lines.length; i < ii; ++i) {
      currX = 0;
      currY = glyphAtlas.height * i;
      charArr = lines[i].split('');

      for (j = 0, jj = charArr.length; j < jj; ++j) {
        charInfo = glyphAtlas.atlas.getInfo(charArr[j]);

        if (charInfo) {
          var image = charInfo.image;

          this.anchorX = anchorX - currX;
          this.anchorY = anchorY - currY;
          this.originX = j === 0 ? charInfo.offsetX - lineWidth : charInfo.offsetX;
          this.originY = charInfo.offsetY;
          this.height = glyphAtlas.height;
          this.width = j === 0 || j === charArr.length - 1 ? glyphAtlas.width[charArr[j]] + lineWidth : glyphAtlas.width[charArr[j]];
          this.imageHeight = image.height;
          this.imageWidth = image.width;

          var currentImage;
          if (this.images_.length === 0) {
            this.images_.push(image);
          } else {
            currentImage = this.images_[this.images_.length - 1];
            if (ol["a" /* default */].getUid(currentImage) != ol["a" /* default */].getUid(image)) {
              this.groupIndices.push(this.indices.length);
              this.images_.push(image);
            }
          }

          this.drawText_(flatCoordinates, offset, end, stride);
        }
        currX += this.width;
      }
    }
  }
};

/**
 * @private
 * @param {Array.<string>} lines Label to draw split to lines.
 * @return {Array.<number>} Size of the label in pixels.
 */
textreplay__ol_render_webgl_TextReplay_.prototype.getTextSize_ = function (lines) {
  var self = this;
  var glyphAtlas = this.currAtlas_;
  var textHeight = lines.length * glyphAtlas.height;
  //Split every line to an array of chars, sum up their width, and select the longest.
  var textWidth = lines.map(function (str) {
    var sum = 0;
    var i, ii;
    for (i = 0, ii = str.length; i < ii; ++i) {
      var curr = str[i];
      if (!glyphAtlas.width[curr]) {
        self.addCharToAtlas_(curr);
      }
      sum += glyphAtlas.width[curr] ? glyphAtlas.width[curr] : 0;
    }
    return sum;
  }).reduce(function (max, curr) {
    return Math.max(max, curr);
  });

  return [textWidth, textHeight];
};

/**
 * @private
 * @param {Array.<number>} flatCoordinates Flat coordinates.
 * @param {number} offset Offset.
 * @param {number} end End.
 * @param {number} stride Stride.
 */
textreplay__ol_render_webgl_TextReplay_.prototype.drawText_ = function (flatCoordinates, offset, end, stride) {
  var i, ii;
  for (i = offset, ii = end; i < ii; i += stride) {
    this.drawCoordinates(flatCoordinates, offset, end, stride);
  }
};

/**
 * @private
 * @param {string} char Character.
 */
textreplay__ol_render_webgl_TextReplay_.prototype.addCharToAtlas_ = function (char) {
  if (char.length === 1) {
    var glyphAtlas = this.currAtlas_;
    var state = this.state_;
    var mCtx = this.measureCanvas_.getContext('2d');
    mCtx.font = state.font;
    var width = Math.ceil(mCtx.measureText(char).width * state.scale);

    var info = glyphAtlas.atlas.add(char, width, glyphAtlas.height, function (ctx, x, y) {
      //Parameterize the canvas
      ctx.font = /** @type {string} */state.font;
      ctx.fillStyle = state.fillColor;
      ctx.strokeStyle = state.strokeColor;
      ctx.lineWidth = state.lineWidth;
      ctx.lineCap = /*** @type {string} */state.lineCap;
      ctx.lineJoin = /** @type {string} */state.lineJoin;
      ctx.miterLimit = /** @type {number} */state.miterLimit;
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';
      if (has["a" /* default */].CANVAS_LINE_DASH && state.lineDash) {
        //FIXME: use pixelRatio
        ctx.setLineDash(state.lineDash);
        ctx.lineDashOffset = /** @type {number} */state.lineDashOffset;
      }
      if (state.scale !== 1) {
        //FIXME: use pixelRatio
        ctx.setTransform( /** @type {number} */state.scale, 0, 0,
        /** @type {number} */state.scale, 0, 0);
      }

      //Draw the character on the canvas
      if (state.strokeColor) {
        ctx.strokeText(char, x, y);
      }
      if (state.fillColor) {
        ctx.fillText(char, x, y);
      }
    });

    if (info) {
      glyphAtlas.width[char] = width;
    }
  }
};

/**
 * @inheritDoc
 */
textreplay__ol_render_webgl_TextReplay_.prototype.finish = function (context) {
  var gl = context.getGL();

  this.groupIndices.push(this.indices.length);
  this.hitDetectionGroupIndices = this.groupIndices;

  // create, bind, and populate the vertices buffer
  this.verticesBuffer = new webgl_buffer(this.vertices);

  // create, bind, and populate the indices buffer
  this.indicesBuffer = new webgl_buffer(this.indices);

  // create textures
  /** @type {Object.<string, WebGLTexture>} */
  var texturePerImage = {};

  this.createTextures(this.textures_, this.images_, texturePerImage, gl);

  this.state_ = {
    strokeColor: null,
    lineCap: undefined,
    lineDash: null,
    lineDashOffset: undefined,
    lineJoin: undefined,
    lineWidth: 0,
    miterLimit: undefined,
    fillColor: null,
    font: undefined,
    scale: undefined
  };
  this.text_ = '';
  this.textAlign_ = undefined;
  this.textBaseline_ = undefined;
  this.offsetX_ = undefined;
  this.offsetY_ = undefined;
  this.images_ = null;
  this.atlases_ = {};
  this.currAtlas_ = undefined;
  texturereplay.prototype.finish.call(this, context);
};

/**
 * @inheritDoc
 */
textreplay__ol_render_webgl_TextReplay_.prototype.setTextStyle = function (textStyle) {
  var state = this.state_;
  var textFillStyle = textStyle.getFill();
  var textStrokeStyle = textStyle.getStroke();
  if (!textStyle || !textStyle.getText() || !textFillStyle && !textStrokeStyle) {
    this.text_ = '';
  } else {
    if (!textFillStyle) {
      state.fillColor = null;
    } else {
      var textFillStyleColor = textFillStyle.getColor();
      state.fillColor = colorlike["a" /* default */].asColorLike(textFillStyleColor ? textFillStyleColor : render_webgl.defaultFillStyle);
    }
    if (!textStrokeStyle) {
      state.strokeColor = null;
      state.lineWidth = 0;
    } else {
      var textStrokeStyleColor = textStrokeStyle.getColor();
      state.strokeColor = colorlike["a" /* default */].asColorLike(textStrokeStyleColor ? textStrokeStyleColor : render_webgl.defaultStrokeStyle);
      state.lineWidth = textStrokeStyle.getWidth() || render_webgl.defaultLineWidth;
      state.lineCap = textStrokeStyle.getLineCap() || render_webgl.defaultLineCap;
      state.lineDashOffset = textStrokeStyle.getLineDashOffset() || render_webgl.defaultLineDashOffset;
      state.lineJoin = textStrokeStyle.getLineJoin() || render_webgl.defaultLineJoin;
      state.miterLimit = textStrokeStyle.getMiterLimit() || render_webgl.defaultMiterLimit;
      var lineDash = textStrokeStyle.getLineDash();
      state.lineDash = lineDash ? lineDash.slice() : render_webgl.defaultLineDash;
    }
    state.font = textStyle.getFont() || render_webgl.defaultFont;
    state.scale = textStyle.getScale() || 1;
    this.text_ = /** @type {string} */textStyle.getText();
    var textAlign = render_replay.TEXT_ALIGN[textStyle.getTextAlign()];
    var textBaseline = render_replay.TEXT_ALIGN[textStyle.getTextBaseline()];
    this.textAlign_ = textAlign === undefined ? render_webgl.defaultTextAlign : textAlign;
    this.textBaseline_ = textBaseline === undefined ? render_webgl.defaultTextBaseline : textBaseline;
    this.offsetX_ = textStyle.getOffsetX() || 0;
    this.offsetY_ = textStyle.getOffsetY() || 0;
    this.rotateWithView = !!textStyle.getRotateWithView();
    this.rotation = textStyle.getRotation() || 0;

    this.currAtlas_ = this.getAtlas_(state);
  }
};

/**
 * @private
 * @param {Object} state Font attributes.
 * @return {ol.WebglGlyphAtlas} Glyph atlas.
 */
textreplay__ol_render_webgl_TextReplay_.prototype.getAtlas_ = function (state) {
  var params = [];
  var i;
  for (i in state) {
    if (state[i] || state[i] === 0) {
      if (Array.isArray(state[i])) {
        params = params.concat(state[i]);
      } else {
        params.push(state[i]);
      }
    }
  }
  var hash = this.calculateHash_(params);
  if (!this.atlases_[hash]) {
    var mCtx = this.measureCanvas_.getContext('2d');
    mCtx.font = state.font;
    var height = Math.ceil((mCtx.measureText('M').width * 1.5 + state.lineWidth / 2) * state.scale);

    this.atlases_[hash] = {
      atlas: new atlasmanager({
        space: state.lineWidth + 1
      }),
      width: {},
      height: height
    };
  }
  return this.atlases_[hash];
};

/**
 * @private
 * @param {Array.<string|number>} params Array of parameters.
 * @return {string} Hash string.
 */
textreplay__ol_render_webgl_TextReplay_.prototype.calculateHash_ = function (params) {
  //TODO: Create a more performant, reliable, general hash function.
  var i, ii;
  var hash = '';
  for (i = 0, ii = params.length; i < ii; ++i) {
    hash += params[i];
  }
  return hash;
};

/**
 * @inheritDoc
 */
textreplay__ol_render_webgl_TextReplay_.prototype.getTextures = function (opt_all) {
  return this.textures_;
};

/**
 * @inheritDoc
 */
textreplay__ol_render_webgl_TextReplay_.prototype.getHitDetectionTextures = function () {
  return this.textures_;
};
/* harmony default export */ var webgl_textreplay = (textreplay__ol_render_webgl_TextReplay_);
// CONCATENATED MODULE: ./node_modules/ol/render/webgl/replaygroup.js












/**
 * @constructor
 * @extends {ol.render.ReplayGroup}
 * @param {number} tolerance Tolerance.
 * @param {ol.Extent} maxExtent Max extent.
 * @param {number=} opt_renderBuffer Render buffer.
 * @struct
 */
var replaygroup__ol_render_webgl_ReplayGroup_ = function _ol_render_webgl_ReplayGroup_(tolerance, maxExtent, opt_renderBuffer) {
  replaygroup.call(this);

  /**
   * @type {ol.Extent}
   * @private
   */
  this.maxExtent_ = maxExtent;

  /**
   * @type {number}
   * @private
   */
  this.tolerance_ = tolerance;

  /**
   * @type {number|undefined}
   * @private
   */
  this.renderBuffer_ = opt_renderBuffer;

  /**
   * @private
   * @type {!Object.<string,
   *        Object.<ol.render.ReplayType, ol.render.webgl.Replay>>}
   */
  this.replaysByZIndex_ = {};
};

ol["a" /* default */].inherits(replaygroup__ol_render_webgl_ReplayGroup_, replaygroup);

/**
 * @param {ol.style.Style} style Style.
 * @param {boolean} group Group with previous replay.
 */
replaygroup__ol_render_webgl_ReplayGroup_.prototype.addDeclutter = function (style, group) {};

/**
 * @param {ol.webgl.Context} context WebGL context.
 * @return {function()} Delete resources function.
 */
replaygroup__ol_render_webgl_ReplayGroup_.prototype.getDeleteResourcesFunction = function (context) {
  var functions = [];
  var zKey;
  for (zKey in this.replaysByZIndex_) {
    var replays = this.replaysByZIndex_[zKey];
    var replayKey;
    for (replayKey in replays) {
      functions.push(replays[replayKey].getDeleteResourcesFunction(context));
    }
  }
  return function () {
    var length = functions.length;
    var result;
    for (var i = 0; i < length; i++) {
      result = functions[i].apply(this, arguments);
    }
    return result;
  };
};

/**
 * @param {ol.webgl.Context} context Context.
 */
replaygroup__ol_render_webgl_ReplayGroup_.prototype.finish = function (context) {
  var zKey;
  for (zKey in this.replaysByZIndex_) {
    var replays = this.replaysByZIndex_[zKey];
    var replayKey;
    for (replayKey in replays) {
      replays[replayKey].finish(context);
    }
  }
};

/**
 * @inheritDoc
 */
replaygroup__ol_render_webgl_ReplayGroup_.prototype.getReplay = function (zIndex, replayType) {
  var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
  var replays = this.replaysByZIndex_[zIndexKey];
  if (replays === undefined) {
    replays = {};
    this.replaysByZIndex_[zIndexKey] = replays;
  }
  var replay = replays[replayType];
  if (replay === undefined) {
    /**
     * @type {Function}
     */
    var Constructor = replaygroup__ol_render_webgl_ReplayGroup_.BATCH_CONSTRUCTORS_[replayType];
    replay = new Constructor(this.tolerance_, this.maxExtent_);
    replays[replayType] = replay;
  }
  return replay;
};

/**
 * @inheritDoc
 */
replaygroup__ol_render_webgl_ReplayGroup_.prototype.isEmpty = function () {
  return obj["a" /* default */].isEmpty(this.replaysByZIndex_);
};

/**
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} opacity Global opacity.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 */
replaygroup__ol_render_webgl_ReplayGroup_.prototype.replay = function (context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash) {
  /** @type {Array.<number>} */
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(array["a" /* default */].numberSafeCompareFunction);

  var i, ii, j, jj, replays, replay;
  for (i = 0, ii = zs.length; i < ii; ++i) {
    replays = this.replaysByZIndex_[zs[i].toString()];
    for (j = 0, jj = render_replay.ORDER.length; j < jj; ++j) {
      replay = replays[render_replay.ORDER[j]];
      if (replay !== undefined) {
        replay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, undefined, false);
      }
    }
  }
};

/**
 * @private
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} opacity Global opacity.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} featureCallback Feature callback.
 * @param {boolean} oneByOne Draw features one-by-one for the hit-detecion.
 * @param {ol.Extent=} opt_hitExtent Hit extent: Only features intersecting
 *  this extent are checked.
 * @return {T|undefined} Callback result.
 * @template T
 */
replaygroup__ol_render_webgl_ReplayGroup_.prototype.replayHitDetection_ = function (context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent) {
  /** @type {Array.<number>} */
  var zs = Object.keys(this.replaysByZIndex_).map(Number);
  zs.sort(function (a, b) {
    return b - a;
  });

  var i, ii, j, replays, replay, result;
  for (i = 0, ii = zs.length; i < ii; ++i) {
    replays = this.replaysByZIndex_[zs[i].toString()];
    for (j = render_replay.ORDER.length - 1; j >= 0; --j) {
      replay = replays[render_replay.ORDER[j]];
      if (replay !== undefined) {
        result = replay.replay(context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, featureCallback, oneByOne, opt_hitExtent);
        if (result) {
          return result;
        }
      }
    }
  }
  return undefined;
};

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} opacity Global opacity.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @param {function((ol.Feature|ol.render.Feature)): T|undefined} callback Feature callback.
 * @return {T|undefined} Callback result.
 * @template T
 */
replaygroup__ol_render_webgl_ReplayGroup_.prototype.forEachFeatureAtCoordinate = function (coordinate, context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash, callback) {
  var gl = context.getGL();
  gl.bindFramebuffer(gl.FRAMEBUFFER, context.getHitDetectionFramebuffer());

  /**
   * @type {ol.Extent}
   */
  var hitExtent;
  if (this.renderBuffer_ !== undefined) {
    // build an extent around the coordinate, so that only features that
    // intersect this extent are checked
    hitExtent = ol_extent["a" /* default */].buffer(ol_extent["a" /* default */].createOrUpdateFromCoordinate(coordinate), resolution * this.renderBuffer_);
  }

  return this.replayHitDetection_(context, coordinate, resolution, rotation, replaygroup__ol_render_webgl_ReplayGroup_.HIT_DETECTION_SIZE_, pixelRatio, opacity, skippedFeaturesHash,
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {?} Callback result.
   */
  function (feature) {
    var imageData = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);

    if (imageData[3] > 0) {
      var result = callback(feature);
      if (result) {
        return result;
      }
    }
  }, true, hitExtent);
};

/**
 * @param {ol.Coordinate} coordinate Coordinate.
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} opacity Global opacity.
 * @param {Object.<string, boolean>} skippedFeaturesHash Ids of features
 *  to skip.
 * @return {boolean} Is there a feature at the given coordinate?
 */
replaygroup__ol_render_webgl_ReplayGroup_.prototype.hasFeatureAtCoordinate = function (coordinate, context, center, resolution, rotation, size, pixelRatio, opacity, skippedFeaturesHash) {
  var gl = context.getGL();
  gl.bindFramebuffer(gl.FRAMEBUFFER, context.getHitDetectionFramebuffer());

  var hasFeature = this.replayHitDetection_(context, coordinate, resolution, rotation, replaygroup__ol_render_webgl_ReplayGroup_.HIT_DETECTION_SIZE_, pixelRatio, opacity, skippedFeaturesHash,
  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {boolean} Is there a feature?
   */
  function (feature) {
    var imageData = new Uint8Array(4);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);
    return imageData[3] > 0;
  }, false);

  return hasFeature !== undefined;
};

/**
 * @const
 * @private
 * @type {Array.<number>}
 */
replaygroup__ol_render_webgl_ReplayGroup_.HIT_DETECTION_SIZE_ = [1, 1];

/**
 * @const
 * @private
 * @type {Object.<ol.render.ReplayType,
 *                function(new: ol.render.webgl.Replay, number,
 *                ol.Extent)>}
 */
replaygroup__ol_render_webgl_ReplayGroup_.BATCH_CONSTRUCTORS_ = {
  'Circle': circlereplay,
  'Image': webgl_imagereplay,
  'LineString': webgl_linestringreplay,
  'Polygon': webgl_polygonreplay,
  'Text': webgl_textreplay
};
/* harmony default export */ var webgl_replaygroup = (replaygroup__ol_render_webgl_ReplayGroup_);
// CONCATENATED MODULE: ./node_modules/ol/render/webgl/immediate.js







/**
 * @constructor
 * @extends {ol.render.VectorContext}
 * @param {ol.webgl.Context} context Context.
 * @param {ol.Coordinate} center Center.
 * @param {number} resolution Resolution.
 * @param {number} rotation Rotation.
 * @param {ol.Size} size Size.
 * @param {ol.Extent} extent Extent.
 * @param {number} pixelRatio Pixel ratio.
 * @struct
 */
var immediate__ol_render_webgl_Immediate_ = function _ol_render_webgl_Immediate_(context, center, resolution, rotation, size, extent, pixelRatio) {
  vectorcontext.call(this);

  /**
   * @private
   */
  this.context_ = context;

  /**
   * @private
   */
  this.center_ = center;

  /**
   * @private
   */
  this.extent_ = extent;

  /**
   * @private
   */
  this.pixelRatio_ = pixelRatio;

  /**
   * @private
   */
  this.size_ = size;

  /**
   * @private
   */
  this.rotation_ = rotation;

  /**
   * @private
   */
  this.resolution_ = resolution;

  /**
   * @private
   * @type {ol.style.Image}
   */
  this.imageStyle_ = null;

  /**
   * @private
   * @type {ol.style.Fill}
   */
  this.fillStyle_ = null;

  /**
   * @private
   * @type {ol.style.Stroke}
   */
  this.strokeStyle_ = null;

  /**
   * @private
   * @type {ol.style.Text}
   */
  this.textStyle_ = null;
};

ol["a" /* default */].inherits(immediate__ol_render_webgl_Immediate_, vectorcontext);

/**
 * @param {ol.render.webgl.ReplayGroup} replayGroup Replay group.
 * @param {ol.geom.Geometry|ol.render.Feature} geometry Geometry.
 * @private
 */
immediate__ol_render_webgl_Immediate_.prototype.drawText_ = function (replayGroup, geometry) {
  var context = this.context_;
  var replay = /** @type {ol.render.webgl.TextReplay} */replayGroup.getReplay(0, replaytype.TEXT);
  replay.setTextStyle(this.textStyle_);
  replay.drawText(geometry, null);
  replay.finish(context);
  // default colors
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();
};

/**
 * Set the rendering style.  Note that since this is an immediate rendering API,
 * any `zIndex` on the provided style will be ignored.
 *
 * @param {ol.style.Style} style The rendering style.
 * @override
 * @api
 */
immediate__ol_render_webgl_Immediate_.prototype.setStyle = function (style) {
  this.setFillStrokeStyle(style.getFill(), style.getStroke());
  this.setImageStyle(style.getImage());
  this.setTextStyle(style.getText());
};

/**
 * Render a geometry into the canvas.  Call
 * {@link ol.render.webgl.Immediate#setStyle} first to set the rendering style.
 *
 * @param {ol.geom.Geometry|ol.render.Feature} geometry The geometry to render.
 * @override
 * @api
 */
immediate__ol_render_webgl_Immediate_.prototype.drawGeometry = function (geometry) {
  var type = geometry.getType();
  switch (type) {
    case geometrytype["a" /* default */].POINT:
      this.drawPoint( /** @type {ol.geom.Point} */geometry, null);
      break;
    case geometrytype["a" /* default */].LINE_STRING:
      this.drawLineString( /** @type {ol.geom.LineString} */geometry, null);
      break;
    case geometrytype["a" /* default */].POLYGON:
      this.drawPolygon( /** @type {ol.geom.Polygon} */geometry, null);
      break;
    case geometrytype["a" /* default */].MULTI_POINT:
      this.drawMultiPoint( /** @type {ol.geom.MultiPoint} */geometry, null);
      break;
    case geometrytype["a" /* default */].MULTI_LINE_STRING:
      this.drawMultiLineString( /** @type {ol.geom.MultiLineString} */geometry, null);
      break;
    case geometrytype["a" /* default */].MULTI_POLYGON:
      this.drawMultiPolygon( /** @type {ol.geom.MultiPolygon} */geometry, null);
      break;
    case geometrytype["a" /* default */].GEOMETRY_COLLECTION:
      this.drawGeometryCollection( /** @type {ol.geom.GeometryCollection} */geometry, null);
      break;
    case geometrytype["a" /* default */].CIRCLE:
      this.drawCircle( /** @type {ol.geom.Circle} */geometry, null);
      break;
    default:
    // pass
  }
};

/**
 * @inheritDoc
 * @api
 */
immediate__ol_render_webgl_Immediate_.prototype.drawFeature = function (feature, style) {
  var geometry = style.getGeometryFunction()(feature);
  if (!geometry || !ol_extent["a" /* default */].intersects(this.extent_, geometry.getExtent())) {
    return;
  }
  this.setStyle(style);
  this.drawGeometry(geometry);
};

/**
 * @inheritDoc
 */
immediate__ol_render_webgl_Immediate_.prototype.drawGeometryCollection = function (geometry, data) {
  var geometries = geometry.getGeometriesArray();
  var i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    this.drawGeometry(geometries[i]);
  }
};

/**
 * @inheritDoc
 */
immediate__ol_render_webgl_Immediate_.prototype.drawPoint = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new webgl_replaygroup(1, this.extent_);
  var replay = /** @type {ol.render.webgl.ImageReplay} */replayGroup.getReplay(0, replaytype.IMAGE);
  replay.setImageStyle(this.imageStyle_);
  replay.drawPoint(geometry, data);
  replay.finish(context);
  // default colors
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};

/**
 * @inheritDoc
 */
immediate__ol_render_webgl_Immediate_.prototype.drawMultiPoint = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new webgl_replaygroup(1, this.extent_);
  var replay = /** @type {ol.render.webgl.ImageReplay} */replayGroup.getReplay(0, replaytype.IMAGE);
  replay.setImageStyle(this.imageStyle_);
  replay.drawMultiPoint(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};

/**
 * @inheritDoc
 */
immediate__ol_render_webgl_Immediate_.prototype.drawLineString = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new webgl_replaygroup(1, this.extent_);
  var replay = /** @type {ol.render.webgl.LineStringReplay} */replayGroup.getReplay(0, replaytype.LINE_STRING);
  replay.setFillStrokeStyle(null, this.strokeStyle_);
  replay.drawLineString(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};

/**
 * @inheritDoc
 */
immediate__ol_render_webgl_Immediate_.prototype.drawMultiLineString = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new webgl_replaygroup(1, this.extent_);
  var replay = /** @type {ol.render.webgl.LineStringReplay} */replayGroup.getReplay(0, replaytype.LINE_STRING);
  replay.setFillStrokeStyle(null, this.strokeStyle_);
  replay.drawMultiLineString(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};

/**
 * @inheritDoc
 */
immediate__ol_render_webgl_Immediate_.prototype.drawPolygon = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new webgl_replaygroup(1, this.extent_);
  var replay = /** @type {ol.render.webgl.PolygonReplay} */replayGroup.getReplay(0, replaytype.POLYGON);
  replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);
  replay.drawPolygon(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};

/**
 * @inheritDoc
 */
immediate__ol_render_webgl_Immediate_.prototype.drawMultiPolygon = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new webgl_replaygroup(1, this.extent_);
  var replay = /** @type {ol.render.webgl.PolygonReplay} */replayGroup.getReplay(0, replaytype.POLYGON);
  replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);
  replay.drawMultiPolygon(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};

/**
 * @inheritDoc
 */
immediate__ol_render_webgl_Immediate_.prototype.drawCircle = function (geometry, data) {
  var context = this.context_;
  var replayGroup = new webgl_replaygroup(1, this.extent_);
  var replay = /** @type {ol.render.webgl.CircleReplay} */replayGroup.getReplay(0, replaytype.CIRCLE);
  replay.setFillStrokeStyle(this.fillStyle_, this.strokeStyle_);
  replay.drawCircle(geometry, data);
  replay.finish(context);
  var opacity = 1;
  var skippedFeatures = {};
  var featureCallback;
  var oneByOne = false;
  replay.replay(this.context_, this.center_, this.resolution_, this.rotation_, this.size_, this.pixelRatio_, opacity, skippedFeatures, featureCallback, oneByOne);
  replay.getDeleteResourcesFunction(context)();

  if (this.textStyle_) {
    this.drawText_(replayGroup, geometry);
  }
};

/**
 * @inheritDoc
 */
immediate__ol_render_webgl_Immediate_.prototype.setImageStyle = function (imageStyle) {
  this.imageStyle_ = imageStyle;
};

/**
 * @inheritDoc
 */
immediate__ol_render_webgl_Immediate_.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
  this.fillStyle_ = fillStyle;
  this.strokeStyle_ = strokeStyle;
};

/**
 * @inheritDoc
 */
immediate__ol_render_webgl_Immediate_.prototype.setTextStyle = function (textStyle) {
  this.textStyle_ = textStyle;
};
/* harmony default export */ var webgl_immediate = (immediate__ol_render_webgl_Immediate_);
// CONCATENATED MODULE: ./node_modules/ol/renderer/webgl/defaultmapshader.js
// This file is automatically generated, do not edit



var _ol_renderer_webgl_defaultmapshader_ = {};

_ol_renderer_webgl_defaultmapshader_.fragment = new fragment(ol["a" /* default */].DEBUG_WEBGL ? 'precision mediump float;\nvarying vec2 v_texCoord;\n\n\nuniform float u_opacity;\nuniform sampler2D u_texture;\n\nvoid main(void) {\n  vec4 texColor = texture2D(u_texture, v_texCoord);\n  gl_FragColor.rgb = texColor.rgb;\n  gl_FragColor.a = texColor.a * u_opacity;\n}\n' : 'precision mediump float;varying vec2 a;uniform float f;uniform sampler2D g;void main(void){vec4 texColor=texture2D(g,a);gl_FragColor.rgb=texColor.rgb;gl_FragColor.a=texColor.a*f;}');

_ol_renderer_webgl_defaultmapshader_.vertex = new vertex(ol["a" /* default */].DEBUG_WEBGL ? 'varying vec2 v_texCoord;\n\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\n\nuniform mat4 u_texCoordMatrix;\nuniform mat4 u_projectionMatrix;\n\nvoid main(void) {\n  gl_Position = u_projectionMatrix * vec4(a_position, 0., 1.);\n  v_texCoord = (u_texCoordMatrix * vec4(a_texCoord, 0., 1.)).st;\n}\n\n\n' : 'varying vec2 a;attribute vec2 b;attribute vec2 c;uniform mat4 d;uniform mat4 e;void main(void){gl_Position=e*vec4(b,0.,1.);a=(d*vec4(c,0.,1.)).st;}');
/* harmony default export */ var defaultmapshader = (_ol_renderer_webgl_defaultmapshader_);
// CONCATENATED MODULE: ./node_modules/ol/renderer/webgl/defaultmapshader/locations.js
// This file is automatically generated, do not edit


/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */
var locations__ol_renderer_webgl_defaultmapshader_Locations_ = function _ol_renderer_webgl_defaultmapshader_Locations_(gl, program) {

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_texCoordMatrix = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_texCoordMatrix' : 'd');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_projectionMatrix = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_projectionMatrix' : 'e');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_opacity = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_opacity' : 'f');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_texture = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_texture' : 'g');

  /**
   * @type {number}
   */
  this.a_position = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_position' : 'b');

  /**
   * @type {number}
   */
  this.a_texCoord = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_texCoord' : 'c');
};

/* harmony default export */ var defaultmapshader_locations = (locations__ol_renderer_webgl_defaultmapshader_Locations_);
// CONCATENATED MODULE: ./node_modules/ol/renderer/webgl/layer.js













/**
 * @constructor
 * @abstract
 * @extends {ol.renderer.Layer}
 * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.
 * @param {ol.layer.Layer} layer Layer.
 */
var layer__ol_renderer_webgl_Layer_ = function _ol_renderer_webgl_Layer_(mapRenderer, layer) {

  renderer_layer.call(this, layer);

  /**
   * @protected
   * @type {ol.renderer.webgl.Map}
   */
  this.mapRenderer = mapRenderer;

  /**
   * @private
   * @type {ol.webgl.Buffer}
   */
  this.arrayBuffer_ = new webgl_buffer([-1, -1, 0, 0, 1, -1, 1, 0, -1, 1, 0, 1, 1, 1, 1, 1]);

  /**
   * @protected
   * @type {WebGLTexture}
   */
  this.texture = null;

  /**
   * @protected
   * @type {WebGLFramebuffer}
   */
  this.framebuffer = null;

  /**
   * @protected
   * @type {number|undefined}
   */
  this.framebufferDimension = undefined;

  /**
   * @protected
   * @type {ol.Transform}
   */
  this.texCoordMatrix = ol_transform["a" /* default */].create();

  /**
   * @protected
   * @type {ol.Transform}
   */
  this.projectionMatrix = ol_transform["a" /* default */].create();

  /**
   * @type {Array.<number>}
   * @private
   */
  this.tmpMat4_ = mat4.create();

  /**
   * @private
   * @type {ol.renderer.webgl.defaultmapshader.Locations}
   */
  this.defaultLocations_ = null;
};

ol["a" /* default */].inherits(layer__ol_renderer_webgl_Layer_, renderer_layer);

/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {number} framebufferDimension Framebuffer dimension.
 * @protected
 */
layer__ol_renderer_webgl_Layer_.prototype.bindFramebuffer = function (frameState, framebufferDimension) {

  var gl = this.mapRenderer.getGL();

  if (this.framebufferDimension === undefined || this.framebufferDimension != framebufferDimension) {
    /**
     * @param {WebGLRenderingContext} gl GL.
     * @param {WebGLFramebuffer} framebuffer Framebuffer.
     * @param {WebGLTexture} texture Texture.
     */
    var postRenderFunction = function (gl, framebuffer, texture) {
      if (!gl.isContextLost()) {
        gl.deleteFramebuffer(framebuffer);
        gl.deleteTexture(texture);
      }
    }.bind(null, gl, this.framebuffer, this.texture);

    frameState.postRenderFunctions.push(
    /** @type {ol.PostRenderFunction} */postRenderFunction);

    var texture = webgl_context.createEmptyTexture(gl, framebufferDimension, framebufferDimension);

    var framebuffer = gl.createFramebuffer();
    gl.bindFramebuffer(webgl["a" /* default */].FRAMEBUFFER, framebuffer);
    gl.framebufferTexture2D(webgl["a" /* default */].FRAMEBUFFER, webgl["a" /* default */].COLOR_ATTACHMENT0, webgl["a" /* default */].TEXTURE_2D, texture, 0);

    this.texture = texture;
    this.framebuffer = framebuffer;
    this.framebufferDimension = framebufferDimension;
  } else {
    gl.bindFramebuffer(webgl["a" /* default */].FRAMEBUFFER, this.framebuffer);
  }
};

/**
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {ol.webgl.Context} context Context.
 */
layer__ol_renderer_webgl_Layer_.prototype.composeFrame = function (frameState, layerState, context) {

  this.dispatchComposeEvent_(render_eventtype["a" /* default */].PRECOMPOSE, context, frameState);

  context.bindBuffer(webgl["a" /* default */].ARRAY_BUFFER, this.arrayBuffer_);

  var gl = context.getGL();

  var fragmentShader = defaultmapshader.fragment;
  var vertexShader = defaultmapshader.vertex;

  var program = context.getProgram(fragmentShader, vertexShader);

  var locations;
  if (!this.defaultLocations_) {
    locations = new defaultmapshader_locations(gl, program);
    this.defaultLocations_ = locations;
  } else {
    locations = this.defaultLocations_;
  }

  if (context.useProgram(program)) {
    gl.enableVertexAttribArray(locations.a_position);
    gl.vertexAttribPointer(locations.a_position, 2, webgl["a" /* default */].FLOAT, false, 16, 0);
    gl.enableVertexAttribArray(locations.a_texCoord);
    gl.vertexAttribPointer(locations.a_texCoord, 2, webgl["a" /* default */].FLOAT, false, 16, 8);
    gl.uniform1i(locations.u_texture, 0);
  }

  gl.uniformMatrix4fv(locations.u_texCoordMatrix, false, mat4.fromTransform(this.tmpMat4_, this.getTexCoordMatrix()));
  gl.uniformMatrix4fv(locations.u_projectionMatrix, false, mat4.fromTransform(this.tmpMat4_, this.getProjectionMatrix()));
  gl.uniform1f(locations.u_opacity, layerState.opacity);
  gl.bindTexture(webgl["a" /* default */].TEXTURE_2D, this.getTexture());
  gl.drawArrays(webgl["a" /* default */].TRIANGLE_STRIP, 0, 4);

  this.dispatchComposeEvent_(render_eventtype["a" /* default */].POSTCOMPOSE, context, frameState);
};

/**
 * @param {ol.render.EventType} type Event type.
 * @param {ol.webgl.Context} context WebGL context.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */
layer__ol_renderer_webgl_Layer_.prototype.dispatchComposeEvent_ = function (type, context, frameState) {
  var layer = this.getLayer();
  if (layer.hasListener(type)) {
    var viewState = frameState.viewState;
    var resolution = viewState.resolution;
    var pixelRatio = frameState.pixelRatio;
    var extent = frameState.extent;
    var center = viewState.center;
    var rotation = viewState.rotation;
    var size = frameState.size;

    var render = new webgl_immediate(context, center, resolution, rotation, size, extent, pixelRatio);
    var composeEvent = new render_event(type, render, frameState, null, context);
    layer.dispatchEvent(composeEvent);
  }
};

/**
 * @return {!ol.Transform} Matrix.
 */
layer__ol_renderer_webgl_Layer_.prototype.getTexCoordMatrix = function () {
  return this.texCoordMatrix;
};

/**
 * @return {WebGLTexture} Texture.
 */
layer__ol_renderer_webgl_Layer_.prototype.getTexture = function () {
  return this.texture;
};

/**
 * @return {!ol.Transform} Matrix.
 */
layer__ol_renderer_webgl_Layer_.prototype.getProjectionMatrix = function () {
  return this.projectionMatrix;
};

/**
 * Handle webglcontextlost.
 */
layer__ol_renderer_webgl_Layer_.prototype.handleWebGLContextLost = function () {
  this.texture = null;
  this.framebuffer = null;
  this.framebufferDimension = undefined;
};

/**
 * @abstract
 * @param {olx.FrameState} frameState Frame state.
 * @param {ol.LayerState} layerState Layer state.
 * @param {ol.webgl.Context} context Context.
 * @return {boolean} whether composeFrame should be called.
 */
layer__ol_renderer_webgl_Layer_.prototype.prepareFrame = function (frameState, layerState, context) {};

/**
 * @abstract
 * @param {ol.Pixel} pixel Pixel.
 * @param {olx.FrameState} frameState FrameState.
 * @param {function(this: S, ol.layer.Layer, (Uint8ClampedArray|Uint8Array)): T} callback Layer
 *     callback.
 * @param {S} thisArg Value to use as `this` when executing `callback`.
 * @return {T|undefined} Callback result.
 * @template S,T,U
 */
layer__ol_renderer_webgl_Layer_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg) {};
/* harmony default export */ var webgl_layer = (layer__ol_renderer_webgl_Layer_);
// CONCATENATED MODULE: ./node_modules/ol/renderer/webgl/imagelayer.js












/**
 * @constructor
 * @extends {ol.renderer.webgl.Layer}
 * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.
 * @param {ol.layer.Image} imageLayer Tile layer.
 * @api
 */
var imagelayer__ol_renderer_webgl_ImageLayer_ = function _ol_renderer_webgl_ImageLayer_(mapRenderer, imageLayer) {

  webgl_layer.call(this, mapRenderer, imageLayer);

  /**
   * The last rendered image.
   * @private
   * @type {?ol.ImageBase}
   */
  this.image_ = null;

  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */
  this.hitCanvasContext_ = null;

  /**
   * @private
   * @type {?ol.Transform}
   */
  this.hitTransformationMatrix_ = null;
};

ol["a" /* default */].inherits(imagelayer__ol_renderer_webgl_ImageLayer_, webgl_layer);

/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
imagelayer__ol_renderer_webgl_ImageLayer_['handles'] = function (type, layer) {
  return type === renderer_type.WEBGL && layer.getType() === layertype["a" /* default */].IMAGE;
};

/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.webgl.ImageLayer} The layer renderer.
 */
imagelayer__ol_renderer_webgl_ImageLayer_['create'] = function (mapRenderer, layer) {
  return new imagelayer__ol_renderer_webgl_ImageLayer_(
  /** @type {ol.renderer.webgl.Map} */mapRenderer,
  /** @type {ol.layer.Image} */layer);
};

/**
 * @param {ol.ImageBase} image Image.
 * @private
 * @return {WebGLTexture} Texture.
 */
imagelayer__ol_renderer_webgl_ImageLayer_.prototype.createTexture_ = function (image) {

  // We meet the conditions to work with non-power of two textures.
  // http://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support
  // http://learningwebgl.com/blog/?p=2101

  var imageElement = image.getImage();
  var gl = this.mapRenderer.getGL();

  return webgl_context.createTexture(gl, imageElement, webgl["a" /* default */].CLAMP_TO_EDGE, webgl["a" /* default */].CLAMP_TO_EDGE);
};

/**
 * @inheritDoc
 */
imagelayer__ol_renderer_webgl_ImageLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  var layer = this.getLayer();
  var source = layer.getSource();
  var resolution = frameState.viewState.resolution;
  var rotation = frameState.viewState.rotation;
  var skippedFeatureUids = frameState.skippedFeatureUids;
  return source.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, skippedFeatureUids,

  /**
   * @param {ol.Feature|ol.render.Feature} feature Feature.
   * @return {?} Callback result.
   */
  function (feature) {
    return callback.call(thisArg, feature, layer);
  });
};

/**
 * @inheritDoc
 */
imagelayer__ol_renderer_webgl_ImageLayer_.prototype.prepareFrame = function (frameState, layerState, context) {

  var gl = this.mapRenderer.getGL();

  var pixelRatio = frameState.pixelRatio;
  var viewState = frameState.viewState;
  var viewCenter = viewState.center;
  var viewResolution = viewState.resolution;
  var viewRotation = viewState.rotation;

  var image = this.image_;
  var texture = this.texture;
  var imageLayer = /** @type {ol.layer.Image} */this.getLayer();
  var imageSource = imageLayer.getSource();

  var hints = frameState.viewHints;

  var renderedExtent = frameState.extent;
  if (layerState.extent !== undefined) {
    renderedExtent = ol_extent["a" /* default */].getIntersection(renderedExtent, layerState.extent);
  }
  if (!hints[viewhint["a" /* default */].ANIMATING] && !hints[viewhint["a" /* default */].INTERACTING] && !ol_extent["a" /* default */].isEmpty(renderedExtent)) {
    var projection = viewState.projection;
    if (!ol["a" /* default */].ENABLE_RASTER_REPROJECTION) {
      var sourceProjection = imageSource.getProjection();
      if (sourceProjection) {
        projection = sourceProjection;
      }
    }
    var image_ = imageSource.getImage(renderedExtent, viewResolution, pixelRatio, projection);
    if (image_) {
      var loaded = this.loadImage(image_);
      if (loaded) {
        image = image_;
        texture = this.createTexture_(image_);
        if (this.texture) {
          /**
           * @param {WebGLRenderingContext} gl GL.
           * @param {WebGLTexture} texture Texture.
           */
          var postRenderFunction = function (gl, texture) {
            if (!gl.isContextLost()) {
              gl.deleteTexture(texture);
            }
          }.bind(null, gl, this.texture);
          frameState.postRenderFunctions.push(
          /** @type {ol.PostRenderFunction} */postRenderFunction);
        }
      }
    }
  }

  if (image) {
    var canvas = this.mapRenderer.getContext().getCanvas();

    this.updateProjectionMatrix_(canvas.width, canvas.height, pixelRatio, viewCenter, viewResolution, viewRotation, image.getExtent());
    this.hitTransformationMatrix_ = null;

    // Translate and scale to flip the Y coord.
    var texCoordMatrix = this.texCoordMatrix;
    ol_transform["a" /* default */].reset(texCoordMatrix);
    ol_transform["a" /* default */].scale(texCoordMatrix, 1, -1);
    ol_transform["a" /* default */].translate(texCoordMatrix, 0, -1);

    this.image_ = image;
    this.texture = texture;

    this.updateLogos(frameState, imageSource);
  }

  return !!image;
};

/**
 * @param {number} canvasWidth Canvas width.
 * @param {number} canvasHeight Canvas height.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.Coordinate} viewCenter View center.
 * @param {number} viewResolution View resolution.
 * @param {number} viewRotation View rotation.
 * @param {ol.Extent} imageExtent Image extent.
 * @private
 */
imagelayer__ol_renderer_webgl_ImageLayer_.prototype.updateProjectionMatrix_ = function (canvasWidth, canvasHeight, pixelRatio, viewCenter, viewResolution, viewRotation, imageExtent) {

  var canvasExtentWidth = canvasWidth * viewResolution;
  var canvasExtentHeight = canvasHeight * viewResolution;

  var projectionMatrix = this.projectionMatrix;
  ol_transform["a" /* default */].reset(projectionMatrix);
  ol_transform["a" /* default */].scale(projectionMatrix, pixelRatio * 2 / canvasExtentWidth, pixelRatio * 2 / canvasExtentHeight);
  ol_transform["a" /* default */].rotate(projectionMatrix, -viewRotation);
  ol_transform["a" /* default */].translate(projectionMatrix, imageExtent[0] - viewCenter[0], imageExtent[1] - viewCenter[1]);
  ol_transform["a" /* default */].scale(projectionMatrix, (imageExtent[2] - imageExtent[0]) / 2, (imageExtent[3] - imageExtent[1]) / 2);
  ol_transform["a" /* default */].translate(projectionMatrix, 1, 1);
};

/**
 * @inheritDoc
 */
imagelayer__ol_renderer_webgl_ImageLayer_.prototype.hasFeatureAtCoordinate = function (coordinate, frameState) {
  var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, 0, functions["a" /* default */].TRUE, this);
  return hasFeature !== undefined;
};

/**
 * @inheritDoc
 */
imagelayer__ol_renderer_webgl_ImageLayer_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg) {
  if (!this.image_ || !this.image_.getImage()) {
    return undefined;
  }

  if (this.getLayer().getSource().forEachFeatureAtCoordinate !== ol["a" /* default */].nullFunction) {
    // for ImageCanvas sources use the original hit-detection logic,
    // so that for example also transparent polygons are detected
    var coordinate = ol_transform["a" /* default */].apply(frameState.pixelToCoordinateTransform, pixel.slice());
    var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, 0, functions["a" /* default */].TRUE, this);

    if (hasFeature) {
      return callback.call(thisArg, this.getLayer(), null);
    } else {
      return undefined;
    }
  } else {
    var imageSize = [this.image_.getImage().width, this.image_.getImage().height];

    if (!this.hitTransformationMatrix_) {
      this.hitTransformationMatrix_ = this.getHitTransformationMatrix_(frameState.size, imageSize);
    }

    var pixelOnFrameBuffer = ol_transform["a" /* default */].apply(this.hitTransformationMatrix_, pixel.slice());

    if (pixelOnFrameBuffer[0] < 0 || pixelOnFrameBuffer[0] > imageSize[0] || pixelOnFrameBuffer[1] < 0 || pixelOnFrameBuffer[1] > imageSize[1]) {
      // outside the image, no need to check
      return undefined;
    }

    if (!this.hitCanvasContext_) {
      this.hitCanvasContext_ = dom["a" /* default */].createCanvasContext2D(1, 1);
    }

    this.hitCanvasContext_.clearRect(0, 0, 1, 1);
    this.hitCanvasContext_.drawImage(this.image_.getImage(), pixelOnFrameBuffer[0], pixelOnFrameBuffer[1], 1, 1, 0, 0, 1, 1);

    var imageData = this.hitCanvasContext_.getImageData(0, 0, 1, 1).data;
    if (imageData[3] > 0) {
      return callback.call(thisArg, this.getLayer(), imageData);
    } else {
      return undefined;
    }
  }
};

/**
 * The transformation matrix to get the pixel on the image for a
 * pixel on the map.
 * @param {ol.Size} mapSize The map size.
 * @param {ol.Size} imageSize The image size.
 * @return {ol.Transform} The transformation matrix.
 * @private
 */
imagelayer__ol_renderer_webgl_ImageLayer_.prototype.getHitTransformationMatrix_ = function (mapSize, imageSize) {
  // the first matrix takes a map pixel, flips the y-axis and scales to
  // a range between -1 ... 1
  var mapCoordTransform = ol_transform["a" /* default */].create();
  ol_transform["a" /* default */].translate(mapCoordTransform, -1, -1);
  ol_transform["a" /* default */].scale(mapCoordTransform, 2 / mapSize[0], 2 / mapSize[1]);
  ol_transform["a" /* default */].translate(mapCoordTransform, 0, mapSize[1]);
  ol_transform["a" /* default */].scale(mapCoordTransform, 1, -1);

  // the second matrix is the inverse of the projection matrix used in the
  // shader for drawing
  var projectionMatrixInv = ol_transform["a" /* default */].invert(this.projectionMatrix.slice());

  // the third matrix scales to the image dimensions and flips the y-axis again
  var transform = ol_transform["a" /* default */].create();
  ol_transform["a" /* default */].translate(transform, 0, imageSize[1]);
  ol_transform["a" /* default */].scale(transform, 1, -1);
  ol_transform["a" /* default */].scale(transform, imageSize[0] / 2, imageSize[1] / 2);
  ol_transform["a" /* default */].translate(transform, 1, 1);

  ol_transform["a" /* default */].multiply(transform, projectionMatrixInv);
  ol_transform["a" /* default */].multiply(transform, mapCoordTransform);

  return transform;
};
/* harmony default export */ var webgl_imagelayer = (imagelayer__ol_renderer_webgl_ImageLayer_);
// EXTERNAL MODULE: ./node_modules/ol/structs/lrucache.js
var lrucache = __webpack_require__(65);

// CONCATENATED MODULE: ./node_modules/ol/renderer/webgl/map.js
// FIXME check against gl.getParameter(webgl.MAX_TEXTURE_SIZE)




















/**
 * @constructor
 * @extends {ol.renderer.Map}
 * @param {Element} container Container.
 * @param {ol.PluggableMap} map Map.
 * @api
 */
var map__ol_renderer_webgl_Map_ = function _ol_renderer_webgl_Map_(container, map) {
  renderer_map.call(this, container, map);

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = /** @type {HTMLCanvasElement} */
  document.createElement('CANVAS');
  this.canvas_.style.width = '100%';
  this.canvas_.style.height = '100%';
  this.canvas_.style.display = 'block';
  this.canvas_.className = css["a" /* default */].CLASS_UNSELECTABLE;
  container.insertBefore(this.canvas_, container.childNodes[0] || null);

  /**
   * @private
   * @type {number}
   */
  this.clipTileCanvasWidth_ = 0;

  /**
   * @private
   * @type {number}
   */
  this.clipTileCanvasHeight_ = 0;

  /**
   * @private
   * @type {CanvasRenderingContext2D}
   */
  this.clipTileContext_ = dom["a" /* default */].createCanvasContext2D();

  /**
   * @private
   * @type {boolean}
   */
  this.renderedVisible_ = true;

  /**
   * @private
   * @type {WebGLRenderingContext}
   */
  this.gl_ = webgl["a" /* default */].getContext(this.canvas_, {
    antialias: true,
    depth: true,
    failIfMajorPerformanceCaveat: true,
    preserveDrawingBuffer: false,
    stencil: true
  });

  /**
   * @private
   * @type {ol.webgl.Context}
   */
  this.context_ = new webgl_context(this.canvas_, this.gl_);

  ol_events["a" /* default */].listen(this.canvas_, contexteventtype.LOST, this.handleWebGLContextLost, this);
  ol_events["a" /* default */].listen(this.canvas_, contexteventtype.RESTORED, this.handleWebGLContextRestored, this);

  /**
   * @private
   * @type {ol.structs.LRUCache.<ol.WebglTextureCacheEntry|null>}
   */
  this.textureCache_ = new lrucache["a" /* default */]();

  /**
   * @private
   * @type {ol.Coordinate}
   */
  this.focus_ = null;

  /**
   * @private
   * @type {ol.structs.PriorityQueue.<Array>}
   */
  this.tileTextureQueue_ = new priorityqueue(
  /**
   * @param {Array.<*>} element Element.
   * @return {number} Priority.
   * @this {ol.renderer.webgl.Map}
   */
  function (element) {
    var tileCenter = /** @type {ol.Coordinate} */element[1];
    var tileResolution = /** @type {number} */element[2];
    var deltaX = tileCenter[0] - this.focus_[0];
    var deltaY = tileCenter[1] - this.focus_[1];
    return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
  }.bind(this),
  /**
   * @param {Array.<*>} element Element.
   * @return {string} Key.
   */
  function (element) {
    return (/** @type {ol.Tile} */element[0].getKey()
    );
  });

  /**
   * @param {ol.PluggableMap} map Map.
   * @param {?olx.FrameState} frameState Frame state.
   * @return {boolean} false.
   * @this {ol.renderer.webgl.Map}
   */
  this.loadNextTileTexture_ = function (map, frameState) {
    if (!this.tileTextureQueue_.isEmpty()) {
      this.tileTextureQueue_.reprioritize();
      var element = this.tileTextureQueue_.dequeue();
      var tile = /** @type {ol.Tile} */element[0];
      var tileSize = /** @type {ol.Size} */element[3];
      var tileGutter = /** @type {number} */element[4];
      this.bindTileTexture(tile, tileSize, tileGutter, webgl["a" /* default */].LINEAR, webgl["a" /* default */].LINEAR);
    }
    return false;
  }.bind(this);

  /**
   * @private
   * @type {number}
   */
  this.textureCacheFrameMarkerCount_ = 0;

  this.initializeGL_();
};

ol["a" /* default */].inherits(map__ol_renderer_webgl_Map_, renderer_map);

/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @return {boolean} The renderer can render the layer.
 */
map__ol_renderer_webgl_Map_['handles'] = function (type) {
  return has["a" /* default */].WEBGL && type === renderer_type.WEBGL;
};

/**
 * Create the map renderer.
 * @param {Element} container Container.
 * @param {ol.PluggableMap} map Map.
 * @return {ol.renderer.webgl.Map} The map renderer.
 */
map__ol_renderer_webgl_Map_['create'] = function (container, map) {
  return new map__ol_renderer_webgl_Map_(container, map);
};

/**
 * @param {ol.Tile} tile Tile.
 * @param {ol.Size} tileSize Tile size.
 * @param {number} tileGutter Tile gutter.
 * @param {number} magFilter Mag filter.
 * @param {number} minFilter Min filter.
 */
map__ol_renderer_webgl_Map_.prototype.bindTileTexture = function (tile, tileSize, tileGutter, magFilter, minFilter) {
  var gl = this.getGL();
  var tileKey = tile.getKey();
  if (this.textureCache_.containsKey(tileKey)) {
    var textureCacheEntry = this.textureCache_.get(tileKey);
    gl.bindTexture(webgl["a" /* default */].TEXTURE_2D, textureCacheEntry.texture);
    if (textureCacheEntry.magFilter != magFilter) {
      gl.texParameteri(webgl["a" /* default */].TEXTURE_2D, webgl["a" /* default */].TEXTURE_MAG_FILTER, magFilter);
      textureCacheEntry.magFilter = magFilter;
    }
    if (textureCacheEntry.minFilter != minFilter) {
      gl.texParameteri(webgl["a" /* default */].TEXTURE_2D, webgl["a" /* default */].TEXTURE_MIN_FILTER, minFilter);
      textureCacheEntry.minFilter = minFilter;
    }
  } else {
    var texture = gl.createTexture();
    gl.bindTexture(webgl["a" /* default */].TEXTURE_2D, texture);
    if (tileGutter > 0) {
      var clipTileCanvas = this.clipTileContext_.canvas;
      var clipTileContext = this.clipTileContext_;
      if (this.clipTileCanvasWidth_ !== tileSize[0] || this.clipTileCanvasHeight_ !== tileSize[1]) {
        clipTileCanvas.width = tileSize[0];
        clipTileCanvas.height = tileSize[1];
        this.clipTileCanvasWidth_ = tileSize[0];
        this.clipTileCanvasHeight_ = tileSize[1];
      } else {
        clipTileContext.clearRect(0, 0, tileSize[0], tileSize[1]);
      }
      clipTileContext.drawImage(tile.getImage(), tileGutter, tileGutter, tileSize[0], tileSize[1], 0, 0, tileSize[0], tileSize[1]);
      gl.texImage2D(webgl["a" /* default */].TEXTURE_2D, 0, webgl["a" /* default */].RGBA, webgl["a" /* default */].RGBA, webgl["a" /* default */].UNSIGNED_BYTE, clipTileCanvas);
    } else {
      gl.texImage2D(webgl["a" /* default */].TEXTURE_2D, 0, webgl["a" /* default */].RGBA, webgl["a" /* default */].RGBA, webgl["a" /* default */].UNSIGNED_BYTE, tile.getImage());
    }
    gl.texParameteri(webgl["a" /* default */].TEXTURE_2D, webgl["a" /* default */].TEXTURE_MAG_FILTER, magFilter);
    gl.texParameteri(webgl["a" /* default */].TEXTURE_2D, webgl["a" /* default */].TEXTURE_MIN_FILTER, minFilter);
    gl.texParameteri(webgl["a" /* default */].TEXTURE_2D, webgl["a" /* default */].TEXTURE_WRAP_S, webgl["a" /* default */].CLAMP_TO_EDGE);
    gl.texParameteri(webgl["a" /* default */].TEXTURE_2D, webgl["a" /* default */].TEXTURE_WRAP_T, webgl["a" /* default */].CLAMP_TO_EDGE);
    this.textureCache_.set(tileKey, {
      texture: texture,
      magFilter: magFilter,
      minFilter: minFilter
    });
  }
};

/**
 * @param {ol.render.EventType} type Event type.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */
map__ol_renderer_webgl_Map_.prototype.dispatchComposeEvent_ = function (type, frameState) {
  var map = this.getMap();
  if (map.hasListener(type)) {
    var context = this.context_;

    var extent = frameState.extent;
    var size = frameState.size;
    var viewState = frameState.viewState;
    var pixelRatio = frameState.pixelRatio;

    var resolution = viewState.resolution;
    var center = viewState.center;
    var rotation = viewState.rotation;

    var vectorContext = new webgl_immediate(context, center, resolution, rotation, size, extent, pixelRatio);
    var composeEvent = new render_event(type, vectorContext, frameState, null, context);
    map.dispatchEvent(composeEvent);
  }
};

/**
 * @inheritDoc
 */
map__ol_renderer_webgl_Map_.prototype.disposeInternal = function () {
  var gl = this.getGL();
  if (!gl.isContextLost()) {
    this.textureCache_.forEach(
    /**
     * @param {?ol.WebglTextureCacheEntry} textureCacheEntry
     *     Texture cache entry.
     */
    function (textureCacheEntry) {
      if (textureCacheEntry) {
        gl.deleteTexture(textureCacheEntry.texture);
      }
    });
  }
  this.context_.dispose();
  renderer_map.prototype.disposeInternal.call(this);
};

/**
 * @param {ol.PluggableMap} map Map.
 * @param {olx.FrameState} frameState Frame state.
 * @private
 */
map__ol_renderer_webgl_Map_.prototype.expireCache_ = function (map, frameState) {
  var gl = this.getGL();
  var textureCacheEntry;
  while (this.textureCache_.getCount() - this.textureCacheFrameMarkerCount_ > ol["a" /* default */].WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK) {
    textureCacheEntry = this.textureCache_.peekLast();
    if (!textureCacheEntry) {
      if (+this.textureCache_.peekLastKey() == frameState.index) {
        break;
      } else {
        --this.textureCacheFrameMarkerCount_;
      }
    } else {
      gl.deleteTexture(textureCacheEntry.texture);
    }
    this.textureCache_.pop();
  }
};

/**
 * @return {ol.webgl.Context} The context.
 */
map__ol_renderer_webgl_Map_.prototype.getContext = function () {
  return this.context_;
};

/**
 * @return {WebGLRenderingContext} GL.
 */
map__ol_renderer_webgl_Map_.prototype.getGL = function () {
  return this.gl_;
};

/**
 * @return {ol.structs.PriorityQueue.<Array>} Tile texture queue.
 */
map__ol_renderer_webgl_Map_.prototype.getTileTextureQueue = function () {
  return this.tileTextureQueue_;
};

/**
 * @inheritDoc
 */
map__ol_renderer_webgl_Map_.prototype.getType = function () {
  return renderer_type.WEBGL;
};

/**
 * @param {ol.events.Event} event Event.
 * @protected
 */
map__ol_renderer_webgl_Map_.prototype.handleWebGLContextLost = function (event) {
  event.preventDefault();
  this.textureCache_.clear();
  this.textureCacheFrameMarkerCount_ = 0;

  var renderers = this.getLayerRenderers();
  for (var id in renderers) {
    var renderer = /** @type {ol.renderer.webgl.Layer} */renderers[id];
    renderer.handleWebGLContextLost();
  }
};

/**
 * @protected
 */
map__ol_renderer_webgl_Map_.prototype.handleWebGLContextRestored = function () {
  this.initializeGL_();
  this.getMap().render();
};

/**
 * @private
 */
map__ol_renderer_webgl_Map_.prototype.initializeGL_ = function () {
  var gl = this.gl_;
  gl.activeTexture(webgl["a" /* default */].TEXTURE0);
  gl.blendFuncSeparate(webgl["a" /* default */].SRC_ALPHA, webgl["a" /* default */].ONE_MINUS_SRC_ALPHA, webgl["a" /* default */].ONE, webgl["a" /* default */].ONE_MINUS_SRC_ALPHA);
  gl.disable(webgl["a" /* default */].CULL_FACE);
  gl.disable(webgl["a" /* default */].DEPTH_TEST);
  gl.disable(webgl["a" /* default */].SCISSOR_TEST);
  gl.disable(webgl["a" /* default */].STENCIL_TEST);
};

/**
 * @param {ol.Tile} tile Tile.
 * @return {boolean} Is tile texture loaded.
 */
map__ol_renderer_webgl_Map_.prototype.isTileTextureLoaded = function (tile) {
  return this.textureCache_.containsKey(tile.getKey());
};

/**
 * @inheritDoc
 */
map__ol_renderer_webgl_Map_.prototype.renderFrame = function (frameState) {

  var context = this.getContext();
  var gl = this.getGL();

  if (gl.isContextLost()) {
    return false;
  }

  if (!frameState) {
    if (this.renderedVisible_) {
      this.canvas_.style.display = 'none';
      this.renderedVisible_ = false;
    }
    return false;
  }

  this.focus_ = frameState.focus;

  this.textureCache_.set((-frameState.index).toString(), null);
  ++this.textureCacheFrameMarkerCount_;

  this.dispatchComposeEvent_(render_eventtype["a" /* default */].PRECOMPOSE, frameState);

  /** @type {Array.<ol.LayerState>} */
  var layerStatesToDraw = [];
  var layerStatesArray = frameState.layerStatesArray;
  array["a" /* default */].stableSort(layerStatesArray, renderer_map.sortByZIndex);

  var viewResolution = frameState.viewState.resolution;
  var i, ii, layerRenderer, layerState;
  for (i = 0, ii = layerStatesArray.length; i < ii; ++i) {
    layerState = layerStatesArray[i];
    if (layer_layer["a" /* default */].visibleAtResolution(layerState, viewResolution) && layerState.sourceState == source_state["a" /* default */].READY) {
      layerRenderer = /** @type {ol.renderer.webgl.Layer} */this.getLayerRenderer(layerState.layer);
      if (layerRenderer.prepareFrame(frameState, layerState, context)) {
        layerStatesToDraw.push(layerState);
      }
    }
  }

  var width = frameState.size[0] * frameState.pixelRatio;
  var height = frameState.size[1] * frameState.pixelRatio;
  if (this.canvas_.width != width || this.canvas_.height != height) {
    this.canvas_.width = width;
    this.canvas_.height = height;
  }

  gl.bindFramebuffer(webgl["a" /* default */].FRAMEBUFFER, null);

  gl.clearColor(0, 0, 0, 0);
  gl.clear(webgl["a" /* default */].COLOR_BUFFER_BIT);
  gl.enable(webgl["a" /* default */].BLEND);
  gl.viewport(0, 0, this.canvas_.width, this.canvas_.height);

  for (i = 0, ii = layerStatesToDraw.length; i < ii; ++i) {
    layerState = layerStatesToDraw[i];
    layerRenderer = /** @type {ol.renderer.webgl.Layer} */this.getLayerRenderer(layerState.layer);
    layerRenderer.composeFrame(frameState, layerState, context);
  }

  if (!this.renderedVisible_) {
    this.canvas_.style.display = '';
    this.renderedVisible_ = true;
  }

  this.calculateMatrices2D(frameState);

  if (this.textureCache_.getCount() - this.textureCacheFrameMarkerCount_ > ol["a" /* default */].WEBGL_TEXTURE_CACHE_HIGH_WATER_MARK) {
    frameState.postRenderFunctions.push(
    /** @type {ol.PostRenderFunction} */this.expireCache_.bind(this));
  }

  if (!this.tileTextureQueue_.isEmpty()) {
    frameState.postRenderFunctions.push(this.loadNextTileTexture_);
    frameState.animate = true;
  }

  this.dispatchComposeEvent_(render_eventtype["a" /* default */].POSTCOMPOSE, frameState);

  this.scheduleRemoveUnusedLayerRenderers(frameState);
  this.scheduleExpireIconCache(frameState);
};

/**
 * @inheritDoc
 */
map__ol_renderer_webgl_Map_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg, layerFilter, thisArg2) {
  var result;

  if (this.getGL().isContextLost()) {
    return false;
  }

  var viewState = frameState.viewState;

  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;
  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;
    if (layer_layer["a" /* default */].visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg2, layer)) {
      var layerRenderer = this.getLayerRenderer(layer);
      result = layerRenderer.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, thisArg);
      if (result) {
        return result;
      }
    }
  }
  return undefined;
};

/**
 * @inheritDoc
 */
map__ol_renderer_webgl_Map_.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, layerFilter, thisArg) {
  var hasFeature = false;

  if (this.getGL().isContextLost()) {
    return false;
  }

  var viewState = frameState.viewState;

  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;
  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;
    if (layer_layer["a" /* default */].visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg, layer)) {
      var layerRenderer = this.getLayerRenderer(layer);
      hasFeature = layerRenderer.hasFeatureAtCoordinate(coordinate, frameState);
      if (hasFeature) {
        return true;
      }
    }
  }
  return hasFeature;
};

/**
 * @inheritDoc
 */
map__ol_renderer_webgl_Map_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg, layerFilter, thisArg2) {
  if (this.getGL().isContextLost()) {
    return false;
  }

  var viewState = frameState.viewState;
  var result;

  var layerStates = frameState.layerStatesArray;
  var numLayers = layerStates.length;
  var i;
  for (i = numLayers - 1; i >= 0; --i) {
    var layerState = layerStates[i];
    var layer = layerState.layer;
    if (layer_layer["a" /* default */].visibleAtResolution(layerState, viewState.resolution) && layerFilter.call(thisArg, layer)) {
      var layerRenderer = /** @type {ol.renderer.webgl.Layer} */this.getLayerRenderer(layer);
      result = layerRenderer.forEachLayerAtPixel(pixel, frameState, callback, thisArg);
      if (result) {
        return result;
      }
    }
  }
  return undefined;
};
/* harmony default export */ var webgl_map = (map__ol_renderer_webgl_Map_);
// CONCATENATED MODULE: ./node_modules/ol/renderer/webgl/tilelayershader.js
// This file is automatically generated, do not edit



var _ol_renderer_webgl_tilelayershader_ = {};

_ol_renderer_webgl_tilelayershader_.fragment = new fragment(ol["a" /* default */].DEBUG_WEBGL ? 'precision mediump float;\nvarying vec2 v_texCoord;\n\n\nuniform sampler2D u_texture;\n\nvoid main(void) {\n  gl_FragColor = texture2D(u_texture, v_texCoord);\n}\n' : 'precision mediump float;varying vec2 a;uniform sampler2D e;void main(void){gl_FragColor=texture2D(e,a);}');

_ol_renderer_webgl_tilelayershader_.vertex = new vertex(ol["a" /* default */].DEBUG_WEBGL ? 'varying vec2 v_texCoord;\n\n\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nuniform vec4 u_tileOffset;\n\nvoid main(void) {\n  gl_Position = vec4(a_position * u_tileOffset.xy + u_tileOffset.zw, 0., 1.);\n  v_texCoord = a_texCoord;\n}\n\n\n' : 'varying vec2 a;attribute vec2 b;attribute vec2 c;uniform vec4 d;void main(void){gl_Position=vec4(b*d.xy+d.zw,0.,1.);a=c;}');
/* harmony default export */ var tilelayershader = (_ol_renderer_webgl_tilelayershader_);
// CONCATENATED MODULE: ./node_modules/ol/renderer/webgl/tilelayershader/locations.js
// This file is automatically generated, do not edit


/**
 * @constructor
 * @param {WebGLRenderingContext} gl GL.
 * @param {WebGLProgram} program Program.
 * @struct
 */
var locations__ol_renderer_webgl_tilelayershader_Locations_ = function _ol_renderer_webgl_tilelayershader_Locations_(gl, program) {

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_tileOffset = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_tileOffset' : 'd');

  /**
   * @type {WebGLUniformLocation}
   */
  this.u_texture = gl.getUniformLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'u_texture' : 'e');

  /**
   * @type {number}
   */
  this.a_position = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_position' : 'b');

  /**
   * @type {number}
   */
  this.a_texCoord = gl.getAttribLocation(program, ol["a" /* default */].DEBUG_WEBGL ? 'a_texCoord' : 'c');
};

/* harmony default export */ var tilelayershader_locations = (locations__ol_renderer_webgl_tilelayershader_Locations_);
// CONCATENATED MODULE: ./node_modules/ol/renderer/webgl/tilelayer.js
// FIXME large resolutions lead to too large framebuffers :-(
// FIXME animated shaders! check in redraw

















/**
 * @constructor
 * @extends {ol.renderer.webgl.Layer}
 * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.
 * @param {ol.layer.Tile} tileLayer Tile layer.
 * @api
 */
var tilelayer__ol_renderer_webgl_TileLayer_ = function _ol_renderer_webgl_TileLayer_(mapRenderer, tileLayer) {

  webgl_layer.call(this, mapRenderer, tileLayer);

  /**
   * @private
   * @type {ol.webgl.Fragment}
   */
  this.fragmentShader_ = tilelayershader.fragment;

  /**
   * @private
   * @type {ol.webgl.Vertex}
   */
  this.vertexShader_ = tilelayershader.vertex;

  /**
   * @private
   * @type {ol.renderer.webgl.tilelayershader.Locations}
   */
  this.locations_ = null;

  /**
   * @private
   * @type {ol.webgl.Buffer}
   */
  this.renderArrayBuffer_ = new webgl_buffer([0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0]);

  /**
   * @private
   * @type {ol.TileRange}
   */
  this.renderedTileRange_ = null;

  /**
   * @private
   * @type {ol.Extent}
   */
  this.renderedFramebufferExtent_ = null;

  /**
   * @private
   * @type {number}
   */
  this.renderedRevision_ = -1;

  /**
   * @private
   * @type {ol.Size}
   */
  this.tmpSize_ = [0, 0];
};

ol["a" /* default */].inherits(tilelayer__ol_renderer_webgl_TileLayer_, webgl_layer);

/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
tilelayer__ol_renderer_webgl_TileLayer_['handles'] = function (type, layer) {
  return type === renderer_type.WEBGL && layer.getType() === layertype["a" /* default */].TILE;
};

/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.webgl.TileLayer} The layer renderer.
 */
tilelayer__ol_renderer_webgl_TileLayer_['create'] = function (mapRenderer, layer) {
  return new tilelayer__ol_renderer_webgl_TileLayer_(
  /** @type {ol.renderer.webgl.Map} */mapRenderer,
  /** @type {ol.layer.Tile} */layer);
};

/**
 * @inheritDoc
 */
tilelayer__ol_renderer_webgl_TileLayer_.prototype.disposeInternal = function () {
  var context = this.mapRenderer.getContext();
  context.deleteBuffer(this.renderArrayBuffer_);
  webgl_layer.prototype.disposeInternal.call(this);
};

/**
 * @inheritDoc
 */
tilelayer__ol_renderer_webgl_TileLayer_.prototype.createLoadedTileFinder = function (source, projection, tiles) {
  var mapRenderer = this.mapRenderer;

  return (
    /**
     * @param {number} zoom Zoom level.
     * @param {ol.TileRange} tileRange Tile range.
     * @return {boolean} The tile range is fully loaded.
     */
    function (zoom, tileRange) {
      function callback(tile) {
        var loaded = mapRenderer.isTileTextureLoaded(tile);
        if (loaded) {
          if (!tiles[zoom]) {
            tiles[zoom] = {};
          }
          tiles[zoom][tile.tileCoord.toString()] = tile;
        }
        return loaded;
      }
      return source.forEachLoadedTile(projection, zoom, tileRange, callback);
    }
  );
};

/**
 * @inheritDoc
 */
tilelayer__ol_renderer_webgl_TileLayer_.prototype.handleWebGLContextLost = function () {
  webgl_layer.prototype.handleWebGLContextLost.call(this);
  this.locations_ = null;
};

/**
 * @inheritDoc
 */
tilelayer__ol_renderer_webgl_TileLayer_.prototype.prepareFrame = function (frameState, layerState, context) {

  var mapRenderer = this.mapRenderer;
  var gl = context.getGL();

  var viewState = frameState.viewState;
  var projection = viewState.projection;

  var tileLayer = /** @type {ol.layer.Tile} */this.getLayer();
  var tileSource = tileLayer.getSource();
  var tileGrid = tileSource.getTileGridForProjection(projection);
  var z = tileGrid.getZForResolution(viewState.resolution);
  var tileResolution = tileGrid.getResolution(z);

  var tilePixelSize = tileSource.getTilePixelSize(z, frameState.pixelRatio, projection);
  var pixelRatio = tilePixelSize[0] / ol_size["a" /* default */].toSize(tileGrid.getTileSize(z), this.tmpSize_)[0];
  var tilePixelResolution = tileResolution / pixelRatio;
  var tileGutter = tileSource.getTilePixelRatio(pixelRatio) * tileSource.getGutter(projection);

  var center = viewState.center;
  var extent = frameState.extent;
  var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);

  var framebufferExtent;
  if (this.renderedTileRange_ && this.renderedTileRange_.equals(tileRange) && this.renderedRevision_ == tileSource.getRevision()) {
    framebufferExtent = this.renderedFramebufferExtent_;
  } else {

    var tileRangeSize = tileRange.getSize();

    var maxDimension = Math.max(tileRangeSize[0] * tilePixelSize[0], tileRangeSize[1] * tilePixelSize[1]);
    var framebufferDimension = math["a" /* default */].roundUpToPowerOfTwo(maxDimension);
    var framebufferExtentDimension = tilePixelResolution * framebufferDimension;
    var origin = tileGrid.getOrigin(z);
    var minX = origin[0] + tileRange.minX * tilePixelSize[0] * tilePixelResolution;
    var minY = origin[1] + tileRange.minY * tilePixelSize[1] * tilePixelResolution;
    framebufferExtent = [minX, minY, minX + framebufferExtentDimension, minY + framebufferExtentDimension];

    this.bindFramebuffer(frameState, framebufferDimension);
    gl.viewport(0, 0, framebufferDimension, framebufferDimension);

    gl.clearColor(0, 0, 0, 0);
    gl.clear(webgl["a" /* default */].COLOR_BUFFER_BIT);
    gl.disable(webgl["a" /* default */].BLEND);

    var program = context.getProgram(this.fragmentShader_, this.vertexShader_);
    context.useProgram(program);
    if (!this.locations_) {
      this.locations_ = new tilelayershader_locations(gl, program);
    }

    context.bindBuffer(webgl["a" /* default */].ARRAY_BUFFER, this.renderArrayBuffer_);
    gl.enableVertexAttribArray(this.locations_.a_position);
    gl.vertexAttribPointer(this.locations_.a_position, 2, webgl["a" /* default */].FLOAT, false, 16, 0);
    gl.enableVertexAttribArray(this.locations_.a_texCoord);
    gl.vertexAttribPointer(this.locations_.a_texCoord, 2, webgl["a" /* default */].FLOAT, false, 16, 8);
    gl.uniform1i(this.locations_.u_texture, 0);

    /**
     * @type {Object.<number, Object.<string, ol.Tile>>}
     */
    var tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};

    var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);

    var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    var allTilesLoaded = true;
    var tmpExtent = ol_extent["a" /* default */].createEmpty();
    var tmpTileRange = new tilerange["a" /* default */](0, 0, 0, 0);
    var childTileRange, drawable, fullyLoaded, tile, tileState;
    var x, y, tileExtent;
    for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (y = tileRange.minY; y <= tileRange.maxY; ++y) {

        tile = tileSource.getTile(z, x, y, pixelRatio, projection);
        if (layerState.extent !== undefined) {
          // ignore tiles outside layer extent
          tileExtent = tileGrid.getTileCoordExtent(tile.tileCoord, tmpExtent);
          if (!ol_extent["a" /* default */].intersects(tileExtent, layerState.extent)) {
            continue;
          }
        }
        tileState = tile.getState();
        drawable = tileState == tilestate["a" /* default */].LOADED || tileState == tilestate["a" /* default */].EMPTY || tileState == tilestate["a" /* default */].ERROR && !useInterimTilesOnError;
        if (!drawable) {
          tile = tile.getInterimTile();
        }
        tileState = tile.getState();
        if (tileState == tilestate["a" /* default */].LOADED) {
          if (mapRenderer.isTileTextureLoaded(tile)) {
            tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
            continue;
          }
        } else if (tileState == tilestate["a" /* default */].EMPTY || tileState == tilestate["a" /* default */].ERROR && !useInterimTilesOnError) {
          continue;
        }

        allTilesLoaded = false;
        fullyLoaded = tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, null, tmpTileRange, tmpExtent);
        if (!fullyLoaded) {
          childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
          if (childTileRange) {
            findLoadedTiles(z + 1, childTileRange);
          }
        }
      }
    }

    /** @type {Array.<number>} */
    var zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(array["a" /* default */].numberSafeCompareFunction);
    var u_tileOffset = new Float32Array(4);
    var i, ii, tileKey, tilesToDraw;
    for (i = 0, ii = zs.length; i < ii; ++i) {
      tilesToDraw = tilesToDrawByZ[zs[i]];
      for (tileKey in tilesToDraw) {
        tile = tilesToDraw[tileKey];
        tileExtent = tileGrid.getTileCoordExtent(tile.tileCoord, tmpExtent);
        u_tileOffset[0] = 2 * (tileExtent[2] - tileExtent[0]) / framebufferExtentDimension;
        u_tileOffset[1] = 2 * (tileExtent[3] - tileExtent[1]) / framebufferExtentDimension;
        u_tileOffset[2] = 2 * (tileExtent[0] - framebufferExtent[0]) / framebufferExtentDimension - 1;
        u_tileOffset[3] = 2 * (tileExtent[1] - framebufferExtent[1]) / framebufferExtentDimension - 1;
        gl.uniform4fv(this.locations_.u_tileOffset, u_tileOffset);
        mapRenderer.bindTileTexture(tile, tilePixelSize, tileGutter * pixelRatio, webgl["a" /* default */].LINEAR, webgl["a" /* default */].LINEAR);
        gl.drawArrays(webgl["a" /* default */].TRIANGLE_STRIP, 0, 4);
      }
    }

    if (allTilesLoaded) {
      this.renderedTileRange_ = tileRange;
      this.renderedFramebufferExtent_ = framebufferExtent;
      this.renderedRevision_ = tileSource.getRevision();
    } else {
      this.renderedTileRange_ = null;
      this.renderedFramebufferExtent_ = null;
      this.renderedRevision_ = -1;
      frameState.animate = true;
    }
  }

  this.updateUsedTiles(frameState.usedTiles, tileSource, z, tileRange);
  var tileTextureQueue = mapRenderer.getTileTextureQueue();
  this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload(),
  /**
   * @param {ol.Tile} tile Tile.
   */
  function (tile) {
    if (tile.getState() == tilestate["a" /* default */].LOADED && !mapRenderer.isTileTextureLoaded(tile) && !tileTextureQueue.isKeyQueued(tile.getKey())) {
      tileTextureQueue.enqueue([tile, tileGrid.getTileCoordCenter(tile.tileCoord), tileGrid.getResolution(tile.tileCoord[0]), tilePixelSize, tileGutter * pixelRatio]);
    }
  }, this);
  this.scheduleExpireCache(frameState, tileSource);
  this.updateLogos(frameState, tileSource);

  var texCoordMatrix = this.texCoordMatrix;
  ol_transform["a" /* default */].reset(texCoordMatrix);
  ol_transform["a" /* default */].translate(texCoordMatrix, (Math.round(center[0] / tileResolution) * tileResolution - framebufferExtent[0]) / (framebufferExtent[2] - framebufferExtent[0]), (Math.round(center[1] / tileResolution) * tileResolution - framebufferExtent[1]) / (framebufferExtent[3] - framebufferExtent[1]));
  if (viewState.rotation !== 0) {
    ol_transform["a" /* default */].rotate(texCoordMatrix, viewState.rotation);
  }
  ol_transform["a" /* default */].scale(texCoordMatrix, frameState.size[0] * viewState.resolution / (framebufferExtent[2] - framebufferExtent[0]), frameState.size[1] * viewState.resolution / (framebufferExtent[3] - framebufferExtent[1]));
  ol_transform["a" /* default */].translate(texCoordMatrix, -0.5, -0.5);

  return true;
};

/**
 * @inheritDoc
 */
tilelayer__ol_renderer_webgl_TileLayer_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg) {
  if (!this.framebuffer) {
    return undefined;
  }

  var pixelOnMapScaled = [pixel[0] / frameState.size[0], (frameState.size[1] - pixel[1]) / frameState.size[1]];

  var pixelOnFrameBufferScaled = ol_transform["a" /* default */].apply(this.texCoordMatrix, pixelOnMapScaled.slice());
  var pixelOnFrameBuffer = [pixelOnFrameBufferScaled[0] * this.framebufferDimension, pixelOnFrameBufferScaled[1] * this.framebufferDimension];

  var gl = this.mapRenderer.getContext().getGL();
  gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
  var imageData = new Uint8Array(4);
  gl.readPixels(pixelOnFrameBuffer[0], pixelOnFrameBuffer[1], 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, imageData);

  if (imageData[3] > 0) {
    return callback.call(thisArg, this.getLayer(), imageData);
  } else {
    return undefined;
  }
};
/* harmony default export */ var webgl_tilelayer = (tilelayer__ol_renderer_webgl_TileLayer_);
// CONCATENATED MODULE: ./node_modules/ol/renderer/webgl/vectorlayer.js










/**
 * @constructor
 * @extends {ol.renderer.webgl.Layer}
 * @param {ol.renderer.webgl.Map} mapRenderer Map renderer.
 * @param {ol.layer.Vector} vectorLayer Vector layer.
 * @api
 */
var vectorlayer__ol_renderer_webgl_VectorLayer_ = function _ol_renderer_webgl_VectorLayer_(mapRenderer, vectorLayer) {

  webgl_layer.call(this, mapRenderer, vectorLayer);

  /**
   * @private
   * @type {boolean}
   */
  this.dirty_ = false;

  /**
   * @private
   * @type {number}
   */
  this.renderedRevision_ = -1;

  /**
   * @private
   * @type {number}
   */
  this.renderedResolution_ = NaN;

  /**
   * @private
   * @type {ol.Extent}
   */
  this.renderedExtent_ = ol_extent["a" /* default */].createEmpty();

  /**
   * @private
   * @type {function(ol.Feature, ol.Feature): number|null}
   */
  this.renderedRenderOrder_ = null;

  /**
   * @private
   * @type {ol.render.webgl.ReplayGroup}
   */
  this.replayGroup_ = null;

  /**
   * The last layer state.
   * @private
   * @type {?ol.LayerState}
   */
  this.layerState_ = null;
};

ol["a" /* default */].inherits(vectorlayer__ol_renderer_webgl_VectorLayer_, webgl_layer);

/**
 * Determine if this renderer handles the provided layer.
 * @param {ol.renderer.Type} type The renderer type.
 * @param {ol.layer.Layer} layer The candidate layer.
 * @return {boolean} The renderer can render the layer.
 */
vectorlayer__ol_renderer_webgl_VectorLayer_['handles'] = function (type, layer) {
  return type === renderer_type.WEBGL && layer.getType() === layertype["a" /* default */].VECTOR;
};

/**
 * Create a layer renderer.
 * @param {ol.renderer.Map} mapRenderer The map renderer.
 * @param {ol.layer.Layer} layer The layer to be rendererd.
 * @return {ol.renderer.webgl.VectorLayer} The layer renderer.
 */
vectorlayer__ol_renderer_webgl_VectorLayer_['create'] = function (mapRenderer, layer) {
  return new vectorlayer__ol_renderer_webgl_VectorLayer_(
  /** @type {ol.renderer.webgl.Map} */mapRenderer,
  /** @type {ol.layer.Vector} */layer);
};

/**
 * @inheritDoc
 */
vectorlayer__ol_renderer_webgl_VectorLayer_.prototype.composeFrame = function (frameState, layerState, context) {
  this.layerState_ = layerState;
  var viewState = frameState.viewState;
  var replayGroup = this.replayGroup_;
  var size = frameState.size;
  var pixelRatio = frameState.pixelRatio;
  var gl = this.mapRenderer.getGL();
  if (replayGroup && !replayGroup.isEmpty()) {
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(0, 0, size[0] * pixelRatio, size[1] * pixelRatio);
    replayGroup.replay(context, viewState.center, viewState.resolution, viewState.rotation, size, pixelRatio, layerState.opacity, layerState.managed ? frameState.skippedFeatureUids : {});
    gl.disable(gl.SCISSOR_TEST);
  }
};

/**
 * @inheritDoc
 */
vectorlayer__ol_renderer_webgl_VectorLayer_.prototype.disposeInternal = function () {
  var replayGroup = this.replayGroup_;
  if (replayGroup) {
    var context = this.mapRenderer.getContext();
    replayGroup.getDeleteResourcesFunction(context)();
    this.replayGroup_ = null;
  }
  webgl_layer.prototype.disposeInternal.call(this);
};

/**
 * @inheritDoc
 */
vectorlayer__ol_renderer_webgl_VectorLayer_.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, thisArg) {
  if (!this.replayGroup_ || !this.layerState_) {
    return undefined;
  } else {
    var context = this.mapRenderer.getContext();
    var viewState = frameState.viewState;
    var layer = this.getLayer();
    var layerState = this.layerState_;
    /** @type {Object.<string, boolean>} */
    var features = {};
    return this.replayGroup_.forEachFeatureAtCoordinate(coordinate, context, viewState.center, viewState.resolution, viewState.rotation, frameState.size, frameState.pixelRatio, layerState.opacity, {},
    /**
     * @param {ol.Feature|ol.render.Feature} feature Feature.
     * @return {?} Callback result.
     */
    function (feature) {
      var key = ol["a" /* default */].getUid(feature).toString();
      if (!(key in features)) {
        features[key] = true;
        return callback.call(thisArg, feature, layer);
      }
    });
  }
};

/**
 * @inheritDoc
 */
vectorlayer__ol_renderer_webgl_VectorLayer_.prototype.hasFeatureAtCoordinate = function (coordinate, frameState) {
  if (!this.replayGroup_ || !this.layerState_) {
    return false;
  } else {
    var context = this.mapRenderer.getContext();
    var viewState = frameState.viewState;
    var layerState = this.layerState_;
    return this.replayGroup_.hasFeatureAtCoordinate(coordinate, context, viewState.center, viewState.resolution, viewState.rotation, frameState.size, frameState.pixelRatio, layerState.opacity, frameState.skippedFeatureUids);
  }
};

/**
 * @inheritDoc
 */
vectorlayer__ol_renderer_webgl_VectorLayer_.prototype.forEachLayerAtPixel = function (pixel, frameState, callback, thisArg) {
  var coordinate = ol_transform["a" /* default */].apply(frameState.pixelToCoordinateTransform, pixel.slice());
  var hasFeature = this.hasFeatureAtCoordinate(coordinate, frameState);

  if (hasFeature) {
    return callback.call(thisArg, this.getLayer(), null);
  } else {
    return undefined;
  }
};

/**
 * Handle changes in image style state.
 * @param {ol.events.Event} event Image style change event.
 * @private
 */
vectorlayer__ol_renderer_webgl_VectorLayer_.prototype.handleStyleImageChange_ = function (event) {
  this.renderIfReadyAndVisible();
};

/**
 * @inheritDoc
 */
vectorlayer__ol_renderer_webgl_VectorLayer_.prototype.prepareFrame = function (frameState, layerState, context) {

  var vectorLayer = /** @type {ol.layer.Vector} */this.getLayer();
  var vectorSource = vectorLayer.getSource();

  this.updateLogos(frameState, vectorSource);

  var animating = frameState.viewHints[viewhint["a" /* default */].ANIMATING];
  var interacting = frameState.viewHints[viewhint["a" /* default */].INTERACTING];
  var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
  var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();

  if (!this.dirty_ && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
    return true;
  }

  var frameStateExtent = frameState.extent;
  var viewState = frameState.viewState;
  var projection = viewState.projection;
  var resolution = viewState.resolution;
  var pixelRatio = frameState.pixelRatio;
  var vectorLayerRevision = vectorLayer.getRevision();
  var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
  var vectorLayerRenderOrder = vectorLayer.getRenderOrder();

  if (vectorLayerRenderOrder === undefined) {
    vectorLayerRenderOrder = vector.defaultOrder;
  }

  var extent = ol_extent["a" /* default */].buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);

  if (!this.dirty_ && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && ol_extent["a" /* default */].containsExtent(this.renderedExtent_, extent)) {
    return true;
  }

  if (this.replayGroup_) {
    frameState.postRenderFunctions.push(this.replayGroup_.getDeleteResourcesFunction(context));
  }

  this.dirty_ = false;

  var replayGroup = new webgl_replaygroup(vector.getTolerance(resolution, pixelRatio), extent, vectorLayer.getRenderBuffer());
  vectorSource.loadFeatures(extent, resolution, projection);
  /**
   * @param {ol.Feature} feature Feature.
   * @this {ol.renderer.webgl.VectorLayer}
   */
  var renderFeature = function renderFeature(feature) {
    var styles;
    var styleFunction = feature.getStyleFunction();
    if (styleFunction) {
      styles = styleFunction.call(feature, resolution);
    } else {
      styleFunction = vectorLayer.getStyleFunction();
      if (styleFunction) {
        styles = styleFunction(feature, resolution);
      }
    }
    if (styles) {
      var dirty = this.renderFeature(feature, resolution, pixelRatio, styles, replayGroup);
      this.dirty_ = this.dirty_ || dirty;
    }
  };
  if (vectorLayerRenderOrder) {
    /** @type {Array.<ol.Feature>} */
    var features = [];
    vectorSource.forEachFeatureInExtent(extent,
    /**
     * @param {ol.Feature} feature Feature.
     */
    function (feature) {
      features.push(feature);
    }, this);
    features.sort(vectorLayerRenderOrder);
    features.forEach(renderFeature, this);
  } else {
    vectorSource.forEachFeatureInExtent(extent, renderFeature, this);
  }
  replayGroup.finish(context);

  this.renderedResolution_ = resolution;
  this.renderedRevision_ = vectorLayerRevision;
  this.renderedRenderOrder_ = vectorLayerRenderOrder;
  this.renderedExtent_ = extent;
  this.replayGroup_ = replayGroup;

  return true;
};

/**
 * @param {ol.Feature} feature Feature.
 * @param {number} resolution Resolution.
 * @param {number} pixelRatio Pixel ratio.
 * @param {(ol.style.Style|Array.<ol.style.Style>)} styles The style or array of
 *     styles.
 * @param {ol.render.webgl.ReplayGroup} replayGroup Replay group.
 * @return {boolean} `true` if an image is loading.
 */
vectorlayer__ol_renderer_webgl_VectorLayer_.prototype.renderFeature = function (feature, resolution, pixelRatio, styles, replayGroup) {
  if (!styles) {
    return false;
  }
  var loading = false;
  if (Array.isArray(styles)) {
    for (var i = styles.length - 1, ii = 0; i >= ii; --i) {
      loading = vector.renderFeature(replayGroup, feature, styles[i], vector.getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;
    }
  } else {
    loading = vector.renderFeature(replayGroup, feature, styles, vector.getSquaredTolerance(resolution, pixelRatio), this.handleStyleImageChange_, this) || loading;
  }
  return loading;
};
/* harmony default export */ var webgl_vectorlayer = (vectorlayer__ol_renderer_webgl_VectorLayer_);
// CONCATENATED MODULE: ./node_modules/ol/map.js

















if (ol["a" /* default */].ENABLE_CANVAS) {
  ol_plugins.register(plugintype.MAP_RENDERER, canvas_map);
  ol_plugins.registerMultiple(plugintype.LAYER_RENDERER, [imagelayer, tilelayer, vectorlayer, vectortilelayer]);
}

if (ol["a" /* default */].ENABLE_WEBGL) {
  ol_plugins.register(plugintype.MAP_RENDERER, webgl_map);
  ol_plugins.registerMultiple(plugintype.LAYER_RENDERER, [webgl_imagelayer, webgl_tilelayer, webgl_vectorlayer]);
}

/**
 * @classdesc
 * The map is the core component of OpenLayers. For a map to render, a view,
 * one or more layers, and a target container are needed:
 *
 *     var map = new ol.Map({
 *       view: new ol.View({
 *         center: [0, 0],
 *         zoom: 1
 *       }),
 *       layers: [
 *         new ol.layer.Tile({
 *           source: new ol.source.OSM()
 *         })
 *       ],
 *       target: 'map'
 *     });
 *
 * The above snippet creates a map using a {@link ol.layer.Tile} to display
 * {@link ol.source.OSM} OSM data and render it to a DOM element with the
 * id `map`.
 *
 * The constructor places a viewport container (with CSS class name
 * `ol-viewport`) in the target element (see `getViewport()`), and then two
 * further elements within the viewport: one with CSS class name
 * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
 * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
 * option of {@link ol.Overlay} for the difference). The map itself is placed in
 * a further element within the viewport.
 *
 * Layers are stored as a `ol.Collection` in layerGroups. A top-level group is
 * provided by the library. This is what is accessed by `getLayerGroup` and
 * `setLayerGroup`. Layers entered in the options are added to this group, and
 * `addLayer` and `removeLayer` change the layer collection in the group.
 * `getLayers` is a convenience function for `getLayerGroup().getLayers()`.
 * Note that `ol.layer.Group` is a subclass of `ol.layer.Base`, so layers
 * entered in the options or added with `addLayer` can be groups, which can
 * contain further groups, and so on.
 *
 * @constructor
 * @extends {ol.PluggableMap}
 * @param {olx.MapOptions} options Map options.
 * @fires ol.MapBrowserEvent
 * @fires ol.MapEvent
 * @fires ol.render.Event#postcompose
 * @fires ol.render.Event#precompose
 * @api
 */
var map__ol_Map_ = function _ol_Map_(options) {
  options = obj["a" /* default */].assign({}, options);
  if (!options.controls) {
    options.controls = ol_control.defaults();
  }
  if (!options.interactions) {
    options.interactions = ol_interaction.defaults();
  }

  pluggablemap.call(this, options);
};

ol["a" /* default */].inherits(map__ol_Map_, pluggablemap);
/* harmony default export */ var ol_map = __webpack_exports__["default"] = (map__ol_Map_);

/***/ }),
/* 105 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/ol/index.js
var ol = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ol/layertype.js
var layertype = __webpack_require__(24);

// EXTERNAL MODULE: ./node_modules/ol/layer/layer.js
var layer_layer = __webpack_require__(42);

// CONCATENATED MODULE: ./node_modules/ol/layer/tileproperty.js
/**
 * @enum {string}
 */
var _ol_layer_TileProperty_ = {
  PRELOAD: 'preload',
  USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError'
};

/* harmony default export */ var tileproperty = (_ol_layer_TileProperty_);
// EXTERNAL MODULE: ./node_modules/ol/obj.js
var obj = __webpack_require__(2);

// CONCATENATED MODULE: ./node_modules/ol/layer/tile.js






/**
 * @classdesc
 * For layer sources that provide pre-rendered, tiled images in grids that are
 * organized by zoom levels for specific resolutions.
 * Note that any property set in the options is set as a {@link ol.Object}
 * property on the layer object; for example, setting `title: 'My Title'` in the
 * options means that `title` is observable, and has get/set accessors.
 *
 * @constructor
 * @extends {ol.layer.Layer}
 * @fires ol.render.Event
 * @param {olx.layer.TileOptions=} opt_options Tile layer options.
 * @api
 */
var tile__ol_layer_Tile_ = function _ol_layer_Tile_(opt_options) {
  var options = opt_options ? opt_options : {};

  var baseOptions = obj["a" /* default */].assign({}, options);

  delete baseOptions.preload;
  delete baseOptions.useInterimTilesOnError;
  layer_layer["a" /* default */].call(this, /** @type {olx.layer.LayerOptions} */baseOptions);

  this.setPreload(options.preload !== undefined ? options.preload : 0);
  this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined ? options.useInterimTilesOnError : true);

  /**
   * The layer type.
   * @protected
   * @type {ol.LayerType}
   */
  this.type = layertype["a" /* default */].TILE;
};

ol["a" /* default */].inherits(tile__ol_layer_Tile_, layer_layer["a" /* default */]);

/**
 * Return the level as number to which we will preload tiles up to.
 * @return {number} The level to preload tiles up to.
 * @observable
 * @api
 */
tile__ol_layer_Tile_.prototype.getPreload = function () {
  return (
    /** @type {number} */this.get(tileproperty.PRELOAD)
  );
};

/**
 * Return the associated {@link ol.source.Tile tilesource} of the layer.
 * @function
 * @return {ol.source.Tile} Source.
 * @api
 */
tile__ol_layer_Tile_.prototype.getSource;

/**
 * Set the level as number to which we will preload tiles up to.
 * @param {number} preload The level to preload tiles up to.
 * @observable
 * @api
 */
tile__ol_layer_Tile_.prototype.setPreload = function (preload) {
  this.set(tileproperty.PRELOAD, preload);
};

/**
 * Whether we use interim tiles on error.
 * @return {boolean} Use interim tiles on error.
 * @observable
 * @api
 */
tile__ol_layer_Tile_.prototype.getUseInterimTilesOnError = function () {
  return (
    /** @type {boolean} */this.get(tileproperty.USE_INTERIM_TILES_ON_ERROR)
  );
};

/**
 * Set whether we use interim tiles on error.
 * @param {boolean} useInterimTilesOnError Use interim tiles on error.
 * @observable
 * @api
 */
tile__ol_layer_Tile_.prototype.setUseInterimTilesOnError = function (useInterimTilesOnError) {
  this.set(tileproperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
};
/* harmony default export */ var tile = __webpack_exports__["default"] = (tile__ol_layer_Tile_);

/***/ }),
/* 106 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/ol/index.js
var ol = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ol/tilestate.js
var tilestate = __webpack_require__(20);

// EXTERNAL MODULE: ./node_modules/ol/easing.js
var easing = __webpack_require__(29);

// EXTERNAL MODULE: ./node_modules/ol/events/eventtarget.js
var eventtarget = __webpack_require__(31);

// EXTERNAL MODULE: ./node_modules/ol/events/eventtype.js
var eventtype = __webpack_require__(4);

// CONCATENATED MODULE: ./node_modules/ol/tile.js






/**
 * @classdesc
 * Base class for tiles.
 *
 * @constructor
 * @abstract
 * @extends {ol.events.EventTarget}
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileState} state State.
 * @param {olx.TileOptions=} opt_options Tile options.
 */
var tile__ol_Tile_ = function _ol_Tile_(tileCoord, state, opt_options) {
  eventtarget["a" /* default */].call(this);

  var options = opt_options ? opt_options : {};

  /**
   * @type {ol.TileCoord}
   */
  this.tileCoord = tileCoord;

  /**
   * @protected
   * @type {ol.TileState}
   */
  this.state = state;

  /**
   * An "interim" tile for this tile. The interim tile may be used while this
   * one is loading, for "smooth" transitions when changing params/dimensions
   * on the source.
   * @type {ol.Tile}
   */
  this.interimTile = null;

  /**
   * A key assigned to the tile. This is used by the tile source to determine
   * if this tile can effectively be used, or if a new tile should be created
   * and this one be used as an interim tile for this new tile.
   * @type {string}
   */
  this.key = '';

  /**
   * The duration for the opacity transition.
   * @type {number}
   */
  this.transition_ = options.transition === undefined ? 250 : options.transition;

  /**
   * Lookup of start times for rendering transitions.  If the start time is
   * equal to -1, the transition is complete.
   * @type {Object.<number, number>}
   */
  this.transitionStarts_ = {};
};

ol["a" /* default */].inherits(tile__ol_Tile_, eventtarget["a" /* default */]);

/**
 * @protected
 */
tile__ol_Tile_.prototype.changed = function () {
  this.dispatchEvent(eventtype["a" /* default */].CHANGE);
};

/**
 * @return {string} Key.
 */
tile__ol_Tile_.prototype.getKey = function () {
  return this.key + '/' + this.tileCoord;
};

/**
 * Get the interim tile most suitable for rendering using the chain of interim
 * tiles. This corresponds to the  most recent tile that has been loaded, if no
 * such tile exists, the original tile is returned.
 * @return {!ol.Tile} Best tile for rendering.
 */
tile__ol_Tile_.prototype.getInterimTile = function () {
  if (!this.interimTile) {
    //empty chain
    return this;
  }
  var tile = this.interimTile;

  // find the first loaded tile and return it. Since the chain is sorted in
  // decreasing order of creation time, there is no need to search the remainder
  // of the list (all those tiles correspond to older requests and will be
  // cleaned up by refreshInterimChain)
  do {
    if (tile.getState() == tilestate["a" /* default */].LOADED) {
      return tile;
    }
    tile = tile.interimTile;
  } while (tile);

  // we can not find a better tile
  return this;
};

/**
 * Goes through the chain of interim tiles and discards sections of the chain
 * that are no longer relevant.
 */
tile__ol_Tile_.prototype.refreshInterimChain = function () {
  if (!this.interimTile) {
    return;
  }

  var tile = this.interimTile;
  var prev = this;

  do {
    if (tile.getState() == tilestate["a" /* default */].LOADED) {
      //we have a loaded tile, we can discard the rest of the list
      //we would could abort any LOADING tile request
      //older than this tile (i.e. any LOADING tile following this entry in the chain)
      tile.interimTile = null;
      break;
    } else if (tile.getState() == tilestate["a" /* default */].LOADING) {
      //keep this LOADING tile any loaded tiles later in the chain are
      //older than this tile, so we're still interested in the request
      prev = tile;
    } else if (tile.getState() == tilestate["a" /* default */].IDLE) {
      //the head of the list is the most current tile, we don't need
      //to start any other requests for this chain
      prev.interimTile = tile.interimTile;
    } else {
      prev = tile;
    }
    tile = prev.interimTile;
  } while (tile);
};

/**
 * Get the tile coordinate for this tile.
 * @return {ol.TileCoord} The tile coordinate.
 * @api
 */
tile__ol_Tile_.prototype.getTileCoord = function () {
  return this.tileCoord;
};

/**
 * @return {ol.TileState} State.
 */
tile__ol_Tile_.prototype.getState = function () {
  return this.state;
};

/**
 * @param {ol.TileState} state State.
 */
tile__ol_Tile_.prototype.setState = function (state) {
  this.state = state;
  this.changed();
};

/**
 * Load the image or retry if loading previously failed.
 * Loading is taken care of by the tile queue, and calling this method is
 * only needed for preloading or for reloading in case of an error.
 * @abstract
 * @api
 */
tile__ol_Tile_.prototype.load = function () {};

/**
 * Get the alpha value for rendering.
 * @param {number} id An id for the renderer.
 * @param {number} time The render frame time.
 * @return {number} A number between 0 and 1.
 */
tile__ol_Tile_.prototype.getAlpha = function (id, time) {
  if (!this.transition_) {
    return 1;
  }

  var start = this.transitionStarts_[id];
  if (!start) {
    start = time;
    this.transitionStarts_[id] = start;
  } else if (start === -1) {
    return 1;
  }

  var delta = time - start + 1000 / 60; // avoid rendering at 0
  if (delta >= this.transition_) {
    return 1;
  }
  return easing["a" /* default */].easeIn(delta / this.transition_);
};

/**
 * Determine if a tile is in an alpha transition.  A tile is considered in
 * transition if tile.getAlpha() has not yet been called or has been called
 * and returned 1.
 * @param {number} id An id for the renderer.
 * @return {boolean} The tile is in transition.
 */
tile__ol_Tile_.prototype.inTransition = function (id) {
  if (!this.transition_) {
    return false;
  }
  return this.transitionStarts_[id] !== -1;
};

/**
 * Mark a transition as complete.
 * @param {number} id An id for the renderer.
 */
tile__ol_Tile_.prototype.endTransition = function (id) {
  if (this.transition_) {
    this.transitionStarts_[id] = -1;
  }
};
/* harmony default export */ var ol_tile = (tile__ol_Tile_);
// EXTERNAL MODULE: ./node_modules/ol/dom.js
var dom = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/ol/events.js
var events = __webpack_require__(3);

// CONCATENATED MODULE: ./node_modules/ol/imagetile.js







/**
 * @constructor
 * @extends {ol.Tile}
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.TileState} state State.
 * @param {string} src Image source URI.
 * @param {?string} crossOrigin Cross origin.
 * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.
 * @param {olx.TileOptions=} opt_options Tile options.
 */
var imagetile__ol_ImageTile_ = function _ol_ImageTile_(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {

  ol_tile.call(this, tileCoord, state, opt_options);

  /**
   * @private
   * @type {?string}
   */
  this.crossOrigin_ = crossOrigin;

  /**
   * Image URI
   *
   * @private
   * @type {string}
   */
  this.src_ = src;

  /**
   * @private
   * @type {Image|HTMLCanvasElement}
   */
  this.image_ = new Image();
  if (crossOrigin !== null) {
    this.image_.crossOrigin = crossOrigin;
  }

  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */
  this.imageListenerKeys_ = null;

  /**
   * @private
   * @type {ol.TileLoadFunctionType}
   */
  this.tileLoadFunction_ = tileLoadFunction;
};

ol["a" /* default */].inherits(imagetile__ol_ImageTile_, ol_tile);

/**
 * @inheritDoc
 */
imagetile__ol_ImageTile_.prototype.disposeInternal = function () {
  if (this.state == tilestate["a" /* default */].LOADING) {
    this.unlistenImage_();
    this.image_ = imagetile__ol_ImageTile_.getBlankImage();
  }
  if (this.interimTile) {
    this.interimTile.dispose();
  }
  this.state = tilestate["a" /* default */].ABORT;
  this.changed();
  ol_tile.prototype.disposeInternal.call(this);
};

/**
 * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
 * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
 * @api
 */
imagetile__ol_ImageTile_.prototype.getImage = function () {
  return this.image_;
};

/**
 * @inheritDoc
 */
imagetile__ol_ImageTile_.prototype.getKey = function () {
  return this.src_;
};

/**
 * Tracks loading or read errors.
 *
 * @private
 */
imagetile__ol_ImageTile_.prototype.handleImageError_ = function () {
  this.state = tilestate["a" /* default */].ERROR;
  this.unlistenImage_();
  this.image_ = imagetile__ol_ImageTile_.getBlankImage();
  this.changed();
};

/**
 * Tracks successful image load.
 *
 * @private
 */
imagetile__ol_ImageTile_.prototype.handleImageLoad_ = function () {
  if (this.image_.naturalWidth && this.image_.naturalHeight) {
    this.state = tilestate["a" /* default */].LOADED;
  } else {
    this.state = tilestate["a" /* default */].EMPTY;
  }
  this.unlistenImage_();
  this.changed();
};

/**
 * @inheritDoc
 * @api
 */
imagetile__ol_ImageTile_.prototype.load = function () {
  if (this.state == tilestate["a" /* default */].ERROR) {
    this.state = tilestate["a" /* default */].IDLE;
    this.image_ = new Image();
    if (this.crossOrigin_ !== null) {
      this.image_.crossOrigin = this.crossOrigin_;
    }
  }
  if (this.state == tilestate["a" /* default */].IDLE) {
    this.state = tilestate["a" /* default */].LOADING;
    this.changed();
    this.imageListenerKeys_ = [events["a" /* default */].listenOnce(this.image_, eventtype["a" /* default */].ERROR, this.handleImageError_, this), events["a" /* default */].listenOnce(this.image_, eventtype["a" /* default */].LOAD, this.handleImageLoad_, this)];
    this.tileLoadFunction_(this, this.src_);
  }
};

/**
 * Discards event handlers which listen for load completion or errors.
 *
 * @private
 */
imagetile__ol_ImageTile_.prototype.unlistenImage_ = function () {
  this.imageListenerKeys_.forEach(events["a" /* default */].unlistenByKey);
  this.imageListenerKeys_ = null;
};

/**
 * Get a 1-pixel blank image.
 * @return {HTMLCanvasElement} Blank image.
 */
imagetile__ol_ImageTile_.getBlankImage = function () {
  var ctx = dom["a" /* default */].createCanvasContext2D(1, 1);
  ctx.fillStyle = 'rgba(0,0,0,0)';
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
};
/* harmony default export */ var imagetile = (imagetile__ol_ImageTile_);
// EXTERNAL MODULE: ./node_modules/ol/structs/lrucache.js
var lrucache = __webpack_require__(65);

// EXTERNAL MODULE: ./node_modules/ol/tilecoord.js
var tilecoord = __webpack_require__(44);

// CONCATENATED MODULE: ./node_modules/ol/tilecache.js




/**
 * @constructor
 * @extends {ol.structs.LRUCache.<ol.Tile>}
 * @param {number=} opt_highWaterMark High water mark.
 * @struct
 */
var tilecache__ol_TileCache_ = function _ol_TileCache_(opt_highWaterMark) {

  lrucache["a" /* default */].call(this, opt_highWaterMark);
};

ol["a" /* default */].inherits(tilecache__ol_TileCache_, lrucache["a" /* default */]);

/**
 * @param {Object.<string, ol.TileRange>} usedTiles Used tiles.
 */
tilecache__ol_TileCache_.prototype.expireCache = function (usedTiles) {
  var tile, zKey;
  while (this.canExpireCache()) {
    tile = this.peekLast();
    zKey = tile.tileCoord[0].toString();
    if (zKey in usedTiles && usedTiles[zKey].contains(tile.tileCoord)) {
      break;
    } else {
      this.pop().dispose();
    }
  }
};

/**
 * Prune all tiles from the cache that don't have the same z as the newest tile.
 */
tilecache__ol_TileCache_.prototype.pruneExceptNewestZ = function () {
  if (this.getCount() === 0) {
    return;
  }
  var key = this.peekFirstKey();
  var tileCoord = tilecoord["a" /* default */].fromKey(key);
  var z = tileCoord[0];
  this.forEach(function (tile) {
    if (tile.tileCoord[0] !== z) {
      this.remove(tilecoord["a" /* default */].getKey(tile.tileCoord));
      tile.dispose();
    }
  }, this);
};
/* harmony default export */ var tilecache = (tilecache__ol_TileCache_);
// EXTERNAL MODULE: ./node_modules/ol/proj.js + 7 modules
var ol_proj = __webpack_require__(16);

// EXTERNAL MODULE: ./node_modules/ol/extent.js
var ol_extent = __webpack_require__(1);

// EXTERNAL MODULE: ./node_modules/ol/math.js
var math = __webpack_require__(6);

// CONCATENATED MODULE: ./node_modules/ol/reproj.js




var _ol_reproj_ = {};

/**
 * Calculates ideal resolution to use from the source in order to achieve
 * pixel mapping as close as possible to 1:1 during reprojection.
 * The resolution is calculated regardless of what resolutions
 * are actually available in the dataset (TileGrid, Image, ...).
 *
 * @param {ol.proj.Projection} sourceProj Source projection.
 * @param {ol.proj.Projection} targetProj Target projection.
 * @param {ol.Coordinate} targetCenter Target center.
 * @param {number} targetResolution Target resolution.
 * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
 */
_ol_reproj_.calculateSourceResolution = function (sourceProj, targetProj, targetCenter, targetResolution) {

    var sourceCenter = ol_proj["default"].transform(targetCenter, targetProj, sourceProj);

    // calculate the ideal resolution of the source data
    var sourceResolution = ol_proj["default"].getPointResolution(targetProj, targetResolution, targetCenter);

    var targetMetersPerUnit = targetProj.getMetersPerUnit();
    if (targetMetersPerUnit !== undefined) {
        sourceResolution *= targetMetersPerUnit;
    }
    var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
    if (sourceMetersPerUnit !== undefined) {
        sourceResolution /= sourceMetersPerUnit;
    }

    // Based on the projection properties, the point resolution at the specified
    // coordinates may be slightly different. We need to reverse-compensate this
    // in order to achieve optimal results.

    var sourceExtent = sourceProj.getExtent();
    if (!sourceExtent || ol_extent["a" /* default */].containsCoordinate(sourceExtent, sourceCenter)) {
        var compensationFactor = ol_proj["default"].getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
        if (isFinite(compensationFactor) && compensationFactor > 0) {
            sourceResolution /= compensationFactor;
        }
    }

    return sourceResolution;
};

/**
 * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap
 * in order to mask gaps caused by antialiasing.
 *
 * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).
 * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).
 * @param {number} x X coordinate of the point (in pixels).
 * @param {number} y Y coordinate of the point (in pixels).
 * @return {ol.Coordinate} New point 1 px farther from the centroid.
 * @private
 */
_ol_reproj_.enlargeClipPoint_ = function (centroidX, centroidY, x, y) {
    var dX = x - centroidX,
        dY = y - centroidY;
    var distance = Math.sqrt(dX * dX + dY * dY);
    return [Math.round(x + dX / distance), Math.round(y + dY / distance)];
};

/**
 * Renders the source data into new canvas based on the triangulation.
 *
 * @param {number} width Width of the canvas.
 * @param {number} height Height of the canvas.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} sourceResolution Source resolution.
 * @param {ol.Extent} sourceExtent Extent of the data source.
 * @param {number} targetResolution Target resolution.
 * @param {ol.Extent} targetExtent Target extent.
 * @param {ol.reproj.Triangulation} triangulation Calculated triangulation.
 * @param {Array.<{extent: ol.Extent,
 *                 image: (HTMLCanvasElement|Image|HTMLVideoElement)}>} sources
 *             Array of sources.
 * @param {number} gutter Gutter of the sources.
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 * @return {HTMLCanvasElement} Canvas with reprojected data.
 */
_ol_reproj_.render = function (width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges) {

    var context = dom["a" /* default */].createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));

    if (sources.length === 0) {
        return context.canvas;
    }

    context.scale(pixelRatio, pixelRatio);

    var sourceDataExtent = ol_extent["a" /* default */].createEmpty();
    sources.forEach(function (src, i, arr) {
        ol_extent["a" /* default */].extend(sourceDataExtent, src.extent);
    });

    var canvasWidthInUnits = ol_extent["a" /* default */].getWidth(sourceDataExtent);
    var canvasHeightInUnits = ol_extent["a" /* default */].getHeight(sourceDataExtent);
    var stitchContext = dom["a" /* default */].createCanvasContext2D(Math.round(pixelRatio * canvasWidthInUnits / sourceResolution), Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));

    var stitchScale = pixelRatio / sourceResolution;

    sources.forEach(function (src, i, arr) {
        var xPos = src.extent[0] - sourceDataExtent[0];
        var yPos = -(src.extent[3] - sourceDataExtent[3]);
        var srcWidth = ol_extent["a" /* default */].getWidth(src.extent);
        var srcHeight = ol_extent["a" /* default */].getHeight(src.extent);

        stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
    });

    var targetTopLeft = ol_extent["a" /* default */].getTopLeft(targetExtent);

    triangulation.getTriangles().forEach(function (triangle, i, arr) {
        /* Calculate affine transform (src -> dst)
         * Resulting matrix can be used to transform coordinate
         * from `sourceProjection` to destination pixels.
         *
         * To optimize number of context calls and increase numerical stability,
         * we also do the following operations:
         * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
         * here before solving the linear system so [ui, vi] are pixel coordinates.
         *
         * Src points: xi, yi
         * Dst points: ui, vi
         * Affine coefficients: aij
         *
         * | x0 y0 1  0  0 0 |   |a00|   |u0|
         * | x1 y1 1  0  0 0 |   |a01|   |u1|
         * | x2 y2 1  0  0 0 | x |a02| = |u2|
         * |  0  0 0 x0 y0 1 |   |a10|   |v0|
         * |  0  0 0 x1 y1 1 |   |a11|   |v1|
         * |  0  0 0 x2 y2 1 |   |a12|   |v2|
         */
        var source = triangle.source,
            target = triangle.target;
        var x0 = source[0][0],
            y0 = source[0][1],
            x1 = source[1][0],
            y1 = source[1][1],
            x2 = source[2][0],
            y2 = source[2][1];
        var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution,
            v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
        var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution,
            v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
        var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution,
            v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

        // Shift all the source points to improve numerical stability
        // of all the subsequent calculations. The [x0, y0] is used here.
        // This is also used to simplify the linear system.
        var sourceNumericalShiftX = x0,
            sourceNumericalShiftY = y0;
        x0 = 0;
        y0 = 0;
        x1 -= sourceNumericalShiftX;
        y1 -= sourceNumericalShiftY;
        x2 -= sourceNumericalShiftX;
        y2 -= sourceNumericalShiftY;

        var augmentedMatrix = [[x1, y1, 0, 0, u1 - u0], [x2, y2, 0, 0, u2 - u0], [0, 0, x1, y1, v1 - v0], [0, 0, x2, y2, v2 - v0]];
        var affineCoefs = math["a" /* default */].solveLinearSystem(augmentedMatrix);
        if (!affineCoefs) {
            return;
        }

        context.save();
        context.beginPath();
        var centroidX = (u0 + u1 + u2) / 3,
            centroidY = (v0 + v1 + v2) / 3;
        var p0 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u0, v0);
        var p1 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u1, v1);
        var p2 = _ol_reproj_.enlargeClipPoint_(centroidX, centroidY, u2, v2);

        context.moveTo(p1[0], p1[1]);
        context.lineTo(p0[0], p0[1]);
        context.lineTo(p2[0], p2[1]);
        context.clip();

        context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);

        context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);

        context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);

        context.drawImage(stitchContext.canvas, 0, 0);
        context.restore();
    });

    if (opt_renderEdges) {
        context.save();

        context.strokeStyle = 'black';
        context.lineWidth = 1;

        triangulation.getTriangles().forEach(function (triangle, i, arr) {
            var target = triangle.target;
            var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution,
                v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
            var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution,
                v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
            var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution,
                v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;

            context.beginPath();
            context.moveTo(u1, v1);
            context.lineTo(u0, v0);
            context.lineTo(u2, v2);
            context.closePath();
            context.stroke();
        });

        context.restore();
    }
    return context.canvas;
};
/* harmony default export */ var reproj = (_ol_reproj_);
// CONCATENATED MODULE: ./node_modules/ol/reproj/triangulation.js





/**
 * @classdesc
 * Class containing triangulation of the given target extent.
 * Used for determining source data and the reprojection itself.
 *
 * @param {ol.proj.Projection} sourceProj Source projection.
 * @param {ol.proj.Projection} targetProj Target projection.
 * @param {ol.Extent} targetExtent Target extent to triangulate.
 * @param {ol.Extent} maxSourceExtent Maximal source extent that can be used.
 * @param {number} errorThreshold Acceptable error (in source units).
 * @constructor
 */
var triangulation__ol_reproj_Triangulation_ = function _ol_reproj_Triangulation_(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {

  /**
   * @type {ol.proj.Projection}
   * @private
   */
  this.sourceProj_ = sourceProj;

  /**
   * @type {ol.proj.Projection}
   * @private
   */
  this.targetProj_ = targetProj;

  /** @type {!Object.<string, ol.Coordinate>} */
  var transformInvCache = {};
  var transformInv = ol_proj["default"].getTransform(this.targetProj_, this.sourceProj_);

  /**
   * @param {ol.Coordinate} c A coordinate.
   * @return {ol.Coordinate} Transformed coordinate.
   * @private
   */
  this.transformInv_ = function (c) {
    var key = c[0] + '/' + c[1];
    if (!transformInvCache[key]) {
      transformInvCache[key] = transformInv(c);
    }
    return transformInvCache[key];
  };

  /**
   * @type {ol.Extent}
   * @private
   */
  this.maxSourceExtent_ = maxSourceExtent;

  /**
   * @type {number}
   * @private
   */
  this.errorThresholdSquared_ = errorThreshold * errorThreshold;

  /**
   * @type {Array.<ol.ReprojTriangle>}
   * @private
   */
  this.triangles_ = [];

  /**
   * Indicates that the triangulation crosses edge of the source projection.
   * @type {boolean}
   * @private
   */
  this.wrapsXInSource_ = false;

  /**
   * @type {boolean}
   * @private
   */
  this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && ol_extent["a" /* default */].getWidth(maxSourceExtent) == ol_extent["a" /* default */].getWidth(this.sourceProj_.getExtent());

  /**
   * @type {?number}
   * @private
   */
  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? ol_extent["a" /* default */].getWidth(this.sourceProj_.getExtent()) : null;

  /**
   * @type {?number}
   * @private
   */
  this.targetWorldWidth_ = this.targetProj_.getExtent() ? ol_extent["a" /* default */].getWidth(this.targetProj_.getExtent()) : null;

  var destinationTopLeft = ol_extent["a" /* default */].getTopLeft(targetExtent);
  var destinationTopRight = ol_extent["a" /* default */].getTopRight(targetExtent);
  var destinationBottomRight = ol_extent["a" /* default */].getBottomRight(targetExtent);
  var destinationBottomLeft = ol_extent["a" /* default */].getBottomLeft(targetExtent);
  var sourceTopLeft = this.transformInv_(destinationTopLeft);
  var sourceTopRight = this.transformInv_(destinationTopRight);
  var sourceBottomRight = this.transformInv_(destinationBottomRight);
  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);

  this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, ol["a" /* default */].RASTER_REPROJECTION_MAX_SUBDIVISION);

  if (this.wrapsXInSource_) {
    var leftBound = Infinity;
    this.triangles_.forEach(function (triangle, i, arr) {
      leftBound = Math.min(leftBound, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
    });

    // Shift triangles to be as close to `leftBound` as possible
    // (if the distance is more than `worldWidth / 2` it can be closer.
    this.triangles_.forEach(function (triangle) {
      if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {
        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]], [triangle.source[1][0], triangle.source[1][1]], [triangle.source[2][0], triangle.source[2][1]]];
        if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[0][0] -= this.sourceWorldWidth_;
        }
        if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[1][0] -= this.sourceWorldWidth_;
        }
        if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
          newTriangle[2][0] -= this.sourceWorldWidth_;
        }

        // Rarely (if the extent contains both the dateline and prime meridian)
        // the shift can in turn break some triangles.
        // Detect this here and don't shift in such cases.
        var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
        if (maxX - minX < this.sourceWorldWidth_ / 2) {
          triangle.source = newTriangle;
        }
      }
    }, this);
  }

  transformInvCache = {};
};

/**
 * Adds triangle to the triangulation.
 * @param {ol.Coordinate} a The target a coordinate.
 * @param {ol.Coordinate} b The target b coordinate.
 * @param {ol.Coordinate} c The target c coordinate.
 * @param {ol.Coordinate} aSrc The source a coordinate.
 * @param {ol.Coordinate} bSrc The source b coordinate.
 * @param {ol.Coordinate} cSrc The source c coordinate.
 * @private
 */
triangulation__ol_reproj_Triangulation_.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {
  this.triangles_.push({
    source: [aSrc, bSrc, cSrc],
    target: [a, b, c]
  });
};

/**
 * Adds quad (points in clock-wise order) to the triangulation
 * (and reprojects the vertices) if valid.
 * Performs quad subdivision if needed to increase precision.
 *
 * @param {ol.Coordinate} a The target a coordinate.
 * @param {ol.Coordinate} b The target b coordinate.
 * @param {ol.Coordinate} c The target c coordinate.
 * @param {ol.Coordinate} d The target d coordinate.
 * @param {ol.Coordinate} aSrc The source a coordinate.
 * @param {ol.Coordinate} bSrc The source b coordinate.
 * @param {ol.Coordinate} cSrc The source c coordinate.
 * @param {ol.Coordinate} dSrc The source d coordinate.
 * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
 * @private
 */
triangulation__ol_reproj_Triangulation_.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {

  var sourceQuadExtent = ol_extent["a" /* default */].boundingExtent([aSrc, bSrc, cSrc, dSrc]);
  var sourceCoverageX = this.sourceWorldWidth_ ? ol_extent["a" /* default */].getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
  var sourceWorldWidth = /** @type {number} */this.sourceWorldWidth_;

  // when the quad is wrapped in the source projection
  // it covers most of the projection extent, but not fully
  var wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;

  var needsSubdivision = false;

  if (maxSubdivision > 0) {
    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
      var targetQuadExtent = ol_extent["a" /* default */].boundingExtent([a, b, c, d]);
      var targetCoverageX = ol_extent["a" /* default */].getWidth(targetQuadExtent) / this.targetWorldWidth_;
      needsSubdivision |= targetCoverageX > ol["a" /* default */].RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;
    }
    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
      needsSubdivision |= sourceCoverageX > ol["a" /* default */].RASTER_REPROJECTION_MAX_TRIANGLE_WIDTH;
    }
  }

  if (!needsSubdivision && this.maxSourceExtent_) {
    if (!ol_extent["a" /* default */].intersects(sourceQuadExtent, this.maxSourceExtent_)) {
      // whole quad outside source projection extent -> ignore
      return;
    }
  }

  if (!needsSubdivision) {
    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
      if (maxSubdivision > 0) {
        needsSubdivision = true;
      } else {
        return;
      }
    }
  }

  if (maxSubdivision > 0) {
    if (!needsSubdivision) {
      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
      var centerSrc = this.transformInv_(center);

      var dx;
      if (wrapsX) {
        var centerSrcEstimX = (math["a" /* default */].modulo(aSrc[0], sourceWorldWidth) + math["a" /* default */].modulo(cSrc[0], sourceWorldWidth)) / 2;
        dx = centerSrcEstimX - math["a" /* default */].modulo(centerSrc[0], sourceWorldWidth);
      } else {
        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
      }
      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
      var centerSrcErrorSquared = dx * dx + dy * dy;
      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
    }
    if (needsSubdivision) {
      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
        // split horizontally (top & bottom)
        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
        var bcSrc = this.transformInv_(bc);
        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
        var daSrc = this.transformInv_(da);

        this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
        this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
      } else {
        // split vertically (left & right)
        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
        var abSrc = this.transformInv_(ab);
        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
        var cdSrc = this.transformInv_(cd);

        this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
        this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
      }
      return;
    }
  }

  if (wrapsX) {
    if (!this.canWrapXInSource_) {
      return;
    }
    this.wrapsXInSource_ = true;
  }

  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);
};

/**
 * Calculates extent of the 'source' coordinates from all the triangles.
 *
 * @return {ol.Extent} Calculated extent.
 */
triangulation__ol_reproj_Triangulation_.prototype.calculateSourceExtent = function () {
  var extent = ol_extent["a" /* default */].createEmpty();

  this.triangles_.forEach(function (triangle, i, arr) {
    var src = triangle.source;
    ol_extent["a" /* default */].extendCoordinate(extent, src[0]);
    ol_extent["a" /* default */].extendCoordinate(extent, src[1]);
    ol_extent["a" /* default */].extendCoordinate(extent, src[2]);
  });

  return extent;
};

/**
 * @return {Array.<ol.ReprojTriangle>} Array of the calculated triangles.
 */
triangulation__ol_reproj_Triangulation_.prototype.getTriangles = function () {
  return this.triangles_;
};
/* harmony default export */ var reproj_triangulation = (triangulation__ol_reproj_Triangulation_);
// CONCATENATED MODULE: ./node_modules/ol/reproj/tile.js










/**
 * @classdesc
 * Class encapsulating single reprojected tile.
 * See {@link ol.source.TileImage}.
 *
 * @constructor
 * @extends {ol.Tile}
 * @param {ol.proj.Projection} sourceProj Source projection.
 * @param {ol.tilegrid.TileGrid} sourceTileGrid Source tile grid.
 * @param {ol.proj.Projection} targetProj Target projection.
 * @param {ol.tilegrid.TileGrid} targetTileGrid Target tile grid.
 * @param {ol.TileCoord} tileCoord Coordinate of the tile.
 * @param {ol.TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
 * @param {number} pixelRatio Pixel ratio.
 * @param {number} gutter Gutter of the source tiles.
 * @param {ol.ReprojTileFunctionType} getTileFunction
 *     Function returning source tiles (z, x, y, pixelRatio).
 * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).
 * @param {boolean=} opt_renderEdges Render reprojection edges.
 */
var tile__ol_reproj_Tile_ = function _ol_reproj_Tile_(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges) {
  ol_tile.call(this, tileCoord, tilestate["a" /* default */].IDLE);

  /**
   * @private
   * @type {boolean}
   */
  this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;

  /**
   * @private
   * @type {number}
   */
  this.pixelRatio_ = pixelRatio;

  /**
   * @private
   * @type {number}
   */
  this.gutter_ = gutter;

  /**
   * @private
   * @type {HTMLCanvasElement}
   */
  this.canvas_ = null;

  /**
   * @private
   * @type {ol.tilegrid.TileGrid}
   */
  this.sourceTileGrid_ = sourceTileGrid;

  /**
   * @private
   * @type {ol.tilegrid.TileGrid}
   */
  this.targetTileGrid_ = targetTileGrid;

  /**
   * @private
   * @type {ol.TileCoord}
   */
  this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;

  /**
   * @private
   * @type {!Array.<ol.Tile>}
   */
  this.sourceTiles_ = [];

  /**
   * @private
   * @type {Array.<ol.EventsKey>}
   */
  this.sourcesListenerKeys_ = null;

  /**
   * @private
   * @type {number}
   */
  this.sourceZ_ = 0;

  var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);
  var maxTargetExtent = this.targetTileGrid_.getExtent();
  var maxSourceExtent = this.sourceTileGrid_.getExtent();

  var limitedTargetExtent = maxTargetExtent ? ol_extent["a" /* default */].getIntersection(targetExtent, maxTargetExtent) : targetExtent;

  if (ol_extent["a" /* default */].getArea(limitedTargetExtent) === 0) {
    // Tile is completely outside range -> EMPTY
    // TODO: is it actually correct that the source even creates the tile ?
    this.state = tilestate["a" /* default */].EMPTY;
    return;
  }

  var sourceProjExtent = sourceProj.getExtent();
  if (sourceProjExtent) {
    if (!maxSourceExtent) {
      maxSourceExtent = sourceProjExtent;
    } else {
      maxSourceExtent = ol_extent["a" /* default */].getIntersection(maxSourceExtent, sourceProjExtent);
    }
  }

  var targetResolution = targetTileGrid.getResolution(this.wrappedTileCoord_[0]);

  var targetCenter = ol_extent["a" /* default */].getCenter(limitedTargetExtent);
  var sourceResolution = reproj.calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);

  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    // invalid sourceResolution -> EMPTY
    // probably edges of the projections when no extent is defined
    this.state = tilestate["a" /* default */].EMPTY;
    return;
  }

  var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ol["a" /* default */].DEFAULT_RASTER_REPROJECTION_ERROR_THRESHOLD;

  /**
   * @private
   * @type {!ol.reproj.Triangulation}
   */
  this.triangulation_ = new reproj_triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels);

  if (this.triangulation_.getTriangles().length === 0) {
    // no valid triangles -> EMPTY
    this.state = tilestate["a" /* default */].EMPTY;
    return;
  }

  this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
  var sourceExtent = this.triangulation_.calculateSourceExtent();

  if (maxSourceExtent) {
    if (sourceProj.canWrapX()) {
      sourceExtent[1] = math["a" /* default */].clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
      sourceExtent[3] = math["a" /* default */].clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
    } else {
      sourceExtent = ol_extent["a" /* default */].getIntersection(sourceExtent, maxSourceExtent);
    }
  }

  if (!ol_extent["a" /* default */].getArea(sourceExtent)) {
    this.state = tilestate["a" /* default */].EMPTY;
  } else {
    var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, this.sourceZ_);

    for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
      for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
        var tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
        if (tile) {
          this.sourceTiles_.push(tile);
        }
      }
    }

    if (this.sourceTiles_.length === 0) {
      this.state = tilestate["a" /* default */].EMPTY;
    }
  }
};

ol["a" /* default */].inherits(tile__ol_reproj_Tile_, ol_tile);

/**
 * @inheritDoc
 */
tile__ol_reproj_Tile_.prototype.disposeInternal = function () {
  if (this.state == tilestate["a" /* default */].LOADING) {
    this.unlistenSources_();
  }
  ol_tile.prototype.disposeInternal.call(this);
};

/**
 * Get the HTML Canvas element for this tile.
 * @return {HTMLCanvasElement} Canvas.
 */
tile__ol_reproj_Tile_.prototype.getImage = function () {
  return this.canvas_;
};

/**
 * @private
 */
tile__ol_reproj_Tile_.prototype.reproject_ = function () {
  var sources = [];
  this.sourceTiles_.forEach(function (tile, i, arr) {
    if (tile && tile.getState() == tilestate["a" /* default */].LOADED) {
      sources.push({
        extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
        image: tile.getImage()
      });
    }
  }, this);
  this.sourceTiles_.length = 0;

  if (sources.length === 0) {
    this.state = tilestate["a" /* default */].ERROR;
  } else {
    var z = this.wrappedTileCoord_[0];
    var size = this.targetTileGrid_.getTileSize(z);
    var width = typeof size === 'number' ? size : size[0];
    var height = typeof size === 'number' ? size : size[1];
    var targetResolution = this.targetTileGrid_.getResolution(z);
    var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);

    var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
    this.canvas_ = reproj.render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_);

    this.state = tilestate["a" /* default */].LOADED;
  }
  this.changed();
};

/**
 * @inheritDoc
 */
tile__ol_reproj_Tile_.prototype.load = function () {
  if (this.state == tilestate["a" /* default */].IDLE) {
    this.state = tilestate["a" /* default */].LOADING;
    this.changed();

    var leftToLoad = 0;

    this.sourcesListenerKeys_ = [];
    this.sourceTiles_.forEach(function (tile, i, arr) {
      var state = tile.getState();
      if (state == tilestate["a" /* default */].IDLE || state == tilestate["a" /* default */].LOADING) {
        leftToLoad++;

        var sourceListenKey;
        sourceListenKey = events["a" /* default */].listen(tile, eventtype["a" /* default */].CHANGE, function (e) {
          var state = tile.getState();
          if (state == tilestate["a" /* default */].LOADED || state == tilestate["a" /* default */].ERROR || state == tilestate["a" /* default */].EMPTY) {
            events["a" /* default */].unlistenByKey(sourceListenKey);
            leftToLoad--;
            if (leftToLoad === 0) {
              this.unlistenSources_();
              this.reproject_();
            }
          }
        }, this);
        this.sourcesListenerKeys_.push(sourceListenKey);
      }
    }, this);

    this.sourceTiles_.forEach(function (tile, i, arr) {
      var state = tile.getState();
      if (state == tilestate["a" /* default */].IDLE) {
        tile.load();
      }
    });

    if (leftToLoad === 0) {
      setTimeout(this.reproject_.bind(this), 0);
    }
  }
};

/**
 * @private
 */
tile__ol_reproj_Tile_.prototype.unlistenSources_ = function () {
  this.sourcesListenerKeys_.forEach(events["a" /* default */].unlistenByKey);
  this.sourcesListenerKeys_ = null;
};
/* harmony default export */ var reproj_tile = (tile__ol_reproj_Tile_);
// EXTERNAL MODULE: ./node_modules/ol/asserts.js
var asserts = __webpack_require__(9);

// CONCATENATED MODULE: ./node_modules/ol/tileurlfunction.js



var _ol_TileUrlFunction_ = {};

/**
 * @param {string} template Template.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {ol.TileUrlFunctionType} Tile URL function.
 */
_ol_TileUrlFunction_.createFromTemplate = function (template, tileGrid) {
  var zRegEx = /\{z\}/g;
  var xRegEx = /\{x\}/g;
  var yRegEx = /\{y\}/g;
  var dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {ol.TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {ol.proj.Projection} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, function () {
          var y = -tileCoord[2] - 1;
          return y.toString();
        }).replace(dashYRegEx, function () {
          var z = tileCoord[0];
          var range = tileGrid.getFullTileRange(z);
          asserts["a" /* default */].assert(range, 55); // The {-y} placeholder requires a tile grid with extent
          var y = range.getHeight() + tileCoord[2];
          return y.toString();
        });
      }
    }
  );
};

/**
 * @param {Array.<string>} templates Templates.
 * @param {ol.tilegrid.TileGrid} tileGrid Tile grid.
 * @return {ol.TileUrlFunctionType} Tile URL function.
 */
_ol_TileUrlFunction_.createFromTemplates = function (templates, tileGrid) {
  var len = templates.length;
  var tileUrlFunctions = new Array(len);
  for (var i = 0; i < len; ++i) {
    tileUrlFunctions[i] = _ol_TileUrlFunction_.createFromTemplate(templates[i], tileGrid);
  }
  return _ol_TileUrlFunction_.createFromTileUrlFunctions(tileUrlFunctions);
};

/**
 * @param {Array.<ol.TileUrlFunctionType>} tileUrlFunctions Tile URL Functions.
 * @return {ol.TileUrlFunctionType} Tile URL function.
 */
_ol_TileUrlFunction_.createFromTileUrlFunctions = function (tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {ol.TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {ol.proj.Projection} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function (tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return undefined;
      } else {
        var h = tilecoord["a" /* default */].hash(tileCoord);
        var index = math["a" /* default */].modulo(h, tileUrlFunctions.length);
        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
      }
    }
  );
};

/**
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @return {string|undefined} Tile URL.
 */
_ol_TileUrlFunction_.nullTileUrlFunction = function (tileCoord, pixelRatio, projection) {
  return undefined;
};

/**
 * @param {string} url URL.
 * @return {Array.<string>} Array of urls.
 */
_ol_TileUrlFunction_.expandUrl = function (url) {
  var urls = [];
  var match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    // char range
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    // number range
    var stop = parseInt(match[2], 10);
    for (var i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
};
/* harmony default export */ var tileurlfunction = (_ol_TileUrlFunction_);
// EXTERNAL MODULE: ./node_modules/ol/events/event.js
var events_event = __webpack_require__(18);

// EXTERNAL MODULE: ./node_modules/ol/size.js
var ol_size = __webpack_require__(53);

// EXTERNAL MODULE: ./node_modules/ol/source/source.js + 1 modules
var source_source = __webpack_require__(90);

// EXTERNAL MODULE: ./node_modules/ol/tilegrid.js + 1 modules
var ol_tilegrid = __webpack_require__(64);

// CONCATENATED MODULE: ./node_modules/ol/source/tile.js










/**
 * @classdesc
 * Abstract base class; normally only used for creating subclasses and not
 * instantiated in apps.
 * Base class for sources providing images divided into a tile grid.
 *
 * @constructor
 * @abstract
 * @extends {ol.source.Source}
 * @param {ol.SourceTileOptions} options Tile source options.
 * @api
 */
var tile__ol_source_Tile_ = function _ol_source_Tile_(options) {

  source_source["a" /* default */].call(this, {
    attributions: options.attributions,
    extent: options.extent,
    logo: options.logo,
    projection: options.projection,
    state: options.state,
    wrapX: options.wrapX
  });

  /**
   * @private
   * @type {boolean}
   */
  this.opaque_ = options.opaque !== undefined ? options.opaque : false;

  /**
   * @private
   * @type {number}
   */
  this.tilePixelRatio_ = options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;

  /**
   * @protected
   * @type {ol.tilegrid.TileGrid}
   */
  this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;

  /**
   * @protected
   * @type {ol.TileCache}
   */
  this.tileCache = new tilecache(options.cacheSize);

  /**
   * @protected
   * @type {ol.Size}
   */
  this.tmpSize = [0, 0];

  /**
   * @private
   * @type {string}
   */
  this.key_ = '';

  /**
   * @protected
   * @type {olx.TileOptions}
   */
  this.tileOptions = { transition: options.transition };
};

ol["a" /* default */].inherits(tile__ol_source_Tile_, source_source["a" /* default */]);

/**
 * @return {boolean} Can expire cache.
 */
tile__ol_source_Tile_.prototype.canExpireCache = function () {
  return this.tileCache.canExpireCache();
};

/**
 * @param {ol.proj.Projection} projection Projection.
 * @param {Object.<string, ol.TileRange>} usedTiles Used tiles.
 */
tile__ol_source_Tile_.prototype.expireCache = function (projection, usedTiles) {
  var tileCache = this.getTileCacheForProjection(projection);
  if (tileCache) {
    tileCache.expireCache(usedTiles);
  }
};

/**
 * @param {ol.proj.Projection} projection Projection.
 * @param {number} z Zoom level.
 * @param {ol.TileRange} tileRange Tile range.
 * @param {function(ol.Tile):(boolean|undefined)} callback Called with each
 *     loaded tile.  If the callback returns `false`, the tile will not be
 *     considered loaded.
 * @return {boolean} The tile range is fully covered with loaded tiles.
 */
tile__ol_source_Tile_.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {
  var tileCache = this.getTileCacheForProjection(projection);
  if (!tileCache) {
    return false;
  }

  var covered = true;
  var tile, tileCoordKey, loaded;
  for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
    for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
      tileCoordKey = tilecoord["a" /* default */].getKeyZXY(z, x, y);
      loaded = false;
      if (tileCache.containsKey(tileCoordKey)) {
        tile = /** @type {!ol.Tile} */tileCache.get(tileCoordKey);
        loaded = tile.getState() === tilestate["a" /* default */].LOADED;
        if (loaded) {
          loaded = callback(tile) !== false;
        }
      }
      if (!loaded) {
        covered = false;
      }
    }
  }
  return covered;
};

/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {number} Gutter.
 */
tile__ol_source_Tile_.prototype.getGutter = function (projection) {
  return 0;
};

/**
 * Return the key to be used for all tiles in the source.
 * @return {string} The key for all tiles.
 * @protected
 */
tile__ol_source_Tile_.prototype.getKey = function () {
  return this.key_;
};

/**
 * Set the value to be used as the key for all tiles in the source.
 * @param {string} key The key for tiles.
 * @protected
 */
tile__ol_source_Tile_.prototype.setKey = function (key) {
  if (this.key_ !== key) {
    this.key_ = key;
    this.changed();
  }
};

/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {boolean} Opaque.
 */
tile__ol_source_Tile_.prototype.getOpaque = function (projection) {
  return this.opaque_;
};

/**
 * @inheritDoc
 */
tile__ol_source_Tile_.prototype.getResolutions = function () {
  return this.tileGrid.getResolutions();
};

/**
 * @abstract
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @return {!ol.Tile} Tile.
 */
tile__ol_source_Tile_.prototype.getTile = function (z, x, y, pixelRatio, projection) {};

/**
 * Return the tile grid of the tile source.
 * @return {ol.tilegrid.TileGrid} Tile grid.
 * @api
 */
tile__ol_source_Tile_.prototype.getTileGrid = function () {
  return this.tileGrid;
};

/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {!ol.tilegrid.TileGrid} Tile grid.
 */
tile__ol_source_Tile_.prototype.getTileGridForProjection = function (projection) {
  if (!this.tileGrid) {
    return ol_tilegrid["a" /* default */].getForProjection(projection);
  } else {
    return this.tileGrid;
  }
};

/**
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.TileCache} Tile cache.
 * @protected
 */
tile__ol_source_Tile_.prototype.getTileCacheForProjection = function (projection) {
  var thisProj = this.getProjection();
  if (thisProj && !ol_proj["default"].equivalent(thisProj, projection)) {
    return null;
  } else {
    return this.tileCache;
  }
};

/**
 * Get the tile pixel ratio for this source. Subclasses may override this
 * method, which is meant to return a supported pixel ratio that matches the
 * provided `pixelRatio` as close as possible.
 * @param {number} pixelRatio Pixel ratio.
 * @return {number} Tile pixel ratio.
 */
tile__ol_source_Tile_.prototype.getTilePixelRatio = function (pixelRatio) {
  return this.tilePixelRatio_;
};

/**
 * @param {number} z Z.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @return {ol.Size} Tile size.
 */
tile__ol_source_Tile_.prototype.getTilePixelSize = function (z, pixelRatio, projection) {
  var tileGrid = this.getTileGridForProjection(projection);
  var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
  var tileSize = ol_size["a" /* default */].toSize(tileGrid.getTileSize(z), this.tmpSize);
  if (tilePixelRatio == 1) {
    return tileSize;
  } else {
    return ol_size["a" /* default */].scale(tileSize, tilePixelRatio, this.tmpSize);
  }
};

/**
 * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
 * is outside the resolution and extent range of the tile grid, `null` will be
 * returned.
 * @param {ol.TileCoord} tileCoord Tile coordinate.
 * @param {ol.proj.Projection=} opt_projection Projection.
 * @return {ol.TileCoord} Tile coordinate to be passed to the tileUrlFunction or
 *     null if no tile URL should be created for the passed `tileCoord`.
 */
tile__ol_source_Tile_.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {
  var projection = opt_projection !== undefined ? opt_projection : this.getProjection();
  var tileGrid = this.getTileGridForProjection(projection);
  if (this.getWrapX() && projection.isGlobal()) {
    tileCoord = ol_tilegrid["a" /* default */].wrapX(tileGrid, tileCoord, projection);
  }
  return tilecoord["a" /* default */].withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
};

/**
 * @inheritDoc
 */
tile__ol_source_Tile_.prototype.refresh = function () {
  this.tileCache.clear();
  this.changed();
};

/**
 * Marks a tile coord as being used, without triggering a load.
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {ol.proj.Projection} projection Projection.
 */
tile__ol_source_Tile_.prototype.useTile = ol["a" /* default */].nullFunction;

/**
 * @classdesc
 * Events emitted by {@link ol.source.Tile} instances are instances of this
 * type.
 *
 * @constructor
 * @extends {ol.events.Event}
 * @implements {oli.source.Tile.Event}
 * @param {string} type Type.
 * @param {ol.Tile} tile The tile.
 */
tile__ol_source_Tile_.Event = function (type, tile) {

  events_event["a" /* default */].call(this, type);

  /**
   * The tile related to the event.
   * @type {ol.Tile}
   * @api
   */
  this.tile = tile;
};
ol["a" /* default */].inherits(tile__ol_source_Tile_.Event, events_event["a" /* default */]);
/* harmony default export */ var source_tile = (tile__ol_source_Tile_);
// CONCATENATED MODULE: ./node_modules/ol/source/tileeventtype.js
/**
 * @enum {string}
 */
var _ol_source_TileEventType_ = {

  /**
   * Triggered when a tile starts loading.
   * @event ol.source.Tile.Event#tileloadstart
   * @api
   */
  TILELOADSTART: 'tileloadstart',

  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event ol.source.Tile.Event#tileloadend
   * @api
   */
  TILELOADEND: 'tileloadend',

  /**
   * Triggered if tile loading results in an error.
   * @event ol.source.Tile.Event#tileloaderror
   * @api
   */
  TILELOADERROR: 'tileloaderror'

};

/* harmony default export */ var tileeventtype = (_ol_source_TileEventType_);
// CONCATENATED MODULE: ./node_modules/ol/source/urltile.js







/**
 * @classdesc
 * Base class for sources providing tiles divided into a tile grid over http.
 *
 * @constructor
 * @abstract
 * @fires ol.source.Tile.Event
 * @extends {ol.source.Tile}
 * @param {ol.SourceUrlTileOptions} options Image tile options.
 */
var urltile__ol_source_UrlTile_ = function _ol_source_UrlTile_(options) {

  source_tile.call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    extent: options.extent,
    logo: options.logo,
    opaque: options.opaque,
    projection: options.projection,
    state: options.state,
    tileGrid: options.tileGrid,
    tilePixelRatio: options.tilePixelRatio,
    wrapX: options.wrapX,
    transition: options.transition
  });

  /**
   * @protected
   * @type {ol.TileLoadFunctionType}
   */
  this.tileLoadFunction = options.tileLoadFunction;

  /**
   * @protected
   * @type {ol.TileUrlFunctionType}
   */
  this.tileUrlFunction = this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : tileurlfunction.nullTileUrlFunction;

  /**
   * @protected
   * @type {!Array.<string>|null}
   */
  this.urls = null;

  if (options.urls) {
    this.setUrls(options.urls);
  } else if (options.url) {
    this.setUrl(options.url);
  }
  if (options.tileUrlFunction) {
    this.setTileUrlFunction(options.tileUrlFunction);
  }

  /**
   * @private
   * @type {Object.<number, boolean>}
   */
  this.tileLoadingKeys_ = {};
};

ol["a" /* default */].inherits(urltile__ol_source_UrlTile_, source_tile);

/**
 * @type {ol.TileUrlFunctionType|undefined}
 * @protected
 */
urltile__ol_source_UrlTile_.prototype.fixedTileUrlFunction;

/**
 * Return the tile load function of the source.
 * @return {ol.TileLoadFunctionType} TileLoadFunction
 * @api
 */
urltile__ol_source_UrlTile_.prototype.getTileLoadFunction = function () {
  return this.tileLoadFunction;
};

/**
 * Return the tile URL function of the source.
 * @return {ol.TileUrlFunctionType} TileUrlFunction
 * @api
 */
urltile__ol_source_UrlTile_.prototype.getTileUrlFunction = function () {
  return this.tileUrlFunction;
};

/**
 * Return the URLs used for this source.
 * When a tileUrlFunction is used instead of url or urls,
 * null will be returned.
 * @return {!Array.<string>|null} URLs.
 * @api
 */
urltile__ol_source_UrlTile_.prototype.getUrls = function () {
  return this.urls;
};

/**
 * Handle tile change events.
 * @param {ol.events.Event} event Event.
 * @protected
 */
urltile__ol_source_UrlTile_.prototype.handleTileChange = function (event) {
  var tile = /** @type {ol.Tile} */event.target;
  var uid = ol["a" /* default */].getUid(tile);
  var tileState = tile.getState();
  var type;
  if (tileState == tilestate["a" /* default */].LOADING) {
    this.tileLoadingKeys_[uid] = true;
    type = tileeventtype.TILELOADSTART;
  } else if (uid in this.tileLoadingKeys_) {
    delete this.tileLoadingKeys_[uid];
    type = tileState == tilestate["a" /* default */].ERROR ? tileeventtype.TILELOADERROR : tileState == tilestate["a" /* default */].LOADED || tileState == tilestate["a" /* default */].ABORT ? tileeventtype.TILELOADEND : undefined;
  }
  if (type != undefined) {
    this.dispatchEvent(new source_tile.Event(type, tile));
  }
};

/**
 * Set the tile load function of the source.
 * @param {ol.TileLoadFunctionType} tileLoadFunction Tile load function.
 * @api
 */
urltile__ol_source_UrlTile_.prototype.setTileLoadFunction = function (tileLoadFunction) {
  this.tileCache.clear();
  this.tileLoadFunction = tileLoadFunction;
  this.changed();
};

/**
 * Set the tile URL function of the source.
 * @param {ol.TileUrlFunctionType} tileUrlFunction Tile URL function.
 * @param {string=} opt_key Optional new tile key for the source.
 * @api
 */
urltile__ol_source_UrlTile_.prototype.setTileUrlFunction = function (tileUrlFunction, opt_key) {
  this.tileUrlFunction = tileUrlFunction;
  this.tileCache.pruneExceptNewestZ();
  if (typeof opt_key !== 'undefined') {
    this.setKey(opt_key);
  } else {
    this.changed();
  }
};

/**
 * Set the URL to use for requests.
 * @param {string} url URL.
 * @api
 */
urltile__ol_source_UrlTile_.prototype.setUrl = function (url) {
  var urls = this.urls = tileurlfunction.expandUrl(url);
  this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : tileurlfunction.createFromTemplates(urls, this.tileGrid), url);
};

/**
 * Set the URLs to use for requests.
 * @param {Array.<string>} urls URLs.
 * @api
 */
urltile__ol_source_UrlTile_.prototype.setUrls = function (urls) {
  this.urls = urls;
  var key = urls.join('\n');
  this.setTileUrlFunction(this.fixedTileUrlFunction ? this.fixedTileUrlFunction.bind(this) : tileurlfunction.createFromTemplates(urls, this.tileGrid), key);
};

/**
 * @inheritDoc
 */
urltile__ol_source_UrlTile_.prototype.useTile = function (z, x, y) {
  var tileCoordKey = tilecoord["a" /* default */].getKeyZXY(z, x, y);
  if (this.tileCache.containsKey(tileCoordKey)) {
    this.tileCache.get(tileCoordKey);
  }
};
/* harmony default export */ var urltile = (urltile__ol_source_UrlTile_);
// CONCATENATED MODULE: ./node_modules/ol/source/tileimage.js












/**
 * @classdesc
 * Base class for sources providing images divided into a tile grid.
 *
 * @constructor
 * @fires ol.source.Tile.Event
 * @extends {ol.source.UrlTile}
 * @param {olx.source.TileImageOptions} options Image tile options.
 * @api
 */
var tileimage__ol_source_TileImage_ = function _ol_source_TileImage_(options) {

  urltile.call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    extent: options.extent,
    logo: options.logo,
    opaque: options.opaque,
    projection: options.projection,
    state: options.state,
    tileGrid: options.tileGrid,
    tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : _ol_source_TileImage_.defaultTileLoadFunction,
    tilePixelRatio: options.tilePixelRatio,
    tileUrlFunction: options.tileUrlFunction,
    url: options.url,
    urls: options.urls,
    wrapX: options.wrapX,
    transition: options.transition
  });

  /**
   * @protected
   * @type {?string}
   */
  this.crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : null;

  /**
   * @protected
   * @type {function(new: ol.ImageTile, ol.TileCoord, ol.TileState, string,
   *        ?string, ol.TileLoadFunctionType, olx.TileOptions=)}
   */
  this.tileClass = options.tileClass !== undefined ? options.tileClass : imagetile;

  /**
   * @protected
   * @type {Object.<string, ol.TileCache>}
   */
  this.tileCacheForProjection = {};

  /**
   * @protected
   * @type {Object.<string, ol.tilegrid.TileGrid>}
   */
  this.tileGridForProjection = {};

  /**
   * @private
   * @type {number|undefined}
   */
  this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;

  /**
   * @private
   * @type {boolean}
   */
  this.renderReprojectionEdges_ = false;
};

ol["a" /* default */].inherits(tileimage__ol_source_TileImage_, urltile);

/**
 * @inheritDoc
 */
tileimage__ol_source_TileImage_.prototype.canExpireCache = function () {
  if (!ol["a" /* default */].ENABLE_RASTER_REPROJECTION) {
    return urltile.prototype.canExpireCache.call(this);
  }
  if (this.tileCache.canExpireCache()) {
    return true;
  } else {
    for (var key in this.tileCacheForProjection) {
      if (this.tileCacheForProjection[key].canExpireCache()) {
        return true;
      }
    }
  }
  return false;
};

/**
 * @inheritDoc
 */
tileimage__ol_source_TileImage_.prototype.expireCache = function (projection, usedTiles) {
  if (!ol["a" /* default */].ENABLE_RASTER_REPROJECTION) {
    urltile.prototype.expireCache.call(this, projection, usedTiles);
    return;
  }
  var usedTileCache = this.getTileCacheForProjection(projection);

  this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
  for (var id in this.tileCacheForProjection) {
    var tileCache = this.tileCacheForProjection[id];
    tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
  }
};

/**
 * @inheritDoc
 */
tileimage__ol_source_TileImage_.prototype.getGutter = function (projection) {
  if (ol["a" /* default */].ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !ol_proj["default"].equivalent(this.getProjection(), projection)) {
    return 0;
  } else {
    return this.getGutterInternal();
  }
};

/**
 * @protected
 * @return {number} Gutter.
 */
tileimage__ol_source_TileImage_.prototype.getGutterInternal = function () {
  return 0;
};

/**
 * @inheritDoc
 */
tileimage__ol_source_TileImage_.prototype.getOpaque = function (projection) {
  if (ol["a" /* default */].ENABLE_RASTER_REPROJECTION && this.getProjection() && projection && !ol_proj["default"].equivalent(this.getProjection(), projection)) {
    return false;
  } else {
    return urltile.prototype.getOpaque.call(this, projection);
  }
};

/**
 * @inheritDoc
 */
tileimage__ol_source_TileImage_.prototype.getTileGridForProjection = function (projection) {
  if (!ol["a" /* default */].ENABLE_RASTER_REPROJECTION) {
    return urltile.prototype.getTileGridForProjection.call(this, projection);
  }
  var thisProj = this.getProjection();
  if (this.tileGrid && (!thisProj || ol_proj["default"].equivalent(thisProj, projection))) {
    return this.tileGrid;
  } else {
    var projKey = ol["a" /* default */].getUid(projection).toString();
    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] = ol_tilegrid["a" /* default */].getForProjection(projection);
    }
    return (/** @type {!ol.tilegrid.TileGrid} */this.tileGridForProjection[projKey]
    );
  }
};

/**
 * @inheritDoc
 */
tileimage__ol_source_TileImage_.prototype.getTileCacheForProjection = function (projection) {
  if (!ol["a" /* default */].ENABLE_RASTER_REPROJECTION) {
    return urltile.prototype.getTileCacheForProjection.call(this, projection);
  }
  var thisProj = this.getProjection();
  if (!thisProj || ol_proj["default"].equivalent(thisProj, projection)) {
    return this.tileCache;
  } else {
    var projKey = ol["a" /* default */].getUid(projection).toString();
    if (!(projKey in this.tileCacheForProjection)) {
      this.tileCacheForProjection[projKey] = new tilecache(this.tileCache.highWaterMark);
    }
    return this.tileCacheForProjection[projKey];
  }
};

/**
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {ol.proj.Projection} projection Projection.
 * @param {string} key The key set on the tile.
 * @return {!ol.Tile} Tile.
 * @private
 */
tileimage__ol_source_TileImage_.prototype.createTile_ = function (z, x, y, pixelRatio, projection, key) {
  var tileCoord = [z, x, y];
  var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
  var tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : undefined;
  var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? tilestate["a" /* default */].IDLE : tilestate["a" /* default */].EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);
  tile.key = key;
  events["a" /* default */].listen(tile, eventtype["a" /* default */].CHANGE, this.handleTileChange, this);
  return tile;
};

/**
 * @inheritDoc
 */
tileimage__ol_source_TileImage_.prototype.getTile = function (z, x, y, pixelRatio, projection) {
  var sourceProjection = /** @type {!ol.proj.Projection} */this.getProjection();
  if (!ol["a" /* default */].ENABLE_RASTER_REPROJECTION || !sourceProjection || !projection || ol_proj["default"].equivalent(sourceProjection, projection)) {
    return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
  } else {
    var cache = this.getTileCacheForProjection(projection);
    var tileCoord = [z, x, y];
    var tile;
    var tileCoordKey = tilecoord["a" /* default */].getKey(tileCoord);
    if (cache.containsKey(tileCoordKey)) {
      tile = /** @type {!ol.Tile} */cache.get(tileCoordKey);
    }
    var key = this.getKey();
    if (tile && tile.key == key) {
      return tile;
    } else {
      var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
      var targetTileGrid = this.getTileGridForProjection(projection);
      var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
      var newTile = new reproj_tile(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutterInternal(), function (z, x, y, pixelRatio) {
        return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
      }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_);
      newTile.key = key;

      if (tile) {
        newTile.interimTile = tile;
        newTile.refreshInterimChain();
        cache.replace(tileCoordKey, newTile);
      } else {
        cache.set(tileCoordKey, newTile);
      }
      return newTile;
    }
  }
};

/**
 * @param {number} z Tile coordinate z.
 * @param {number} x Tile coordinate x.
 * @param {number} y Tile coordinate y.
 * @param {number} pixelRatio Pixel ratio.
 * @param {!ol.proj.Projection} projection Projection.
 * @return {!ol.Tile} Tile.
 * @protected
 */
tileimage__ol_source_TileImage_.prototype.getTileInternal = function (z, x, y, pixelRatio, projection) {
  var tile = null;
  var tileCoordKey = tilecoord["a" /* default */].getKeyZXY(z, x, y);
  var key = this.getKey();
  if (!this.tileCache.containsKey(tileCoordKey)) {
    tile = this.createTile_(z, x, y, pixelRatio, projection, key);
    this.tileCache.set(tileCoordKey, tile);
  } else {
    tile = this.tileCache.get(tileCoordKey);
    if (tile.key != key) {
      // The source's params changed. If the tile has an interim tile and if we
      // can use it then we use it. Otherwise we create a new tile.  In both
      // cases we attempt to assign an interim tile to the new tile.
      var interimTile = tile;
      tile = this.createTile_(z, x, y, pixelRatio, projection, key);

      //make the new tile the head of the list,
      if (interimTile.getState() == tilestate["a" /* default */].IDLE) {
        //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
        tile.interimTile = interimTile.interimTile;
      } else {
        tile.interimTile = interimTile;
      }
      tile.refreshInterimChain();
      this.tileCache.replace(tileCoordKey, tile);
    }
  }
  return tile;
};

/**
 * Sets whether to render reprojection edges or not (usually for debugging).
 * @param {boolean} render Render the edges.
 * @api
 */
tileimage__ol_source_TileImage_.prototype.setRenderReprojectionEdges = function (render) {
  if (!ol["a" /* default */].ENABLE_RASTER_REPROJECTION || this.renderReprojectionEdges_ == render) {
    return;
  }
  this.renderReprojectionEdges_ = render;
  for (var id in this.tileCacheForProjection) {
    this.tileCacheForProjection[id].clear();
  }
  this.changed();
};

/**
 * Sets the tile grid to use when reprojecting the tiles to the given
 * projection instead of the default tile grid for the projection.
 *
 * This can be useful when the default tile grid cannot be created
 * (e.g. projection has no extent defined) or
 * for optimization reasons (custom tile size, resolutions, ...).
 *
 * @param {ol.ProjectionLike} projection Projection.
 * @param {ol.tilegrid.TileGrid} tilegrid Tile grid to use for the projection.
 * @api
 */
tileimage__ol_source_TileImage_.prototype.setTileGridForProjection = function (projection, tilegrid) {
  if (ol["a" /* default */].ENABLE_RASTER_REPROJECTION) {
    var proj = ol_proj["default"].get(projection);
    if (proj) {
      var projKey = ol["a" /* default */].getUid(proj).toString();
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }
};

/**
 * @param {ol.ImageTile} imageTile Image tile.
 * @param {string} src Source.
 */
tileimage__ol_source_TileImage_.defaultTileLoadFunction = function (imageTile, src) {
  imageTile.getImage().src = src;
};
/* harmony default export */ var tileimage = (tileimage__ol_source_TileImage_);
// CONCATENATED MODULE: ./node_modules/ol/source/xyz.js




/**
 * @classdesc
 * Layer source for tile data with URLs in a set XYZ format that are
 * defined in a URL template. By default, this follows the widely-used
 * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
 * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
 * using the `{-y}` placeholder in the URL template, so long as the
 * source does not have a custom tile grid. In this case,
 * {@link ol.source.TileImage} can be used with a `tileUrlFunction`
 * such as:
 *
 *  tileUrlFunction: function(coordinate) {
 *    return 'http://mapserver.com/' + coordinate[0] + '/' +
 *        coordinate[1] + '/' + coordinate[2] + '.png';
 *    }
 *
 *
 * @constructor
 * @extends {ol.source.TileImage}
 * @param {olx.source.XYZOptions=} opt_options XYZ options.
 * @api
 */
var xyz__ol_source_XYZ_ = function _ol_source_XYZ_(opt_options) {
  var options = opt_options || {};
  var projection = options.projection !== undefined ? options.projection : 'EPSG:3857';

  var tileGrid = options.tileGrid !== undefined ? options.tileGrid : ol_tilegrid["a" /* default */].createXYZ({
    extent: ol_tilegrid["a" /* default */].extentFromProjection(projection),
    maxZoom: options.maxZoom,
    minZoom: options.minZoom,
    tileSize: options.tileSize
  });

  tileimage.call(this, {
    attributions: options.attributions,
    cacheSize: options.cacheSize,
    crossOrigin: options.crossOrigin,
    logo: options.logo,
    opaque: options.opaque,
    projection: projection,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    tileGrid: tileGrid,
    tileLoadFunction: options.tileLoadFunction,
    tilePixelRatio: options.tilePixelRatio,
    tileUrlFunction: options.tileUrlFunction,
    url: options.url,
    urls: options.urls,
    wrapX: options.wrapX !== undefined ? options.wrapX : true,
    transition: options.transition
  });
};

ol["a" /* default */].inherits(xyz__ol_source_XYZ_, tileimage);
/* harmony default export */ var xyz = (xyz__ol_source_XYZ_);
// CONCATENATED MODULE: ./node_modules/ol/source/osm.js



/**
 * @classdesc
 * Layer source for the OpenStreetMap tile server.
 *
 * @constructor
 * @extends {ol.source.XYZ}
 * @param {olx.source.OSMOptions=} opt_options Open Street Map options.
 * @api
 */
var osm__ol_source_OSM_ = function _ol_source_OSM_(opt_options) {

  var options = opt_options || {};

  var attributions;
  if (options.attributions !== undefined) {
    attributions = options.attributions;
  } else {
    attributions = [_ol_source_OSM_.ATTRIBUTION];
  }

  var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';

  var url = options.url !== undefined ? options.url : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';

  xyz.call(this, {
    attributions: attributions,
    cacheSize: options.cacheSize,
    crossOrigin: crossOrigin,
    opaque: options.opaque !== undefined ? options.opaque : true,
    maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
    reprojectionErrorThreshold: options.reprojectionErrorThreshold,
    tileLoadFunction: options.tileLoadFunction,
    url: url,
    wrapX: options.wrapX
  });
};

ol["a" /* default */].inherits(osm__ol_source_OSM_, xyz);

/**
 * The attribution containing a link to the OpenStreetMap Copyright and License
 * page.
 * @const
 * @type {string}
 * @api
 */
osm__ol_source_OSM_.ATTRIBUTION = '&copy; ' + '<a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> ' + 'contributors.';
/* harmony default export */ var osm = __webpack_exports__["default"] = (osm__ol_source_OSM_);

/***/ }),
/* 107 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__index_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__collectioneventtype_js__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__array_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__events_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__events_event_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__events_condition_js__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__functions_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__geom_geometrytype_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__interaction_interaction_js__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__layer_vector_js__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__obj_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__source_vector_js__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__style_style_js__ = __webpack_require__(39);














/**
 * @classdesc
 * Interaction for selecting vector features. By default, selected features are
 * styled differently, so this interaction can be used for visual highlighting,
 * as well as selecting features for other actions, such as modification or
 * output. There are three ways of controlling which features are selected:
 * using the browser event as defined by the `condition` and optionally the
 * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
 * further feature filter using the `filter` option.
 *
 * Selected features are added to an internal unmanaged layer.
 *
 * @constructor
 * @extends {ol.interaction.Interaction}
 * @param {olx.interaction.SelectOptions=} opt_options Options.
 * @fires ol.interaction.Select.Event
 * @api
 */
var _ol_interaction_Select_ = function _ol_interaction_Select_(opt_options) {

  __WEBPACK_IMPORTED_MODULE_8__interaction_interaction_js__["a" /* default */].call(this, {
    handleEvent: _ol_interaction_Select_.handleEvent
  });

  var options = opt_options ? opt_options : {};

  /**
   * @private
   * @type {ol.EventsConditionType}
   */
  this.condition_ = options.condition ? options.condition : __WEBPACK_IMPORTED_MODULE_5__events_condition_js__["a" /* default */].singleClick;

  /**
   * @private
   * @type {ol.EventsConditionType}
   */
  this.addCondition_ = options.addCondition ? options.addCondition : __WEBPACK_IMPORTED_MODULE_5__events_condition_js__["a" /* default */].never;

  /**
   * @private
   * @type {ol.EventsConditionType}
   */
  this.removeCondition_ = options.removeCondition ? options.removeCondition : __WEBPACK_IMPORTED_MODULE_5__events_condition_js__["a" /* default */].never;

  /**
   * @private
   * @type {ol.EventsConditionType}
   */
  this.toggleCondition_ = options.toggleCondition ? options.toggleCondition : __WEBPACK_IMPORTED_MODULE_5__events_condition_js__["a" /* default */].shiftKeyOnly;

  /**
   * @private
   * @type {boolean}
   */
  this.multi_ = options.multi ? options.multi : false;

  /**
   * @private
   * @type {ol.SelectFilterFunction}
   */
  this.filter_ = options.filter ? options.filter : __WEBPACK_IMPORTED_MODULE_6__functions_js__["a" /* default */].TRUE;

  /**
   * @private
   * @type {number}
   */
  this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;

  var featureOverlay = new __WEBPACK_IMPORTED_MODULE_9__layer_vector_js__["default"]({
    source: new __WEBPACK_IMPORTED_MODULE_11__source_vector_js__["default"]({
      useSpatialIndex: false,
      features: options.features,
      wrapX: options.wrapX
    }),
    style: options.style ? options.style : _ol_interaction_Select_.getDefaultStyleFunction(),
    updateWhileAnimating: true,
    updateWhileInteracting: true
  });

  /**
   * @private
   * @type {ol.layer.Vector}
   */
  this.featureOverlay_ = featureOverlay;

  /** @type {function(ol.layer.Layer): boolean} */
  var layerFilter;
  if (options.layers) {
    if (typeof options.layers === 'function') {
      layerFilter = options.layers;
    } else {
      var layers = options.layers;
      layerFilter = function layerFilter(layer) {
        return __WEBPACK_IMPORTED_MODULE_2__array_js__["a" /* default */].includes(layers, layer);
      };
    }
  } else {
    layerFilter = __WEBPACK_IMPORTED_MODULE_6__functions_js__["a" /* default */].TRUE;
  }

  /**
   * @private
   * @type {function(ol.layer.Layer): boolean}
   */
  this.layerFilter_ = layerFilter;

  /**
   * An association between selected feature (key)
   * and layer (value)
   * @private
   * @type {Object.<number, ol.layer.Layer>}
   */
  this.featureLayerAssociation_ = {};

  var features = this.featureOverlay_.getSource().getFeaturesCollection();
  __WEBPACK_IMPORTED_MODULE_3__events_js__["a" /* default */].listen(features, __WEBPACK_IMPORTED_MODULE_1__collectioneventtype_js__["a" /* default */].ADD, this.addFeature_, this);
  __WEBPACK_IMPORTED_MODULE_3__events_js__["a" /* default */].listen(features, __WEBPACK_IMPORTED_MODULE_1__collectioneventtype_js__["a" /* default */].REMOVE, this.removeFeature_, this);
};

__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].inherits(_ol_interaction_Select_, __WEBPACK_IMPORTED_MODULE_8__interaction_interaction_js__["a" /* default */]);

/**
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @param {ol.layer.Layer} layer Layer.
 * @private
 */
_ol_interaction_Select_.prototype.addFeatureLayerAssociation_ = function (feature, layer) {
  var key = __WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].getUid(feature);
  this.featureLayerAssociation_[key] = layer;
};

/**
 * Get the selected features.
 * @return {ol.Collection.<ol.Feature>} Features collection.
 * @api
 */
_ol_interaction_Select_.prototype.getFeatures = function () {
  return this.featureOverlay_.getSource().getFeaturesCollection();
};

/**
 * Returns the Hit-detection tolerance.
 * @returns {number} Hit tolerance in pixels.
 * @api
 */
_ol_interaction_Select_.prototype.getHitTolerance = function () {
  return this.hitTolerance_;
};

/**
 * Returns the associated {@link ol.layer.Vector vectorlayer} of
 * the (last) selected feature. Note that this will not work with any
 * programmatic method like pushing features to
 * {@link ol.interaction.Select#getFeatures collection}.
 * @param {ol.Feature|ol.render.Feature} feature Feature
 * @return {ol.layer.Vector} Layer.
 * @api
 */
_ol_interaction_Select_.prototype.getLayer = function (feature) {
  var key = __WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].getUid(feature);
  return (/** @type {ol.layer.Vector} */this.featureLayerAssociation_[key]
  );
};

/**
 * Handles the {@link ol.MapBrowserEvent map browser event} and may change the
 * selected state of features.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Map browser event.
 * @return {boolean} `false` to stop event propagation.
 * @this {ol.interaction.Select}
 * @api
 */
_ol_interaction_Select_.handleEvent = function (mapBrowserEvent) {
  if (!this.condition_(mapBrowserEvent)) {
    return true;
  }
  var add = this.addCondition_(mapBrowserEvent);
  var remove = this.removeCondition_(mapBrowserEvent);
  var toggle = this.toggleCondition_(mapBrowserEvent);
  var set = !add && !remove && !toggle;
  var map = mapBrowserEvent.map;
  var features = this.featureOverlay_.getSource().getFeaturesCollection();
  var deselected = [];
  var selected = [];
  if (set) {
    // Replace the currently selected feature(s) with the feature(s) at the
    // pixel, or clear the selected feature(s) if there is no feature at
    // the pixel.
    __WEBPACK_IMPORTED_MODULE_10__obj_js__["a" /* default */].clear(this.featureLayerAssociation_);
    map.forEachFeatureAtPixel(mapBrowserEvent.pixel,
    /**
     * @param {ol.Feature|ol.render.Feature} feature Feature.
     * @param {ol.layer.Layer} layer Layer.
     * @return {boolean|undefined} Continue to iterate over the features.
     */
    function (feature, layer) {
      if (this.filter_(feature, layer)) {
        selected.push(feature);
        this.addFeatureLayerAssociation_(feature, layer);
        return !this.multi_;
      }
    }.bind(this), {
      layerFilter: this.layerFilter_,
      hitTolerance: this.hitTolerance_
    });
    var i;
    for (i = features.getLength() - 1; i >= 0; --i) {
      var feature = features.item(i);
      var index = selected.indexOf(feature);
      if (index > -1) {
        // feature is already selected
        selected.splice(index, 1);
      } else {
        features.remove(feature);
        deselected.push(feature);
      }
    }
    if (selected.length !== 0) {
      features.extend(selected);
    }
  } else {
    // Modify the currently selected feature(s).
    map.forEachFeatureAtPixel(mapBrowserEvent.pixel,
    /**
     * @param {ol.Feature|ol.render.Feature} feature Feature.
     * @param {ol.layer.Layer} layer Layer.
     * @return {boolean|undefined} Continue to iterate over the features.
     */
    function (feature, layer) {
      if (this.filter_(feature, layer)) {
        if ((add || toggle) && !__WEBPACK_IMPORTED_MODULE_2__array_js__["a" /* default */].includes(features.getArray(), feature)) {
          selected.push(feature);
          this.addFeatureLayerAssociation_(feature, layer);
        } else if ((remove || toggle) && __WEBPACK_IMPORTED_MODULE_2__array_js__["a" /* default */].includes(features.getArray(), feature)) {
          deselected.push(feature);
          this.removeFeatureLayerAssociation_(feature);
        }
        return !this.multi_;
      }
    }.bind(this), {
      layerFilter: this.layerFilter_,
      hitTolerance: this.hitTolerance_
    });
    var j;
    for (j = deselected.length - 1; j >= 0; --j) {
      features.remove(deselected[j]);
    }
    features.extend(selected);
  }
  if (selected.length > 0 || deselected.length > 0) {
    this.dispatchEvent(new _ol_interaction_Select_.Event(_ol_interaction_Select_.EventType_.SELECT, selected, deselected, mapBrowserEvent));
  }
  return __WEBPACK_IMPORTED_MODULE_5__events_condition_js__["a" /* default */].pointerMove(mapBrowserEvent);
};

/**
 * Hit-detection tolerance. Pixels inside the radius around the given position
 * will be checked for features. This only works for the canvas renderer and
 * not for WebGL.
 * @param {number} hitTolerance Hit tolerance in pixels.
 * @api
 */
_ol_interaction_Select_.prototype.setHitTolerance = function (hitTolerance) {
  this.hitTolerance_ = hitTolerance;
};

/**
 * Remove the interaction from its current map, if any,  and attach it to a new
 * map, if any. Pass `null` to just remove the interaction from the current map.
 * @param {ol.PluggableMap} map Map.
 * @override
 * @api
 */
_ol_interaction_Select_.prototype.setMap = function (map) {
  var currentMap = this.getMap();
  var selectedFeatures = this.featureOverlay_.getSource().getFeaturesCollection();
  if (currentMap) {
    selectedFeatures.forEach(currentMap.unskipFeature, currentMap);
  }
  __WEBPACK_IMPORTED_MODULE_8__interaction_interaction_js__["a" /* default */].prototype.setMap.call(this, map);
  this.featureOverlay_.setMap(map);
  if (map) {
    selectedFeatures.forEach(map.skipFeature, map);
  }
};

/**
 * @return {ol.StyleFunction} Styles.
 */
_ol_interaction_Select_.getDefaultStyleFunction = function () {
  var styles = __WEBPACK_IMPORTED_MODULE_12__style_style_js__["default"].createDefaultEditing();
  __WEBPACK_IMPORTED_MODULE_2__array_js__["a" /* default */].extend(styles[__WEBPACK_IMPORTED_MODULE_7__geom_geometrytype_js__["a" /* default */].POLYGON], styles[__WEBPACK_IMPORTED_MODULE_7__geom_geometrytype_js__["a" /* default */].LINE_STRING]);
  __WEBPACK_IMPORTED_MODULE_2__array_js__["a" /* default */].extend(styles[__WEBPACK_IMPORTED_MODULE_7__geom_geometrytype_js__["a" /* default */].GEOMETRY_COLLECTION], styles[__WEBPACK_IMPORTED_MODULE_7__geom_geometrytype_js__["a" /* default */].LINE_STRING]);

  return function (feature, resolution) {
    if (!feature.getGeometry()) {
      return null;
    }
    return styles[feature.getGeometry().getType()];
  };
};

/**
 * @param {ol.Collection.Event} evt Event.
 * @private
 */
_ol_interaction_Select_.prototype.addFeature_ = function (evt) {
  var map = this.getMap();
  if (map) {
    map.skipFeature( /** @type {ol.Feature} */evt.element);
  }
};

/**
 * @param {ol.Collection.Event} evt Event.
 * @private
 */
_ol_interaction_Select_.prototype.removeFeature_ = function (evt) {
  var map = this.getMap();
  if (map) {
    map.unskipFeature( /** @type {ol.Feature} */evt.element);
  }
};

/**
 * @param {ol.Feature|ol.render.Feature} feature Feature.
 * @private
 */
_ol_interaction_Select_.prototype.removeFeatureLayerAssociation_ = function (feature) {
  var key = __WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].getUid(feature);
  delete this.featureLayerAssociation_[key];
};

/**
 * @classdesc
 * Events emitted by {@link ol.interaction.Select} instances are instances of
 * this type.
 *
 * @param {ol.interaction.Select.EventType_} type The event type.
 * @param {Array.<ol.Feature>} selected Selected features.
 * @param {Array.<ol.Feature>} deselected Deselected features.
 * @param {ol.MapBrowserEvent} mapBrowserEvent Associated
 *     {@link ol.MapBrowserEvent}.
 * @implements {oli.SelectEvent}
 * @extends {ol.events.Event}
 * @constructor
 */
_ol_interaction_Select_.Event = function (type, selected, deselected, mapBrowserEvent) {
  __WEBPACK_IMPORTED_MODULE_4__events_event_js__["a" /* default */].call(this, type);

  /**
   * Selected features array.
   * @type {Array.<ol.Feature>}
   * @api
   */
  this.selected = selected;

  /**
   * Deselected features array.
   * @type {Array.<ol.Feature>}
   * @api
   */
  this.deselected = deselected;

  /**
   * Associated {@link ol.MapBrowserEvent}.
   * @type {ol.MapBrowserEvent}
   * @api
   */
  this.mapBrowserEvent = mapBrowserEvent;
};
__WEBPACK_IMPORTED_MODULE_0__index_js__["a" /* default */].inherits(_ol_interaction_Select_.Event, __WEBPACK_IMPORTED_MODULE_4__events_event_js__["a" /* default */]);

/**
 * @enum {string}
 * @private
 */
_ol_interaction_Select_.EventType_ = {
  /**
   * Triggered when feature(s) has been (de)selected.
   * @event ol.interaction.Select.Event#select
   * @api
   */
  SELECT: 'select'
};
/* harmony default export */ __webpack_exports__["default"] = (_ol_interaction_Select_);

/***/ }),
/* 108 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./node_modules/ol/index.js
var ol = __webpack_require__(0);

// EXTERNAL MODULE: ./node_modules/ol/mapeventtype.js
var mapeventtype = __webpack_require__(68);

// EXTERNAL MODULE: ./node_modules/ol/object.js
var object = __webpack_require__(15);

// CONCATENATED MODULE: ./node_modules/ol/overlaypositioning.js
/**
 * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
 * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
 * `'top-center'`, `'top-right'`
 * @enum {string}
 */
var _ol_OverlayPositioning_ = {
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_CENTER: 'bottom-center',
  BOTTOM_RIGHT: 'bottom-right',
  CENTER_LEFT: 'center-left',
  CENTER_CENTER: 'center-center',
  CENTER_RIGHT: 'center-right',
  TOP_LEFT: 'top-left',
  TOP_CENTER: 'top-center',
  TOP_RIGHT: 'top-right'
};

/* harmony default export */ var overlaypositioning = (_ol_OverlayPositioning_);
// EXTERNAL MODULE: ./node_modules/ol/css.js
var css = __webpack_require__(32);

// EXTERNAL MODULE: ./node_modules/ol/dom.js
var dom = __webpack_require__(8);

// EXTERNAL MODULE: ./node_modules/ol/events.js
var events = __webpack_require__(3);

// EXTERNAL MODULE: ./node_modules/ol/extent.js
var extent = __webpack_require__(1);

// CONCATENATED MODULE: ./node_modules/ol/overlay.js









/**
 * @classdesc
 * An element to be displayed over the map and attached to a single map
 * location.  Like {@link ol.control.Control}, Overlays are visible widgets.
 * Unlike Controls, they are not in a fixed position on the screen, but are tied
 * to a geographical coordinate, so panning the map will move an Overlay but not
 * a Control.
 *
 * Example:
 *
 *     var popup = new ol.Overlay({
 *       element: document.getElementById('popup')
 *     });
 *     popup.setPosition(coordinate);
 *     map.addOverlay(popup);
 *
 * @constructor
 * @extends {ol.Object}
 * @param {olx.OverlayOptions} options Overlay options.
 * @api
 */
var overlay__ol_Overlay_ = function _ol_Overlay_(options) {

  object["a" /* default */].call(this);

  /**
   * @protected
   * @type {olx.OverlayOptions}
   */
  this.options = options;

  /**
   * @protected
   * @type {number|string|undefined}
   */
  this.id = options.id;

  /**
   * @protected
   * @type {boolean}
   */
  this.insertFirst = options.insertFirst !== undefined ? options.insertFirst : true;

  /**
   * @protected
   * @type {boolean}
   */
  this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;

  /**
   * @protected
   * @type {Element}
   */
  this.element = document.createElement('DIV');
  this.element.className = options.className !== undefined ? options.className : 'ol-overlay-container ' + css["a" /* default */].CLASS_SELECTABLE;
  this.element.style.position = 'absolute';

  /**
   * @protected
   * @type {boolean}
   */
  this.autoPan = options.autoPan !== undefined ? options.autoPan : false;

  /**
   * @protected
   * @type {olx.OverlayPanOptions}
   */
  this.autoPanAnimation = options.autoPanAnimation ||
  /** @type {olx.OverlayPanOptions} */{};

  /**
   * @protected
   * @type {number}
   */
  this.autoPanMargin = options.autoPanMargin !== undefined ? options.autoPanMargin : 20;

  /**
   * @protected
   * @type {{bottom_: string,
   *         left_: string,
   *         right_: string,
   *         top_: string,
   *         visible: boolean}}
   */
  this.rendered = {
    bottom_: '',
    left_: '',
    right_: '',
    top_: '',
    visible: true
  };

  /**
   * @protected
   * @type {?ol.EventsKey}
   */
  this.mapPostrenderListenerKey = null;

  events["a" /* default */].listen(this, object["a" /* default */].getChangeEventType(_ol_Overlay_.Property.ELEMENT), this.handleElementChanged, this);

  events["a" /* default */].listen(this, object["a" /* default */].getChangeEventType(_ol_Overlay_.Property.MAP), this.handleMapChanged, this);

  events["a" /* default */].listen(this, object["a" /* default */].getChangeEventType(_ol_Overlay_.Property.OFFSET), this.handleOffsetChanged, this);

  events["a" /* default */].listen(this, object["a" /* default */].getChangeEventType(_ol_Overlay_.Property.POSITION), this.handlePositionChanged, this);

  events["a" /* default */].listen(this, object["a" /* default */].getChangeEventType(_ol_Overlay_.Property.POSITIONING), this.handlePositioningChanged, this);

  if (options.element !== undefined) {
    this.setElement(options.element);
  }

  this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);

  this.setPositioning(options.positioning !== undefined ?
  /** @type {ol.OverlayPositioning} */options.positioning : overlaypositioning.TOP_LEFT);

  if (options.position !== undefined) {
    this.setPosition(options.position);
  }
};

ol["a" /* default */].inherits(overlay__ol_Overlay_, object["a" /* default */]);

/**
 * Get the DOM element of this overlay.
 * @return {Element|undefined} The Element containing the overlay.
 * @observable
 * @api
 */
overlay__ol_Overlay_.prototype.getElement = function () {
  return (
    /** @type {Element|undefined} */this.get(overlay__ol_Overlay_.Property.ELEMENT)
  );
};

/**
 * Get the overlay identifier which is set on constructor.
 * @return {number|string|undefined} Id.
 * @api
 */
overlay__ol_Overlay_.prototype.getId = function () {
  return this.id;
};

/**
 * Get the map associated with this overlay.
 * @return {ol.PluggableMap|undefined} The map that the overlay is part of.
 * @observable
 * @api
 */
overlay__ol_Overlay_.prototype.getMap = function () {
  return (
    /** @type {ol.PluggableMap|undefined} */this.get(overlay__ol_Overlay_.Property.MAP)
  );
};

/**
 * Get the offset of this overlay.
 * @return {Array.<number>} The offset.
 * @observable
 * @api
 */
overlay__ol_Overlay_.prototype.getOffset = function () {
  return (
    /** @type {Array.<number>} */this.get(overlay__ol_Overlay_.Property.OFFSET)
  );
};

/**
 * Get the current position of this overlay.
 * @return {ol.Coordinate|undefined} The spatial point that the overlay is
 *     anchored at.
 * @observable
 * @api
 */
overlay__ol_Overlay_.prototype.getPosition = function () {
  return (
    /** @type {ol.Coordinate|undefined} */this.get(overlay__ol_Overlay_.Property.POSITION)
  );
};

/**
 * Get the current positioning of this overlay.
 * @return {ol.OverlayPositioning} How the overlay is positioned
 *     relative to its point on the map.
 * @observable
 * @api
 */
overlay__ol_Overlay_.prototype.getPositioning = function () {
  return (
    /** @type {ol.OverlayPositioning} */this.get(overlay__ol_Overlay_.Property.POSITIONING)
  );
};

/**
 * @protected
 */
overlay__ol_Overlay_.prototype.handleElementChanged = function () {
  dom["a" /* default */].removeChildren(this.element);
  var element = this.getElement();
  if (element) {
    this.element.appendChild(element);
  }
};

/**
 * @protected
 */
overlay__ol_Overlay_.prototype.handleMapChanged = function () {
  if (this.mapPostrenderListenerKey) {
    dom["a" /* default */].removeNode(this.element);
    events["a" /* default */].unlistenByKey(this.mapPostrenderListenerKey);
    this.mapPostrenderListenerKey = null;
  }
  var map = this.getMap();
  if (map) {
    this.mapPostrenderListenerKey = events["a" /* default */].listen(map, mapeventtype["a" /* default */].POSTRENDER, this.render, this);
    this.updatePixelPosition();
    var container = this.stopEvent ? map.getOverlayContainerStopEvent() : map.getOverlayContainer();
    if (this.insertFirst) {
      container.insertBefore(this.element, container.childNodes[0] || null);
    } else {
      container.appendChild(this.element);
    }
  }
};

/**
 * @protected
 */
overlay__ol_Overlay_.prototype.render = function () {
  this.updatePixelPosition();
};

/**
 * @protected
 */
overlay__ol_Overlay_.prototype.handleOffsetChanged = function () {
  this.updatePixelPosition();
};

/**
 * @protected
 */
overlay__ol_Overlay_.prototype.handlePositionChanged = function () {
  this.updatePixelPosition();
  if (this.get(overlay__ol_Overlay_.Property.POSITION) && this.autoPan) {
    this.panIntoView();
  }
};

/**
 * @protected
 */
overlay__ol_Overlay_.prototype.handlePositioningChanged = function () {
  this.updatePixelPosition();
};

/**
 * Set the DOM element to be associated with this overlay.
 * @param {Element|undefined} element The Element containing the overlay.
 * @observable
 * @api
 */
overlay__ol_Overlay_.prototype.setElement = function (element) {
  this.set(overlay__ol_Overlay_.Property.ELEMENT, element);
};

/**
 * Set the map to be associated with this overlay.
 * @param {ol.PluggableMap|undefined} map The map that the overlay is part of.
 * @observable
 * @api
 */
overlay__ol_Overlay_.prototype.setMap = function (map) {
  this.set(overlay__ol_Overlay_.Property.MAP, map);
};

/**
 * Set the offset for this overlay.
 * @param {Array.<number>} offset Offset.
 * @observable
 * @api
 */
overlay__ol_Overlay_.prototype.setOffset = function (offset) {
  this.set(overlay__ol_Overlay_.Property.OFFSET, offset);
};

/**
 * Set the position for this overlay. If the position is `undefined` the
 * overlay is hidden.
 * @param {ol.Coordinate|undefined} position The spatial point that the overlay
 *     is anchored at.
 * @observable
 * @api
 */
overlay__ol_Overlay_.prototype.setPosition = function (position) {
  this.set(overlay__ol_Overlay_.Property.POSITION, position);
};

/**
 * Pan the map so that the overlay is entirely visible in the current viewport
 * (if necessary).
 * @protected
 */
overlay__ol_Overlay_.prototype.panIntoView = function () {
  var map = this.getMap();

  if (!map || !map.getTargetElement()) {
    return;
  }

  var mapRect = this.getRect(map.getTargetElement(), map.getSize());
  var element = /** @type {!Element} */this.getElement();
  var overlayRect = this.getRect(element, [dom["a" /* default */].outerWidth(element), dom["a" /* default */].outerHeight(element)]);

  var margin = this.autoPanMargin;
  if (!extent["a" /* default */].containsExtent(mapRect, overlayRect)) {
    // the overlay is not completely inside the viewport, so pan the map
    var offsetLeft = overlayRect[0] - mapRect[0];
    var offsetRight = mapRect[2] - overlayRect[2];
    var offsetTop = overlayRect[1] - mapRect[1];
    var offsetBottom = mapRect[3] - overlayRect[3];

    var delta = [0, 0];
    if (offsetLeft < 0) {
      // move map to the left
      delta[0] = offsetLeft - margin;
    } else if (offsetRight < 0) {
      // move map to the right
      delta[0] = Math.abs(offsetRight) + margin;
    }
    if (offsetTop < 0) {
      // move map up
      delta[1] = offsetTop - margin;
    } else if (offsetBottom < 0) {
      // move map down
      delta[1] = Math.abs(offsetBottom) + margin;
    }

    if (delta[0] !== 0 || delta[1] !== 0) {
      var center = /** @type {ol.Coordinate} */map.getView().getCenter();
      var centerPx = map.getPixelFromCoordinate(center);
      var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];

      map.getView().animate({
        center: map.getCoordinateFromPixel(newCenterPx),
        duration: this.autoPanAnimation.duration,
        easing: this.autoPanAnimation.easing
      });
    }
  }
};

/**
 * Get the extent of an element relative to the document
 * @param {Element|undefined} element The element.
 * @param {ol.Size|undefined} size The size of the element.
 * @return {ol.Extent} The extent.
 * @protected
 */
overlay__ol_Overlay_.prototype.getRect = function (element, size) {
  var box = element.getBoundingClientRect();
  var offsetX = box.left + window.pageXOffset;
  var offsetY = box.top + window.pageYOffset;
  return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
};

/**
 * Set the positioning for this overlay.
 * @param {ol.OverlayPositioning} positioning how the overlay is
 *     positioned relative to its point on the map.
 * @observable
 * @api
 */
overlay__ol_Overlay_.prototype.setPositioning = function (positioning) {
  this.set(overlay__ol_Overlay_.Property.POSITIONING, positioning);
};

/**
 * Modify the visibility of the element.
 * @param {boolean} visible Element visibility.
 * @protected
 */
overlay__ol_Overlay_.prototype.setVisible = function (visible) {
  if (this.rendered.visible !== visible) {
    this.element.style.display = visible ? '' : 'none';
    this.rendered.visible = visible;
  }
};

/**
 * Update pixel position.
 * @protected
 */
overlay__ol_Overlay_.prototype.updatePixelPosition = function () {
  var map = this.getMap();
  var position = this.getPosition();
  if (!map || !map.isRendered() || !position) {
    this.setVisible(false);
    return;
  }

  var pixel = map.getPixelFromCoordinate(position);
  var mapSize = map.getSize();
  this.updateRenderedPosition(pixel, mapSize);
};

/**
 * @param {ol.Pixel} pixel The pixel location.
 * @param {ol.Size|undefined} mapSize The map size.
 * @protected
 */
overlay__ol_Overlay_.prototype.updateRenderedPosition = function (pixel, mapSize) {
  var style = this.element.style;
  var offset = this.getOffset();

  var positioning = this.getPositioning();

  this.setVisible(true);

  var offsetX = offset[0];
  var offsetY = offset[1];
  if (positioning == overlaypositioning.BOTTOM_RIGHT || positioning == overlaypositioning.CENTER_RIGHT || positioning == overlaypositioning.TOP_RIGHT) {
    if (this.rendered.left_ !== '') {
      this.rendered.left_ = style.left = '';
    }
    var right = Math.round(mapSize[0] - pixel[0] - offsetX) + 'px';
    if (this.rendered.right_ != right) {
      this.rendered.right_ = style.right = right;
    }
  } else {
    if (this.rendered.right_ !== '') {
      this.rendered.right_ = style.right = '';
    }
    if (positioning == overlaypositioning.BOTTOM_CENTER || positioning == overlaypositioning.CENTER_CENTER || positioning == overlaypositioning.TOP_CENTER) {
      offsetX -= this.element.offsetWidth / 2;
    }
    var left = Math.round(pixel[0] + offsetX) + 'px';
    if (this.rendered.left_ != left) {
      this.rendered.left_ = style.left = left;
    }
  }
  if (positioning == overlaypositioning.BOTTOM_LEFT || positioning == overlaypositioning.BOTTOM_CENTER || positioning == overlaypositioning.BOTTOM_RIGHT) {
    if (this.rendered.top_ !== '') {
      this.rendered.top_ = style.top = '';
    }
    var bottom = Math.round(mapSize[1] - pixel[1] - offsetY) + 'px';
    if (this.rendered.bottom_ != bottom) {
      this.rendered.bottom_ = style.bottom = bottom;
    }
  } else {
    if (this.rendered.bottom_ !== '') {
      this.rendered.bottom_ = style.bottom = '';
    }
    if (positioning == overlaypositioning.CENTER_LEFT || positioning == overlaypositioning.CENTER_CENTER || positioning == overlaypositioning.CENTER_RIGHT) {
      offsetY -= this.element.offsetHeight / 2;
    }
    var top = Math.round(pixel[1] + offsetY) + 'px';
    if (this.rendered.top_ != top) {
      this.rendered.top_ = style.top = top;
    }
  }
};

/**
 * returns the options this Overlay has been created with
 * @public
 * @return {olx.OverlayOptions} overlay options
 */
overlay__ol_Overlay_.prototype.getOptions = function () {
  return this.options;
};

/**
 * @enum {string}
 * @protected
 */
overlay__ol_Overlay_.Property = {
  ELEMENT: 'element',
  MAP: 'map',
  OFFSET: 'offset',
  POSITION: 'position',
  POSITIONING: 'positioning'
};
/* harmony default export */ var overlay = __webpack_exports__["default"] = (overlay__ol_Overlay_);

/***/ }),
/* 109 */
/***/ (function(module, exports) {

module.exports = require("lodash/range");

/***/ }),
/* 110 */
/***/ (function(module, exports) {

module.exports = require("react-datepicker");

/***/ })
/******/ ]);